
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Models
 * 
 */
export type Models = $Result.DefaultSelection<Prisma.$ModelsPayload>
/**
 * Model Parts
 * 
 */
export type Parts = $Result.DefaultSelection<Prisma.$PartsPayload>
/**
 * Model Claim
 * 
 */
export type Claim = $Result.DefaultSelection<Prisma.$ClaimPayload>
/**
 * Model Problem
 * 
 */
export type Problem = $Result.DefaultSelection<Prisma.$ProblemPayload>
/**
 * Model ClaimToEntity
 * 
 */
export type ClaimToEntity = $Result.DefaultSelection<Prisma.$ClaimToEntityPayload>
/**
 * Model Investigation
 * 
 */
export type Investigation = $Result.DefaultSelection<Prisma.$InvestigationPayload>
/**
 * Model Shipment
 * 
 */
export type Shipment = $Result.DefaultSelection<Prisma.$ShipmentPayload>
/**
 * Model Organization
 * 
 */
export type Organization = $Result.DefaultSelection<Prisma.$OrganizationPayload>
/**
 * Model Role
 * 
 */
export type Role = $Result.DefaultSelection<Prisma.$RolePayload>
/**
 * Model SystemType
 * 
 */
export type SystemType = $Result.DefaultSelection<Prisma.$SystemTypePayload>
/**
 * Model EntityType
 * 
 */
export type EntityType = $Result.DefaultSelection<Prisma.$EntityTypePayload>
/**
 * Model businessType
 * 
 */
export type businessType = $Result.DefaultSelection<Prisma.$businessTypePayload>
/**
 * Model Business
 * 
 */
export type Business = $Result.DefaultSelection<Prisma.$BusinessPayload>
/**
 * Model Functions
 * 
 */
export type Functions = $Result.DefaultSelection<Prisma.$FunctionsPayload>
/**
 * Model Section
 * 
 */
export type Section = $Result.DefaultSelection<Prisma.$SectionPayload>
/**
 * Model Location
 * 
 */
export type Location = $Result.DefaultSelection<Prisma.$LocationPayload>
/**
 * Model Entity
 * 
 */
export type Entity = $Result.DefaultSelection<Prisma.$EntityPayload>
/**
 * Model LocationBusiness
 * 
 */
export type LocationBusiness = $Result.DefaultSelection<Prisma.$LocationBusinessPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model Doctype
 * 
 */
export type Doctype = $Result.DefaultSelection<Prisma.$DoctypePayload>
/**
 * Model Documents
 * 
 */
export type Documents = $Result.DefaultSelection<Prisma.$DocumentsPayload>
/**
 * Model documentAttachmentHistory
 * 
 */
export type documentAttachmentHistory = $Result.DefaultSelection<Prisma.$documentAttachmentHistoryPayload>
/**
 * Model ReferenceDocuments
 * 
 */
export type ReferenceDocuments = $Result.DefaultSelection<Prisma.$ReferenceDocumentsPayload>
/**
 * Model VersionReferenceDocuments
 * 
 */
export type VersionReferenceDocuments = $Result.DefaultSelection<Prisma.$VersionReferenceDocumentsPayload>
/**
 * Model DocumentVersions
 * 
 */
export type DocumentVersions = $Result.DefaultSelection<Prisma.$DocumentVersionsPayload>
/**
 * Model DocumentComments
 * 
 */
export type DocumentComments = $Result.DefaultSelection<Prisma.$DocumentCommentsPayload>
/**
 * Model DocumentWorkFlowHistory
 * 
 */
export type DocumentWorkFlowHistory = $Result.DefaultSelection<Prisma.$DocumentWorkFlowHistoryPayload>
/**
 * Model documentAdmins
 * 
 */
export type documentAdmins = $Result.DefaultSelection<Prisma.$documentAdminsPayload>
/**
 * Model AdditionalDocumentAdmins
 * 
 */
export type AdditionalDocumentAdmins = $Result.DefaultSelection<Prisma.$AdditionalDocumentAdminsPayload>
/**
 * Model Logs
 * 
 */
export type Logs = $Result.DefaultSelection<Prisma.$LogsPayload>
/**
 * Model userPersonalisation
 * 
 */
export type userPersonalisation = $Result.DefaultSelection<Prisma.$userPersonalisationPayload>
/**
 * Model ConnectedApps
 * 
 */
export type ConnectedApps = $Result.DefaultSelection<Prisma.$ConnectedAppsPayload>
/**
 * Model unitType
 * 
 */
export type unitType = $Result.DefaultSelection<Prisma.$unitTypePayload>
/**
 * Model kpi
 * 
 */
export type kpi = $Result.DefaultSelection<Prisma.$kpiPayload>
/**
 * Model auditTrial
 * 
 */
export type auditTrial = $Result.DefaultSelection<Prisma.$auditTrialPayload>
/**
 * Model prefixSuffix
 * 
 */
export type prefixSuffix = $Result.DefaultSelection<Prisma.$prefixSuffixPayload>
/**
 * Model serialNumber
 * 
 */
export type serialNumber = $Result.DefaultSelection<Prisma.$serialNumberPayload>
/**
 * Model rolesTable
 * 
 */
export type rolesTable = $Result.DefaultSelection<Prisma.$rolesTablePayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P]): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number }): $Utils.JsPromise<R>

  /**
   * Executes a raw MongoDB command and returns the result of it.
   * @example
   * ```
   * const user = await prisma.$runCommandRaw({
   *   aggregate: 'User',
   *   pipeline: [{ $match: { name: 'Bob' } }, { $project: { email: true, _id: false } }],
   *   explain: false,
   * })
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $runCommandRaw(command: Prisma.InputJsonObject): Prisma.PrismaPromise<Prisma.JsonObject>

  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.models`: Exposes CRUD operations for the **Models** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Models
    * const models = await prisma.models.findMany()
    * ```
    */
  get models(): Prisma.ModelsDelegate<ExtArgs>;

  /**
   * `prisma.parts`: Exposes CRUD operations for the **Parts** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Parts
    * const parts = await prisma.parts.findMany()
    * ```
    */
  get parts(): Prisma.PartsDelegate<ExtArgs>;

  /**
   * `prisma.claim`: Exposes CRUD operations for the **Claim** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Claims
    * const claims = await prisma.claim.findMany()
    * ```
    */
  get claim(): Prisma.ClaimDelegate<ExtArgs>;

  /**
   * `prisma.problem`: Exposes CRUD operations for the **Problem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Problems
    * const problems = await prisma.problem.findMany()
    * ```
    */
  get problem(): Prisma.ProblemDelegate<ExtArgs>;

  /**
   * `prisma.claimToEntity`: Exposes CRUD operations for the **ClaimToEntity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClaimToEntities
    * const claimToEntities = await prisma.claimToEntity.findMany()
    * ```
    */
  get claimToEntity(): Prisma.ClaimToEntityDelegate<ExtArgs>;

  /**
   * `prisma.investigation`: Exposes CRUD operations for the **Investigation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Investigations
    * const investigations = await prisma.investigation.findMany()
    * ```
    */
  get investigation(): Prisma.InvestigationDelegate<ExtArgs>;

  /**
   * `prisma.shipment`: Exposes CRUD operations for the **Shipment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Shipments
    * const shipments = await prisma.shipment.findMany()
    * ```
    */
  get shipment(): Prisma.ShipmentDelegate<ExtArgs>;

  /**
   * `prisma.organization`: Exposes CRUD operations for the **Organization** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Organizations
    * const organizations = await prisma.organization.findMany()
    * ```
    */
  get organization(): Prisma.OrganizationDelegate<ExtArgs>;

  /**
   * `prisma.role`: Exposes CRUD operations for the **Role** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.role.findMany()
    * ```
    */
  get role(): Prisma.RoleDelegate<ExtArgs>;

  /**
   * `prisma.systemType`: Exposes CRUD operations for the **SystemType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SystemTypes
    * const systemTypes = await prisma.systemType.findMany()
    * ```
    */
  get systemType(): Prisma.SystemTypeDelegate<ExtArgs>;

  /**
   * `prisma.entityType`: Exposes CRUD operations for the **EntityType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EntityTypes
    * const entityTypes = await prisma.entityType.findMany()
    * ```
    */
  get entityType(): Prisma.EntityTypeDelegate<ExtArgs>;

  /**
   * `prisma.businessType`: Exposes CRUD operations for the **businessType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BusinessTypes
    * const businessTypes = await prisma.businessType.findMany()
    * ```
    */
  get businessType(): Prisma.businessTypeDelegate<ExtArgs>;

  /**
   * `prisma.business`: Exposes CRUD operations for the **Business** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Businesses
    * const businesses = await prisma.business.findMany()
    * ```
    */
  get business(): Prisma.BusinessDelegate<ExtArgs>;

  /**
   * `prisma.functions`: Exposes CRUD operations for the **Functions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Functions
    * const functions = await prisma.functions.findMany()
    * ```
    */
  get functions(): Prisma.FunctionsDelegate<ExtArgs>;

  /**
   * `prisma.section`: Exposes CRUD operations for the **Section** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sections
    * const sections = await prisma.section.findMany()
    * ```
    */
  get section(): Prisma.SectionDelegate<ExtArgs>;

  /**
   * `prisma.location`: Exposes CRUD operations for the **Location** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Locations
    * const locations = await prisma.location.findMany()
    * ```
    */
  get location(): Prisma.LocationDelegate<ExtArgs>;

  /**
   * `prisma.entity`: Exposes CRUD operations for the **Entity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Entities
    * const entities = await prisma.entity.findMany()
    * ```
    */
  get entity(): Prisma.EntityDelegate<ExtArgs>;

  /**
   * `prisma.locationBusiness`: Exposes CRUD operations for the **LocationBusiness** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LocationBusinesses
    * const locationBusinesses = await prisma.locationBusiness.findMany()
    * ```
    */
  get locationBusiness(): Prisma.LocationBusinessDelegate<ExtArgs>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs>;

  /**
   * `prisma.doctype`: Exposes CRUD operations for the **Doctype** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Doctypes
    * const doctypes = await prisma.doctype.findMany()
    * ```
    */
  get doctype(): Prisma.DoctypeDelegate<ExtArgs>;

  /**
   * `prisma.documents`: Exposes CRUD operations for the **Documents** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Documents
    * const documents = await prisma.documents.findMany()
    * ```
    */
  get documents(): Prisma.DocumentsDelegate<ExtArgs>;

  /**
   * `prisma.documentAttachmentHistory`: Exposes CRUD operations for the **documentAttachmentHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DocumentAttachmentHistories
    * const documentAttachmentHistories = await prisma.documentAttachmentHistory.findMany()
    * ```
    */
  get documentAttachmentHistory(): Prisma.documentAttachmentHistoryDelegate<ExtArgs>;

  /**
   * `prisma.referenceDocuments`: Exposes CRUD operations for the **ReferenceDocuments** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReferenceDocuments
    * const referenceDocuments = await prisma.referenceDocuments.findMany()
    * ```
    */
  get referenceDocuments(): Prisma.ReferenceDocumentsDelegate<ExtArgs>;

  /**
   * `prisma.versionReferenceDocuments`: Exposes CRUD operations for the **VersionReferenceDocuments** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VersionReferenceDocuments
    * const versionReferenceDocuments = await prisma.versionReferenceDocuments.findMany()
    * ```
    */
  get versionReferenceDocuments(): Prisma.VersionReferenceDocumentsDelegate<ExtArgs>;

  /**
   * `prisma.documentVersions`: Exposes CRUD operations for the **DocumentVersions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DocumentVersions
    * const documentVersions = await prisma.documentVersions.findMany()
    * ```
    */
  get documentVersions(): Prisma.DocumentVersionsDelegate<ExtArgs>;

  /**
   * `prisma.documentComments`: Exposes CRUD operations for the **DocumentComments** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DocumentComments
    * const documentComments = await prisma.documentComments.findMany()
    * ```
    */
  get documentComments(): Prisma.DocumentCommentsDelegate<ExtArgs>;

  /**
   * `prisma.documentWorkFlowHistory`: Exposes CRUD operations for the **DocumentWorkFlowHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DocumentWorkFlowHistories
    * const documentWorkFlowHistories = await prisma.documentWorkFlowHistory.findMany()
    * ```
    */
  get documentWorkFlowHistory(): Prisma.DocumentWorkFlowHistoryDelegate<ExtArgs>;

  /**
   * `prisma.documentAdmins`: Exposes CRUD operations for the **documentAdmins** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DocumentAdmins
    * const documentAdmins = await prisma.documentAdmins.findMany()
    * ```
    */
  get documentAdmins(): Prisma.documentAdminsDelegate<ExtArgs>;

  /**
   * `prisma.additionalDocumentAdmins`: Exposes CRUD operations for the **AdditionalDocumentAdmins** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdditionalDocumentAdmins
    * const additionalDocumentAdmins = await prisma.additionalDocumentAdmins.findMany()
    * ```
    */
  get additionalDocumentAdmins(): Prisma.AdditionalDocumentAdminsDelegate<ExtArgs>;

  /**
   * `prisma.logs`: Exposes CRUD operations for the **Logs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Logs
    * const logs = await prisma.logs.findMany()
    * ```
    */
  get logs(): Prisma.LogsDelegate<ExtArgs>;

  /**
   * `prisma.userPersonalisation`: Exposes CRUD operations for the **userPersonalisation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserPersonalisations
    * const userPersonalisations = await prisma.userPersonalisation.findMany()
    * ```
    */
  get userPersonalisation(): Prisma.userPersonalisationDelegate<ExtArgs>;

  /**
   * `prisma.connectedApps`: Exposes CRUD operations for the **ConnectedApps** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ConnectedApps
    * const connectedApps = await prisma.connectedApps.findMany()
    * ```
    */
  get connectedApps(): Prisma.ConnectedAppsDelegate<ExtArgs>;

  /**
   * `prisma.unitType`: Exposes CRUD operations for the **unitType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UnitTypes
    * const unitTypes = await prisma.unitType.findMany()
    * ```
    */
  get unitType(): Prisma.unitTypeDelegate<ExtArgs>;

  /**
   * `prisma.kpi`: Exposes CRUD operations for the **kpi** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Kpis
    * const kpis = await prisma.kpi.findMany()
    * ```
    */
  get kpi(): Prisma.kpiDelegate<ExtArgs>;

  /**
   * `prisma.auditTrial`: Exposes CRUD operations for the **auditTrial** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditTrials
    * const auditTrials = await prisma.auditTrial.findMany()
    * ```
    */
  get auditTrial(): Prisma.auditTrialDelegate<ExtArgs>;

  /**
   * `prisma.prefixSuffix`: Exposes CRUD operations for the **prefixSuffix** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PrefixSuffixes
    * const prefixSuffixes = await prisma.prefixSuffix.findMany()
    * ```
    */
  get prefixSuffix(): Prisma.prefixSuffixDelegate<ExtArgs>;

  /**
   * `prisma.serialNumber`: Exposes CRUD operations for the **serialNumber** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SerialNumbers
    * const serialNumbers = await prisma.serialNumber.findMany()
    * ```
    */
  get serialNumber(): Prisma.serialNumberDelegate<ExtArgs>;

  /**
   * `prisma.rolesTable`: Exposes CRUD operations for the **rolesTable** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RolesTables
    * const rolesTables = await prisma.rolesTable.findMany()
    * ```
    */
  get rolesTable(): Prisma.rolesTableDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Models: 'Models',
    Parts: 'Parts',
    Claim: 'Claim',
    Problem: 'Problem',
    ClaimToEntity: 'ClaimToEntity',
    Investigation: 'Investigation',
    Shipment: 'Shipment',
    Organization: 'Organization',
    Role: 'Role',
    SystemType: 'SystemType',
    EntityType: 'EntityType',
    businessType: 'businessType',
    Business: 'Business',
    Functions: 'Functions',
    Section: 'Section',
    Location: 'Location',
    Entity: 'Entity',
    LocationBusiness: 'LocationBusiness',
    Notification: 'Notification',
    Doctype: 'Doctype',
    Documents: 'Documents',
    documentAttachmentHistory: 'documentAttachmentHistory',
    ReferenceDocuments: 'ReferenceDocuments',
    VersionReferenceDocuments: 'VersionReferenceDocuments',
    DocumentVersions: 'DocumentVersions',
    DocumentComments: 'DocumentComments',
    DocumentWorkFlowHistory: 'DocumentWorkFlowHistory',
    documentAdmins: 'documentAdmins',
    AdditionalDocumentAdmins: 'AdditionalDocumentAdmins',
    Logs: 'Logs',
    userPersonalisation: 'userPersonalisation',
    ConnectedApps: 'ConnectedApps',
    unitType: 'unitType',
    kpi: 'kpi',
    auditTrial: 'auditTrial',
    prefixSuffix: 'prefixSuffix',
    serialNumber: 'serialNumber',
    rolesTable: 'rolesTable'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "models" | "parts" | "claim" | "problem" | "claimToEntity" | "investigation" | "shipment" | "organization" | "role" | "systemType" | "entityType" | "businessType" | "business" | "functions" | "section" | "location" | "entity" | "locationBusiness" | "notification" | "doctype" | "documents" | "documentAttachmentHistory" | "referenceDocuments" | "versionReferenceDocuments" | "documentVersions" | "documentComments" | "documentWorkFlowHistory" | "documentAdmins" | "additionalDocumentAdmins" | "logs" | "userPersonalisation" | "connectedApps" | "unitType" | "kpi" | "auditTrial" | "prefixSuffix" | "serialNumber" | "rolesTable"
      txIsolationLevel: never
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.UserFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.UserAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Models: {
        payload: Prisma.$ModelsPayload<ExtArgs>
        fields: Prisma.ModelsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ModelsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ModelsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelsPayload>
          }
          findFirst: {
            args: Prisma.ModelsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ModelsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelsPayload>
          }
          findMany: {
            args: Prisma.ModelsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelsPayload>[]
          }
          create: {
            args: Prisma.ModelsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelsPayload>
          }
          createMany: {
            args: Prisma.ModelsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ModelsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelsPayload>
          }
          update: {
            args: Prisma.ModelsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelsPayload>
          }
          deleteMany: {
            args: Prisma.ModelsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ModelsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ModelsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelsPayload>
          }
          aggregate: {
            args: Prisma.ModelsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateModels>
          }
          groupBy: {
            args: Prisma.ModelsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ModelsGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ModelsFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.ModelsAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.ModelsCountArgs<ExtArgs>
            result: $Utils.Optional<ModelsCountAggregateOutputType> | number
          }
        }
      }
      Parts: {
        payload: Prisma.$PartsPayload<ExtArgs>
        fields: Prisma.PartsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PartsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PartsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartsPayload>
          }
          findFirst: {
            args: Prisma.PartsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PartsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartsPayload>
          }
          findMany: {
            args: Prisma.PartsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartsPayload>[]
          }
          create: {
            args: Prisma.PartsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartsPayload>
          }
          createMany: {
            args: Prisma.PartsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PartsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartsPayload>
          }
          update: {
            args: Prisma.PartsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartsPayload>
          }
          deleteMany: {
            args: Prisma.PartsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PartsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PartsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartsPayload>
          }
          aggregate: {
            args: Prisma.PartsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateParts>
          }
          groupBy: {
            args: Prisma.PartsGroupByArgs<ExtArgs>
            result: $Utils.Optional<PartsGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.PartsFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.PartsAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.PartsCountArgs<ExtArgs>
            result: $Utils.Optional<PartsCountAggregateOutputType> | number
          }
        }
      }
      Claim: {
        payload: Prisma.$ClaimPayload<ExtArgs>
        fields: Prisma.ClaimFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClaimFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClaimPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClaimFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClaimPayload>
          }
          findFirst: {
            args: Prisma.ClaimFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClaimPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClaimFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClaimPayload>
          }
          findMany: {
            args: Prisma.ClaimFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClaimPayload>[]
          }
          create: {
            args: Prisma.ClaimCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClaimPayload>
          }
          createMany: {
            args: Prisma.ClaimCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ClaimDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClaimPayload>
          }
          update: {
            args: Prisma.ClaimUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClaimPayload>
          }
          deleteMany: {
            args: Prisma.ClaimDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClaimUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ClaimUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClaimPayload>
          }
          aggregate: {
            args: Prisma.ClaimAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClaim>
          }
          groupBy: {
            args: Prisma.ClaimGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClaimGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ClaimFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.ClaimAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.ClaimCountArgs<ExtArgs>
            result: $Utils.Optional<ClaimCountAggregateOutputType> | number
          }
        }
      }
      Problem: {
        payload: Prisma.$ProblemPayload<ExtArgs>
        fields: Prisma.ProblemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProblemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProblemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProblemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProblemPayload>
          }
          findFirst: {
            args: Prisma.ProblemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProblemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProblemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProblemPayload>
          }
          findMany: {
            args: Prisma.ProblemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProblemPayload>[]
          }
          create: {
            args: Prisma.ProblemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProblemPayload>
          }
          createMany: {
            args: Prisma.ProblemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ProblemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProblemPayload>
          }
          update: {
            args: Prisma.ProblemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProblemPayload>
          }
          deleteMany: {
            args: Prisma.ProblemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProblemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProblemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProblemPayload>
          }
          aggregate: {
            args: Prisma.ProblemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProblem>
          }
          groupBy: {
            args: Prisma.ProblemGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProblemGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ProblemFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.ProblemAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.ProblemCountArgs<ExtArgs>
            result: $Utils.Optional<ProblemCountAggregateOutputType> | number
          }
        }
      }
      ClaimToEntity: {
        payload: Prisma.$ClaimToEntityPayload<ExtArgs>
        fields: Prisma.ClaimToEntityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClaimToEntityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClaimToEntityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClaimToEntityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClaimToEntityPayload>
          }
          findFirst: {
            args: Prisma.ClaimToEntityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClaimToEntityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClaimToEntityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClaimToEntityPayload>
          }
          findMany: {
            args: Prisma.ClaimToEntityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClaimToEntityPayload>[]
          }
          create: {
            args: Prisma.ClaimToEntityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClaimToEntityPayload>
          }
          createMany: {
            args: Prisma.ClaimToEntityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ClaimToEntityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClaimToEntityPayload>
          }
          update: {
            args: Prisma.ClaimToEntityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClaimToEntityPayload>
          }
          deleteMany: {
            args: Prisma.ClaimToEntityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClaimToEntityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ClaimToEntityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClaimToEntityPayload>
          }
          aggregate: {
            args: Prisma.ClaimToEntityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClaimToEntity>
          }
          groupBy: {
            args: Prisma.ClaimToEntityGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClaimToEntityGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ClaimToEntityFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.ClaimToEntityAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.ClaimToEntityCountArgs<ExtArgs>
            result: $Utils.Optional<ClaimToEntityCountAggregateOutputType> | number
          }
        }
      }
      Investigation: {
        payload: Prisma.$InvestigationPayload<ExtArgs>
        fields: Prisma.InvestigationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvestigationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestigationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvestigationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestigationPayload>
          }
          findFirst: {
            args: Prisma.InvestigationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestigationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvestigationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestigationPayload>
          }
          findMany: {
            args: Prisma.InvestigationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestigationPayload>[]
          }
          create: {
            args: Prisma.InvestigationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestigationPayload>
          }
          createMany: {
            args: Prisma.InvestigationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.InvestigationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestigationPayload>
          }
          update: {
            args: Prisma.InvestigationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestigationPayload>
          }
          deleteMany: {
            args: Prisma.InvestigationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvestigationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InvestigationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestigationPayload>
          }
          aggregate: {
            args: Prisma.InvestigationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvestigation>
          }
          groupBy: {
            args: Prisma.InvestigationGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvestigationGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.InvestigationFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.InvestigationAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.InvestigationCountArgs<ExtArgs>
            result: $Utils.Optional<InvestigationCountAggregateOutputType> | number
          }
        }
      }
      Shipment: {
        payload: Prisma.$ShipmentPayload<ExtArgs>
        fields: Prisma.ShipmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ShipmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShipmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ShipmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShipmentPayload>
          }
          findFirst: {
            args: Prisma.ShipmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShipmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ShipmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShipmentPayload>
          }
          findMany: {
            args: Prisma.ShipmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShipmentPayload>[]
          }
          create: {
            args: Prisma.ShipmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShipmentPayload>
          }
          createMany: {
            args: Prisma.ShipmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ShipmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShipmentPayload>
          }
          update: {
            args: Prisma.ShipmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShipmentPayload>
          }
          deleteMany: {
            args: Prisma.ShipmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ShipmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ShipmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShipmentPayload>
          }
          aggregate: {
            args: Prisma.ShipmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateShipment>
          }
          groupBy: {
            args: Prisma.ShipmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<ShipmentGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ShipmentFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.ShipmentAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.ShipmentCountArgs<ExtArgs>
            result: $Utils.Optional<ShipmentCountAggregateOutputType> | number
          }
        }
      }
      Organization: {
        payload: Prisma.$OrganizationPayload<ExtArgs>
        fields: Prisma.OrganizationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrganizationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrganizationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          findFirst: {
            args: Prisma.OrganizationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrganizationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          findMany: {
            args: Prisma.OrganizationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>[]
          }
          create: {
            args: Prisma.OrganizationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          createMany: {
            args: Prisma.OrganizationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.OrganizationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          update: {
            args: Prisma.OrganizationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          deleteMany: {
            args: Prisma.OrganizationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrganizationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OrganizationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          aggregate: {
            args: Prisma.OrganizationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrganization>
          }
          groupBy: {
            args: Prisma.OrganizationGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrganizationGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.OrganizationFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.OrganizationAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.OrganizationCountArgs<ExtArgs>
            result: $Utils.Optional<OrganizationCountAggregateOutputType> | number
          }
        }
      }
      Role: {
        payload: Prisma.$RolePayload<ExtArgs>
        fields: Prisma.RoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findFirst: {
            args: Prisma.RoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findMany: {
            args: Prisma.RoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          create: {
            args: Prisma.RoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          createMany: {
            args: Prisma.RoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.RoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          update: {
            args: Prisma.RoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          deleteMany: {
            args: Prisma.RoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          aggregate: {
            args: Prisma.RoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRole>
          }
          groupBy: {
            args: Prisma.RoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoleGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.RoleFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.RoleAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.RoleCountArgs<ExtArgs>
            result: $Utils.Optional<RoleCountAggregateOutputType> | number
          }
        }
      }
      SystemType: {
        payload: Prisma.$SystemTypePayload<ExtArgs>
        fields: Prisma.SystemTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SystemTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SystemTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemTypePayload>
          }
          findFirst: {
            args: Prisma.SystemTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SystemTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemTypePayload>
          }
          findMany: {
            args: Prisma.SystemTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemTypePayload>[]
          }
          create: {
            args: Prisma.SystemTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemTypePayload>
          }
          createMany: {
            args: Prisma.SystemTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SystemTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemTypePayload>
          }
          update: {
            args: Prisma.SystemTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemTypePayload>
          }
          deleteMany: {
            args: Prisma.SystemTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SystemTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SystemTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemTypePayload>
          }
          aggregate: {
            args: Prisma.SystemTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSystemType>
          }
          groupBy: {
            args: Prisma.SystemTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<SystemTypeGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.SystemTypeFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.SystemTypeAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.SystemTypeCountArgs<ExtArgs>
            result: $Utils.Optional<SystemTypeCountAggregateOutputType> | number
          }
        }
      }
      EntityType: {
        payload: Prisma.$EntityTypePayload<ExtArgs>
        fields: Prisma.EntityTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EntityTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntityTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EntityTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntityTypePayload>
          }
          findFirst: {
            args: Prisma.EntityTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntityTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EntityTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntityTypePayload>
          }
          findMany: {
            args: Prisma.EntityTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntityTypePayload>[]
          }
          create: {
            args: Prisma.EntityTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntityTypePayload>
          }
          createMany: {
            args: Prisma.EntityTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EntityTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntityTypePayload>
          }
          update: {
            args: Prisma.EntityTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntityTypePayload>
          }
          deleteMany: {
            args: Prisma.EntityTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EntityTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EntityTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntityTypePayload>
          }
          aggregate: {
            args: Prisma.EntityTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEntityType>
          }
          groupBy: {
            args: Prisma.EntityTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<EntityTypeGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.EntityTypeFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.EntityTypeAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.EntityTypeCountArgs<ExtArgs>
            result: $Utils.Optional<EntityTypeCountAggregateOutputType> | number
          }
        }
      }
      businessType: {
        payload: Prisma.$businessTypePayload<ExtArgs>
        fields: Prisma.businessTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.businessTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$businessTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.businessTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$businessTypePayload>
          }
          findFirst: {
            args: Prisma.businessTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$businessTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.businessTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$businessTypePayload>
          }
          findMany: {
            args: Prisma.businessTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$businessTypePayload>[]
          }
          create: {
            args: Prisma.businessTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$businessTypePayload>
          }
          createMany: {
            args: Prisma.businessTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.businessTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$businessTypePayload>
          }
          update: {
            args: Prisma.businessTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$businessTypePayload>
          }
          deleteMany: {
            args: Prisma.businessTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.businessTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.businessTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$businessTypePayload>
          }
          aggregate: {
            args: Prisma.BusinessTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBusinessType>
          }
          groupBy: {
            args: Prisma.businessTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<BusinessTypeGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.businessTypeFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.businessTypeAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.businessTypeCountArgs<ExtArgs>
            result: $Utils.Optional<BusinessTypeCountAggregateOutputType> | number
          }
        }
      }
      Business: {
        payload: Prisma.$BusinessPayload<ExtArgs>
        fields: Prisma.BusinessFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BusinessFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BusinessFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessPayload>
          }
          findFirst: {
            args: Prisma.BusinessFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BusinessFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessPayload>
          }
          findMany: {
            args: Prisma.BusinessFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessPayload>[]
          }
          create: {
            args: Prisma.BusinessCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessPayload>
          }
          createMany: {
            args: Prisma.BusinessCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BusinessDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessPayload>
          }
          update: {
            args: Prisma.BusinessUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessPayload>
          }
          deleteMany: {
            args: Prisma.BusinessDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BusinessUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BusinessUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessPayload>
          }
          aggregate: {
            args: Prisma.BusinessAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBusiness>
          }
          groupBy: {
            args: Prisma.BusinessGroupByArgs<ExtArgs>
            result: $Utils.Optional<BusinessGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.BusinessFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.BusinessAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.BusinessCountArgs<ExtArgs>
            result: $Utils.Optional<BusinessCountAggregateOutputType> | number
          }
        }
      }
      Functions: {
        payload: Prisma.$FunctionsPayload<ExtArgs>
        fields: Prisma.FunctionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FunctionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FunctionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FunctionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FunctionsPayload>
          }
          findFirst: {
            args: Prisma.FunctionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FunctionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FunctionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FunctionsPayload>
          }
          findMany: {
            args: Prisma.FunctionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FunctionsPayload>[]
          }
          create: {
            args: Prisma.FunctionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FunctionsPayload>
          }
          createMany: {
            args: Prisma.FunctionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.FunctionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FunctionsPayload>
          }
          update: {
            args: Prisma.FunctionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FunctionsPayload>
          }
          deleteMany: {
            args: Prisma.FunctionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FunctionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FunctionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FunctionsPayload>
          }
          aggregate: {
            args: Prisma.FunctionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFunctions>
          }
          groupBy: {
            args: Prisma.FunctionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<FunctionsGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.FunctionsFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.FunctionsAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.FunctionsCountArgs<ExtArgs>
            result: $Utils.Optional<FunctionsCountAggregateOutputType> | number
          }
        }
      }
      Section: {
        payload: Prisma.$SectionPayload<ExtArgs>
        fields: Prisma.SectionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SectionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SectionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionPayload>
          }
          findFirst: {
            args: Prisma.SectionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SectionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionPayload>
          }
          findMany: {
            args: Prisma.SectionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionPayload>[]
          }
          create: {
            args: Prisma.SectionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionPayload>
          }
          createMany: {
            args: Prisma.SectionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SectionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionPayload>
          }
          update: {
            args: Prisma.SectionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionPayload>
          }
          deleteMany: {
            args: Prisma.SectionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SectionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SectionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionPayload>
          }
          aggregate: {
            args: Prisma.SectionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSection>
          }
          groupBy: {
            args: Prisma.SectionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SectionGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.SectionFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.SectionAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.SectionCountArgs<ExtArgs>
            result: $Utils.Optional<SectionCountAggregateOutputType> | number
          }
        }
      }
      Location: {
        payload: Prisma.$LocationPayload<ExtArgs>
        fields: Prisma.LocationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LocationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LocationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          findFirst: {
            args: Prisma.LocationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LocationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          findMany: {
            args: Prisma.LocationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>[]
          }
          create: {
            args: Prisma.LocationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          createMany: {
            args: Prisma.LocationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.LocationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          update: {
            args: Prisma.LocationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          deleteMany: {
            args: Prisma.LocationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LocationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LocationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          aggregate: {
            args: Prisma.LocationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLocation>
          }
          groupBy: {
            args: Prisma.LocationGroupByArgs<ExtArgs>
            result: $Utils.Optional<LocationGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.LocationFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.LocationAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.LocationCountArgs<ExtArgs>
            result: $Utils.Optional<LocationCountAggregateOutputType> | number
          }
        }
      }
      Entity: {
        payload: Prisma.$EntityPayload<ExtArgs>
        fields: Prisma.EntityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EntityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EntityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntityPayload>
          }
          findFirst: {
            args: Prisma.EntityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EntityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntityPayload>
          }
          findMany: {
            args: Prisma.EntityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntityPayload>[]
          }
          create: {
            args: Prisma.EntityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntityPayload>
          }
          createMany: {
            args: Prisma.EntityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EntityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntityPayload>
          }
          update: {
            args: Prisma.EntityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntityPayload>
          }
          deleteMany: {
            args: Prisma.EntityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EntityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EntityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntityPayload>
          }
          aggregate: {
            args: Prisma.EntityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEntity>
          }
          groupBy: {
            args: Prisma.EntityGroupByArgs<ExtArgs>
            result: $Utils.Optional<EntityGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.EntityFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.EntityAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.EntityCountArgs<ExtArgs>
            result: $Utils.Optional<EntityCountAggregateOutputType> | number
          }
        }
      }
      LocationBusiness: {
        payload: Prisma.$LocationBusinessPayload<ExtArgs>
        fields: Prisma.LocationBusinessFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LocationBusinessFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationBusinessPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LocationBusinessFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationBusinessPayload>
          }
          findFirst: {
            args: Prisma.LocationBusinessFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationBusinessPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LocationBusinessFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationBusinessPayload>
          }
          findMany: {
            args: Prisma.LocationBusinessFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationBusinessPayload>[]
          }
          create: {
            args: Prisma.LocationBusinessCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationBusinessPayload>
          }
          createMany: {
            args: Prisma.LocationBusinessCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.LocationBusinessDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationBusinessPayload>
          }
          update: {
            args: Prisma.LocationBusinessUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationBusinessPayload>
          }
          deleteMany: {
            args: Prisma.LocationBusinessDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LocationBusinessUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LocationBusinessUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationBusinessPayload>
          }
          aggregate: {
            args: Prisma.LocationBusinessAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLocationBusiness>
          }
          groupBy: {
            args: Prisma.LocationBusinessGroupByArgs<ExtArgs>
            result: $Utils.Optional<LocationBusinessGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.LocationBusinessFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.LocationBusinessAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.LocationBusinessCountArgs<ExtArgs>
            result: $Utils.Optional<LocationBusinessCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.NotificationFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.NotificationAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      Doctype: {
        payload: Prisma.$DoctypePayload<ExtArgs>
        fields: Prisma.DoctypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DoctypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DoctypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctypePayload>
          }
          findFirst: {
            args: Prisma.DoctypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DoctypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctypePayload>
          }
          findMany: {
            args: Prisma.DoctypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctypePayload>[]
          }
          create: {
            args: Prisma.DoctypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctypePayload>
          }
          createMany: {
            args: Prisma.DoctypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DoctypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctypePayload>
          }
          update: {
            args: Prisma.DoctypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctypePayload>
          }
          deleteMany: {
            args: Prisma.DoctypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DoctypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DoctypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctypePayload>
          }
          aggregate: {
            args: Prisma.DoctypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDoctype>
          }
          groupBy: {
            args: Prisma.DoctypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<DoctypeGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.DoctypeFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.DoctypeAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.DoctypeCountArgs<ExtArgs>
            result: $Utils.Optional<DoctypeCountAggregateOutputType> | number
          }
        }
      }
      Documents: {
        payload: Prisma.$DocumentsPayload<ExtArgs>
        fields: Prisma.DocumentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DocumentsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DocumentsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentsPayload>
          }
          findFirst: {
            args: Prisma.DocumentsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DocumentsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentsPayload>
          }
          findMany: {
            args: Prisma.DocumentsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentsPayload>[]
          }
          create: {
            args: Prisma.DocumentsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentsPayload>
          }
          createMany: {
            args: Prisma.DocumentsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DocumentsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentsPayload>
          }
          update: {
            args: Prisma.DocumentsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentsPayload>
          }
          deleteMany: {
            args: Prisma.DocumentsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DocumentsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DocumentsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentsPayload>
          }
          aggregate: {
            args: Prisma.DocumentsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDocuments>
          }
          groupBy: {
            args: Prisma.DocumentsGroupByArgs<ExtArgs>
            result: $Utils.Optional<DocumentsGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.DocumentsFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.DocumentsAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.DocumentsCountArgs<ExtArgs>
            result: $Utils.Optional<DocumentsCountAggregateOutputType> | number
          }
        }
      }
      documentAttachmentHistory: {
        payload: Prisma.$documentAttachmentHistoryPayload<ExtArgs>
        fields: Prisma.documentAttachmentHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.documentAttachmentHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$documentAttachmentHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.documentAttachmentHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$documentAttachmentHistoryPayload>
          }
          findFirst: {
            args: Prisma.documentAttachmentHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$documentAttachmentHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.documentAttachmentHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$documentAttachmentHistoryPayload>
          }
          findMany: {
            args: Prisma.documentAttachmentHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$documentAttachmentHistoryPayload>[]
          }
          create: {
            args: Prisma.documentAttachmentHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$documentAttachmentHistoryPayload>
          }
          createMany: {
            args: Prisma.documentAttachmentHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.documentAttachmentHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$documentAttachmentHistoryPayload>
          }
          update: {
            args: Prisma.documentAttachmentHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$documentAttachmentHistoryPayload>
          }
          deleteMany: {
            args: Prisma.documentAttachmentHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.documentAttachmentHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.documentAttachmentHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$documentAttachmentHistoryPayload>
          }
          aggregate: {
            args: Prisma.DocumentAttachmentHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDocumentAttachmentHistory>
          }
          groupBy: {
            args: Prisma.documentAttachmentHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<DocumentAttachmentHistoryGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.documentAttachmentHistoryFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.documentAttachmentHistoryAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.documentAttachmentHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<DocumentAttachmentHistoryCountAggregateOutputType> | number
          }
        }
      }
      ReferenceDocuments: {
        payload: Prisma.$ReferenceDocumentsPayload<ExtArgs>
        fields: Prisma.ReferenceDocumentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReferenceDocumentsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferenceDocumentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReferenceDocumentsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferenceDocumentsPayload>
          }
          findFirst: {
            args: Prisma.ReferenceDocumentsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferenceDocumentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReferenceDocumentsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferenceDocumentsPayload>
          }
          findMany: {
            args: Prisma.ReferenceDocumentsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferenceDocumentsPayload>[]
          }
          create: {
            args: Prisma.ReferenceDocumentsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferenceDocumentsPayload>
          }
          createMany: {
            args: Prisma.ReferenceDocumentsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ReferenceDocumentsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferenceDocumentsPayload>
          }
          update: {
            args: Prisma.ReferenceDocumentsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferenceDocumentsPayload>
          }
          deleteMany: {
            args: Prisma.ReferenceDocumentsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReferenceDocumentsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ReferenceDocumentsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferenceDocumentsPayload>
          }
          aggregate: {
            args: Prisma.ReferenceDocumentsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReferenceDocuments>
          }
          groupBy: {
            args: Prisma.ReferenceDocumentsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReferenceDocumentsGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ReferenceDocumentsFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.ReferenceDocumentsAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.ReferenceDocumentsCountArgs<ExtArgs>
            result: $Utils.Optional<ReferenceDocumentsCountAggregateOutputType> | number
          }
        }
      }
      VersionReferenceDocuments: {
        payload: Prisma.$VersionReferenceDocumentsPayload<ExtArgs>
        fields: Prisma.VersionReferenceDocumentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VersionReferenceDocumentsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VersionReferenceDocumentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VersionReferenceDocumentsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VersionReferenceDocumentsPayload>
          }
          findFirst: {
            args: Prisma.VersionReferenceDocumentsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VersionReferenceDocumentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VersionReferenceDocumentsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VersionReferenceDocumentsPayload>
          }
          findMany: {
            args: Prisma.VersionReferenceDocumentsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VersionReferenceDocumentsPayload>[]
          }
          create: {
            args: Prisma.VersionReferenceDocumentsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VersionReferenceDocumentsPayload>
          }
          createMany: {
            args: Prisma.VersionReferenceDocumentsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.VersionReferenceDocumentsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VersionReferenceDocumentsPayload>
          }
          update: {
            args: Prisma.VersionReferenceDocumentsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VersionReferenceDocumentsPayload>
          }
          deleteMany: {
            args: Prisma.VersionReferenceDocumentsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VersionReferenceDocumentsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VersionReferenceDocumentsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VersionReferenceDocumentsPayload>
          }
          aggregate: {
            args: Prisma.VersionReferenceDocumentsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVersionReferenceDocuments>
          }
          groupBy: {
            args: Prisma.VersionReferenceDocumentsGroupByArgs<ExtArgs>
            result: $Utils.Optional<VersionReferenceDocumentsGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.VersionReferenceDocumentsFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.VersionReferenceDocumentsAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.VersionReferenceDocumentsCountArgs<ExtArgs>
            result: $Utils.Optional<VersionReferenceDocumentsCountAggregateOutputType> | number
          }
        }
      }
      DocumentVersions: {
        payload: Prisma.$DocumentVersionsPayload<ExtArgs>
        fields: Prisma.DocumentVersionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DocumentVersionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentVersionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DocumentVersionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentVersionsPayload>
          }
          findFirst: {
            args: Prisma.DocumentVersionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentVersionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DocumentVersionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentVersionsPayload>
          }
          findMany: {
            args: Prisma.DocumentVersionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentVersionsPayload>[]
          }
          create: {
            args: Prisma.DocumentVersionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentVersionsPayload>
          }
          createMany: {
            args: Prisma.DocumentVersionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DocumentVersionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentVersionsPayload>
          }
          update: {
            args: Prisma.DocumentVersionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentVersionsPayload>
          }
          deleteMany: {
            args: Prisma.DocumentVersionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DocumentVersionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DocumentVersionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentVersionsPayload>
          }
          aggregate: {
            args: Prisma.DocumentVersionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDocumentVersions>
          }
          groupBy: {
            args: Prisma.DocumentVersionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<DocumentVersionsGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.DocumentVersionsFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.DocumentVersionsAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.DocumentVersionsCountArgs<ExtArgs>
            result: $Utils.Optional<DocumentVersionsCountAggregateOutputType> | number
          }
        }
      }
      DocumentComments: {
        payload: Prisma.$DocumentCommentsPayload<ExtArgs>
        fields: Prisma.DocumentCommentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DocumentCommentsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentCommentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DocumentCommentsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentCommentsPayload>
          }
          findFirst: {
            args: Prisma.DocumentCommentsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentCommentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DocumentCommentsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentCommentsPayload>
          }
          findMany: {
            args: Prisma.DocumentCommentsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentCommentsPayload>[]
          }
          create: {
            args: Prisma.DocumentCommentsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentCommentsPayload>
          }
          createMany: {
            args: Prisma.DocumentCommentsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DocumentCommentsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentCommentsPayload>
          }
          update: {
            args: Prisma.DocumentCommentsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentCommentsPayload>
          }
          deleteMany: {
            args: Prisma.DocumentCommentsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DocumentCommentsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DocumentCommentsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentCommentsPayload>
          }
          aggregate: {
            args: Prisma.DocumentCommentsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDocumentComments>
          }
          groupBy: {
            args: Prisma.DocumentCommentsGroupByArgs<ExtArgs>
            result: $Utils.Optional<DocumentCommentsGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.DocumentCommentsFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.DocumentCommentsAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.DocumentCommentsCountArgs<ExtArgs>
            result: $Utils.Optional<DocumentCommentsCountAggregateOutputType> | number
          }
        }
      }
      DocumentWorkFlowHistory: {
        payload: Prisma.$DocumentWorkFlowHistoryPayload<ExtArgs>
        fields: Prisma.DocumentWorkFlowHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DocumentWorkFlowHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentWorkFlowHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DocumentWorkFlowHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentWorkFlowHistoryPayload>
          }
          findFirst: {
            args: Prisma.DocumentWorkFlowHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentWorkFlowHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DocumentWorkFlowHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentWorkFlowHistoryPayload>
          }
          findMany: {
            args: Prisma.DocumentWorkFlowHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentWorkFlowHistoryPayload>[]
          }
          create: {
            args: Prisma.DocumentWorkFlowHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentWorkFlowHistoryPayload>
          }
          createMany: {
            args: Prisma.DocumentWorkFlowHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DocumentWorkFlowHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentWorkFlowHistoryPayload>
          }
          update: {
            args: Prisma.DocumentWorkFlowHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentWorkFlowHistoryPayload>
          }
          deleteMany: {
            args: Prisma.DocumentWorkFlowHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DocumentWorkFlowHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DocumentWorkFlowHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentWorkFlowHistoryPayload>
          }
          aggregate: {
            args: Prisma.DocumentWorkFlowHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDocumentWorkFlowHistory>
          }
          groupBy: {
            args: Prisma.DocumentWorkFlowHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<DocumentWorkFlowHistoryGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.DocumentWorkFlowHistoryFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.DocumentWorkFlowHistoryAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.DocumentWorkFlowHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<DocumentWorkFlowHistoryCountAggregateOutputType> | number
          }
        }
      }
      documentAdmins: {
        payload: Prisma.$documentAdminsPayload<ExtArgs>
        fields: Prisma.documentAdminsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.documentAdminsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$documentAdminsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.documentAdminsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$documentAdminsPayload>
          }
          findFirst: {
            args: Prisma.documentAdminsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$documentAdminsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.documentAdminsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$documentAdminsPayload>
          }
          findMany: {
            args: Prisma.documentAdminsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$documentAdminsPayload>[]
          }
          create: {
            args: Prisma.documentAdminsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$documentAdminsPayload>
          }
          createMany: {
            args: Prisma.documentAdminsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.documentAdminsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$documentAdminsPayload>
          }
          update: {
            args: Prisma.documentAdminsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$documentAdminsPayload>
          }
          deleteMany: {
            args: Prisma.documentAdminsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.documentAdminsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.documentAdminsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$documentAdminsPayload>
          }
          aggregate: {
            args: Prisma.DocumentAdminsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDocumentAdmins>
          }
          groupBy: {
            args: Prisma.documentAdminsGroupByArgs<ExtArgs>
            result: $Utils.Optional<DocumentAdminsGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.documentAdminsFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.documentAdminsAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.documentAdminsCountArgs<ExtArgs>
            result: $Utils.Optional<DocumentAdminsCountAggregateOutputType> | number
          }
        }
      }
      AdditionalDocumentAdmins: {
        payload: Prisma.$AdditionalDocumentAdminsPayload<ExtArgs>
        fields: Prisma.AdditionalDocumentAdminsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdditionalDocumentAdminsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdditionalDocumentAdminsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdditionalDocumentAdminsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdditionalDocumentAdminsPayload>
          }
          findFirst: {
            args: Prisma.AdditionalDocumentAdminsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdditionalDocumentAdminsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdditionalDocumentAdminsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdditionalDocumentAdminsPayload>
          }
          findMany: {
            args: Prisma.AdditionalDocumentAdminsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdditionalDocumentAdminsPayload>[]
          }
          create: {
            args: Prisma.AdditionalDocumentAdminsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdditionalDocumentAdminsPayload>
          }
          createMany: {
            args: Prisma.AdditionalDocumentAdminsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AdditionalDocumentAdminsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdditionalDocumentAdminsPayload>
          }
          update: {
            args: Prisma.AdditionalDocumentAdminsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdditionalDocumentAdminsPayload>
          }
          deleteMany: {
            args: Prisma.AdditionalDocumentAdminsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdditionalDocumentAdminsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AdditionalDocumentAdminsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdditionalDocumentAdminsPayload>
          }
          aggregate: {
            args: Prisma.AdditionalDocumentAdminsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdditionalDocumentAdmins>
          }
          groupBy: {
            args: Prisma.AdditionalDocumentAdminsGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdditionalDocumentAdminsGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.AdditionalDocumentAdminsFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.AdditionalDocumentAdminsAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.AdditionalDocumentAdminsCountArgs<ExtArgs>
            result: $Utils.Optional<AdditionalDocumentAdminsCountAggregateOutputType> | number
          }
        }
      }
      Logs: {
        payload: Prisma.$LogsPayload<ExtArgs>
        fields: Prisma.LogsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LogsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LogsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogsPayload>
          }
          findFirst: {
            args: Prisma.LogsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LogsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogsPayload>
          }
          findMany: {
            args: Prisma.LogsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogsPayload>[]
          }
          create: {
            args: Prisma.LogsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogsPayload>
          }
          createMany: {
            args: Prisma.LogsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.LogsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogsPayload>
          }
          update: {
            args: Prisma.LogsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogsPayload>
          }
          deleteMany: {
            args: Prisma.LogsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LogsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LogsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogsPayload>
          }
          aggregate: {
            args: Prisma.LogsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLogs>
          }
          groupBy: {
            args: Prisma.LogsGroupByArgs<ExtArgs>
            result: $Utils.Optional<LogsGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.LogsFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.LogsAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.LogsCountArgs<ExtArgs>
            result: $Utils.Optional<LogsCountAggregateOutputType> | number
          }
        }
      }
      userPersonalisation: {
        payload: Prisma.$userPersonalisationPayload<ExtArgs>
        fields: Prisma.userPersonalisationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.userPersonalisationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPersonalisationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.userPersonalisationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPersonalisationPayload>
          }
          findFirst: {
            args: Prisma.userPersonalisationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPersonalisationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.userPersonalisationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPersonalisationPayload>
          }
          findMany: {
            args: Prisma.userPersonalisationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPersonalisationPayload>[]
          }
          create: {
            args: Prisma.userPersonalisationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPersonalisationPayload>
          }
          createMany: {
            args: Prisma.userPersonalisationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.userPersonalisationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPersonalisationPayload>
          }
          update: {
            args: Prisma.userPersonalisationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPersonalisationPayload>
          }
          deleteMany: {
            args: Prisma.userPersonalisationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.userPersonalisationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.userPersonalisationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPersonalisationPayload>
          }
          aggregate: {
            args: Prisma.UserPersonalisationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserPersonalisation>
          }
          groupBy: {
            args: Prisma.userPersonalisationGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserPersonalisationGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.userPersonalisationFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.userPersonalisationAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.userPersonalisationCountArgs<ExtArgs>
            result: $Utils.Optional<UserPersonalisationCountAggregateOutputType> | number
          }
        }
      }
      ConnectedApps: {
        payload: Prisma.$ConnectedAppsPayload<ExtArgs>
        fields: Prisma.ConnectedAppsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConnectedAppsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConnectedAppsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConnectedAppsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConnectedAppsPayload>
          }
          findFirst: {
            args: Prisma.ConnectedAppsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConnectedAppsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConnectedAppsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConnectedAppsPayload>
          }
          findMany: {
            args: Prisma.ConnectedAppsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConnectedAppsPayload>[]
          }
          create: {
            args: Prisma.ConnectedAppsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConnectedAppsPayload>
          }
          createMany: {
            args: Prisma.ConnectedAppsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ConnectedAppsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConnectedAppsPayload>
          }
          update: {
            args: Prisma.ConnectedAppsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConnectedAppsPayload>
          }
          deleteMany: {
            args: Prisma.ConnectedAppsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConnectedAppsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ConnectedAppsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConnectedAppsPayload>
          }
          aggregate: {
            args: Prisma.ConnectedAppsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConnectedApps>
          }
          groupBy: {
            args: Prisma.ConnectedAppsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConnectedAppsGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ConnectedAppsFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.ConnectedAppsAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.ConnectedAppsCountArgs<ExtArgs>
            result: $Utils.Optional<ConnectedAppsCountAggregateOutputType> | number
          }
        }
      }
      unitType: {
        payload: Prisma.$unitTypePayload<ExtArgs>
        fields: Prisma.unitTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.unitTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$unitTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.unitTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$unitTypePayload>
          }
          findFirst: {
            args: Prisma.unitTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$unitTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.unitTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$unitTypePayload>
          }
          findMany: {
            args: Prisma.unitTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$unitTypePayload>[]
          }
          create: {
            args: Prisma.unitTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$unitTypePayload>
          }
          createMany: {
            args: Prisma.unitTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.unitTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$unitTypePayload>
          }
          update: {
            args: Prisma.unitTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$unitTypePayload>
          }
          deleteMany: {
            args: Prisma.unitTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.unitTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.unitTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$unitTypePayload>
          }
          aggregate: {
            args: Prisma.UnitTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUnitType>
          }
          groupBy: {
            args: Prisma.unitTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<UnitTypeGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.unitTypeFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.unitTypeAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.unitTypeCountArgs<ExtArgs>
            result: $Utils.Optional<UnitTypeCountAggregateOutputType> | number
          }
        }
      }
      kpi: {
        payload: Prisma.$kpiPayload<ExtArgs>
        fields: Prisma.kpiFieldRefs
        operations: {
          findUnique: {
            args: Prisma.kpiFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kpiPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.kpiFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kpiPayload>
          }
          findFirst: {
            args: Prisma.kpiFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kpiPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.kpiFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kpiPayload>
          }
          findMany: {
            args: Prisma.kpiFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kpiPayload>[]
          }
          create: {
            args: Prisma.kpiCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kpiPayload>
          }
          createMany: {
            args: Prisma.kpiCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.kpiDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kpiPayload>
          }
          update: {
            args: Prisma.kpiUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kpiPayload>
          }
          deleteMany: {
            args: Prisma.kpiDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.kpiUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.kpiUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kpiPayload>
          }
          aggregate: {
            args: Prisma.KpiAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKpi>
          }
          groupBy: {
            args: Prisma.kpiGroupByArgs<ExtArgs>
            result: $Utils.Optional<KpiGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.kpiFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.kpiAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.kpiCountArgs<ExtArgs>
            result: $Utils.Optional<KpiCountAggregateOutputType> | number
          }
        }
      }
      auditTrial: {
        payload: Prisma.$auditTrialPayload<ExtArgs>
        fields: Prisma.auditTrialFieldRefs
        operations: {
          findUnique: {
            args: Prisma.auditTrialFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auditTrialPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.auditTrialFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auditTrialPayload>
          }
          findFirst: {
            args: Prisma.auditTrialFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auditTrialPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.auditTrialFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auditTrialPayload>
          }
          findMany: {
            args: Prisma.auditTrialFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auditTrialPayload>[]
          }
          create: {
            args: Prisma.auditTrialCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auditTrialPayload>
          }
          createMany: {
            args: Prisma.auditTrialCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.auditTrialDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auditTrialPayload>
          }
          update: {
            args: Prisma.auditTrialUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auditTrialPayload>
          }
          deleteMany: {
            args: Prisma.auditTrialDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.auditTrialUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.auditTrialUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auditTrialPayload>
          }
          aggregate: {
            args: Prisma.AuditTrialAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditTrial>
          }
          groupBy: {
            args: Prisma.auditTrialGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditTrialGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.auditTrialFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.auditTrialAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.auditTrialCountArgs<ExtArgs>
            result: $Utils.Optional<AuditTrialCountAggregateOutputType> | number
          }
        }
      }
      prefixSuffix: {
        payload: Prisma.$prefixSuffixPayload<ExtArgs>
        fields: Prisma.prefixSuffixFieldRefs
        operations: {
          findUnique: {
            args: Prisma.prefixSuffixFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prefixSuffixPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.prefixSuffixFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prefixSuffixPayload>
          }
          findFirst: {
            args: Prisma.prefixSuffixFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prefixSuffixPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.prefixSuffixFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prefixSuffixPayload>
          }
          findMany: {
            args: Prisma.prefixSuffixFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prefixSuffixPayload>[]
          }
          create: {
            args: Prisma.prefixSuffixCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prefixSuffixPayload>
          }
          createMany: {
            args: Prisma.prefixSuffixCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.prefixSuffixDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prefixSuffixPayload>
          }
          update: {
            args: Prisma.prefixSuffixUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prefixSuffixPayload>
          }
          deleteMany: {
            args: Prisma.prefixSuffixDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.prefixSuffixUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.prefixSuffixUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prefixSuffixPayload>
          }
          aggregate: {
            args: Prisma.PrefixSuffixAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePrefixSuffix>
          }
          groupBy: {
            args: Prisma.prefixSuffixGroupByArgs<ExtArgs>
            result: $Utils.Optional<PrefixSuffixGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.prefixSuffixFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.prefixSuffixAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.prefixSuffixCountArgs<ExtArgs>
            result: $Utils.Optional<PrefixSuffixCountAggregateOutputType> | number
          }
        }
      }
      serialNumber: {
        payload: Prisma.$serialNumberPayload<ExtArgs>
        fields: Prisma.serialNumberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.serialNumberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$serialNumberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.serialNumberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$serialNumberPayload>
          }
          findFirst: {
            args: Prisma.serialNumberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$serialNumberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.serialNumberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$serialNumberPayload>
          }
          findMany: {
            args: Prisma.serialNumberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$serialNumberPayload>[]
          }
          create: {
            args: Prisma.serialNumberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$serialNumberPayload>
          }
          createMany: {
            args: Prisma.serialNumberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.serialNumberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$serialNumberPayload>
          }
          update: {
            args: Prisma.serialNumberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$serialNumberPayload>
          }
          deleteMany: {
            args: Prisma.serialNumberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.serialNumberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.serialNumberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$serialNumberPayload>
          }
          aggregate: {
            args: Prisma.SerialNumberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSerialNumber>
          }
          groupBy: {
            args: Prisma.serialNumberGroupByArgs<ExtArgs>
            result: $Utils.Optional<SerialNumberGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.serialNumberFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.serialNumberAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.serialNumberCountArgs<ExtArgs>
            result: $Utils.Optional<SerialNumberCountAggregateOutputType> | number
          }
        }
      }
      rolesTable: {
        payload: Prisma.$rolesTablePayload<ExtArgs>
        fields: Prisma.rolesTableFieldRefs
        operations: {
          findUnique: {
            args: Prisma.rolesTableFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesTablePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.rolesTableFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesTablePayload>
          }
          findFirst: {
            args: Prisma.rolesTableFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesTablePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.rolesTableFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesTablePayload>
          }
          findMany: {
            args: Prisma.rolesTableFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesTablePayload>[]
          }
          create: {
            args: Prisma.rolesTableCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesTablePayload>
          }
          createMany: {
            args: Prisma.rolesTableCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.rolesTableDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesTablePayload>
          }
          update: {
            args: Prisma.rolesTableUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesTablePayload>
          }
          deleteMany: {
            args: Prisma.rolesTableDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.rolesTableUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.rolesTableUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesTablePayload>
          }
          aggregate: {
            args: Prisma.RolesTableAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRolesTable>
          }
          groupBy: {
            args: Prisma.rolesTableGroupByArgs<ExtArgs>
            result: $Utils.Optional<RolesTableGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.rolesTableFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.rolesTableAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.rolesTableCountArgs<ExtArgs>
            result: $Utils.Optional<RolesTableCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $runCommandRaw: {
          args: Prisma.InputJsonObject,
          result: Prisma.JsonObject
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    AdditionalDocumentAdmins: number
    DocumentComments: number
    DocumentVersions: number
    DocumentWorkFlowHistory: number
    Logs: number
    Notification: number
    documentAdmins: number
    userPersonalisation: number
    auditTrial: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    AdditionalDocumentAdmins?: boolean | UserCountOutputTypeCountAdditionalDocumentAdminsArgs
    DocumentComments?: boolean | UserCountOutputTypeCountDocumentCommentsArgs
    DocumentVersions?: boolean | UserCountOutputTypeCountDocumentVersionsArgs
    DocumentWorkFlowHistory?: boolean | UserCountOutputTypeCountDocumentWorkFlowHistoryArgs
    Logs?: boolean | UserCountOutputTypeCountLogsArgs
    Notification?: boolean | UserCountOutputTypeCountNotificationArgs
    documentAdmins?: boolean | UserCountOutputTypeCountDocumentAdminsArgs
    userPersonalisation?: boolean | UserCountOutputTypeCountUserPersonalisationArgs
    auditTrial?: boolean | UserCountOutputTypeCountAuditTrialArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAdditionalDocumentAdminsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdditionalDocumentAdminsWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDocumentCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentCommentsWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDocumentVersionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentVersionsWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDocumentWorkFlowHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWorkFlowHistoryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LogsWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDocumentAdminsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: documentAdminsWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserPersonalisationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userPersonalisationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditTrialArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: auditTrialWhereInput
  }


  /**
   * Count Type ModelsCountOutputType
   */

  export type ModelsCountOutputType = {
    claims: number
    Parts: number
  }

  export type ModelsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    claims?: boolean | ModelsCountOutputTypeCountClaimsArgs
    Parts?: boolean | ModelsCountOutputTypeCountPartsArgs
  }

  // Custom InputTypes
  /**
   * ModelsCountOutputType without action
   */
  export type ModelsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelsCountOutputType
     */
    select?: ModelsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ModelsCountOutputType without action
   */
  export type ModelsCountOutputTypeCountClaimsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClaimWhereInput
  }

  /**
   * ModelsCountOutputType without action
   */
  export type ModelsCountOutputTypeCountPartsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PartsWhereInput
  }


  /**
   * Count Type PartsCountOutputType
   */

  export type PartsCountOutputType = {
    claims: number
    models: number
  }

  export type PartsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    claims?: boolean | PartsCountOutputTypeCountClaimsArgs
    models?: boolean | PartsCountOutputTypeCountModelsArgs
  }

  // Custom InputTypes
  /**
   * PartsCountOutputType without action
   */
  export type PartsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartsCountOutputType
     */
    select?: PartsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PartsCountOutputType without action
   */
  export type PartsCountOutputTypeCountClaimsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClaimWhereInput
  }

  /**
   * PartsCountOutputType without action
   */
  export type PartsCountOutputTypeCountModelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModelsWhereInput
  }


  /**
   * Count Type ClaimCountOutputType
   */

  export type ClaimCountOutputType = {
    claimToEntity: number
  }

  export type ClaimCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    claimToEntity?: boolean | ClaimCountOutputTypeCountClaimToEntityArgs
  }

  // Custom InputTypes
  /**
   * ClaimCountOutputType without action
   */
  export type ClaimCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClaimCountOutputType
     */
    select?: ClaimCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClaimCountOutputType without action
   */
  export type ClaimCountOutputTypeCountClaimToEntityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClaimToEntityWhereInput
  }


  /**
   * Count Type ProblemCountOutputType
   */

  export type ProblemCountOutputType = {
    investigations: number
    claim: number
  }

  export type ProblemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    investigations?: boolean | ProblemCountOutputTypeCountInvestigationsArgs
    claim?: boolean | ProblemCountOutputTypeCountClaimArgs
  }

  // Custom InputTypes
  /**
   * ProblemCountOutputType without action
   */
  export type ProblemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProblemCountOutputType
     */
    select?: ProblemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProblemCountOutputType without action
   */
  export type ProblemCountOutputTypeCountInvestigationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvestigationWhereInput
  }

  /**
   * ProblemCountOutputType without action
   */
  export type ProblemCountOutputTypeCountClaimArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClaimWhereInput
  }


  /**
   * Count Type InvestigationCountOutputType
   */

  export type InvestigationCountOutputType = {
    claims: number
  }

  export type InvestigationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    claims?: boolean | InvestigationCountOutputTypeCountClaimsArgs
  }

  // Custom InputTypes
  /**
   * InvestigationCountOutputType without action
   */
  export type InvestigationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvestigationCountOutputType
     */
    select?: InvestigationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InvestigationCountOutputType without action
   */
  export type InvestigationCountOutputTypeCountClaimsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClaimWhereInput
  }


  /**
   * Count Type ShipmentCountOutputType
   */

  export type ShipmentCountOutputType = {
    claims: number
  }

  export type ShipmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    claims?: boolean | ShipmentCountOutputTypeCountClaimsArgs
  }

  // Custom InputTypes
  /**
   * ShipmentCountOutputType without action
   */
  export type ShipmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShipmentCountOutputType
     */
    select?: ShipmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ShipmentCountOutputType without action
   */
  export type ShipmentCountOutputTypeCountClaimsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClaimWhereInput
  }


  /**
   * Count Type OrganizationCountOutputType
   */

  export type OrganizationCountOutputType = {
    business: number
    Doctype: number
    Documents: number
    entity: number
    entityType: number
    location: number
    role: number
    section: number
    systemType: number
    user: number
    userPersonalisation: number
    ConnectedApps: number
    unitOfMeasurement: number
    kpi: number
    businessType: number
    prefixSuffix: number
    serialNumber: number
    function: number
    rolesTable: number
    problem: number
    parts: number
    Models: number
  }

  export type OrganizationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    business?: boolean | OrganizationCountOutputTypeCountBusinessArgs
    Doctype?: boolean | OrganizationCountOutputTypeCountDoctypeArgs
    Documents?: boolean | OrganizationCountOutputTypeCountDocumentsArgs
    entity?: boolean | OrganizationCountOutputTypeCountEntityArgs
    entityType?: boolean | OrganizationCountOutputTypeCountEntityTypeArgs
    location?: boolean | OrganizationCountOutputTypeCountLocationArgs
    role?: boolean | OrganizationCountOutputTypeCountRoleArgs
    section?: boolean | OrganizationCountOutputTypeCountSectionArgs
    systemType?: boolean | OrganizationCountOutputTypeCountSystemTypeArgs
    user?: boolean | OrganizationCountOutputTypeCountUserArgs
    userPersonalisation?: boolean | OrganizationCountOutputTypeCountUserPersonalisationArgs
    ConnectedApps?: boolean | OrganizationCountOutputTypeCountConnectedAppsArgs
    unitOfMeasurement?: boolean | OrganizationCountOutputTypeCountUnitOfMeasurementArgs
    kpi?: boolean | OrganizationCountOutputTypeCountKpiArgs
    businessType?: boolean | OrganizationCountOutputTypeCountBusinessTypeArgs
    prefixSuffix?: boolean | OrganizationCountOutputTypeCountPrefixSuffixArgs
    serialNumber?: boolean | OrganizationCountOutputTypeCountSerialNumberArgs
    function?: boolean | OrganizationCountOutputTypeCountFunctionArgs
    rolesTable?: boolean | OrganizationCountOutputTypeCountRolesTableArgs
    problem?: boolean | OrganizationCountOutputTypeCountProblemArgs
    parts?: boolean | OrganizationCountOutputTypeCountPartsArgs
    Models?: boolean | OrganizationCountOutputTypeCountModelsArgs
  }

  // Custom InputTypes
  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationCountOutputType
     */
    select?: OrganizationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountBusinessArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BusinessWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountDoctypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DoctypeWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentsWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountEntityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EntityWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountEntityTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EntityTypeWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountLocationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LocationWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountRoleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountSectionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SectionWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountSystemTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SystemTypeWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountUserPersonalisationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userPersonalisationWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountConnectedAppsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConnectedAppsWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountUnitOfMeasurementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: unitTypeWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountKpiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: kpiWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountBusinessTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: businessTypeWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountPrefixSuffixArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: prefixSuffixWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountSerialNumberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: serialNumberWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountFunctionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FunctionsWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountRolesTableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: rolesTableWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountProblemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProblemWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountPartsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PartsWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountModelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModelsWhereInput
  }


  /**
   * Count Type EntityTypeCountOutputType
   */

  export type EntityTypeCountOutputType = {
    entity: number
  }

  export type EntityTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    entity?: boolean | EntityTypeCountOutputTypeCountEntityArgs
  }

  // Custom InputTypes
  /**
   * EntityTypeCountOutputType without action
   */
  export type EntityTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntityTypeCountOutputType
     */
    select?: EntityTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EntityTypeCountOutputType without action
   */
  export type EntityTypeCountOutputTypeCountEntityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EntityWhereInput
  }


  /**
   * Count Type BusinessCountOutputType
   */

  export type BusinessCountOutputType = {
    location: number
  }

  export type BusinessCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location?: boolean | BusinessCountOutputTypeCountLocationArgs
  }

  // Custom InputTypes
  /**
   * BusinessCountOutputType without action
   */
  export type BusinessCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessCountOutputType
     */
    select?: BusinessCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BusinessCountOutputType without action
   */
  export type BusinessCountOutputTypeCountLocationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LocationBusinessWhereInput
  }


  /**
   * Count Type FunctionsCountOutputType
   */

  export type FunctionsCountOutputType = {
    entity: number
  }

  export type FunctionsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    entity?: boolean | FunctionsCountOutputTypeCountEntityArgs
  }

  // Custom InputTypes
  /**
   * FunctionsCountOutputType without action
   */
  export type FunctionsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FunctionsCountOutputType
     */
    select?: FunctionsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FunctionsCountOutputType without action
   */
  export type FunctionsCountOutputTypeCountEntityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EntityWhereInput
  }


  /**
   * Count Type LocationCountOutputType
   */

  export type LocationCountOutputType = {
    Documents: number
    entity: number
    business: number
    user: number
    uom: number
    rolesTable: number
    Role: number
  }

  export type LocationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Documents?: boolean | LocationCountOutputTypeCountDocumentsArgs
    entity?: boolean | LocationCountOutputTypeCountEntityArgs
    business?: boolean | LocationCountOutputTypeCountBusinessArgs
    user?: boolean | LocationCountOutputTypeCountUserArgs
    uom?: boolean | LocationCountOutputTypeCountUomArgs
    rolesTable?: boolean | LocationCountOutputTypeCountRolesTableArgs
    Role?: boolean | LocationCountOutputTypeCountRoleArgs
  }

  // Custom InputTypes
  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationCountOutputType
     */
    select?: LocationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentsWhereInput
  }

  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeCountEntityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EntityWhereInput
  }

  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeCountBusinessArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LocationBusinessWhereInput
  }

  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeCountUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeCountUomArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: unitTypeWhereInput
  }

  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeCountRolesTableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: rolesTableWhereInput
  }

  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeCountRoleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleWhereInput
  }


  /**
   * Count Type EntityCountOutputType
   */

  export type EntityCountOutputType = {
    Doctype: number
    Documents: number
    user: number
    parts: number
    claimToEntity: number
  }

  export type EntityCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Doctype?: boolean | EntityCountOutputTypeCountDoctypeArgs
    Documents?: boolean | EntityCountOutputTypeCountDocumentsArgs
    user?: boolean | EntityCountOutputTypeCountUserArgs
    parts?: boolean | EntityCountOutputTypeCountPartsArgs
    claimToEntity?: boolean | EntityCountOutputTypeCountClaimToEntityArgs
  }

  // Custom InputTypes
  /**
   * EntityCountOutputType without action
   */
  export type EntityCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntityCountOutputType
     */
    select?: EntityCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EntityCountOutputType without action
   */
  export type EntityCountOutputTypeCountDoctypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DoctypeWhereInput
  }

  /**
   * EntityCountOutputType without action
   */
  export type EntityCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentsWhereInput
  }

  /**
   * EntityCountOutputType without action
   */
  export type EntityCountOutputTypeCountUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * EntityCountOutputType without action
   */
  export type EntityCountOutputTypeCountPartsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PartsWhereInput
  }

  /**
   * EntityCountOutputType without action
   */
  export type EntityCountOutputTypeCountClaimToEntityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClaimToEntityWhereInput
  }


  /**
   * Count Type DoctypeCountOutputType
   */

  export type DoctypeCountOutputType = {
    Documents: number
    documentAdmins: number
  }

  export type DoctypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Documents?: boolean | DoctypeCountOutputTypeCountDocumentsArgs
    documentAdmins?: boolean | DoctypeCountOutputTypeCountDocumentAdminsArgs
  }

  // Custom InputTypes
  /**
   * DoctypeCountOutputType without action
   */
  export type DoctypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctypeCountOutputType
     */
    select?: DoctypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DoctypeCountOutputType without action
   */
  export type DoctypeCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentsWhereInput
  }

  /**
   * DoctypeCountOutputType without action
   */
  export type DoctypeCountOutputTypeCountDocumentAdminsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: documentAdminsWhereInput
  }


  /**
   * Count Type DocumentsCountOutputType
   */

  export type DocumentsCountOutputType = {
    ReferenceDocuments: number
    DocumentVersions: number
    DocumentComments: number
    DocumentWorkFlowHistory: number
    AdditionalDocumentAdmins: number
    VersionReferenceDocuments: number
  }

  export type DocumentsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ReferenceDocuments?: boolean | DocumentsCountOutputTypeCountReferenceDocumentsArgs
    DocumentVersions?: boolean | DocumentsCountOutputTypeCountDocumentVersionsArgs
    DocumentComments?: boolean | DocumentsCountOutputTypeCountDocumentCommentsArgs
    DocumentWorkFlowHistory?: boolean | DocumentsCountOutputTypeCountDocumentWorkFlowHistoryArgs
    AdditionalDocumentAdmins?: boolean | DocumentsCountOutputTypeCountAdditionalDocumentAdminsArgs
    VersionReferenceDocuments?: boolean | DocumentsCountOutputTypeCountVersionReferenceDocumentsArgs
  }

  // Custom InputTypes
  /**
   * DocumentsCountOutputType without action
   */
  export type DocumentsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentsCountOutputType
     */
    select?: DocumentsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DocumentsCountOutputType without action
   */
  export type DocumentsCountOutputTypeCountReferenceDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReferenceDocumentsWhereInput
  }

  /**
   * DocumentsCountOutputType without action
   */
  export type DocumentsCountOutputTypeCountDocumentVersionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentVersionsWhereInput
  }

  /**
   * DocumentsCountOutputType without action
   */
  export type DocumentsCountOutputTypeCountDocumentCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentCommentsWhereInput
  }

  /**
   * DocumentsCountOutputType without action
   */
  export type DocumentsCountOutputTypeCountDocumentWorkFlowHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWorkFlowHistoryWhereInput
  }

  /**
   * DocumentsCountOutputType without action
   */
  export type DocumentsCountOutputTypeCountAdditionalDocumentAdminsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdditionalDocumentAdminsWhereInput
  }

  /**
   * DocumentsCountOutputType without action
   */
  export type DocumentsCountOutputTypeCountVersionReferenceDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VersionReferenceDocumentsWhereInput
  }


  /**
   * Count Type DocumentVersionsCountOutputType
   */

  export type DocumentVersionsCountOutputType = {
    ReferenceDocuments: number
    VersionReferenceDocuments: number
  }

  export type DocumentVersionsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ReferenceDocuments?: boolean | DocumentVersionsCountOutputTypeCountReferenceDocumentsArgs
    VersionReferenceDocuments?: boolean | DocumentVersionsCountOutputTypeCountVersionReferenceDocumentsArgs
  }

  // Custom InputTypes
  /**
   * DocumentVersionsCountOutputType without action
   */
  export type DocumentVersionsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentVersionsCountOutputType
     */
    select?: DocumentVersionsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DocumentVersionsCountOutputType without action
   */
  export type DocumentVersionsCountOutputTypeCountReferenceDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReferenceDocumentsWhereInput
  }

  /**
   * DocumentVersionsCountOutputType without action
   */
  export type DocumentVersionsCountOutputTypeCountVersionReferenceDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VersionReferenceDocumentsWhereInput
  }


  /**
   * Count Type ConnectedAppsCountOutputType
   */

  export type ConnectedAppsCountOutputType = {
    uom: number
    kpi: number
  }

  export type ConnectedAppsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    uom?: boolean | ConnectedAppsCountOutputTypeCountUomArgs
    kpi?: boolean | ConnectedAppsCountOutputTypeCountKpiArgs
  }

  // Custom InputTypes
  /**
   * ConnectedAppsCountOutputType without action
   */
  export type ConnectedAppsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConnectedAppsCountOutputType
     */
    select?: ConnectedAppsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ConnectedAppsCountOutputType without action
   */
  export type ConnectedAppsCountOutputTypeCountUomArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: unitTypeWhereInput
  }

  /**
   * ConnectedAppsCountOutputType without action
   */
  export type ConnectedAppsCountOutputTypeCountKpiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: kpiWhereInput
  }


  /**
   * Count Type UnitTypeCountOutputType
   */

  export type UnitTypeCountOutputType = {
    kpi: number
  }

  export type UnitTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    kpi?: boolean | UnitTypeCountOutputTypeCountKpiArgs
  }

  // Custom InputTypes
  /**
   * UnitTypeCountOutputType without action
   */
  export type UnitTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitTypeCountOutputType
     */
    select?: UnitTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UnitTypeCountOutputType without action
   */
  export type UnitTypeCountOutputTypeCountKpiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: kpiWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    kcId: string | null
    email: string | null
    username: string | null
    firstname: string | null
    lastname: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
    enabled: boolean | null
    organizationId: string | null
    locationId: string | null
    entityId: string | null
    userType: string | null
    status: boolean | null
    avatar: string | null
    deleted: boolean | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    kcId: string | null
    email: string | null
    username: string | null
    firstname: string | null
    lastname: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
    enabled: boolean | null
    organizationId: string | null
    locationId: string | null
    entityId: string | null
    userType: string | null
    status: boolean | null
    avatar: string | null
    deleted: boolean | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    kcId: number
    email: number
    username: number
    firstname: number
    lastname: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    enabled: number
    organizationId: number
    locationId: number
    entityId: number
    userType: number
    status: number
    avatar: number
    deleted: number
    roleId: number
    functionId: number
    additionalUnits: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    kcId?: true
    email?: true
    username?: true
    firstname?: true
    lastname?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    enabled?: true
    organizationId?: true
    locationId?: true
    entityId?: true
    userType?: true
    status?: true
    avatar?: true
    deleted?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    kcId?: true
    email?: true
    username?: true
    firstname?: true
    lastname?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    enabled?: true
    organizationId?: true
    locationId?: true
    entityId?: true
    userType?: true
    status?: true
    avatar?: true
    deleted?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    kcId?: true
    email?: true
    username?: true
    firstname?: true
    lastname?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    enabled?: true
    organizationId?: true
    locationId?: true
    entityId?: true
    userType?: true
    status?: true
    avatar?: true
    deleted?: true
    roleId?: true
    functionId?: true
    additionalUnits?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    kcId: string | null
    email: string | null
    username: string | null
    firstname: string | null
    lastname: string | null
    createdAt: Date
    createdBy: string | null
    updatedAt: Date
    updatedBy: string | null
    enabled: boolean | null
    organizationId: string | null
    locationId: string | null
    entityId: string | null
    userType: string | null
    status: boolean | null
    avatar: string | null
    deleted: boolean | null
    roleId: string[]
    functionId: JsonValue | null
    additionalUnits: string[]
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    kcId?: boolean
    email?: boolean
    username?: boolean
    firstname?: boolean
    lastname?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    enabled?: boolean
    organizationId?: boolean
    locationId?: boolean
    entityId?: boolean
    userType?: boolean
    status?: boolean
    avatar?: boolean
    deleted?: boolean
    roleId?: boolean
    functionId?: boolean
    additionalUnits?: boolean
    entity?: boolean | User$entityArgs<ExtArgs>
    location?: boolean | User$locationArgs<ExtArgs>
    organization?: boolean | User$organizationArgs<ExtArgs>
    AdditionalDocumentAdmins?: boolean | User$AdditionalDocumentAdminsArgs<ExtArgs>
    DocumentComments?: boolean | User$DocumentCommentsArgs<ExtArgs>
    DocumentVersions?: boolean | User$DocumentVersionsArgs<ExtArgs>
    DocumentWorkFlowHistory?: boolean | User$DocumentWorkFlowHistoryArgs<ExtArgs>
    Logs?: boolean | User$LogsArgs<ExtArgs>
    Notification?: boolean | User$NotificationArgs<ExtArgs>
    documentAdmins?: boolean | User$documentAdminsArgs<ExtArgs>
    userPersonalisation?: boolean | User$userPersonalisationArgs<ExtArgs>
    auditTrial?: boolean | User$auditTrialArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>


  export type UserSelectScalar = {
    id?: boolean
    kcId?: boolean
    email?: boolean
    username?: boolean
    firstname?: boolean
    lastname?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    enabled?: boolean
    organizationId?: boolean
    locationId?: boolean
    entityId?: boolean
    userType?: boolean
    status?: boolean
    avatar?: boolean
    deleted?: boolean
    roleId?: boolean
    functionId?: boolean
    additionalUnits?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    entity?: boolean | User$entityArgs<ExtArgs>
    location?: boolean | User$locationArgs<ExtArgs>
    organization?: boolean | User$organizationArgs<ExtArgs>
    AdditionalDocumentAdmins?: boolean | User$AdditionalDocumentAdminsArgs<ExtArgs>
    DocumentComments?: boolean | User$DocumentCommentsArgs<ExtArgs>
    DocumentVersions?: boolean | User$DocumentVersionsArgs<ExtArgs>
    DocumentWorkFlowHistory?: boolean | User$DocumentWorkFlowHistoryArgs<ExtArgs>
    Logs?: boolean | User$LogsArgs<ExtArgs>
    Notification?: boolean | User$NotificationArgs<ExtArgs>
    documentAdmins?: boolean | User$documentAdminsArgs<ExtArgs>
    userPersonalisation?: boolean | User$userPersonalisationArgs<ExtArgs>
    auditTrial?: boolean | User$auditTrialArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      entity: Prisma.$EntityPayload<ExtArgs> | null
      location: Prisma.$LocationPayload<ExtArgs> | null
      organization: Prisma.$OrganizationPayload<ExtArgs> | null
      AdditionalDocumentAdmins: Prisma.$AdditionalDocumentAdminsPayload<ExtArgs>[]
      DocumentComments: Prisma.$DocumentCommentsPayload<ExtArgs>[]
      DocumentVersions: Prisma.$DocumentVersionsPayload<ExtArgs>[]
      DocumentWorkFlowHistory: Prisma.$DocumentWorkFlowHistoryPayload<ExtArgs>[]
      Logs: Prisma.$LogsPayload<ExtArgs>[]
      Notification: Prisma.$NotificationPayload<ExtArgs>[]
      documentAdmins: Prisma.$documentAdminsPayload<ExtArgs>[]
      userPersonalisation: Prisma.$userPersonalisationPayload<ExtArgs>[]
      auditTrial: Prisma.$auditTrialPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      kcId: string | null
      email: string | null
      username: string | null
      firstname: string | null
      lastname: string | null
      createdAt: Date
      createdBy: string | null
      updatedAt: Date
      updatedBy: string | null
      enabled: boolean | null
      organizationId: string | null
      locationId: string | null
      entityId: string | null
      userType: string | null
      status: boolean | null
      avatar: string | null
      deleted: boolean | null
      roleId: string[]
      functionId: Prisma.JsonValue | null
      additionalUnits: string[]
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * @param {UserFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const user = await prisma.user.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: UserFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a User.
     * @param {UserAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const user = await prisma.user.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: UserAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    entity<T extends User$entityArgs<ExtArgs> = {}>(args?: Subset<T, User$entityArgs<ExtArgs>>): Prisma__EntityClient<$Result.GetResult<Prisma.$EntityPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    location<T extends User$locationArgs<ExtArgs> = {}>(args?: Subset<T, User$locationArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    organization<T extends User$organizationArgs<ExtArgs> = {}>(args?: Subset<T, User$organizationArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    AdditionalDocumentAdmins<T extends User$AdditionalDocumentAdminsArgs<ExtArgs> = {}>(args?: Subset<T, User$AdditionalDocumentAdminsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdditionalDocumentAdminsPayload<ExtArgs>, T, "findMany"> | Null>
    DocumentComments<T extends User$DocumentCommentsArgs<ExtArgs> = {}>(args?: Subset<T, User$DocumentCommentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentCommentsPayload<ExtArgs>, T, "findMany"> | Null>
    DocumentVersions<T extends User$DocumentVersionsArgs<ExtArgs> = {}>(args?: Subset<T, User$DocumentVersionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentVersionsPayload<ExtArgs>, T, "findMany"> | Null>
    DocumentWorkFlowHistory<T extends User$DocumentWorkFlowHistoryArgs<ExtArgs> = {}>(args?: Subset<T, User$DocumentWorkFlowHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentWorkFlowHistoryPayload<ExtArgs>, T, "findMany"> | Null>
    Logs<T extends User$LogsArgs<ExtArgs> = {}>(args?: Subset<T, User$LogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogsPayload<ExtArgs>, T, "findMany"> | Null>
    Notification<T extends User$NotificationArgs<ExtArgs> = {}>(args?: Subset<T, User$NotificationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany"> | Null>
    documentAdmins<T extends User$documentAdminsArgs<ExtArgs> = {}>(args?: Subset<T, User$documentAdminsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$documentAdminsPayload<ExtArgs>, T, "findMany"> | Null>
    userPersonalisation<T extends User$userPersonalisationArgs<ExtArgs> = {}>(args?: Subset<T, User$userPersonalisationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userPersonalisationPayload<ExtArgs>, T, "findMany"> | Null>
    auditTrial<T extends User$auditTrialArgs<ExtArgs> = {}>(args?: Subset<T, User$auditTrialArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$auditTrialPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly kcId: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly username: FieldRef<"User", 'String'>
    readonly firstname: FieldRef<"User", 'String'>
    readonly lastname: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly createdBy: FieldRef<"User", 'String'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly updatedBy: FieldRef<"User", 'String'>
    readonly enabled: FieldRef<"User", 'Boolean'>
    readonly organizationId: FieldRef<"User", 'String'>
    readonly locationId: FieldRef<"User", 'String'>
    readonly entityId: FieldRef<"User", 'String'>
    readonly userType: FieldRef<"User", 'String'>
    readonly status: FieldRef<"User", 'Boolean'>
    readonly avatar: FieldRef<"User", 'String'>
    readonly deleted: FieldRef<"User", 'Boolean'>
    readonly roleId: FieldRef<"User", 'String[]'>
    readonly functionId: FieldRef<"User", 'Json'>
    readonly additionalUnits: FieldRef<"User", 'String[]'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User findRaw
   */
  export type UserFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * User aggregateRaw
   */
  export type UserAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * User.entity
   */
  export type User$entityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entity
     */
    select?: EntitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntityInclude<ExtArgs> | null
    where?: EntityWhereInput
  }

  /**
   * User.location
   */
  export type User$locationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    where?: LocationWhereInput
  }

  /**
   * User.organization
   */
  export type User$organizationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    where?: OrganizationWhereInput
  }

  /**
   * User.AdditionalDocumentAdmins
   */
  export type User$AdditionalDocumentAdminsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdditionalDocumentAdmins
     */
    select?: AdditionalDocumentAdminsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdditionalDocumentAdminsInclude<ExtArgs> | null
    where?: AdditionalDocumentAdminsWhereInput
    orderBy?: AdditionalDocumentAdminsOrderByWithRelationInput | AdditionalDocumentAdminsOrderByWithRelationInput[]
    cursor?: AdditionalDocumentAdminsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdditionalDocumentAdminsScalarFieldEnum | AdditionalDocumentAdminsScalarFieldEnum[]
  }

  /**
   * User.DocumentComments
   */
  export type User$DocumentCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentComments
     */
    select?: DocumentCommentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentCommentsInclude<ExtArgs> | null
    where?: DocumentCommentsWhereInput
    orderBy?: DocumentCommentsOrderByWithRelationInput | DocumentCommentsOrderByWithRelationInput[]
    cursor?: DocumentCommentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentCommentsScalarFieldEnum | DocumentCommentsScalarFieldEnum[]
  }

  /**
   * User.DocumentVersions
   */
  export type User$DocumentVersionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentVersions
     */
    select?: DocumentVersionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentVersionsInclude<ExtArgs> | null
    where?: DocumentVersionsWhereInput
    orderBy?: DocumentVersionsOrderByWithRelationInput | DocumentVersionsOrderByWithRelationInput[]
    cursor?: DocumentVersionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentVersionsScalarFieldEnum | DocumentVersionsScalarFieldEnum[]
  }

  /**
   * User.DocumentWorkFlowHistory
   */
  export type User$DocumentWorkFlowHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentWorkFlowHistory
     */
    select?: DocumentWorkFlowHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentWorkFlowHistoryInclude<ExtArgs> | null
    where?: DocumentWorkFlowHistoryWhereInput
    orderBy?: DocumentWorkFlowHistoryOrderByWithRelationInput | DocumentWorkFlowHistoryOrderByWithRelationInput[]
    cursor?: DocumentWorkFlowHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentWorkFlowHistoryScalarFieldEnum | DocumentWorkFlowHistoryScalarFieldEnum[]
  }

  /**
   * User.Logs
   */
  export type User$LogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Logs
     */
    select?: LogsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogsInclude<ExtArgs> | null
    where?: LogsWhereInput
    orderBy?: LogsOrderByWithRelationInput | LogsOrderByWithRelationInput[]
    cursor?: LogsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LogsScalarFieldEnum | LogsScalarFieldEnum[]
  }

  /**
   * User.Notification
   */
  export type User$NotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.documentAdmins
   */
  export type User$documentAdminsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the documentAdmins
     */
    select?: documentAdminsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: documentAdminsInclude<ExtArgs> | null
    where?: documentAdminsWhereInput
    orderBy?: documentAdminsOrderByWithRelationInput | documentAdminsOrderByWithRelationInput[]
    cursor?: documentAdminsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentAdminsScalarFieldEnum | DocumentAdminsScalarFieldEnum[]
  }

  /**
   * User.userPersonalisation
   */
  export type User$userPersonalisationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userPersonalisation
     */
    select?: userPersonalisationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userPersonalisationInclude<ExtArgs> | null
    where?: userPersonalisationWhereInput
    orderBy?: userPersonalisationOrderByWithRelationInput | userPersonalisationOrderByWithRelationInput[]
    cursor?: userPersonalisationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserPersonalisationScalarFieldEnum | UserPersonalisationScalarFieldEnum[]
  }

  /**
   * User.auditTrial
   */
  export type User$auditTrialArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auditTrial
     */
    select?: auditTrialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditTrialInclude<ExtArgs> | null
    where?: auditTrialWhereInput
    orderBy?: auditTrialOrderByWithRelationInput | auditTrialOrderByWithRelationInput[]
    cursor?: auditTrialWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditTrialScalarFieldEnum | AuditTrialScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Models
   */

  export type AggregateModels = {
    _count: ModelsCountAggregateOutputType | null
    _min: ModelsMinAggregateOutputType | null
    _max: ModelsMaxAggregateOutputType | null
  }

  export type ModelsMinAggregateOutputType = {
    id: string | null
    modelNo: string | null
    modelName: string | null
    description: string | null
    organizationId: string | null
  }

  export type ModelsMaxAggregateOutputType = {
    id: string | null
    modelNo: string | null
    modelName: string | null
    description: string | null
    organizationId: string | null
  }

  export type ModelsCountAggregateOutputType = {
    id: number
    modelNo: number
    modelName: number
    description: number
    organizationId: number
    partsId: number
    claimId: number
    _all: number
  }


  export type ModelsMinAggregateInputType = {
    id?: true
    modelNo?: true
    modelName?: true
    description?: true
    organizationId?: true
  }

  export type ModelsMaxAggregateInputType = {
    id?: true
    modelNo?: true
    modelName?: true
    description?: true
    organizationId?: true
  }

  export type ModelsCountAggregateInputType = {
    id?: true
    modelNo?: true
    modelName?: true
    description?: true
    organizationId?: true
    partsId?: true
    claimId?: true
    _all?: true
  }

  export type ModelsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Models to aggregate.
     */
    where?: ModelsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Models to fetch.
     */
    orderBy?: ModelsOrderByWithRelationInput | ModelsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ModelsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Models from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Models.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Models
    **/
    _count?: true | ModelsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ModelsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ModelsMaxAggregateInputType
  }

  export type GetModelsAggregateType<T extends ModelsAggregateArgs> = {
        [P in keyof T & keyof AggregateModels]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateModels[P]>
      : GetScalarType<T[P], AggregateModels[P]>
  }




  export type ModelsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModelsWhereInput
    orderBy?: ModelsOrderByWithAggregationInput | ModelsOrderByWithAggregationInput[]
    by: ModelsScalarFieldEnum[] | ModelsScalarFieldEnum
    having?: ModelsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ModelsCountAggregateInputType | true
    _min?: ModelsMinAggregateInputType
    _max?: ModelsMaxAggregateInputType
  }

  export type ModelsGroupByOutputType = {
    id: string
    modelNo: string
    modelName: string
    description: string | null
    organizationId: string
    partsId: string[]
    claimId: string[]
    _count: ModelsCountAggregateOutputType | null
    _min: ModelsMinAggregateOutputType | null
    _max: ModelsMaxAggregateOutputType | null
  }

  type GetModelsGroupByPayload<T extends ModelsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ModelsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ModelsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ModelsGroupByOutputType[P]>
            : GetScalarType<T[P], ModelsGroupByOutputType[P]>
        }
      >
    >


  export type ModelsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    modelNo?: boolean
    modelName?: boolean
    description?: boolean
    organizationId?: boolean
    partsId?: boolean
    claimId?: boolean
    claims?: boolean | Models$claimsArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    Parts?: boolean | Models$PartsArgs<ExtArgs>
    _count?: boolean | ModelsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["models"]>


  export type ModelsSelectScalar = {
    id?: boolean
    modelNo?: boolean
    modelName?: boolean
    description?: boolean
    organizationId?: boolean
    partsId?: boolean
    claimId?: boolean
  }

  export type ModelsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    claims?: boolean | Models$claimsArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    Parts?: boolean | Models$PartsArgs<ExtArgs>
    _count?: boolean | ModelsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ModelsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Models"
    objects: {
      claims: Prisma.$ClaimPayload<ExtArgs>[]
      organization: Prisma.$OrganizationPayload<ExtArgs>
      Parts: Prisma.$PartsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      modelNo: string
      modelName: string
      description: string | null
      organizationId: string
      partsId: string[]
      claimId: string[]
    }, ExtArgs["result"]["models"]>
    composites: {}
  }

  type ModelsGetPayload<S extends boolean | null | undefined | ModelsDefaultArgs> = $Result.GetResult<Prisma.$ModelsPayload, S>

  type ModelsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ModelsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ModelsCountAggregateInputType | true
    }

  export interface ModelsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Models'], meta: { name: 'Models' } }
    /**
     * Find zero or one Models that matches the filter.
     * @param {ModelsFindUniqueArgs} args - Arguments to find a Models
     * @example
     * // Get one Models
     * const models = await prisma.models.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ModelsFindUniqueArgs>(args: SelectSubset<T, ModelsFindUniqueArgs<ExtArgs>>): Prisma__ModelsClient<$Result.GetResult<Prisma.$ModelsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Models that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ModelsFindUniqueOrThrowArgs} args - Arguments to find a Models
     * @example
     * // Get one Models
     * const models = await prisma.models.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ModelsFindUniqueOrThrowArgs>(args: SelectSubset<T, ModelsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ModelsClient<$Result.GetResult<Prisma.$ModelsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Models that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelsFindFirstArgs} args - Arguments to find a Models
     * @example
     * // Get one Models
     * const models = await prisma.models.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ModelsFindFirstArgs>(args?: SelectSubset<T, ModelsFindFirstArgs<ExtArgs>>): Prisma__ModelsClient<$Result.GetResult<Prisma.$ModelsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Models that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelsFindFirstOrThrowArgs} args - Arguments to find a Models
     * @example
     * // Get one Models
     * const models = await prisma.models.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ModelsFindFirstOrThrowArgs>(args?: SelectSubset<T, ModelsFindFirstOrThrowArgs<ExtArgs>>): Prisma__ModelsClient<$Result.GetResult<Prisma.$ModelsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Models that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Models
     * const models = await prisma.models.findMany()
     * 
     * // Get first 10 Models
     * const models = await prisma.models.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const modelsWithIdOnly = await prisma.models.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ModelsFindManyArgs>(args?: SelectSubset<T, ModelsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModelsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Models.
     * @param {ModelsCreateArgs} args - Arguments to create a Models.
     * @example
     * // Create one Models
     * const Models = await prisma.models.create({
     *   data: {
     *     // ... data to create a Models
     *   }
     * })
     * 
     */
    create<T extends ModelsCreateArgs>(args: SelectSubset<T, ModelsCreateArgs<ExtArgs>>): Prisma__ModelsClient<$Result.GetResult<Prisma.$ModelsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Models.
     * @param {ModelsCreateManyArgs} args - Arguments to create many Models.
     * @example
     * // Create many Models
     * const models = await prisma.models.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ModelsCreateManyArgs>(args?: SelectSubset<T, ModelsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Models.
     * @param {ModelsDeleteArgs} args - Arguments to delete one Models.
     * @example
     * // Delete one Models
     * const Models = await prisma.models.delete({
     *   where: {
     *     // ... filter to delete one Models
     *   }
     * })
     * 
     */
    delete<T extends ModelsDeleteArgs>(args: SelectSubset<T, ModelsDeleteArgs<ExtArgs>>): Prisma__ModelsClient<$Result.GetResult<Prisma.$ModelsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Models.
     * @param {ModelsUpdateArgs} args - Arguments to update one Models.
     * @example
     * // Update one Models
     * const models = await prisma.models.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ModelsUpdateArgs>(args: SelectSubset<T, ModelsUpdateArgs<ExtArgs>>): Prisma__ModelsClient<$Result.GetResult<Prisma.$ModelsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Models.
     * @param {ModelsDeleteManyArgs} args - Arguments to filter Models to delete.
     * @example
     * // Delete a few Models
     * const { count } = await prisma.models.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ModelsDeleteManyArgs>(args?: SelectSubset<T, ModelsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Models.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Models
     * const models = await prisma.models.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ModelsUpdateManyArgs>(args: SelectSubset<T, ModelsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Models.
     * @param {ModelsUpsertArgs} args - Arguments to update or create a Models.
     * @example
     * // Update or create a Models
     * const models = await prisma.models.upsert({
     *   create: {
     *     // ... data to create a Models
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Models we want to update
     *   }
     * })
     */
    upsert<T extends ModelsUpsertArgs>(args: SelectSubset<T, ModelsUpsertArgs<ExtArgs>>): Prisma__ModelsClient<$Result.GetResult<Prisma.$ModelsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Models that matches the filter.
     * @param {ModelsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const models = await prisma.models.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: ModelsFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Models.
     * @param {ModelsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const models = await prisma.models.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: ModelsAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Models.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelsCountArgs} args - Arguments to filter Models to count.
     * @example
     * // Count the number of Models
     * const count = await prisma.models.count({
     *   where: {
     *     // ... the filter for the Models we want to count
     *   }
     * })
    **/
    count<T extends ModelsCountArgs>(
      args?: Subset<T, ModelsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ModelsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Models.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ModelsAggregateArgs>(args: Subset<T, ModelsAggregateArgs>): Prisma.PrismaPromise<GetModelsAggregateType<T>>

    /**
     * Group by Models.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ModelsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ModelsGroupByArgs['orderBy'] }
        : { orderBy?: ModelsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ModelsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetModelsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Models model
   */
  readonly fields: ModelsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Models.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ModelsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    claims<T extends Models$claimsArgs<ExtArgs> = {}>(args?: Subset<T, Models$claimsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClaimPayload<ExtArgs>, T, "findMany"> | Null>
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    Parts<T extends Models$PartsArgs<ExtArgs> = {}>(args?: Subset<T, Models$PartsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PartsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Models model
   */ 
  interface ModelsFieldRefs {
    readonly id: FieldRef<"Models", 'String'>
    readonly modelNo: FieldRef<"Models", 'String'>
    readonly modelName: FieldRef<"Models", 'String'>
    readonly description: FieldRef<"Models", 'String'>
    readonly organizationId: FieldRef<"Models", 'String'>
    readonly partsId: FieldRef<"Models", 'String[]'>
    readonly claimId: FieldRef<"Models", 'String[]'>
  }
    

  // Custom InputTypes
  /**
   * Models findUnique
   */
  export type ModelsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Models
     */
    select?: ModelsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelsInclude<ExtArgs> | null
    /**
     * Filter, which Models to fetch.
     */
    where: ModelsWhereUniqueInput
  }

  /**
   * Models findUniqueOrThrow
   */
  export type ModelsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Models
     */
    select?: ModelsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelsInclude<ExtArgs> | null
    /**
     * Filter, which Models to fetch.
     */
    where: ModelsWhereUniqueInput
  }

  /**
   * Models findFirst
   */
  export type ModelsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Models
     */
    select?: ModelsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelsInclude<ExtArgs> | null
    /**
     * Filter, which Models to fetch.
     */
    where?: ModelsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Models to fetch.
     */
    orderBy?: ModelsOrderByWithRelationInput | ModelsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Models.
     */
    cursor?: ModelsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Models from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Models.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Models.
     */
    distinct?: ModelsScalarFieldEnum | ModelsScalarFieldEnum[]
  }

  /**
   * Models findFirstOrThrow
   */
  export type ModelsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Models
     */
    select?: ModelsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelsInclude<ExtArgs> | null
    /**
     * Filter, which Models to fetch.
     */
    where?: ModelsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Models to fetch.
     */
    orderBy?: ModelsOrderByWithRelationInput | ModelsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Models.
     */
    cursor?: ModelsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Models from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Models.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Models.
     */
    distinct?: ModelsScalarFieldEnum | ModelsScalarFieldEnum[]
  }

  /**
   * Models findMany
   */
  export type ModelsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Models
     */
    select?: ModelsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelsInclude<ExtArgs> | null
    /**
     * Filter, which Models to fetch.
     */
    where?: ModelsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Models to fetch.
     */
    orderBy?: ModelsOrderByWithRelationInput | ModelsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Models.
     */
    cursor?: ModelsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Models from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Models.
     */
    skip?: number
    distinct?: ModelsScalarFieldEnum | ModelsScalarFieldEnum[]
  }

  /**
   * Models create
   */
  export type ModelsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Models
     */
    select?: ModelsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelsInclude<ExtArgs> | null
    /**
     * The data needed to create a Models.
     */
    data: XOR<ModelsCreateInput, ModelsUncheckedCreateInput>
  }

  /**
   * Models createMany
   */
  export type ModelsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Models.
     */
    data: ModelsCreateManyInput | ModelsCreateManyInput[]
  }

  /**
   * Models update
   */
  export type ModelsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Models
     */
    select?: ModelsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelsInclude<ExtArgs> | null
    /**
     * The data needed to update a Models.
     */
    data: XOR<ModelsUpdateInput, ModelsUncheckedUpdateInput>
    /**
     * Choose, which Models to update.
     */
    where: ModelsWhereUniqueInput
  }

  /**
   * Models updateMany
   */
  export type ModelsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Models.
     */
    data: XOR<ModelsUpdateManyMutationInput, ModelsUncheckedUpdateManyInput>
    /**
     * Filter which Models to update
     */
    where?: ModelsWhereInput
  }

  /**
   * Models upsert
   */
  export type ModelsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Models
     */
    select?: ModelsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelsInclude<ExtArgs> | null
    /**
     * The filter to search for the Models to update in case it exists.
     */
    where: ModelsWhereUniqueInput
    /**
     * In case the Models found by the `where` argument doesn't exist, create a new Models with this data.
     */
    create: XOR<ModelsCreateInput, ModelsUncheckedCreateInput>
    /**
     * In case the Models was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ModelsUpdateInput, ModelsUncheckedUpdateInput>
  }

  /**
   * Models delete
   */
  export type ModelsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Models
     */
    select?: ModelsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelsInclude<ExtArgs> | null
    /**
     * Filter which Models to delete.
     */
    where: ModelsWhereUniqueInput
  }

  /**
   * Models deleteMany
   */
  export type ModelsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Models to delete
     */
    where?: ModelsWhereInput
  }

  /**
   * Models findRaw
   */
  export type ModelsFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Models aggregateRaw
   */
  export type ModelsAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Models.claims
   */
  export type Models$claimsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaimInclude<ExtArgs> | null
    where?: ClaimWhereInput
    orderBy?: ClaimOrderByWithRelationInput | ClaimOrderByWithRelationInput[]
    cursor?: ClaimWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClaimScalarFieldEnum | ClaimScalarFieldEnum[]
  }

  /**
   * Models.Parts
   */
  export type Models$PartsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parts
     */
    select?: PartsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartsInclude<ExtArgs> | null
    where?: PartsWhereInput
    orderBy?: PartsOrderByWithRelationInput | PartsOrderByWithRelationInput[]
    cursor?: PartsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PartsScalarFieldEnum | PartsScalarFieldEnum[]
  }

  /**
   * Models without action
   */
  export type ModelsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Models
     */
    select?: ModelsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelsInclude<ExtArgs> | null
  }


  /**
   * Model Parts
   */

  export type AggregateParts = {
    _count: PartsCountAggregateOutputType | null
    _min: PartsMinAggregateOutputType | null
    _max: PartsMaxAggregateOutputType | null
  }

  export type PartsMinAggregateOutputType = {
    id: string | null
    partNo: string | null
    partName: string | null
    description: string | null
    organizationId: string | null
    entityId: string | null
  }

  export type PartsMaxAggregateOutputType = {
    id: string | null
    partNo: string | null
    partName: string | null
    description: string | null
    organizationId: string | null
    entityId: string | null
  }

  export type PartsCountAggregateOutputType = {
    id: number
    partNo: number
    partName: number
    description: number
    organizationId: number
    entityId: number
    claimId: number
    modelsId: number
    _all: number
  }


  export type PartsMinAggregateInputType = {
    id?: true
    partNo?: true
    partName?: true
    description?: true
    organizationId?: true
    entityId?: true
  }

  export type PartsMaxAggregateInputType = {
    id?: true
    partNo?: true
    partName?: true
    description?: true
    organizationId?: true
    entityId?: true
  }

  export type PartsCountAggregateInputType = {
    id?: true
    partNo?: true
    partName?: true
    description?: true
    organizationId?: true
    entityId?: true
    claimId?: true
    modelsId?: true
    _all?: true
  }

  export type PartsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Parts to aggregate.
     */
    where?: PartsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parts to fetch.
     */
    orderBy?: PartsOrderByWithRelationInput | PartsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PartsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Parts
    **/
    _count?: true | PartsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PartsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PartsMaxAggregateInputType
  }

  export type GetPartsAggregateType<T extends PartsAggregateArgs> = {
        [P in keyof T & keyof AggregateParts]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateParts[P]>
      : GetScalarType<T[P], AggregateParts[P]>
  }




  export type PartsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PartsWhereInput
    orderBy?: PartsOrderByWithAggregationInput | PartsOrderByWithAggregationInput[]
    by: PartsScalarFieldEnum[] | PartsScalarFieldEnum
    having?: PartsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PartsCountAggregateInputType | true
    _min?: PartsMinAggregateInputType
    _max?: PartsMaxAggregateInputType
  }

  export type PartsGroupByOutputType = {
    id: string
    partNo: string
    partName: string
    description: string | null
    organizationId: string | null
    entityId: string | null
    claimId: string[]
    modelsId: string[]
    _count: PartsCountAggregateOutputType | null
    _min: PartsMinAggregateOutputType | null
    _max: PartsMaxAggregateOutputType | null
  }

  type GetPartsGroupByPayload<T extends PartsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PartsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PartsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PartsGroupByOutputType[P]>
            : GetScalarType<T[P], PartsGroupByOutputType[P]>
        }
      >
    >


  export type PartsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    partNo?: boolean
    partName?: boolean
    description?: boolean
    organizationId?: boolean
    entityId?: boolean
    claimId?: boolean
    modelsId?: boolean
    claims?: boolean | Parts$claimsArgs<ExtArgs>
    entity?: boolean | Parts$entityArgs<ExtArgs>
    organization?: boolean | Parts$organizationArgs<ExtArgs>
    models?: boolean | Parts$modelsArgs<ExtArgs>
    _count?: boolean | PartsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["parts"]>


  export type PartsSelectScalar = {
    id?: boolean
    partNo?: boolean
    partName?: boolean
    description?: boolean
    organizationId?: boolean
    entityId?: boolean
    claimId?: boolean
    modelsId?: boolean
  }

  export type PartsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    claims?: boolean | Parts$claimsArgs<ExtArgs>
    entity?: boolean | Parts$entityArgs<ExtArgs>
    organization?: boolean | Parts$organizationArgs<ExtArgs>
    models?: boolean | Parts$modelsArgs<ExtArgs>
    _count?: boolean | PartsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $PartsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Parts"
    objects: {
      claims: Prisma.$ClaimPayload<ExtArgs>[]
      entity: Prisma.$EntityPayload<ExtArgs> | null
      organization: Prisma.$OrganizationPayload<ExtArgs> | null
      models: Prisma.$ModelsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      partNo: string
      partName: string
      description: string | null
      organizationId: string | null
      entityId: string | null
      claimId: string[]
      modelsId: string[]
    }, ExtArgs["result"]["parts"]>
    composites: {}
  }

  type PartsGetPayload<S extends boolean | null | undefined | PartsDefaultArgs> = $Result.GetResult<Prisma.$PartsPayload, S>

  type PartsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PartsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PartsCountAggregateInputType | true
    }

  export interface PartsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Parts'], meta: { name: 'Parts' } }
    /**
     * Find zero or one Parts that matches the filter.
     * @param {PartsFindUniqueArgs} args - Arguments to find a Parts
     * @example
     * // Get one Parts
     * const parts = await prisma.parts.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PartsFindUniqueArgs>(args: SelectSubset<T, PartsFindUniqueArgs<ExtArgs>>): Prisma__PartsClient<$Result.GetResult<Prisma.$PartsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Parts that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PartsFindUniqueOrThrowArgs} args - Arguments to find a Parts
     * @example
     * // Get one Parts
     * const parts = await prisma.parts.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PartsFindUniqueOrThrowArgs>(args: SelectSubset<T, PartsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PartsClient<$Result.GetResult<Prisma.$PartsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Parts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartsFindFirstArgs} args - Arguments to find a Parts
     * @example
     * // Get one Parts
     * const parts = await prisma.parts.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PartsFindFirstArgs>(args?: SelectSubset<T, PartsFindFirstArgs<ExtArgs>>): Prisma__PartsClient<$Result.GetResult<Prisma.$PartsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Parts that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartsFindFirstOrThrowArgs} args - Arguments to find a Parts
     * @example
     * // Get one Parts
     * const parts = await prisma.parts.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PartsFindFirstOrThrowArgs>(args?: SelectSubset<T, PartsFindFirstOrThrowArgs<ExtArgs>>): Prisma__PartsClient<$Result.GetResult<Prisma.$PartsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Parts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Parts
     * const parts = await prisma.parts.findMany()
     * 
     * // Get first 10 Parts
     * const parts = await prisma.parts.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const partsWithIdOnly = await prisma.parts.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PartsFindManyArgs>(args?: SelectSubset<T, PartsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PartsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Parts.
     * @param {PartsCreateArgs} args - Arguments to create a Parts.
     * @example
     * // Create one Parts
     * const Parts = await prisma.parts.create({
     *   data: {
     *     // ... data to create a Parts
     *   }
     * })
     * 
     */
    create<T extends PartsCreateArgs>(args: SelectSubset<T, PartsCreateArgs<ExtArgs>>): Prisma__PartsClient<$Result.GetResult<Prisma.$PartsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Parts.
     * @param {PartsCreateManyArgs} args - Arguments to create many Parts.
     * @example
     * // Create many Parts
     * const parts = await prisma.parts.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PartsCreateManyArgs>(args?: SelectSubset<T, PartsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Parts.
     * @param {PartsDeleteArgs} args - Arguments to delete one Parts.
     * @example
     * // Delete one Parts
     * const Parts = await prisma.parts.delete({
     *   where: {
     *     // ... filter to delete one Parts
     *   }
     * })
     * 
     */
    delete<T extends PartsDeleteArgs>(args: SelectSubset<T, PartsDeleteArgs<ExtArgs>>): Prisma__PartsClient<$Result.GetResult<Prisma.$PartsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Parts.
     * @param {PartsUpdateArgs} args - Arguments to update one Parts.
     * @example
     * // Update one Parts
     * const parts = await prisma.parts.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PartsUpdateArgs>(args: SelectSubset<T, PartsUpdateArgs<ExtArgs>>): Prisma__PartsClient<$Result.GetResult<Prisma.$PartsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Parts.
     * @param {PartsDeleteManyArgs} args - Arguments to filter Parts to delete.
     * @example
     * // Delete a few Parts
     * const { count } = await prisma.parts.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PartsDeleteManyArgs>(args?: SelectSubset<T, PartsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Parts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Parts
     * const parts = await prisma.parts.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PartsUpdateManyArgs>(args: SelectSubset<T, PartsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Parts.
     * @param {PartsUpsertArgs} args - Arguments to update or create a Parts.
     * @example
     * // Update or create a Parts
     * const parts = await prisma.parts.upsert({
     *   create: {
     *     // ... data to create a Parts
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Parts we want to update
     *   }
     * })
     */
    upsert<T extends PartsUpsertArgs>(args: SelectSubset<T, PartsUpsertArgs<ExtArgs>>): Prisma__PartsClient<$Result.GetResult<Prisma.$PartsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Parts that matches the filter.
     * @param {PartsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const parts = await prisma.parts.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: PartsFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Parts.
     * @param {PartsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const parts = await prisma.parts.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: PartsAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Parts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartsCountArgs} args - Arguments to filter Parts to count.
     * @example
     * // Count the number of Parts
     * const count = await prisma.parts.count({
     *   where: {
     *     // ... the filter for the Parts we want to count
     *   }
     * })
    **/
    count<T extends PartsCountArgs>(
      args?: Subset<T, PartsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PartsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Parts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PartsAggregateArgs>(args: Subset<T, PartsAggregateArgs>): Prisma.PrismaPromise<GetPartsAggregateType<T>>

    /**
     * Group by Parts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PartsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PartsGroupByArgs['orderBy'] }
        : { orderBy?: PartsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PartsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPartsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Parts model
   */
  readonly fields: PartsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Parts.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PartsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    claims<T extends Parts$claimsArgs<ExtArgs> = {}>(args?: Subset<T, Parts$claimsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClaimPayload<ExtArgs>, T, "findMany"> | Null>
    entity<T extends Parts$entityArgs<ExtArgs> = {}>(args?: Subset<T, Parts$entityArgs<ExtArgs>>): Prisma__EntityClient<$Result.GetResult<Prisma.$EntityPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    organization<T extends Parts$organizationArgs<ExtArgs> = {}>(args?: Subset<T, Parts$organizationArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    models<T extends Parts$modelsArgs<ExtArgs> = {}>(args?: Subset<T, Parts$modelsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModelsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Parts model
   */ 
  interface PartsFieldRefs {
    readonly id: FieldRef<"Parts", 'String'>
    readonly partNo: FieldRef<"Parts", 'String'>
    readonly partName: FieldRef<"Parts", 'String'>
    readonly description: FieldRef<"Parts", 'String'>
    readonly organizationId: FieldRef<"Parts", 'String'>
    readonly entityId: FieldRef<"Parts", 'String'>
    readonly claimId: FieldRef<"Parts", 'String[]'>
    readonly modelsId: FieldRef<"Parts", 'String[]'>
  }
    

  // Custom InputTypes
  /**
   * Parts findUnique
   */
  export type PartsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parts
     */
    select?: PartsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartsInclude<ExtArgs> | null
    /**
     * Filter, which Parts to fetch.
     */
    where: PartsWhereUniqueInput
  }

  /**
   * Parts findUniqueOrThrow
   */
  export type PartsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parts
     */
    select?: PartsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartsInclude<ExtArgs> | null
    /**
     * Filter, which Parts to fetch.
     */
    where: PartsWhereUniqueInput
  }

  /**
   * Parts findFirst
   */
  export type PartsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parts
     */
    select?: PartsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartsInclude<ExtArgs> | null
    /**
     * Filter, which Parts to fetch.
     */
    where?: PartsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parts to fetch.
     */
    orderBy?: PartsOrderByWithRelationInput | PartsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Parts.
     */
    cursor?: PartsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Parts.
     */
    distinct?: PartsScalarFieldEnum | PartsScalarFieldEnum[]
  }

  /**
   * Parts findFirstOrThrow
   */
  export type PartsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parts
     */
    select?: PartsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartsInclude<ExtArgs> | null
    /**
     * Filter, which Parts to fetch.
     */
    where?: PartsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parts to fetch.
     */
    orderBy?: PartsOrderByWithRelationInput | PartsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Parts.
     */
    cursor?: PartsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Parts.
     */
    distinct?: PartsScalarFieldEnum | PartsScalarFieldEnum[]
  }

  /**
   * Parts findMany
   */
  export type PartsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parts
     */
    select?: PartsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartsInclude<ExtArgs> | null
    /**
     * Filter, which Parts to fetch.
     */
    where?: PartsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parts to fetch.
     */
    orderBy?: PartsOrderByWithRelationInput | PartsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Parts.
     */
    cursor?: PartsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parts.
     */
    skip?: number
    distinct?: PartsScalarFieldEnum | PartsScalarFieldEnum[]
  }

  /**
   * Parts create
   */
  export type PartsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parts
     */
    select?: PartsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartsInclude<ExtArgs> | null
    /**
     * The data needed to create a Parts.
     */
    data: XOR<PartsCreateInput, PartsUncheckedCreateInput>
  }

  /**
   * Parts createMany
   */
  export type PartsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Parts.
     */
    data: PartsCreateManyInput | PartsCreateManyInput[]
  }

  /**
   * Parts update
   */
  export type PartsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parts
     */
    select?: PartsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartsInclude<ExtArgs> | null
    /**
     * The data needed to update a Parts.
     */
    data: XOR<PartsUpdateInput, PartsUncheckedUpdateInput>
    /**
     * Choose, which Parts to update.
     */
    where: PartsWhereUniqueInput
  }

  /**
   * Parts updateMany
   */
  export type PartsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Parts.
     */
    data: XOR<PartsUpdateManyMutationInput, PartsUncheckedUpdateManyInput>
    /**
     * Filter which Parts to update
     */
    where?: PartsWhereInput
  }

  /**
   * Parts upsert
   */
  export type PartsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parts
     */
    select?: PartsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartsInclude<ExtArgs> | null
    /**
     * The filter to search for the Parts to update in case it exists.
     */
    where: PartsWhereUniqueInput
    /**
     * In case the Parts found by the `where` argument doesn't exist, create a new Parts with this data.
     */
    create: XOR<PartsCreateInput, PartsUncheckedCreateInput>
    /**
     * In case the Parts was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PartsUpdateInput, PartsUncheckedUpdateInput>
  }

  /**
   * Parts delete
   */
  export type PartsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parts
     */
    select?: PartsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartsInclude<ExtArgs> | null
    /**
     * Filter which Parts to delete.
     */
    where: PartsWhereUniqueInput
  }

  /**
   * Parts deleteMany
   */
  export type PartsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Parts to delete
     */
    where?: PartsWhereInput
  }

  /**
   * Parts findRaw
   */
  export type PartsFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Parts aggregateRaw
   */
  export type PartsAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Parts.claims
   */
  export type Parts$claimsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaimInclude<ExtArgs> | null
    where?: ClaimWhereInput
    orderBy?: ClaimOrderByWithRelationInput | ClaimOrderByWithRelationInput[]
    cursor?: ClaimWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClaimScalarFieldEnum | ClaimScalarFieldEnum[]
  }

  /**
   * Parts.entity
   */
  export type Parts$entityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entity
     */
    select?: EntitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntityInclude<ExtArgs> | null
    where?: EntityWhereInput
  }

  /**
   * Parts.organization
   */
  export type Parts$organizationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    where?: OrganizationWhereInput
  }

  /**
   * Parts.models
   */
  export type Parts$modelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Models
     */
    select?: ModelsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelsInclude<ExtArgs> | null
    where?: ModelsWhereInput
    orderBy?: ModelsOrderByWithRelationInput | ModelsOrderByWithRelationInput[]
    cursor?: ModelsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ModelsScalarFieldEnum | ModelsScalarFieldEnum[]
  }

  /**
   * Parts without action
   */
  export type PartsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parts
     */
    select?: PartsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartsInclude<ExtArgs> | null
  }


  /**
   * Model Claim
   */

  export type AggregateClaim = {
    _count: ClaimCountAggregateOutputType | null
    _avg: ClaimAvgAggregateOutputType | null
    _sum: ClaimSumAggregateOutputType | null
    _min: ClaimMinAggregateOutputType | null
    _max: ClaimMaxAggregateOutputType | null
  }

  export type ClaimAvgAggregateOutputType = {
    kms: number | null
    mis: number | null
    claimNo: number | null
  }

  export type ClaimSumAggregateOutputType = {
    kms: number | null
    mis: number | null
    claimNo: number | null
  }

  export type ClaimMinAggregateOutputType = {
    id: string | null
    partId: string | null
    modelId: string | null
    partRecieptDate: string | null
    vehicleType: string | null
    FrameNo: string | null
    prNo: string | null
    lineOffDate: string | null
    saleDate: string | null
    repairDate: string | null
    shipmentId: string | null
    investigationId: string | null
    settleMonth: string | null
    kms: number | null
    problemId: string | null
    mis: number | null
    claimNo: number | null
  }

  export type ClaimMaxAggregateOutputType = {
    id: string | null
    partId: string | null
    modelId: string | null
    partRecieptDate: string | null
    vehicleType: string | null
    FrameNo: string | null
    prNo: string | null
    lineOffDate: string | null
    saleDate: string | null
    repairDate: string | null
    shipmentId: string | null
    investigationId: string | null
    settleMonth: string | null
    kms: number | null
    problemId: string | null
    mis: number | null
    claimNo: number | null
  }

  export type ClaimCountAggregateOutputType = {
    id: number
    partId: number
    modelId: number
    partRecieptDate: number
    vehicleType: number
    FrameNo: number
    prNo: number
    lineOffDate: number
    saleDate: number
    repairDate: number
    shipmentId: number
    investigationId: number
    settleMonth: number
    kms: number
    problemId: number
    mis: number
    claimNo: number
    _all: number
  }


  export type ClaimAvgAggregateInputType = {
    kms?: true
    mis?: true
    claimNo?: true
  }

  export type ClaimSumAggregateInputType = {
    kms?: true
    mis?: true
    claimNo?: true
  }

  export type ClaimMinAggregateInputType = {
    id?: true
    partId?: true
    modelId?: true
    partRecieptDate?: true
    vehicleType?: true
    FrameNo?: true
    prNo?: true
    lineOffDate?: true
    saleDate?: true
    repairDate?: true
    shipmentId?: true
    investigationId?: true
    settleMonth?: true
    kms?: true
    problemId?: true
    mis?: true
    claimNo?: true
  }

  export type ClaimMaxAggregateInputType = {
    id?: true
    partId?: true
    modelId?: true
    partRecieptDate?: true
    vehicleType?: true
    FrameNo?: true
    prNo?: true
    lineOffDate?: true
    saleDate?: true
    repairDate?: true
    shipmentId?: true
    investigationId?: true
    settleMonth?: true
    kms?: true
    problemId?: true
    mis?: true
    claimNo?: true
  }

  export type ClaimCountAggregateInputType = {
    id?: true
    partId?: true
    modelId?: true
    partRecieptDate?: true
    vehicleType?: true
    FrameNo?: true
    prNo?: true
    lineOffDate?: true
    saleDate?: true
    repairDate?: true
    shipmentId?: true
    investigationId?: true
    settleMonth?: true
    kms?: true
    problemId?: true
    mis?: true
    claimNo?: true
    _all?: true
  }

  export type ClaimAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Claim to aggregate.
     */
    where?: ClaimWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Claims to fetch.
     */
    orderBy?: ClaimOrderByWithRelationInput | ClaimOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClaimWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Claims from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Claims.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Claims
    **/
    _count?: true | ClaimCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClaimAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClaimSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClaimMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClaimMaxAggregateInputType
  }

  export type GetClaimAggregateType<T extends ClaimAggregateArgs> = {
        [P in keyof T & keyof AggregateClaim]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClaim[P]>
      : GetScalarType<T[P], AggregateClaim[P]>
  }




  export type ClaimGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClaimWhereInput
    orderBy?: ClaimOrderByWithAggregationInput | ClaimOrderByWithAggregationInput[]
    by: ClaimScalarFieldEnum[] | ClaimScalarFieldEnum
    having?: ClaimScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClaimCountAggregateInputType | true
    _avg?: ClaimAvgAggregateInputType
    _sum?: ClaimSumAggregateInputType
    _min?: ClaimMinAggregateInputType
    _max?: ClaimMaxAggregateInputType
  }

  export type ClaimGroupByOutputType = {
    id: string
    partId: string | null
    modelId: string | null
    partRecieptDate: string
    vehicleType: string
    FrameNo: string
    prNo: string
    lineOffDate: string
    saleDate: string
    repairDate: string
    shipmentId: string | null
    investigationId: string | null
    settleMonth: string | null
    kms: number
    problemId: string | null
    mis: number
    claimNo: number
    _count: ClaimCountAggregateOutputType | null
    _avg: ClaimAvgAggregateOutputType | null
    _sum: ClaimSumAggregateOutputType | null
    _min: ClaimMinAggregateOutputType | null
    _max: ClaimMaxAggregateOutputType | null
  }

  type GetClaimGroupByPayload<T extends ClaimGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClaimGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClaimGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClaimGroupByOutputType[P]>
            : GetScalarType<T[P], ClaimGroupByOutputType[P]>
        }
      >
    >


  export type ClaimSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    partId?: boolean
    modelId?: boolean
    partRecieptDate?: boolean
    vehicleType?: boolean
    FrameNo?: boolean
    prNo?: boolean
    lineOffDate?: boolean
    saleDate?: boolean
    repairDate?: boolean
    shipmentId?: boolean
    investigationId?: boolean
    settleMonth?: boolean
    kms?: boolean
    problemId?: boolean
    mis?: boolean
    claimNo?: boolean
    problem?: boolean | Claim$problemArgs<ExtArgs>
    investigations?: boolean | Claim$investigationsArgs<ExtArgs>
    models?: boolean | Claim$modelsArgs<ExtArgs>
    parts?: boolean | Claim$partsArgs<ExtArgs>
    shipments?: boolean | Claim$shipmentsArgs<ExtArgs>
    claimToEntity?: boolean | Claim$claimToEntityArgs<ExtArgs>
    _count?: boolean | ClaimCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["claim"]>


  export type ClaimSelectScalar = {
    id?: boolean
    partId?: boolean
    modelId?: boolean
    partRecieptDate?: boolean
    vehicleType?: boolean
    FrameNo?: boolean
    prNo?: boolean
    lineOffDate?: boolean
    saleDate?: boolean
    repairDate?: boolean
    shipmentId?: boolean
    investigationId?: boolean
    settleMonth?: boolean
    kms?: boolean
    problemId?: boolean
    mis?: boolean
    claimNo?: boolean
  }

  export type ClaimInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    problem?: boolean | Claim$problemArgs<ExtArgs>
    investigations?: boolean | Claim$investigationsArgs<ExtArgs>
    models?: boolean | Claim$modelsArgs<ExtArgs>
    parts?: boolean | Claim$partsArgs<ExtArgs>
    shipments?: boolean | Claim$shipmentsArgs<ExtArgs>
    claimToEntity?: boolean | Claim$claimToEntityArgs<ExtArgs>
    _count?: boolean | ClaimCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ClaimPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Claim"
    objects: {
      problem: Prisma.$ProblemPayload<ExtArgs> | null
      investigations: Prisma.$InvestigationPayload<ExtArgs> | null
      models: Prisma.$ModelsPayload<ExtArgs> | null
      parts: Prisma.$PartsPayload<ExtArgs> | null
      shipments: Prisma.$ShipmentPayload<ExtArgs> | null
      claimToEntity: Prisma.$ClaimToEntityPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      partId: string | null
      modelId: string | null
      partRecieptDate: string
      vehicleType: string
      FrameNo: string
      prNo: string
      lineOffDate: string
      saleDate: string
      repairDate: string
      shipmentId: string | null
      investigationId: string | null
      settleMonth: string | null
      kms: number
      problemId: string | null
      mis: number
      claimNo: number
    }, ExtArgs["result"]["claim"]>
    composites: {}
  }

  type ClaimGetPayload<S extends boolean | null | undefined | ClaimDefaultArgs> = $Result.GetResult<Prisma.$ClaimPayload, S>

  type ClaimCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ClaimFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ClaimCountAggregateInputType | true
    }

  export interface ClaimDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Claim'], meta: { name: 'Claim' } }
    /**
     * Find zero or one Claim that matches the filter.
     * @param {ClaimFindUniqueArgs} args - Arguments to find a Claim
     * @example
     * // Get one Claim
     * const claim = await prisma.claim.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClaimFindUniqueArgs>(args: SelectSubset<T, ClaimFindUniqueArgs<ExtArgs>>): Prisma__ClaimClient<$Result.GetResult<Prisma.$ClaimPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Claim that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ClaimFindUniqueOrThrowArgs} args - Arguments to find a Claim
     * @example
     * // Get one Claim
     * const claim = await prisma.claim.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClaimFindUniqueOrThrowArgs>(args: SelectSubset<T, ClaimFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClaimClient<$Result.GetResult<Prisma.$ClaimPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Claim that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimFindFirstArgs} args - Arguments to find a Claim
     * @example
     * // Get one Claim
     * const claim = await prisma.claim.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClaimFindFirstArgs>(args?: SelectSubset<T, ClaimFindFirstArgs<ExtArgs>>): Prisma__ClaimClient<$Result.GetResult<Prisma.$ClaimPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Claim that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimFindFirstOrThrowArgs} args - Arguments to find a Claim
     * @example
     * // Get one Claim
     * const claim = await prisma.claim.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClaimFindFirstOrThrowArgs>(args?: SelectSubset<T, ClaimFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClaimClient<$Result.GetResult<Prisma.$ClaimPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Claims that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Claims
     * const claims = await prisma.claim.findMany()
     * 
     * // Get first 10 Claims
     * const claims = await prisma.claim.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const claimWithIdOnly = await prisma.claim.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClaimFindManyArgs>(args?: SelectSubset<T, ClaimFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClaimPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Claim.
     * @param {ClaimCreateArgs} args - Arguments to create a Claim.
     * @example
     * // Create one Claim
     * const Claim = await prisma.claim.create({
     *   data: {
     *     // ... data to create a Claim
     *   }
     * })
     * 
     */
    create<T extends ClaimCreateArgs>(args: SelectSubset<T, ClaimCreateArgs<ExtArgs>>): Prisma__ClaimClient<$Result.GetResult<Prisma.$ClaimPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Claims.
     * @param {ClaimCreateManyArgs} args - Arguments to create many Claims.
     * @example
     * // Create many Claims
     * const claim = await prisma.claim.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClaimCreateManyArgs>(args?: SelectSubset<T, ClaimCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Claim.
     * @param {ClaimDeleteArgs} args - Arguments to delete one Claim.
     * @example
     * // Delete one Claim
     * const Claim = await prisma.claim.delete({
     *   where: {
     *     // ... filter to delete one Claim
     *   }
     * })
     * 
     */
    delete<T extends ClaimDeleteArgs>(args: SelectSubset<T, ClaimDeleteArgs<ExtArgs>>): Prisma__ClaimClient<$Result.GetResult<Prisma.$ClaimPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Claim.
     * @param {ClaimUpdateArgs} args - Arguments to update one Claim.
     * @example
     * // Update one Claim
     * const claim = await prisma.claim.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClaimUpdateArgs>(args: SelectSubset<T, ClaimUpdateArgs<ExtArgs>>): Prisma__ClaimClient<$Result.GetResult<Prisma.$ClaimPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Claims.
     * @param {ClaimDeleteManyArgs} args - Arguments to filter Claims to delete.
     * @example
     * // Delete a few Claims
     * const { count } = await prisma.claim.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClaimDeleteManyArgs>(args?: SelectSubset<T, ClaimDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Claims.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Claims
     * const claim = await prisma.claim.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClaimUpdateManyArgs>(args: SelectSubset<T, ClaimUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Claim.
     * @param {ClaimUpsertArgs} args - Arguments to update or create a Claim.
     * @example
     * // Update or create a Claim
     * const claim = await prisma.claim.upsert({
     *   create: {
     *     // ... data to create a Claim
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Claim we want to update
     *   }
     * })
     */
    upsert<T extends ClaimUpsertArgs>(args: SelectSubset<T, ClaimUpsertArgs<ExtArgs>>): Prisma__ClaimClient<$Result.GetResult<Prisma.$ClaimPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Claims that matches the filter.
     * @param {ClaimFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const claim = await prisma.claim.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: ClaimFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Claim.
     * @param {ClaimAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const claim = await prisma.claim.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: ClaimAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Claims.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimCountArgs} args - Arguments to filter Claims to count.
     * @example
     * // Count the number of Claims
     * const count = await prisma.claim.count({
     *   where: {
     *     // ... the filter for the Claims we want to count
     *   }
     * })
    **/
    count<T extends ClaimCountArgs>(
      args?: Subset<T, ClaimCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClaimCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Claim.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClaimAggregateArgs>(args: Subset<T, ClaimAggregateArgs>): Prisma.PrismaPromise<GetClaimAggregateType<T>>

    /**
     * Group by Claim.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClaimGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClaimGroupByArgs['orderBy'] }
        : { orderBy?: ClaimGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClaimGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClaimGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Claim model
   */
  readonly fields: ClaimFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Claim.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClaimClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    problem<T extends Claim$problemArgs<ExtArgs> = {}>(args?: Subset<T, Claim$problemArgs<ExtArgs>>): Prisma__ProblemClient<$Result.GetResult<Prisma.$ProblemPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    investigations<T extends Claim$investigationsArgs<ExtArgs> = {}>(args?: Subset<T, Claim$investigationsArgs<ExtArgs>>): Prisma__InvestigationClient<$Result.GetResult<Prisma.$InvestigationPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    models<T extends Claim$modelsArgs<ExtArgs> = {}>(args?: Subset<T, Claim$modelsArgs<ExtArgs>>): Prisma__ModelsClient<$Result.GetResult<Prisma.$ModelsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    parts<T extends Claim$partsArgs<ExtArgs> = {}>(args?: Subset<T, Claim$partsArgs<ExtArgs>>): Prisma__PartsClient<$Result.GetResult<Prisma.$PartsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    shipments<T extends Claim$shipmentsArgs<ExtArgs> = {}>(args?: Subset<T, Claim$shipmentsArgs<ExtArgs>>): Prisma__ShipmentClient<$Result.GetResult<Prisma.$ShipmentPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    claimToEntity<T extends Claim$claimToEntityArgs<ExtArgs> = {}>(args?: Subset<T, Claim$claimToEntityArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClaimToEntityPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Claim model
   */ 
  interface ClaimFieldRefs {
    readonly id: FieldRef<"Claim", 'String'>
    readonly partId: FieldRef<"Claim", 'String'>
    readonly modelId: FieldRef<"Claim", 'String'>
    readonly partRecieptDate: FieldRef<"Claim", 'String'>
    readonly vehicleType: FieldRef<"Claim", 'String'>
    readonly FrameNo: FieldRef<"Claim", 'String'>
    readonly prNo: FieldRef<"Claim", 'String'>
    readonly lineOffDate: FieldRef<"Claim", 'String'>
    readonly saleDate: FieldRef<"Claim", 'String'>
    readonly repairDate: FieldRef<"Claim", 'String'>
    readonly shipmentId: FieldRef<"Claim", 'String'>
    readonly investigationId: FieldRef<"Claim", 'String'>
    readonly settleMonth: FieldRef<"Claim", 'String'>
    readonly kms: FieldRef<"Claim", 'Int'>
    readonly problemId: FieldRef<"Claim", 'String'>
    readonly mis: FieldRef<"Claim", 'Int'>
    readonly claimNo: FieldRef<"Claim", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Claim findUnique
   */
  export type ClaimFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaimInclude<ExtArgs> | null
    /**
     * Filter, which Claim to fetch.
     */
    where: ClaimWhereUniqueInput
  }

  /**
   * Claim findUniqueOrThrow
   */
  export type ClaimFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaimInclude<ExtArgs> | null
    /**
     * Filter, which Claim to fetch.
     */
    where: ClaimWhereUniqueInput
  }

  /**
   * Claim findFirst
   */
  export type ClaimFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaimInclude<ExtArgs> | null
    /**
     * Filter, which Claim to fetch.
     */
    where?: ClaimWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Claims to fetch.
     */
    orderBy?: ClaimOrderByWithRelationInput | ClaimOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Claims.
     */
    cursor?: ClaimWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Claims from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Claims.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Claims.
     */
    distinct?: ClaimScalarFieldEnum | ClaimScalarFieldEnum[]
  }

  /**
   * Claim findFirstOrThrow
   */
  export type ClaimFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaimInclude<ExtArgs> | null
    /**
     * Filter, which Claim to fetch.
     */
    where?: ClaimWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Claims to fetch.
     */
    orderBy?: ClaimOrderByWithRelationInput | ClaimOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Claims.
     */
    cursor?: ClaimWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Claims from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Claims.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Claims.
     */
    distinct?: ClaimScalarFieldEnum | ClaimScalarFieldEnum[]
  }

  /**
   * Claim findMany
   */
  export type ClaimFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaimInclude<ExtArgs> | null
    /**
     * Filter, which Claims to fetch.
     */
    where?: ClaimWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Claims to fetch.
     */
    orderBy?: ClaimOrderByWithRelationInput | ClaimOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Claims.
     */
    cursor?: ClaimWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Claims from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Claims.
     */
    skip?: number
    distinct?: ClaimScalarFieldEnum | ClaimScalarFieldEnum[]
  }

  /**
   * Claim create
   */
  export type ClaimCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaimInclude<ExtArgs> | null
    /**
     * The data needed to create a Claim.
     */
    data: XOR<ClaimCreateInput, ClaimUncheckedCreateInput>
  }

  /**
   * Claim createMany
   */
  export type ClaimCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Claims.
     */
    data: ClaimCreateManyInput | ClaimCreateManyInput[]
  }

  /**
   * Claim update
   */
  export type ClaimUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaimInclude<ExtArgs> | null
    /**
     * The data needed to update a Claim.
     */
    data: XOR<ClaimUpdateInput, ClaimUncheckedUpdateInput>
    /**
     * Choose, which Claim to update.
     */
    where: ClaimWhereUniqueInput
  }

  /**
   * Claim updateMany
   */
  export type ClaimUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Claims.
     */
    data: XOR<ClaimUpdateManyMutationInput, ClaimUncheckedUpdateManyInput>
    /**
     * Filter which Claims to update
     */
    where?: ClaimWhereInput
  }

  /**
   * Claim upsert
   */
  export type ClaimUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaimInclude<ExtArgs> | null
    /**
     * The filter to search for the Claim to update in case it exists.
     */
    where: ClaimWhereUniqueInput
    /**
     * In case the Claim found by the `where` argument doesn't exist, create a new Claim with this data.
     */
    create: XOR<ClaimCreateInput, ClaimUncheckedCreateInput>
    /**
     * In case the Claim was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClaimUpdateInput, ClaimUncheckedUpdateInput>
  }

  /**
   * Claim delete
   */
  export type ClaimDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaimInclude<ExtArgs> | null
    /**
     * Filter which Claim to delete.
     */
    where: ClaimWhereUniqueInput
  }

  /**
   * Claim deleteMany
   */
  export type ClaimDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Claims to delete
     */
    where?: ClaimWhereInput
  }

  /**
   * Claim findRaw
   */
  export type ClaimFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Claim aggregateRaw
   */
  export type ClaimAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Claim.problem
   */
  export type Claim$problemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Problem
     */
    select?: ProblemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProblemInclude<ExtArgs> | null
    where?: ProblemWhereInput
  }

  /**
   * Claim.investigations
   */
  export type Claim$investigationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investigation
     */
    select?: InvestigationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestigationInclude<ExtArgs> | null
    where?: InvestigationWhereInput
  }

  /**
   * Claim.models
   */
  export type Claim$modelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Models
     */
    select?: ModelsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelsInclude<ExtArgs> | null
    where?: ModelsWhereInput
  }

  /**
   * Claim.parts
   */
  export type Claim$partsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parts
     */
    select?: PartsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartsInclude<ExtArgs> | null
    where?: PartsWhereInput
  }

  /**
   * Claim.shipments
   */
  export type Claim$shipmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shipment
     */
    select?: ShipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentInclude<ExtArgs> | null
    where?: ShipmentWhereInput
  }

  /**
   * Claim.claimToEntity
   */
  export type Claim$claimToEntityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClaimToEntity
     */
    select?: ClaimToEntitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaimToEntityInclude<ExtArgs> | null
    where?: ClaimToEntityWhereInput
    orderBy?: ClaimToEntityOrderByWithRelationInput | ClaimToEntityOrderByWithRelationInput[]
    cursor?: ClaimToEntityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClaimToEntityScalarFieldEnum | ClaimToEntityScalarFieldEnum[]
  }

  /**
   * Claim without action
   */
  export type ClaimDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaimInclude<ExtArgs> | null
  }


  /**
   * Model Problem
   */

  export type AggregateProblem = {
    _count: ProblemCountAggregateOutputType | null
    _min: ProblemMinAggregateOutputType | null
    _max: ProblemMaxAggregateOutputType | null
  }

  export type ProblemMinAggregateOutputType = {
    id: string | null
    problem: string | null
    createdAt: string | null
    organizationId: string | null
  }

  export type ProblemMaxAggregateOutputType = {
    id: string | null
    problem: string | null
    createdAt: string | null
    organizationId: string | null
  }

  export type ProblemCountAggregateOutputType = {
    id: number
    problem: number
    createdAt: number
    organizationId: number
    _all: number
  }


  export type ProblemMinAggregateInputType = {
    id?: true
    problem?: true
    createdAt?: true
    organizationId?: true
  }

  export type ProblemMaxAggregateInputType = {
    id?: true
    problem?: true
    createdAt?: true
    organizationId?: true
  }

  export type ProblemCountAggregateInputType = {
    id?: true
    problem?: true
    createdAt?: true
    organizationId?: true
    _all?: true
  }

  export type ProblemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Problem to aggregate.
     */
    where?: ProblemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Problems to fetch.
     */
    orderBy?: ProblemOrderByWithRelationInput | ProblemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProblemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Problems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Problems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Problems
    **/
    _count?: true | ProblemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProblemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProblemMaxAggregateInputType
  }

  export type GetProblemAggregateType<T extends ProblemAggregateArgs> = {
        [P in keyof T & keyof AggregateProblem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProblem[P]>
      : GetScalarType<T[P], AggregateProblem[P]>
  }




  export type ProblemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProblemWhereInput
    orderBy?: ProblemOrderByWithAggregationInput | ProblemOrderByWithAggregationInput[]
    by: ProblemScalarFieldEnum[] | ProblemScalarFieldEnum
    having?: ProblemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProblemCountAggregateInputType | true
    _min?: ProblemMinAggregateInputType
    _max?: ProblemMaxAggregateInputType
  }

  export type ProblemGroupByOutputType = {
    id: string
    problem: string
    createdAt: string
    organizationId: string
    _count: ProblemCountAggregateOutputType | null
    _min: ProblemMinAggregateOutputType | null
    _max: ProblemMaxAggregateOutputType | null
  }

  type GetProblemGroupByPayload<T extends ProblemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProblemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProblemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProblemGroupByOutputType[P]>
            : GetScalarType<T[P], ProblemGroupByOutputType[P]>
        }
      >
    >


  export type ProblemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    problem?: boolean
    createdAt?: boolean
    organizationId?: boolean
    investigations?: boolean | Problem$investigationsArgs<ExtArgs>
    claim?: boolean | Problem$claimArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    _count?: boolean | ProblemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["problem"]>


  export type ProblemSelectScalar = {
    id?: boolean
    problem?: boolean
    createdAt?: boolean
    organizationId?: boolean
  }

  export type ProblemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    investigations?: boolean | Problem$investigationsArgs<ExtArgs>
    claim?: boolean | Problem$claimArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    _count?: boolean | ProblemCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ProblemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Problem"
    objects: {
      investigations: Prisma.$InvestigationPayload<ExtArgs>[]
      claim: Prisma.$ClaimPayload<ExtArgs>[]
      organization: Prisma.$OrganizationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      problem: string
      createdAt: string
      organizationId: string
    }, ExtArgs["result"]["problem"]>
    composites: {}
  }

  type ProblemGetPayload<S extends boolean | null | undefined | ProblemDefaultArgs> = $Result.GetResult<Prisma.$ProblemPayload, S>

  type ProblemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProblemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProblemCountAggregateInputType | true
    }

  export interface ProblemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Problem'], meta: { name: 'Problem' } }
    /**
     * Find zero or one Problem that matches the filter.
     * @param {ProblemFindUniqueArgs} args - Arguments to find a Problem
     * @example
     * // Get one Problem
     * const problem = await prisma.problem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProblemFindUniqueArgs>(args: SelectSubset<T, ProblemFindUniqueArgs<ExtArgs>>): Prisma__ProblemClient<$Result.GetResult<Prisma.$ProblemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Problem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProblemFindUniqueOrThrowArgs} args - Arguments to find a Problem
     * @example
     * // Get one Problem
     * const problem = await prisma.problem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProblemFindUniqueOrThrowArgs>(args: SelectSubset<T, ProblemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProblemClient<$Result.GetResult<Prisma.$ProblemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Problem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProblemFindFirstArgs} args - Arguments to find a Problem
     * @example
     * // Get one Problem
     * const problem = await prisma.problem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProblemFindFirstArgs>(args?: SelectSubset<T, ProblemFindFirstArgs<ExtArgs>>): Prisma__ProblemClient<$Result.GetResult<Prisma.$ProblemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Problem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProblemFindFirstOrThrowArgs} args - Arguments to find a Problem
     * @example
     * // Get one Problem
     * const problem = await prisma.problem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProblemFindFirstOrThrowArgs>(args?: SelectSubset<T, ProblemFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProblemClient<$Result.GetResult<Prisma.$ProblemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Problems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProblemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Problems
     * const problems = await prisma.problem.findMany()
     * 
     * // Get first 10 Problems
     * const problems = await prisma.problem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const problemWithIdOnly = await prisma.problem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProblemFindManyArgs>(args?: SelectSubset<T, ProblemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProblemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Problem.
     * @param {ProblemCreateArgs} args - Arguments to create a Problem.
     * @example
     * // Create one Problem
     * const Problem = await prisma.problem.create({
     *   data: {
     *     // ... data to create a Problem
     *   }
     * })
     * 
     */
    create<T extends ProblemCreateArgs>(args: SelectSubset<T, ProblemCreateArgs<ExtArgs>>): Prisma__ProblemClient<$Result.GetResult<Prisma.$ProblemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Problems.
     * @param {ProblemCreateManyArgs} args - Arguments to create many Problems.
     * @example
     * // Create many Problems
     * const problem = await prisma.problem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProblemCreateManyArgs>(args?: SelectSubset<T, ProblemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Problem.
     * @param {ProblemDeleteArgs} args - Arguments to delete one Problem.
     * @example
     * // Delete one Problem
     * const Problem = await prisma.problem.delete({
     *   where: {
     *     // ... filter to delete one Problem
     *   }
     * })
     * 
     */
    delete<T extends ProblemDeleteArgs>(args: SelectSubset<T, ProblemDeleteArgs<ExtArgs>>): Prisma__ProblemClient<$Result.GetResult<Prisma.$ProblemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Problem.
     * @param {ProblemUpdateArgs} args - Arguments to update one Problem.
     * @example
     * // Update one Problem
     * const problem = await prisma.problem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProblemUpdateArgs>(args: SelectSubset<T, ProblemUpdateArgs<ExtArgs>>): Prisma__ProblemClient<$Result.GetResult<Prisma.$ProblemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Problems.
     * @param {ProblemDeleteManyArgs} args - Arguments to filter Problems to delete.
     * @example
     * // Delete a few Problems
     * const { count } = await prisma.problem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProblemDeleteManyArgs>(args?: SelectSubset<T, ProblemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Problems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProblemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Problems
     * const problem = await prisma.problem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProblemUpdateManyArgs>(args: SelectSubset<T, ProblemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Problem.
     * @param {ProblemUpsertArgs} args - Arguments to update or create a Problem.
     * @example
     * // Update or create a Problem
     * const problem = await prisma.problem.upsert({
     *   create: {
     *     // ... data to create a Problem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Problem we want to update
     *   }
     * })
     */
    upsert<T extends ProblemUpsertArgs>(args: SelectSubset<T, ProblemUpsertArgs<ExtArgs>>): Prisma__ProblemClient<$Result.GetResult<Prisma.$ProblemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Problems that matches the filter.
     * @param {ProblemFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const problem = await prisma.problem.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: ProblemFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Problem.
     * @param {ProblemAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const problem = await prisma.problem.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: ProblemAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Problems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProblemCountArgs} args - Arguments to filter Problems to count.
     * @example
     * // Count the number of Problems
     * const count = await prisma.problem.count({
     *   where: {
     *     // ... the filter for the Problems we want to count
     *   }
     * })
    **/
    count<T extends ProblemCountArgs>(
      args?: Subset<T, ProblemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProblemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Problem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProblemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProblemAggregateArgs>(args: Subset<T, ProblemAggregateArgs>): Prisma.PrismaPromise<GetProblemAggregateType<T>>

    /**
     * Group by Problem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProblemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProblemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProblemGroupByArgs['orderBy'] }
        : { orderBy?: ProblemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProblemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProblemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Problem model
   */
  readonly fields: ProblemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Problem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProblemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    investigations<T extends Problem$investigationsArgs<ExtArgs> = {}>(args?: Subset<T, Problem$investigationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvestigationPayload<ExtArgs>, T, "findMany"> | Null>
    claim<T extends Problem$claimArgs<ExtArgs> = {}>(args?: Subset<T, Problem$claimArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClaimPayload<ExtArgs>, T, "findMany"> | Null>
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Problem model
   */ 
  interface ProblemFieldRefs {
    readonly id: FieldRef<"Problem", 'String'>
    readonly problem: FieldRef<"Problem", 'String'>
    readonly createdAt: FieldRef<"Problem", 'String'>
    readonly organizationId: FieldRef<"Problem", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Problem findUnique
   */
  export type ProblemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Problem
     */
    select?: ProblemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProblemInclude<ExtArgs> | null
    /**
     * Filter, which Problem to fetch.
     */
    where: ProblemWhereUniqueInput
  }

  /**
   * Problem findUniqueOrThrow
   */
  export type ProblemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Problem
     */
    select?: ProblemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProblemInclude<ExtArgs> | null
    /**
     * Filter, which Problem to fetch.
     */
    where: ProblemWhereUniqueInput
  }

  /**
   * Problem findFirst
   */
  export type ProblemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Problem
     */
    select?: ProblemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProblemInclude<ExtArgs> | null
    /**
     * Filter, which Problem to fetch.
     */
    where?: ProblemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Problems to fetch.
     */
    orderBy?: ProblemOrderByWithRelationInput | ProblemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Problems.
     */
    cursor?: ProblemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Problems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Problems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Problems.
     */
    distinct?: ProblemScalarFieldEnum | ProblemScalarFieldEnum[]
  }

  /**
   * Problem findFirstOrThrow
   */
  export type ProblemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Problem
     */
    select?: ProblemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProblemInclude<ExtArgs> | null
    /**
     * Filter, which Problem to fetch.
     */
    where?: ProblemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Problems to fetch.
     */
    orderBy?: ProblemOrderByWithRelationInput | ProblemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Problems.
     */
    cursor?: ProblemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Problems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Problems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Problems.
     */
    distinct?: ProblemScalarFieldEnum | ProblemScalarFieldEnum[]
  }

  /**
   * Problem findMany
   */
  export type ProblemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Problem
     */
    select?: ProblemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProblemInclude<ExtArgs> | null
    /**
     * Filter, which Problems to fetch.
     */
    where?: ProblemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Problems to fetch.
     */
    orderBy?: ProblemOrderByWithRelationInput | ProblemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Problems.
     */
    cursor?: ProblemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Problems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Problems.
     */
    skip?: number
    distinct?: ProblemScalarFieldEnum | ProblemScalarFieldEnum[]
  }

  /**
   * Problem create
   */
  export type ProblemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Problem
     */
    select?: ProblemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProblemInclude<ExtArgs> | null
    /**
     * The data needed to create a Problem.
     */
    data: XOR<ProblemCreateInput, ProblemUncheckedCreateInput>
  }

  /**
   * Problem createMany
   */
  export type ProblemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Problems.
     */
    data: ProblemCreateManyInput | ProblemCreateManyInput[]
  }

  /**
   * Problem update
   */
  export type ProblemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Problem
     */
    select?: ProblemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProblemInclude<ExtArgs> | null
    /**
     * The data needed to update a Problem.
     */
    data: XOR<ProblemUpdateInput, ProblemUncheckedUpdateInput>
    /**
     * Choose, which Problem to update.
     */
    where: ProblemWhereUniqueInput
  }

  /**
   * Problem updateMany
   */
  export type ProblemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Problems.
     */
    data: XOR<ProblemUpdateManyMutationInput, ProblemUncheckedUpdateManyInput>
    /**
     * Filter which Problems to update
     */
    where?: ProblemWhereInput
  }

  /**
   * Problem upsert
   */
  export type ProblemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Problem
     */
    select?: ProblemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProblemInclude<ExtArgs> | null
    /**
     * The filter to search for the Problem to update in case it exists.
     */
    where: ProblemWhereUniqueInput
    /**
     * In case the Problem found by the `where` argument doesn't exist, create a new Problem with this data.
     */
    create: XOR<ProblemCreateInput, ProblemUncheckedCreateInput>
    /**
     * In case the Problem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProblemUpdateInput, ProblemUncheckedUpdateInput>
  }

  /**
   * Problem delete
   */
  export type ProblemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Problem
     */
    select?: ProblemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProblemInclude<ExtArgs> | null
    /**
     * Filter which Problem to delete.
     */
    where: ProblemWhereUniqueInput
  }

  /**
   * Problem deleteMany
   */
  export type ProblemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Problems to delete
     */
    where?: ProblemWhereInput
  }

  /**
   * Problem findRaw
   */
  export type ProblemFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Problem aggregateRaw
   */
  export type ProblemAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Problem.investigations
   */
  export type Problem$investigationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investigation
     */
    select?: InvestigationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestigationInclude<ExtArgs> | null
    where?: InvestigationWhereInput
    orderBy?: InvestigationOrderByWithRelationInput | InvestigationOrderByWithRelationInput[]
    cursor?: InvestigationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvestigationScalarFieldEnum | InvestigationScalarFieldEnum[]
  }

  /**
   * Problem.claim
   */
  export type Problem$claimArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaimInclude<ExtArgs> | null
    where?: ClaimWhereInput
    orderBy?: ClaimOrderByWithRelationInput | ClaimOrderByWithRelationInput[]
    cursor?: ClaimWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClaimScalarFieldEnum | ClaimScalarFieldEnum[]
  }

  /**
   * Problem without action
   */
  export type ProblemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Problem
     */
    select?: ProblemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProblemInclude<ExtArgs> | null
  }


  /**
   * Model ClaimToEntity
   */

  export type AggregateClaimToEntity = {
    _count: ClaimToEntityCountAggregateOutputType | null
    _min: ClaimToEntityMinAggregateOutputType | null
    _max: ClaimToEntityMaxAggregateOutputType | null
  }

  export type ClaimToEntityMinAggregateOutputType = {
    id: string | null
    claimId: string | null
    entityId: string | null
  }

  export type ClaimToEntityMaxAggregateOutputType = {
    id: string | null
    claimId: string | null
    entityId: string | null
  }

  export type ClaimToEntityCountAggregateOutputType = {
    id: number
    claimId: number
    entityId: number
    _all: number
  }


  export type ClaimToEntityMinAggregateInputType = {
    id?: true
    claimId?: true
    entityId?: true
  }

  export type ClaimToEntityMaxAggregateInputType = {
    id?: true
    claimId?: true
    entityId?: true
  }

  export type ClaimToEntityCountAggregateInputType = {
    id?: true
    claimId?: true
    entityId?: true
    _all?: true
  }

  export type ClaimToEntityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClaimToEntity to aggregate.
     */
    where?: ClaimToEntityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClaimToEntities to fetch.
     */
    orderBy?: ClaimToEntityOrderByWithRelationInput | ClaimToEntityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClaimToEntityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClaimToEntities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClaimToEntities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClaimToEntities
    **/
    _count?: true | ClaimToEntityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClaimToEntityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClaimToEntityMaxAggregateInputType
  }

  export type GetClaimToEntityAggregateType<T extends ClaimToEntityAggregateArgs> = {
        [P in keyof T & keyof AggregateClaimToEntity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClaimToEntity[P]>
      : GetScalarType<T[P], AggregateClaimToEntity[P]>
  }




  export type ClaimToEntityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClaimToEntityWhereInput
    orderBy?: ClaimToEntityOrderByWithAggregationInput | ClaimToEntityOrderByWithAggregationInput[]
    by: ClaimToEntityScalarFieldEnum[] | ClaimToEntityScalarFieldEnum
    having?: ClaimToEntityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClaimToEntityCountAggregateInputType | true
    _min?: ClaimToEntityMinAggregateInputType
    _max?: ClaimToEntityMaxAggregateInputType
  }

  export type ClaimToEntityGroupByOutputType = {
    id: string
    claimId: string
    entityId: string
    _count: ClaimToEntityCountAggregateOutputType | null
    _min: ClaimToEntityMinAggregateOutputType | null
    _max: ClaimToEntityMaxAggregateOutputType | null
  }

  type GetClaimToEntityGroupByPayload<T extends ClaimToEntityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClaimToEntityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClaimToEntityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClaimToEntityGroupByOutputType[P]>
            : GetScalarType<T[P], ClaimToEntityGroupByOutputType[P]>
        }
      >
    >


  export type ClaimToEntitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    claimId?: boolean
    entityId?: boolean
    claim?: boolean | ClaimDefaultArgs<ExtArgs>
    entity?: boolean | EntityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["claimToEntity"]>


  export type ClaimToEntitySelectScalar = {
    id?: boolean
    claimId?: boolean
    entityId?: boolean
  }

  export type ClaimToEntityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    claim?: boolean | ClaimDefaultArgs<ExtArgs>
    entity?: boolean | EntityDefaultArgs<ExtArgs>
  }

  export type $ClaimToEntityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClaimToEntity"
    objects: {
      claim: Prisma.$ClaimPayload<ExtArgs>
      entity: Prisma.$EntityPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      claimId: string
      entityId: string
    }, ExtArgs["result"]["claimToEntity"]>
    composites: {}
  }

  type ClaimToEntityGetPayload<S extends boolean | null | undefined | ClaimToEntityDefaultArgs> = $Result.GetResult<Prisma.$ClaimToEntityPayload, S>

  type ClaimToEntityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ClaimToEntityFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ClaimToEntityCountAggregateInputType | true
    }

  export interface ClaimToEntityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClaimToEntity'], meta: { name: 'ClaimToEntity' } }
    /**
     * Find zero or one ClaimToEntity that matches the filter.
     * @param {ClaimToEntityFindUniqueArgs} args - Arguments to find a ClaimToEntity
     * @example
     * // Get one ClaimToEntity
     * const claimToEntity = await prisma.claimToEntity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClaimToEntityFindUniqueArgs>(args: SelectSubset<T, ClaimToEntityFindUniqueArgs<ExtArgs>>): Prisma__ClaimToEntityClient<$Result.GetResult<Prisma.$ClaimToEntityPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ClaimToEntity that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ClaimToEntityFindUniqueOrThrowArgs} args - Arguments to find a ClaimToEntity
     * @example
     * // Get one ClaimToEntity
     * const claimToEntity = await prisma.claimToEntity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClaimToEntityFindUniqueOrThrowArgs>(args: SelectSubset<T, ClaimToEntityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClaimToEntityClient<$Result.GetResult<Prisma.$ClaimToEntityPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ClaimToEntity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimToEntityFindFirstArgs} args - Arguments to find a ClaimToEntity
     * @example
     * // Get one ClaimToEntity
     * const claimToEntity = await prisma.claimToEntity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClaimToEntityFindFirstArgs>(args?: SelectSubset<T, ClaimToEntityFindFirstArgs<ExtArgs>>): Prisma__ClaimToEntityClient<$Result.GetResult<Prisma.$ClaimToEntityPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ClaimToEntity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimToEntityFindFirstOrThrowArgs} args - Arguments to find a ClaimToEntity
     * @example
     * // Get one ClaimToEntity
     * const claimToEntity = await prisma.claimToEntity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClaimToEntityFindFirstOrThrowArgs>(args?: SelectSubset<T, ClaimToEntityFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClaimToEntityClient<$Result.GetResult<Prisma.$ClaimToEntityPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ClaimToEntities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimToEntityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClaimToEntities
     * const claimToEntities = await prisma.claimToEntity.findMany()
     * 
     * // Get first 10 ClaimToEntities
     * const claimToEntities = await prisma.claimToEntity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const claimToEntityWithIdOnly = await prisma.claimToEntity.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClaimToEntityFindManyArgs>(args?: SelectSubset<T, ClaimToEntityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClaimToEntityPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ClaimToEntity.
     * @param {ClaimToEntityCreateArgs} args - Arguments to create a ClaimToEntity.
     * @example
     * // Create one ClaimToEntity
     * const ClaimToEntity = await prisma.claimToEntity.create({
     *   data: {
     *     // ... data to create a ClaimToEntity
     *   }
     * })
     * 
     */
    create<T extends ClaimToEntityCreateArgs>(args: SelectSubset<T, ClaimToEntityCreateArgs<ExtArgs>>): Prisma__ClaimToEntityClient<$Result.GetResult<Prisma.$ClaimToEntityPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ClaimToEntities.
     * @param {ClaimToEntityCreateManyArgs} args - Arguments to create many ClaimToEntities.
     * @example
     * // Create many ClaimToEntities
     * const claimToEntity = await prisma.claimToEntity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClaimToEntityCreateManyArgs>(args?: SelectSubset<T, ClaimToEntityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ClaimToEntity.
     * @param {ClaimToEntityDeleteArgs} args - Arguments to delete one ClaimToEntity.
     * @example
     * // Delete one ClaimToEntity
     * const ClaimToEntity = await prisma.claimToEntity.delete({
     *   where: {
     *     // ... filter to delete one ClaimToEntity
     *   }
     * })
     * 
     */
    delete<T extends ClaimToEntityDeleteArgs>(args: SelectSubset<T, ClaimToEntityDeleteArgs<ExtArgs>>): Prisma__ClaimToEntityClient<$Result.GetResult<Prisma.$ClaimToEntityPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ClaimToEntity.
     * @param {ClaimToEntityUpdateArgs} args - Arguments to update one ClaimToEntity.
     * @example
     * // Update one ClaimToEntity
     * const claimToEntity = await prisma.claimToEntity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClaimToEntityUpdateArgs>(args: SelectSubset<T, ClaimToEntityUpdateArgs<ExtArgs>>): Prisma__ClaimToEntityClient<$Result.GetResult<Prisma.$ClaimToEntityPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ClaimToEntities.
     * @param {ClaimToEntityDeleteManyArgs} args - Arguments to filter ClaimToEntities to delete.
     * @example
     * // Delete a few ClaimToEntities
     * const { count } = await prisma.claimToEntity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClaimToEntityDeleteManyArgs>(args?: SelectSubset<T, ClaimToEntityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClaimToEntities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimToEntityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClaimToEntities
     * const claimToEntity = await prisma.claimToEntity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClaimToEntityUpdateManyArgs>(args: SelectSubset<T, ClaimToEntityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ClaimToEntity.
     * @param {ClaimToEntityUpsertArgs} args - Arguments to update or create a ClaimToEntity.
     * @example
     * // Update or create a ClaimToEntity
     * const claimToEntity = await prisma.claimToEntity.upsert({
     *   create: {
     *     // ... data to create a ClaimToEntity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClaimToEntity we want to update
     *   }
     * })
     */
    upsert<T extends ClaimToEntityUpsertArgs>(args: SelectSubset<T, ClaimToEntityUpsertArgs<ExtArgs>>): Prisma__ClaimToEntityClient<$Result.GetResult<Prisma.$ClaimToEntityPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more ClaimToEntities that matches the filter.
     * @param {ClaimToEntityFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const claimToEntity = await prisma.claimToEntity.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: ClaimToEntityFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a ClaimToEntity.
     * @param {ClaimToEntityAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const claimToEntity = await prisma.claimToEntity.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: ClaimToEntityAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of ClaimToEntities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimToEntityCountArgs} args - Arguments to filter ClaimToEntities to count.
     * @example
     * // Count the number of ClaimToEntities
     * const count = await prisma.claimToEntity.count({
     *   where: {
     *     // ... the filter for the ClaimToEntities we want to count
     *   }
     * })
    **/
    count<T extends ClaimToEntityCountArgs>(
      args?: Subset<T, ClaimToEntityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClaimToEntityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClaimToEntity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimToEntityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClaimToEntityAggregateArgs>(args: Subset<T, ClaimToEntityAggregateArgs>): Prisma.PrismaPromise<GetClaimToEntityAggregateType<T>>

    /**
     * Group by ClaimToEntity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimToEntityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClaimToEntityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClaimToEntityGroupByArgs['orderBy'] }
        : { orderBy?: ClaimToEntityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClaimToEntityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClaimToEntityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClaimToEntity model
   */
  readonly fields: ClaimToEntityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClaimToEntity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClaimToEntityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    claim<T extends ClaimDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClaimDefaultArgs<ExtArgs>>): Prisma__ClaimClient<$Result.GetResult<Prisma.$ClaimPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    entity<T extends EntityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EntityDefaultArgs<ExtArgs>>): Prisma__EntityClient<$Result.GetResult<Prisma.$EntityPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ClaimToEntity model
   */ 
  interface ClaimToEntityFieldRefs {
    readonly id: FieldRef<"ClaimToEntity", 'String'>
    readonly claimId: FieldRef<"ClaimToEntity", 'String'>
    readonly entityId: FieldRef<"ClaimToEntity", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ClaimToEntity findUnique
   */
  export type ClaimToEntityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClaimToEntity
     */
    select?: ClaimToEntitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaimToEntityInclude<ExtArgs> | null
    /**
     * Filter, which ClaimToEntity to fetch.
     */
    where: ClaimToEntityWhereUniqueInput
  }

  /**
   * ClaimToEntity findUniqueOrThrow
   */
  export type ClaimToEntityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClaimToEntity
     */
    select?: ClaimToEntitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaimToEntityInclude<ExtArgs> | null
    /**
     * Filter, which ClaimToEntity to fetch.
     */
    where: ClaimToEntityWhereUniqueInput
  }

  /**
   * ClaimToEntity findFirst
   */
  export type ClaimToEntityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClaimToEntity
     */
    select?: ClaimToEntitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaimToEntityInclude<ExtArgs> | null
    /**
     * Filter, which ClaimToEntity to fetch.
     */
    where?: ClaimToEntityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClaimToEntities to fetch.
     */
    orderBy?: ClaimToEntityOrderByWithRelationInput | ClaimToEntityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClaimToEntities.
     */
    cursor?: ClaimToEntityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClaimToEntities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClaimToEntities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClaimToEntities.
     */
    distinct?: ClaimToEntityScalarFieldEnum | ClaimToEntityScalarFieldEnum[]
  }

  /**
   * ClaimToEntity findFirstOrThrow
   */
  export type ClaimToEntityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClaimToEntity
     */
    select?: ClaimToEntitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaimToEntityInclude<ExtArgs> | null
    /**
     * Filter, which ClaimToEntity to fetch.
     */
    where?: ClaimToEntityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClaimToEntities to fetch.
     */
    orderBy?: ClaimToEntityOrderByWithRelationInput | ClaimToEntityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClaimToEntities.
     */
    cursor?: ClaimToEntityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClaimToEntities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClaimToEntities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClaimToEntities.
     */
    distinct?: ClaimToEntityScalarFieldEnum | ClaimToEntityScalarFieldEnum[]
  }

  /**
   * ClaimToEntity findMany
   */
  export type ClaimToEntityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClaimToEntity
     */
    select?: ClaimToEntitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaimToEntityInclude<ExtArgs> | null
    /**
     * Filter, which ClaimToEntities to fetch.
     */
    where?: ClaimToEntityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClaimToEntities to fetch.
     */
    orderBy?: ClaimToEntityOrderByWithRelationInput | ClaimToEntityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClaimToEntities.
     */
    cursor?: ClaimToEntityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClaimToEntities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClaimToEntities.
     */
    skip?: number
    distinct?: ClaimToEntityScalarFieldEnum | ClaimToEntityScalarFieldEnum[]
  }

  /**
   * ClaimToEntity create
   */
  export type ClaimToEntityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClaimToEntity
     */
    select?: ClaimToEntitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaimToEntityInclude<ExtArgs> | null
    /**
     * The data needed to create a ClaimToEntity.
     */
    data: XOR<ClaimToEntityCreateInput, ClaimToEntityUncheckedCreateInput>
  }

  /**
   * ClaimToEntity createMany
   */
  export type ClaimToEntityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClaimToEntities.
     */
    data: ClaimToEntityCreateManyInput | ClaimToEntityCreateManyInput[]
  }

  /**
   * ClaimToEntity update
   */
  export type ClaimToEntityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClaimToEntity
     */
    select?: ClaimToEntitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaimToEntityInclude<ExtArgs> | null
    /**
     * The data needed to update a ClaimToEntity.
     */
    data: XOR<ClaimToEntityUpdateInput, ClaimToEntityUncheckedUpdateInput>
    /**
     * Choose, which ClaimToEntity to update.
     */
    where: ClaimToEntityWhereUniqueInput
  }

  /**
   * ClaimToEntity updateMany
   */
  export type ClaimToEntityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClaimToEntities.
     */
    data: XOR<ClaimToEntityUpdateManyMutationInput, ClaimToEntityUncheckedUpdateManyInput>
    /**
     * Filter which ClaimToEntities to update
     */
    where?: ClaimToEntityWhereInput
  }

  /**
   * ClaimToEntity upsert
   */
  export type ClaimToEntityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClaimToEntity
     */
    select?: ClaimToEntitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaimToEntityInclude<ExtArgs> | null
    /**
     * The filter to search for the ClaimToEntity to update in case it exists.
     */
    where: ClaimToEntityWhereUniqueInput
    /**
     * In case the ClaimToEntity found by the `where` argument doesn't exist, create a new ClaimToEntity with this data.
     */
    create: XOR<ClaimToEntityCreateInput, ClaimToEntityUncheckedCreateInput>
    /**
     * In case the ClaimToEntity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClaimToEntityUpdateInput, ClaimToEntityUncheckedUpdateInput>
  }

  /**
   * ClaimToEntity delete
   */
  export type ClaimToEntityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClaimToEntity
     */
    select?: ClaimToEntitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaimToEntityInclude<ExtArgs> | null
    /**
     * Filter which ClaimToEntity to delete.
     */
    where: ClaimToEntityWhereUniqueInput
  }

  /**
   * ClaimToEntity deleteMany
   */
  export type ClaimToEntityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClaimToEntities to delete
     */
    where?: ClaimToEntityWhereInput
  }

  /**
   * ClaimToEntity findRaw
   */
  export type ClaimToEntityFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * ClaimToEntity aggregateRaw
   */
  export type ClaimToEntityAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * ClaimToEntity without action
   */
  export type ClaimToEntityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClaimToEntity
     */
    select?: ClaimToEntitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaimToEntityInclude<ExtArgs> | null
  }


  /**
   * Model Investigation
   */

  export type AggregateInvestigation = {
    _count: InvestigationCountAggregateOutputType | null
    _avg: InvestigationAvgAggregateOutputType | null
    _sum: InvestigationSumAggregateOutputType | null
    _min: InvestigationMinAggregateOutputType | null
    _max: InvestigationMaxAggregateOutputType | null
  }

  export type InvestigationAvgAggregateOutputType = {
    claimNo: number | null
  }

  export type InvestigationSumAggregateOutputType = {
    claimNo: number | null
  }

  export type InvestigationMinAggregateOutputType = {
    id: string | null
    rootCause: string | null
    counterMeasure: string | null
    leadTime: string | null
    claimType: string | null
    implementDate: string | null
    claimNo: number | null
    problemId: string | null
  }

  export type InvestigationMaxAggregateOutputType = {
    id: string | null
    rootCause: string | null
    counterMeasure: string | null
    leadTime: string | null
    claimType: string | null
    implementDate: string | null
    claimNo: number | null
    problemId: string | null
  }

  export type InvestigationCountAggregateOutputType = {
    id: number
    rootCause: number
    counterMeasure: number
    leadTime: number
    claimType: number
    implementDate: number
    attachment: number
    claimNo: number
    problemId: number
    _all: number
  }


  export type InvestigationAvgAggregateInputType = {
    claimNo?: true
  }

  export type InvestigationSumAggregateInputType = {
    claimNo?: true
  }

  export type InvestigationMinAggregateInputType = {
    id?: true
    rootCause?: true
    counterMeasure?: true
    leadTime?: true
    claimType?: true
    implementDate?: true
    claimNo?: true
    problemId?: true
  }

  export type InvestigationMaxAggregateInputType = {
    id?: true
    rootCause?: true
    counterMeasure?: true
    leadTime?: true
    claimType?: true
    implementDate?: true
    claimNo?: true
    problemId?: true
  }

  export type InvestigationCountAggregateInputType = {
    id?: true
    rootCause?: true
    counterMeasure?: true
    leadTime?: true
    claimType?: true
    implementDate?: true
    attachment?: true
    claimNo?: true
    problemId?: true
    _all?: true
  }

  export type InvestigationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Investigation to aggregate.
     */
    where?: InvestigationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Investigations to fetch.
     */
    orderBy?: InvestigationOrderByWithRelationInput | InvestigationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvestigationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Investigations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Investigations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Investigations
    **/
    _count?: true | InvestigationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvestigationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvestigationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvestigationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvestigationMaxAggregateInputType
  }

  export type GetInvestigationAggregateType<T extends InvestigationAggregateArgs> = {
        [P in keyof T & keyof AggregateInvestigation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvestigation[P]>
      : GetScalarType<T[P], AggregateInvestigation[P]>
  }




  export type InvestigationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvestigationWhereInput
    orderBy?: InvestigationOrderByWithAggregationInput | InvestigationOrderByWithAggregationInput[]
    by: InvestigationScalarFieldEnum[] | InvestigationScalarFieldEnum
    having?: InvestigationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvestigationCountAggregateInputType | true
    _avg?: InvestigationAvgAggregateInputType
    _sum?: InvestigationSumAggregateInputType
    _min?: InvestigationMinAggregateInputType
    _max?: InvestigationMaxAggregateInputType
  }

  export type InvestigationGroupByOutputType = {
    id: string
    rootCause: string
    counterMeasure: string
    leadTime: string
    claimType: string
    implementDate: string
    attachment: JsonValue[]
    claimNo: number
    problemId: string | null
    _count: InvestigationCountAggregateOutputType | null
    _avg: InvestigationAvgAggregateOutputType | null
    _sum: InvestigationSumAggregateOutputType | null
    _min: InvestigationMinAggregateOutputType | null
    _max: InvestigationMaxAggregateOutputType | null
  }

  type GetInvestigationGroupByPayload<T extends InvestigationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvestigationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvestigationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvestigationGroupByOutputType[P]>
            : GetScalarType<T[P], InvestigationGroupByOutputType[P]>
        }
      >
    >


  export type InvestigationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rootCause?: boolean
    counterMeasure?: boolean
    leadTime?: boolean
    claimType?: boolean
    implementDate?: boolean
    attachment?: boolean
    claimNo?: boolean
    problemId?: boolean
    claims?: boolean | Investigation$claimsArgs<ExtArgs>
    Problem?: boolean | Investigation$ProblemArgs<ExtArgs>
    _count?: boolean | InvestigationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["investigation"]>


  export type InvestigationSelectScalar = {
    id?: boolean
    rootCause?: boolean
    counterMeasure?: boolean
    leadTime?: boolean
    claimType?: boolean
    implementDate?: boolean
    attachment?: boolean
    claimNo?: boolean
    problemId?: boolean
  }

  export type InvestigationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    claims?: boolean | Investigation$claimsArgs<ExtArgs>
    Problem?: boolean | Investigation$ProblemArgs<ExtArgs>
    _count?: boolean | InvestigationCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $InvestigationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Investigation"
    objects: {
      claims: Prisma.$ClaimPayload<ExtArgs>[]
      Problem: Prisma.$ProblemPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      rootCause: string
      counterMeasure: string
      leadTime: string
      claimType: string
      implementDate: string
      attachment: Prisma.JsonValue[]
      claimNo: number
      problemId: string | null
    }, ExtArgs["result"]["investigation"]>
    composites: {}
  }

  type InvestigationGetPayload<S extends boolean | null | undefined | InvestigationDefaultArgs> = $Result.GetResult<Prisma.$InvestigationPayload, S>

  type InvestigationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InvestigationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InvestigationCountAggregateInputType | true
    }

  export interface InvestigationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Investigation'], meta: { name: 'Investigation' } }
    /**
     * Find zero or one Investigation that matches the filter.
     * @param {InvestigationFindUniqueArgs} args - Arguments to find a Investigation
     * @example
     * // Get one Investigation
     * const investigation = await prisma.investigation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvestigationFindUniqueArgs>(args: SelectSubset<T, InvestigationFindUniqueArgs<ExtArgs>>): Prisma__InvestigationClient<$Result.GetResult<Prisma.$InvestigationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Investigation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InvestigationFindUniqueOrThrowArgs} args - Arguments to find a Investigation
     * @example
     * // Get one Investigation
     * const investigation = await prisma.investigation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvestigationFindUniqueOrThrowArgs>(args: SelectSubset<T, InvestigationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvestigationClient<$Result.GetResult<Prisma.$InvestigationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Investigation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestigationFindFirstArgs} args - Arguments to find a Investigation
     * @example
     * // Get one Investigation
     * const investigation = await prisma.investigation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvestigationFindFirstArgs>(args?: SelectSubset<T, InvestigationFindFirstArgs<ExtArgs>>): Prisma__InvestigationClient<$Result.GetResult<Prisma.$InvestigationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Investigation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestigationFindFirstOrThrowArgs} args - Arguments to find a Investigation
     * @example
     * // Get one Investigation
     * const investigation = await prisma.investigation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvestigationFindFirstOrThrowArgs>(args?: SelectSubset<T, InvestigationFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvestigationClient<$Result.GetResult<Prisma.$InvestigationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Investigations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestigationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Investigations
     * const investigations = await prisma.investigation.findMany()
     * 
     * // Get first 10 Investigations
     * const investigations = await prisma.investigation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const investigationWithIdOnly = await prisma.investigation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvestigationFindManyArgs>(args?: SelectSubset<T, InvestigationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvestigationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Investigation.
     * @param {InvestigationCreateArgs} args - Arguments to create a Investigation.
     * @example
     * // Create one Investigation
     * const Investigation = await prisma.investigation.create({
     *   data: {
     *     // ... data to create a Investigation
     *   }
     * })
     * 
     */
    create<T extends InvestigationCreateArgs>(args: SelectSubset<T, InvestigationCreateArgs<ExtArgs>>): Prisma__InvestigationClient<$Result.GetResult<Prisma.$InvestigationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Investigations.
     * @param {InvestigationCreateManyArgs} args - Arguments to create many Investigations.
     * @example
     * // Create many Investigations
     * const investigation = await prisma.investigation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvestigationCreateManyArgs>(args?: SelectSubset<T, InvestigationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Investigation.
     * @param {InvestigationDeleteArgs} args - Arguments to delete one Investigation.
     * @example
     * // Delete one Investigation
     * const Investigation = await prisma.investigation.delete({
     *   where: {
     *     // ... filter to delete one Investigation
     *   }
     * })
     * 
     */
    delete<T extends InvestigationDeleteArgs>(args: SelectSubset<T, InvestigationDeleteArgs<ExtArgs>>): Prisma__InvestigationClient<$Result.GetResult<Prisma.$InvestigationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Investigation.
     * @param {InvestigationUpdateArgs} args - Arguments to update one Investigation.
     * @example
     * // Update one Investigation
     * const investigation = await prisma.investigation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvestigationUpdateArgs>(args: SelectSubset<T, InvestigationUpdateArgs<ExtArgs>>): Prisma__InvestigationClient<$Result.GetResult<Prisma.$InvestigationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Investigations.
     * @param {InvestigationDeleteManyArgs} args - Arguments to filter Investigations to delete.
     * @example
     * // Delete a few Investigations
     * const { count } = await prisma.investigation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvestigationDeleteManyArgs>(args?: SelectSubset<T, InvestigationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Investigations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestigationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Investigations
     * const investigation = await prisma.investigation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvestigationUpdateManyArgs>(args: SelectSubset<T, InvestigationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Investigation.
     * @param {InvestigationUpsertArgs} args - Arguments to update or create a Investigation.
     * @example
     * // Update or create a Investigation
     * const investigation = await prisma.investigation.upsert({
     *   create: {
     *     // ... data to create a Investigation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Investigation we want to update
     *   }
     * })
     */
    upsert<T extends InvestigationUpsertArgs>(args: SelectSubset<T, InvestigationUpsertArgs<ExtArgs>>): Prisma__InvestigationClient<$Result.GetResult<Prisma.$InvestigationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Investigations that matches the filter.
     * @param {InvestigationFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const investigation = await prisma.investigation.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: InvestigationFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Investigation.
     * @param {InvestigationAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const investigation = await prisma.investigation.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: InvestigationAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Investigations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestigationCountArgs} args - Arguments to filter Investigations to count.
     * @example
     * // Count the number of Investigations
     * const count = await prisma.investigation.count({
     *   where: {
     *     // ... the filter for the Investigations we want to count
     *   }
     * })
    **/
    count<T extends InvestigationCountArgs>(
      args?: Subset<T, InvestigationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvestigationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Investigation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestigationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvestigationAggregateArgs>(args: Subset<T, InvestigationAggregateArgs>): Prisma.PrismaPromise<GetInvestigationAggregateType<T>>

    /**
     * Group by Investigation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestigationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvestigationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvestigationGroupByArgs['orderBy'] }
        : { orderBy?: InvestigationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvestigationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvestigationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Investigation model
   */
  readonly fields: InvestigationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Investigation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvestigationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    claims<T extends Investigation$claimsArgs<ExtArgs> = {}>(args?: Subset<T, Investigation$claimsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClaimPayload<ExtArgs>, T, "findMany"> | Null>
    Problem<T extends Investigation$ProblemArgs<ExtArgs> = {}>(args?: Subset<T, Investigation$ProblemArgs<ExtArgs>>): Prisma__ProblemClient<$Result.GetResult<Prisma.$ProblemPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Investigation model
   */ 
  interface InvestigationFieldRefs {
    readonly id: FieldRef<"Investigation", 'String'>
    readonly rootCause: FieldRef<"Investigation", 'String'>
    readonly counterMeasure: FieldRef<"Investigation", 'String'>
    readonly leadTime: FieldRef<"Investigation", 'String'>
    readonly claimType: FieldRef<"Investigation", 'String'>
    readonly implementDate: FieldRef<"Investigation", 'String'>
    readonly attachment: FieldRef<"Investigation", 'Json[]'>
    readonly claimNo: FieldRef<"Investigation", 'Int'>
    readonly problemId: FieldRef<"Investigation", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Investigation findUnique
   */
  export type InvestigationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investigation
     */
    select?: InvestigationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestigationInclude<ExtArgs> | null
    /**
     * Filter, which Investigation to fetch.
     */
    where: InvestigationWhereUniqueInput
  }

  /**
   * Investigation findUniqueOrThrow
   */
  export type InvestigationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investigation
     */
    select?: InvestigationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestigationInclude<ExtArgs> | null
    /**
     * Filter, which Investigation to fetch.
     */
    where: InvestigationWhereUniqueInput
  }

  /**
   * Investigation findFirst
   */
  export type InvestigationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investigation
     */
    select?: InvestigationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestigationInclude<ExtArgs> | null
    /**
     * Filter, which Investigation to fetch.
     */
    where?: InvestigationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Investigations to fetch.
     */
    orderBy?: InvestigationOrderByWithRelationInput | InvestigationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Investigations.
     */
    cursor?: InvestigationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Investigations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Investigations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Investigations.
     */
    distinct?: InvestigationScalarFieldEnum | InvestigationScalarFieldEnum[]
  }

  /**
   * Investigation findFirstOrThrow
   */
  export type InvestigationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investigation
     */
    select?: InvestigationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestigationInclude<ExtArgs> | null
    /**
     * Filter, which Investigation to fetch.
     */
    where?: InvestigationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Investigations to fetch.
     */
    orderBy?: InvestigationOrderByWithRelationInput | InvestigationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Investigations.
     */
    cursor?: InvestigationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Investigations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Investigations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Investigations.
     */
    distinct?: InvestigationScalarFieldEnum | InvestigationScalarFieldEnum[]
  }

  /**
   * Investigation findMany
   */
  export type InvestigationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investigation
     */
    select?: InvestigationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestigationInclude<ExtArgs> | null
    /**
     * Filter, which Investigations to fetch.
     */
    where?: InvestigationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Investigations to fetch.
     */
    orderBy?: InvestigationOrderByWithRelationInput | InvestigationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Investigations.
     */
    cursor?: InvestigationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Investigations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Investigations.
     */
    skip?: number
    distinct?: InvestigationScalarFieldEnum | InvestigationScalarFieldEnum[]
  }

  /**
   * Investigation create
   */
  export type InvestigationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investigation
     */
    select?: InvestigationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestigationInclude<ExtArgs> | null
    /**
     * The data needed to create a Investigation.
     */
    data: XOR<InvestigationCreateInput, InvestigationUncheckedCreateInput>
  }

  /**
   * Investigation createMany
   */
  export type InvestigationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Investigations.
     */
    data: InvestigationCreateManyInput | InvestigationCreateManyInput[]
  }

  /**
   * Investigation update
   */
  export type InvestigationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investigation
     */
    select?: InvestigationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestigationInclude<ExtArgs> | null
    /**
     * The data needed to update a Investigation.
     */
    data: XOR<InvestigationUpdateInput, InvestigationUncheckedUpdateInput>
    /**
     * Choose, which Investigation to update.
     */
    where: InvestigationWhereUniqueInput
  }

  /**
   * Investigation updateMany
   */
  export type InvestigationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Investigations.
     */
    data: XOR<InvestigationUpdateManyMutationInput, InvestigationUncheckedUpdateManyInput>
    /**
     * Filter which Investigations to update
     */
    where?: InvestigationWhereInput
  }

  /**
   * Investigation upsert
   */
  export type InvestigationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investigation
     */
    select?: InvestigationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestigationInclude<ExtArgs> | null
    /**
     * The filter to search for the Investigation to update in case it exists.
     */
    where: InvestigationWhereUniqueInput
    /**
     * In case the Investigation found by the `where` argument doesn't exist, create a new Investigation with this data.
     */
    create: XOR<InvestigationCreateInput, InvestigationUncheckedCreateInput>
    /**
     * In case the Investigation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvestigationUpdateInput, InvestigationUncheckedUpdateInput>
  }

  /**
   * Investigation delete
   */
  export type InvestigationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investigation
     */
    select?: InvestigationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestigationInclude<ExtArgs> | null
    /**
     * Filter which Investigation to delete.
     */
    where: InvestigationWhereUniqueInput
  }

  /**
   * Investigation deleteMany
   */
  export type InvestigationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Investigations to delete
     */
    where?: InvestigationWhereInput
  }

  /**
   * Investigation findRaw
   */
  export type InvestigationFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Investigation aggregateRaw
   */
  export type InvestigationAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Investigation.claims
   */
  export type Investigation$claimsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaimInclude<ExtArgs> | null
    where?: ClaimWhereInput
    orderBy?: ClaimOrderByWithRelationInput | ClaimOrderByWithRelationInput[]
    cursor?: ClaimWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClaimScalarFieldEnum | ClaimScalarFieldEnum[]
  }

  /**
   * Investigation.Problem
   */
  export type Investigation$ProblemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Problem
     */
    select?: ProblemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProblemInclude<ExtArgs> | null
    where?: ProblemWhereInput
  }

  /**
   * Investigation without action
   */
  export type InvestigationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investigation
     */
    select?: InvestigationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestigationInclude<ExtArgs> | null
  }


  /**
   * Model Shipment
   */

  export type AggregateShipment = {
    _count: ShipmentCountAggregateOutputType | null
    _avg: ShipmentAvgAggregateOutputType | null
    _sum: ShipmentSumAggregateOutputType | null
    _min: ShipmentMinAggregateOutputType | null
    _max: ShipmentMaxAggregateOutputType | null
  }

  export type ShipmentAvgAggregateOutputType = {
    quantity: number | null
    shipmentCost: number | null
  }

  export type ShipmentSumAggregateOutputType = {
    quantity: number | null
    shipmentCost: number | null
  }

  export type ShipmentMinAggregateOutputType = {
    id: string | null
    shipmentDate: string | null
    quantity: number | null
    location: string | null
    InvoiceNumber: string | null
    dueDate: string | null
    shipmentCost: number | null
    createdBy: string | null
    awb: string | null
    supplierName: string | null
  }

  export type ShipmentMaxAggregateOutputType = {
    id: string | null
    shipmentDate: string | null
    quantity: number | null
    location: string | null
    InvoiceNumber: string | null
    dueDate: string | null
    shipmentCost: number | null
    createdBy: string | null
    awb: string | null
    supplierName: string | null
  }

  export type ShipmentCountAggregateOutputType = {
    id: number
    shipmentDate: number
    quantity: number
    location: number
    InvoiceNumber: number
    dueDate: number
    shipmentCost: number
    createdBy: number
    awb: number
    supplierName: number
    supplierReport: number
    _all: number
  }


  export type ShipmentAvgAggregateInputType = {
    quantity?: true
    shipmentCost?: true
  }

  export type ShipmentSumAggregateInputType = {
    quantity?: true
    shipmentCost?: true
  }

  export type ShipmentMinAggregateInputType = {
    id?: true
    shipmentDate?: true
    quantity?: true
    location?: true
    InvoiceNumber?: true
    dueDate?: true
    shipmentCost?: true
    createdBy?: true
    awb?: true
    supplierName?: true
  }

  export type ShipmentMaxAggregateInputType = {
    id?: true
    shipmentDate?: true
    quantity?: true
    location?: true
    InvoiceNumber?: true
    dueDate?: true
    shipmentCost?: true
    createdBy?: true
    awb?: true
    supplierName?: true
  }

  export type ShipmentCountAggregateInputType = {
    id?: true
    shipmentDate?: true
    quantity?: true
    location?: true
    InvoiceNumber?: true
    dueDate?: true
    shipmentCost?: true
    createdBy?: true
    awb?: true
    supplierName?: true
    supplierReport?: true
    _all?: true
  }

  export type ShipmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Shipment to aggregate.
     */
    where?: ShipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shipments to fetch.
     */
    orderBy?: ShipmentOrderByWithRelationInput | ShipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ShipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shipments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shipments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Shipments
    **/
    _count?: true | ShipmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ShipmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ShipmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShipmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShipmentMaxAggregateInputType
  }

  export type GetShipmentAggregateType<T extends ShipmentAggregateArgs> = {
        [P in keyof T & keyof AggregateShipment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShipment[P]>
      : GetScalarType<T[P], AggregateShipment[P]>
  }




  export type ShipmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShipmentWhereInput
    orderBy?: ShipmentOrderByWithAggregationInput | ShipmentOrderByWithAggregationInput[]
    by: ShipmentScalarFieldEnum[] | ShipmentScalarFieldEnum
    having?: ShipmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShipmentCountAggregateInputType | true
    _avg?: ShipmentAvgAggregateInputType
    _sum?: ShipmentSumAggregateInputType
    _min?: ShipmentMinAggregateInputType
    _max?: ShipmentMaxAggregateInputType
  }

  export type ShipmentGroupByOutputType = {
    id: string
    shipmentDate: string | null
    quantity: number | null
    location: string | null
    InvoiceNumber: string | null
    dueDate: string | null
    shipmentCost: number | null
    createdBy: string | null
    awb: string | null
    supplierName: string | null
    supplierReport: JsonValue[]
    _count: ShipmentCountAggregateOutputType | null
    _avg: ShipmentAvgAggregateOutputType | null
    _sum: ShipmentSumAggregateOutputType | null
    _min: ShipmentMinAggregateOutputType | null
    _max: ShipmentMaxAggregateOutputType | null
  }

  type GetShipmentGroupByPayload<T extends ShipmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ShipmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShipmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShipmentGroupByOutputType[P]>
            : GetScalarType<T[P], ShipmentGroupByOutputType[P]>
        }
      >
    >


  export type ShipmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    shipmentDate?: boolean
    quantity?: boolean
    location?: boolean
    InvoiceNumber?: boolean
    dueDate?: boolean
    shipmentCost?: boolean
    createdBy?: boolean
    awb?: boolean
    supplierName?: boolean
    supplierReport?: boolean
    claims?: boolean | Shipment$claimsArgs<ExtArgs>
    _count?: boolean | ShipmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shipment"]>


  export type ShipmentSelectScalar = {
    id?: boolean
    shipmentDate?: boolean
    quantity?: boolean
    location?: boolean
    InvoiceNumber?: boolean
    dueDate?: boolean
    shipmentCost?: boolean
    createdBy?: boolean
    awb?: boolean
    supplierName?: boolean
    supplierReport?: boolean
  }

  export type ShipmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    claims?: boolean | Shipment$claimsArgs<ExtArgs>
    _count?: boolean | ShipmentCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ShipmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Shipment"
    objects: {
      claims: Prisma.$ClaimPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      shipmentDate: string | null
      quantity: number | null
      location: string | null
      InvoiceNumber: string | null
      dueDate: string | null
      shipmentCost: number | null
      createdBy: string | null
      awb: string | null
      supplierName: string | null
      supplierReport: Prisma.JsonValue[]
    }, ExtArgs["result"]["shipment"]>
    composites: {}
  }

  type ShipmentGetPayload<S extends boolean | null | undefined | ShipmentDefaultArgs> = $Result.GetResult<Prisma.$ShipmentPayload, S>

  type ShipmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ShipmentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ShipmentCountAggregateInputType | true
    }

  export interface ShipmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Shipment'], meta: { name: 'Shipment' } }
    /**
     * Find zero or one Shipment that matches the filter.
     * @param {ShipmentFindUniqueArgs} args - Arguments to find a Shipment
     * @example
     * // Get one Shipment
     * const shipment = await prisma.shipment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ShipmentFindUniqueArgs>(args: SelectSubset<T, ShipmentFindUniqueArgs<ExtArgs>>): Prisma__ShipmentClient<$Result.GetResult<Prisma.$ShipmentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Shipment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ShipmentFindUniqueOrThrowArgs} args - Arguments to find a Shipment
     * @example
     * // Get one Shipment
     * const shipment = await prisma.shipment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ShipmentFindUniqueOrThrowArgs>(args: SelectSubset<T, ShipmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ShipmentClient<$Result.GetResult<Prisma.$ShipmentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Shipment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShipmentFindFirstArgs} args - Arguments to find a Shipment
     * @example
     * // Get one Shipment
     * const shipment = await prisma.shipment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ShipmentFindFirstArgs>(args?: SelectSubset<T, ShipmentFindFirstArgs<ExtArgs>>): Prisma__ShipmentClient<$Result.GetResult<Prisma.$ShipmentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Shipment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShipmentFindFirstOrThrowArgs} args - Arguments to find a Shipment
     * @example
     * // Get one Shipment
     * const shipment = await prisma.shipment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ShipmentFindFirstOrThrowArgs>(args?: SelectSubset<T, ShipmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__ShipmentClient<$Result.GetResult<Prisma.$ShipmentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Shipments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShipmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Shipments
     * const shipments = await prisma.shipment.findMany()
     * 
     * // Get first 10 Shipments
     * const shipments = await prisma.shipment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const shipmentWithIdOnly = await prisma.shipment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ShipmentFindManyArgs>(args?: SelectSubset<T, ShipmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShipmentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Shipment.
     * @param {ShipmentCreateArgs} args - Arguments to create a Shipment.
     * @example
     * // Create one Shipment
     * const Shipment = await prisma.shipment.create({
     *   data: {
     *     // ... data to create a Shipment
     *   }
     * })
     * 
     */
    create<T extends ShipmentCreateArgs>(args: SelectSubset<T, ShipmentCreateArgs<ExtArgs>>): Prisma__ShipmentClient<$Result.GetResult<Prisma.$ShipmentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Shipments.
     * @param {ShipmentCreateManyArgs} args - Arguments to create many Shipments.
     * @example
     * // Create many Shipments
     * const shipment = await prisma.shipment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ShipmentCreateManyArgs>(args?: SelectSubset<T, ShipmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Shipment.
     * @param {ShipmentDeleteArgs} args - Arguments to delete one Shipment.
     * @example
     * // Delete one Shipment
     * const Shipment = await prisma.shipment.delete({
     *   where: {
     *     // ... filter to delete one Shipment
     *   }
     * })
     * 
     */
    delete<T extends ShipmentDeleteArgs>(args: SelectSubset<T, ShipmentDeleteArgs<ExtArgs>>): Prisma__ShipmentClient<$Result.GetResult<Prisma.$ShipmentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Shipment.
     * @param {ShipmentUpdateArgs} args - Arguments to update one Shipment.
     * @example
     * // Update one Shipment
     * const shipment = await prisma.shipment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ShipmentUpdateArgs>(args: SelectSubset<T, ShipmentUpdateArgs<ExtArgs>>): Prisma__ShipmentClient<$Result.GetResult<Prisma.$ShipmentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Shipments.
     * @param {ShipmentDeleteManyArgs} args - Arguments to filter Shipments to delete.
     * @example
     * // Delete a few Shipments
     * const { count } = await prisma.shipment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ShipmentDeleteManyArgs>(args?: SelectSubset<T, ShipmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Shipments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShipmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Shipments
     * const shipment = await prisma.shipment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ShipmentUpdateManyArgs>(args: SelectSubset<T, ShipmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Shipment.
     * @param {ShipmentUpsertArgs} args - Arguments to update or create a Shipment.
     * @example
     * // Update or create a Shipment
     * const shipment = await prisma.shipment.upsert({
     *   create: {
     *     // ... data to create a Shipment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Shipment we want to update
     *   }
     * })
     */
    upsert<T extends ShipmentUpsertArgs>(args: SelectSubset<T, ShipmentUpsertArgs<ExtArgs>>): Prisma__ShipmentClient<$Result.GetResult<Prisma.$ShipmentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Shipments that matches the filter.
     * @param {ShipmentFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const shipment = await prisma.shipment.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: ShipmentFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Shipment.
     * @param {ShipmentAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const shipment = await prisma.shipment.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: ShipmentAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Shipments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShipmentCountArgs} args - Arguments to filter Shipments to count.
     * @example
     * // Count the number of Shipments
     * const count = await prisma.shipment.count({
     *   where: {
     *     // ... the filter for the Shipments we want to count
     *   }
     * })
    **/
    count<T extends ShipmentCountArgs>(
      args?: Subset<T, ShipmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShipmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Shipment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShipmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShipmentAggregateArgs>(args: Subset<T, ShipmentAggregateArgs>): Prisma.PrismaPromise<GetShipmentAggregateType<T>>

    /**
     * Group by Shipment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShipmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ShipmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ShipmentGroupByArgs['orderBy'] }
        : { orderBy?: ShipmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ShipmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShipmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Shipment model
   */
  readonly fields: ShipmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Shipment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ShipmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    claims<T extends Shipment$claimsArgs<ExtArgs> = {}>(args?: Subset<T, Shipment$claimsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClaimPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Shipment model
   */ 
  interface ShipmentFieldRefs {
    readonly id: FieldRef<"Shipment", 'String'>
    readonly shipmentDate: FieldRef<"Shipment", 'String'>
    readonly quantity: FieldRef<"Shipment", 'Int'>
    readonly location: FieldRef<"Shipment", 'String'>
    readonly InvoiceNumber: FieldRef<"Shipment", 'String'>
    readonly dueDate: FieldRef<"Shipment", 'String'>
    readonly shipmentCost: FieldRef<"Shipment", 'Int'>
    readonly createdBy: FieldRef<"Shipment", 'String'>
    readonly awb: FieldRef<"Shipment", 'String'>
    readonly supplierName: FieldRef<"Shipment", 'String'>
    readonly supplierReport: FieldRef<"Shipment", 'Json[]'>
  }
    

  // Custom InputTypes
  /**
   * Shipment findUnique
   */
  export type ShipmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shipment
     */
    select?: ShipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentInclude<ExtArgs> | null
    /**
     * Filter, which Shipment to fetch.
     */
    where: ShipmentWhereUniqueInput
  }

  /**
   * Shipment findUniqueOrThrow
   */
  export type ShipmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shipment
     */
    select?: ShipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentInclude<ExtArgs> | null
    /**
     * Filter, which Shipment to fetch.
     */
    where: ShipmentWhereUniqueInput
  }

  /**
   * Shipment findFirst
   */
  export type ShipmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shipment
     */
    select?: ShipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentInclude<ExtArgs> | null
    /**
     * Filter, which Shipment to fetch.
     */
    where?: ShipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shipments to fetch.
     */
    orderBy?: ShipmentOrderByWithRelationInput | ShipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Shipments.
     */
    cursor?: ShipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shipments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shipments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Shipments.
     */
    distinct?: ShipmentScalarFieldEnum | ShipmentScalarFieldEnum[]
  }

  /**
   * Shipment findFirstOrThrow
   */
  export type ShipmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shipment
     */
    select?: ShipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentInclude<ExtArgs> | null
    /**
     * Filter, which Shipment to fetch.
     */
    where?: ShipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shipments to fetch.
     */
    orderBy?: ShipmentOrderByWithRelationInput | ShipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Shipments.
     */
    cursor?: ShipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shipments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shipments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Shipments.
     */
    distinct?: ShipmentScalarFieldEnum | ShipmentScalarFieldEnum[]
  }

  /**
   * Shipment findMany
   */
  export type ShipmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shipment
     */
    select?: ShipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentInclude<ExtArgs> | null
    /**
     * Filter, which Shipments to fetch.
     */
    where?: ShipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shipments to fetch.
     */
    orderBy?: ShipmentOrderByWithRelationInput | ShipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Shipments.
     */
    cursor?: ShipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shipments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shipments.
     */
    skip?: number
    distinct?: ShipmentScalarFieldEnum | ShipmentScalarFieldEnum[]
  }

  /**
   * Shipment create
   */
  export type ShipmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shipment
     */
    select?: ShipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Shipment.
     */
    data?: XOR<ShipmentCreateInput, ShipmentUncheckedCreateInput>
  }

  /**
   * Shipment createMany
   */
  export type ShipmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Shipments.
     */
    data: ShipmentCreateManyInput | ShipmentCreateManyInput[]
  }

  /**
   * Shipment update
   */
  export type ShipmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shipment
     */
    select?: ShipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Shipment.
     */
    data: XOR<ShipmentUpdateInput, ShipmentUncheckedUpdateInput>
    /**
     * Choose, which Shipment to update.
     */
    where: ShipmentWhereUniqueInput
  }

  /**
   * Shipment updateMany
   */
  export type ShipmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Shipments.
     */
    data: XOR<ShipmentUpdateManyMutationInput, ShipmentUncheckedUpdateManyInput>
    /**
     * Filter which Shipments to update
     */
    where?: ShipmentWhereInput
  }

  /**
   * Shipment upsert
   */
  export type ShipmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shipment
     */
    select?: ShipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Shipment to update in case it exists.
     */
    where: ShipmentWhereUniqueInput
    /**
     * In case the Shipment found by the `where` argument doesn't exist, create a new Shipment with this data.
     */
    create: XOR<ShipmentCreateInput, ShipmentUncheckedCreateInput>
    /**
     * In case the Shipment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ShipmentUpdateInput, ShipmentUncheckedUpdateInput>
  }

  /**
   * Shipment delete
   */
  export type ShipmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shipment
     */
    select?: ShipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentInclude<ExtArgs> | null
    /**
     * Filter which Shipment to delete.
     */
    where: ShipmentWhereUniqueInput
  }

  /**
   * Shipment deleteMany
   */
  export type ShipmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Shipments to delete
     */
    where?: ShipmentWhereInput
  }

  /**
   * Shipment findRaw
   */
  export type ShipmentFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Shipment aggregateRaw
   */
  export type ShipmentAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Shipment.claims
   */
  export type Shipment$claimsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaimInclude<ExtArgs> | null
    where?: ClaimWhereInput
    orderBy?: ClaimOrderByWithRelationInput | ClaimOrderByWithRelationInput[]
    cursor?: ClaimWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClaimScalarFieldEnum | ClaimScalarFieldEnum[]
  }

  /**
   * Shipment without action
   */
  export type ShipmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shipment
     */
    select?: ShipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentInclude<ExtArgs> | null
  }


  /**
   * Model Organization
   */

  export type AggregateOrganization = {
    _count: OrganizationCountAggregateOutputType | null
    _min: OrganizationMinAggregateOutputType | null
    _max: OrganizationMaxAggregateOutputType | null
  }

  export type OrganizationMinAggregateOutputType = {
    id: string | null
    kcId: string | null
    organizationName: string | null
    realmName: string | null
    instanceUrl: string | null
    principalGeography: string | null
    loginUrl: string | null
    logoutUrl: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
    clientID: string | null
    clientSecret: string | null
    fiscalYearQuarters: string | null
    fiscalYearFormat: string | null
    auditYear: string | null
    logoUrl: string | null
    deleted: boolean | null
  }

  export type OrganizationMaxAggregateOutputType = {
    id: string | null
    kcId: string | null
    organizationName: string | null
    realmName: string | null
    instanceUrl: string | null
    principalGeography: string | null
    loginUrl: string | null
    logoutUrl: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
    clientID: string | null
    clientSecret: string | null
    fiscalYearQuarters: string | null
    fiscalYearFormat: string | null
    auditYear: string | null
    logoUrl: string | null
    deleted: boolean | null
  }

  export type OrganizationCountAggregateOutputType = {
    id: number
    kcId: number
    organizationName: number
    realmName: number
    instanceUrl: number
    principalGeography: number
    loginUrl: number
    logoutUrl: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    activeModules: number
    clientID: number
    clientSecret: number
    fiscalYearQuarters: number
    fiscalYearFormat: number
    auditYear: number
    logoUrl: number
    deleted: number
    _all: number
  }


  export type OrganizationMinAggregateInputType = {
    id?: true
    kcId?: true
    organizationName?: true
    realmName?: true
    instanceUrl?: true
    principalGeography?: true
    loginUrl?: true
    logoutUrl?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    clientID?: true
    clientSecret?: true
    fiscalYearQuarters?: true
    fiscalYearFormat?: true
    auditYear?: true
    logoUrl?: true
    deleted?: true
  }

  export type OrganizationMaxAggregateInputType = {
    id?: true
    kcId?: true
    organizationName?: true
    realmName?: true
    instanceUrl?: true
    principalGeography?: true
    loginUrl?: true
    logoutUrl?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    clientID?: true
    clientSecret?: true
    fiscalYearQuarters?: true
    fiscalYearFormat?: true
    auditYear?: true
    logoUrl?: true
    deleted?: true
  }

  export type OrganizationCountAggregateInputType = {
    id?: true
    kcId?: true
    organizationName?: true
    realmName?: true
    instanceUrl?: true
    principalGeography?: true
    loginUrl?: true
    logoutUrl?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    activeModules?: true
    clientID?: true
    clientSecret?: true
    fiscalYearQuarters?: true
    fiscalYearFormat?: true
    auditYear?: true
    logoUrl?: true
    deleted?: true
    _all?: true
  }

  export type OrganizationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Organization to aggregate.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Organizations
    **/
    _count?: true | OrganizationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrganizationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrganizationMaxAggregateInputType
  }

  export type GetOrganizationAggregateType<T extends OrganizationAggregateArgs> = {
        [P in keyof T & keyof AggregateOrganization]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrganization[P]>
      : GetScalarType<T[P], AggregateOrganization[P]>
  }




  export type OrganizationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrganizationWhereInput
    orderBy?: OrganizationOrderByWithAggregationInput | OrganizationOrderByWithAggregationInput[]
    by: OrganizationScalarFieldEnum[] | OrganizationScalarFieldEnum
    having?: OrganizationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrganizationCountAggregateInputType | true
    _min?: OrganizationMinAggregateInputType
    _max?: OrganizationMaxAggregateInputType
  }

  export type OrganizationGroupByOutputType = {
    id: string
    kcId: string | null
    organizationName: string | null
    realmName: string | null
    instanceUrl: string | null
    principalGeography: string | null
    loginUrl: string | null
    logoutUrl: string | null
    createdAt: Date
    createdBy: string | null
    updatedAt: Date
    updatedBy: string | null
    activeModules: string[]
    clientID: string | null
    clientSecret: string | null
    fiscalYearQuarters: string | null
    fiscalYearFormat: string | null
    auditYear: string | null
    logoUrl: string | null
    deleted: boolean | null
    _count: OrganizationCountAggregateOutputType | null
    _min: OrganizationMinAggregateOutputType | null
    _max: OrganizationMaxAggregateOutputType | null
  }

  type GetOrganizationGroupByPayload<T extends OrganizationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrganizationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrganizationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrganizationGroupByOutputType[P]>
            : GetScalarType<T[P], OrganizationGroupByOutputType[P]>
        }
      >
    >


  export type OrganizationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    kcId?: boolean
    organizationName?: boolean
    realmName?: boolean
    instanceUrl?: boolean
    principalGeography?: boolean
    loginUrl?: boolean
    logoutUrl?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    activeModules?: boolean
    clientID?: boolean
    clientSecret?: boolean
    fiscalYearQuarters?: boolean
    fiscalYearFormat?: boolean
    auditYear?: boolean
    logoUrl?: boolean
    deleted?: boolean
    business?: boolean | Organization$businessArgs<ExtArgs>
    Doctype?: boolean | Organization$DoctypeArgs<ExtArgs>
    Documents?: boolean | Organization$DocumentsArgs<ExtArgs>
    entity?: boolean | Organization$entityArgs<ExtArgs>
    entityType?: boolean | Organization$entityTypeArgs<ExtArgs>
    location?: boolean | Organization$locationArgs<ExtArgs>
    role?: boolean | Organization$roleArgs<ExtArgs>
    section?: boolean | Organization$sectionArgs<ExtArgs>
    systemType?: boolean | Organization$systemTypeArgs<ExtArgs>
    user?: boolean | Organization$userArgs<ExtArgs>
    userPersonalisation?: boolean | Organization$userPersonalisationArgs<ExtArgs>
    ConnectedApps?: boolean | Organization$ConnectedAppsArgs<ExtArgs>
    unitOfMeasurement?: boolean | Organization$unitOfMeasurementArgs<ExtArgs>
    kpi?: boolean | Organization$kpiArgs<ExtArgs>
    businessType?: boolean | Organization$businessTypeArgs<ExtArgs>
    prefixSuffix?: boolean | Organization$prefixSuffixArgs<ExtArgs>
    serialNumber?: boolean | Organization$serialNumberArgs<ExtArgs>
    function?: boolean | Organization$functionArgs<ExtArgs>
    rolesTable?: boolean | Organization$rolesTableArgs<ExtArgs>
    problem?: boolean | Organization$problemArgs<ExtArgs>
    parts?: boolean | Organization$partsArgs<ExtArgs>
    Models?: boolean | Organization$ModelsArgs<ExtArgs>
    _count?: boolean | OrganizationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["organization"]>


  export type OrganizationSelectScalar = {
    id?: boolean
    kcId?: boolean
    organizationName?: boolean
    realmName?: boolean
    instanceUrl?: boolean
    principalGeography?: boolean
    loginUrl?: boolean
    logoutUrl?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    activeModules?: boolean
    clientID?: boolean
    clientSecret?: boolean
    fiscalYearQuarters?: boolean
    fiscalYearFormat?: boolean
    auditYear?: boolean
    logoUrl?: boolean
    deleted?: boolean
  }

  export type OrganizationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    business?: boolean | Organization$businessArgs<ExtArgs>
    Doctype?: boolean | Organization$DoctypeArgs<ExtArgs>
    Documents?: boolean | Organization$DocumentsArgs<ExtArgs>
    entity?: boolean | Organization$entityArgs<ExtArgs>
    entityType?: boolean | Organization$entityTypeArgs<ExtArgs>
    location?: boolean | Organization$locationArgs<ExtArgs>
    role?: boolean | Organization$roleArgs<ExtArgs>
    section?: boolean | Organization$sectionArgs<ExtArgs>
    systemType?: boolean | Organization$systemTypeArgs<ExtArgs>
    user?: boolean | Organization$userArgs<ExtArgs>
    userPersonalisation?: boolean | Organization$userPersonalisationArgs<ExtArgs>
    ConnectedApps?: boolean | Organization$ConnectedAppsArgs<ExtArgs>
    unitOfMeasurement?: boolean | Organization$unitOfMeasurementArgs<ExtArgs>
    kpi?: boolean | Organization$kpiArgs<ExtArgs>
    businessType?: boolean | Organization$businessTypeArgs<ExtArgs>
    prefixSuffix?: boolean | Organization$prefixSuffixArgs<ExtArgs>
    serialNumber?: boolean | Organization$serialNumberArgs<ExtArgs>
    function?: boolean | Organization$functionArgs<ExtArgs>
    rolesTable?: boolean | Organization$rolesTableArgs<ExtArgs>
    problem?: boolean | Organization$problemArgs<ExtArgs>
    parts?: boolean | Organization$partsArgs<ExtArgs>
    Models?: boolean | Organization$ModelsArgs<ExtArgs>
    _count?: boolean | OrganizationCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $OrganizationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Organization"
    objects: {
      business: Prisma.$BusinessPayload<ExtArgs>[]
      Doctype: Prisma.$DoctypePayload<ExtArgs>[]
      Documents: Prisma.$DocumentsPayload<ExtArgs>[]
      entity: Prisma.$EntityPayload<ExtArgs>[]
      entityType: Prisma.$EntityTypePayload<ExtArgs>[]
      location: Prisma.$LocationPayload<ExtArgs>[]
      role: Prisma.$RolePayload<ExtArgs>[]
      section: Prisma.$SectionPayload<ExtArgs>[]
      systemType: Prisma.$SystemTypePayload<ExtArgs>[]
      user: Prisma.$UserPayload<ExtArgs>[]
      userPersonalisation: Prisma.$userPersonalisationPayload<ExtArgs>[]
      ConnectedApps: Prisma.$ConnectedAppsPayload<ExtArgs>[]
      unitOfMeasurement: Prisma.$unitTypePayload<ExtArgs>[]
      kpi: Prisma.$kpiPayload<ExtArgs>[]
      businessType: Prisma.$businessTypePayload<ExtArgs>[]
      prefixSuffix: Prisma.$prefixSuffixPayload<ExtArgs>[]
      serialNumber: Prisma.$serialNumberPayload<ExtArgs>[]
      function: Prisma.$FunctionsPayload<ExtArgs>[]
      rolesTable: Prisma.$rolesTablePayload<ExtArgs>[]
      problem: Prisma.$ProblemPayload<ExtArgs>[]
      parts: Prisma.$PartsPayload<ExtArgs>[]
      Models: Prisma.$ModelsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      kcId: string | null
      organizationName: string | null
      realmName: string | null
      instanceUrl: string | null
      principalGeography: string | null
      loginUrl: string | null
      logoutUrl: string | null
      createdAt: Date
      createdBy: string | null
      updatedAt: Date
      updatedBy: string | null
      activeModules: string[]
      clientID: string | null
      clientSecret: string | null
      fiscalYearQuarters: string | null
      fiscalYearFormat: string | null
      auditYear: string | null
      logoUrl: string | null
      deleted: boolean | null
    }, ExtArgs["result"]["organization"]>
    composites: {}
  }

  type OrganizationGetPayload<S extends boolean | null | undefined | OrganizationDefaultArgs> = $Result.GetResult<Prisma.$OrganizationPayload, S>

  type OrganizationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OrganizationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OrganizationCountAggregateInputType | true
    }

  export interface OrganizationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Organization'], meta: { name: 'Organization' } }
    /**
     * Find zero or one Organization that matches the filter.
     * @param {OrganizationFindUniqueArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrganizationFindUniqueArgs>(args: SelectSubset<T, OrganizationFindUniqueArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Organization that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OrganizationFindUniqueOrThrowArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrganizationFindUniqueOrThrowArgs>(args: SelectSubset<T, OrganizationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Organization that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindFirstArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrganizationFindFirstArgs>(args?: SelectSubset<T, OrganizationFindFirstArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Organization that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindFirstOrThrowArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrganizationFindFirstOrThrowArgs>(args?: SelectSubset<T, OrganizationFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Organizations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Organizations
     * const organizations = await prisma.organization.findMany()
     * 
     * // Get first 10 Organizations
     * const organizations = await prisma.organization.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const organizationWithIdOnly = await prisma.organization.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrganizationFindManyArgs>(args?: SelectSubset<T, OrganizationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Organization.
     * @param {OrganizationCreateArgs} args - Arguments to create a Organization.
     * @example
     * // Create one Organization
     * const Organization = await prisma.organization.create({
     *   data: {
     *     // ... data to create a Organization
     *   }
     * })
     * 
     */
    create<T extends OrganizationCreateArgs>(args: SelectSubset<T, OrganizationCreateArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Organizations.
     * @param {OrganizationCreateManyArgs} args - Arguments to create many Organizations.
     * @example
     * // Create many Organizations
     * const organization = await prisma.organization.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrganizationCreateManyArgs>(args?: SelectSubset<T, OrganizationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Organization.
     * @param {OrganizationDeleteArgs} args - Arguments to delete one Organization.
     * @example
     * // Delete one Organization
     * const Organization = await prisma.organization.delete({
     *   where: {
     *     // ... filter to delete one Organization
     *   }
     * })
     * 
     */
    delete<T extends OrganizationDeleteArgs>(args: SelectSubset<T, OrganizationDeleteArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Organization.
     * @param {OrganizationUpdateArgs} args - Arguments to update one Organization.
     * @example
     * // Update one Organization
     * const organization = await prisma.organization.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrganizationUpdateArgs>(args: SelectSubset<T, OrganizationUpdateArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Organizations.
     * @param {OrganizationDeleteManyArgs} args - Arguments to filter Organizations to delete.
     * @example
     * // Delete a few Organizations
     * const { count } = await prisma.organization.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrganizationDeleteManyArgs>(args?: SelectSubset<T, OrganizationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Organizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Organizations
     * const organization = await prisma.organization.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrganizationUpdateManyArgs>(args: SelectSubset<T, OrganizationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Organization.
     * @param {OrganizationUpsertArgs} args - Arguments to update or create a Organization.
     * @example
     * // Update or create a Organization
     * const organization = await prisma.organization.upsert({
     *   create: {
     *     // ... data to create a Organization
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Organization we want to update
     *   }
     * })
     */
    upsert<T extends OrganizationUpsertArgs>(args: SelectSubset<T, OrganizationUpsertArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Organizations that matches the filter.
     * @param {OrganizationFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const organization = await prisma.organization.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: OrganizationFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Organization.
     * @param {OrganizationAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const organization = await prisma.organization.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: OrganizationAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Organizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationCountArgs} args - Arguments to filter Organizations to count.
     * @example
     * // Count the number of Organizations
     * const count = await prisma.organization.count({
     *   where: {
     *     // ... the filter for the Organizations we want to count
     *   }
     * })
    **/
    count<T extends OrganizationCountArgs>(
      args?: Subset<T, OrganizationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrganizationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Organization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrganizationAggregateArgs>(args: Subset<T, OrganizationAggregateArgs>): Prisma.PrismaPromise<GetOrganizationAggregateType<T>>

    /**
     * Group by Organization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrganizationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrganizationGroupByArgs['orderBy'] }
        : { orderBy?: OrganizationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrganizationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrganizationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Organization model
   */
  readonly fields: OrganizationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Organization.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrganizationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    business<T extends Organization$businessArgs<ExtArgs> = {}>(args?: Subset<T, Organization$businessArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "findMany"> | Null>
    Doctype<T extends Organization$DoctypeArgs<ExtArgs> = {}>(args?: Subset<T, Organization$DoctypeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DoctypePayload<ExtArgs>, T, "findMany"> | Null>
    Documents<T extends Organization$DocumentsArgs<ExtArgs> = {}>(args?: Subset<T, Organization$DocumentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentsPayload<ExtArgs>, T, "findMany"> | Null>
    entity<T extends Organization$entityArgs<ExtArgs> = {}>(args?: Subset<T, Organization$entityArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EntityPayload<ExtArgs>, T, "findMany"> | Null>
    entityType<T extends Organization$entityTypeArgs<ExtArgs> = {}>(args?: Subset<T, Organization$entityTypeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EntityTypePayload<ExtArgs>, T, "findMany"> | Null>
    location<T extends Organization$locationArgs<ExtArgs> = {}>(args?: Subset<T, Organization$locationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findMany"> | Null>
    role<T extends Organization$roleArgs<ExtArgs> = {}>(args?: Subset<T, Organization$roleArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findMany"> | Null>
    section<T extends Organization$sectionArgs<ExtArgs> = {}>(args?: Subset<T, Organization$sectionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "findMany"> | Null>
    systemType<T extends Organization$systemTypeArgs<ExtArgs> = {}>(args?: Subset<T, Organization$systemTypeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemTypePayload<ExtArgs>, T, "findMany"> | Null>
    user<T extends Organization$userArgs<ExtArgs> = {}>(args?: Subset<T, Organization$userArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany"> | Null>
    userPersonalisation<T extends Organization$userPersonalisationArgs<ExtArgs> = {}>(args?: Subset<T, Organization$userPersonalisationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userPersonalisationPayload<ExtArgs>, T, "findMany"> | Null>
    ConnectedApps<T extends Organization$ConnectedAppsArgs<ExtArgs> = {}>(args?: Subset<T, Organization$ConnectedAppsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConnectedAppsPayload<ExtArgs>, T, "findMany"> | Null>
    unitOfMeasurement<T extends Organization$unitOfMeasurementArgs<ExtArgs> = {}>(args?: Subset<T, Organization$unitOfMeasurementArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$unitTypePayload<ExtArgs>, T, "findMany"> | Null>
    kpi<T extends Organization$kpiArgs<ExtArgs> = {}>(args?: Subset<T, Organization$kpiArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$kpiPayload<ExtArgs>, T, "findMany"> | Null>
    businessType<T extends Organization$businessTypeArgs<ExtArgs> = {}>(args?: Subset<T, Organization$businessTypeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$businessTypePayload<ExtArgs>, T, "findMany"> | Null>
    prefixSuffix<T extends Organization$prefixSuffixArgs<ExtArgs> = {}>(args?: Subset<T, Organization$prefixSuffixArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$prefixSuffixPayload<ExtArgs>, T, "findMany"> | Null>
    serialNumber<T extends Organization$serialNumberArgs<ExtArgs> = {}>(args?: Subset<T, Organization$serialNumberArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$serialNumberPayload<ExtArgs>, T, "findMany"> | Null>
    function<T extends Organization$functionArgs<ExtArgs> = {}>(args?: Subset<T, Organization$functionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FunctionsPayload<ExtArgs>, T, "findMany"> | Null>
    rolesTable<T extends Organization$rolesTableArgs<ExtArgs> = {}>(args?: Subset<T, Organization$rolesTableArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rolesTablePayload<ExtArgs>, T, "findMany"> | Null>
    problem<T extends Organization$problemArgs<ExtArgs> = {}>(args?: Subset<T, Organization$problemArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProblemPayload<ExtArgs>, T, "findMany"> | Null>
    parts<T extends Organization$partsArgs<ExtArgs> = {}>(args?: Subset<T, Organization$partsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PartsPayload<ExtArgs>, T, "findMany"> | Null>
    Models<T extends Organization$ModelsArgs<ExtArgs> = {}>(args?: Subset<T, Organization$ModelsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModelsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Organization model
   */ 
  interface OrganizationFieldRefs {
    readonly id: FieldRef<"Organization", 'String'>
    readonly kcId: FieldRef<"Organization", 'String'>
    readonly organizationName: FieldRef<"Organization", 'String'>
    readonly realmName: FieldRef<"Organization", 'String'>
    readonly instanceUrl: FieldRef<"Organization", 'String'>
    readonly principalGeography: FieldRef<"Organization", 'String'>
    readonly loginUrl: FieldRef<"Organization", 'String'>
    readonly logoutUrl: FieldRef<"Organization", 'String'>
    readonly createdAt: FieldRef<"Organization", 'DateTime'>
    readonly createdBy: FieldRef<"Organization", 'String'>
    readonly updatedAt: FieldRef<"Organization", 'DateTime'>
    readonly updatedBy: FieldRef<"Organization", 'String'>
    readonly activeModules: FieldRef<"Organization", 'String[]'>
    readonly clientID: FieldRef<"Organization", 'String'>
    readonly clientSecret: FieldRef<"Organization", 'String'>
    readonly fiscalYearQuarters: FieldRef<"Organization", 'String'>
    readonly fiscalYearFormat: FieldRef<"Organization", 'String'>
    readonly auditYear: FieldRef<"Organization", 'String'>
    readonly logoUrl: FieldRef<"Organization", 'String'>
    readonly deleted: FieldRef<"Organization", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Organization findUnique
   */
  export type OrganizationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization findUniqueOrThrow
   */
  export type OrganizationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization findFirst
   */
  export type OrganizationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Organizations.
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Organizations.
     */
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }

  /**
   * Organization findFirstOrThrow
   */
  export type OrganizationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Organizations.
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Organizations.
     */
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }

  /**
   * Organization findMany
   */
  export type OrganizationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organizations to fetch.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Organizations.
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }

  /**
   * Organization create
   */
  export type OrganizationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * The data needed to create a Organization.
     */
    data: XOR<OrganizationCreateInput, OrganizationUncheckedCreateInput>
  }

  /**
   * Organization createMany
   */
  export type OrganizationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Organizations.
     */
    data: OrganizationCreateManyInput | OrganizationCreateManyInput[]
  }

  /**
   * Organization update
   */
  export type OrganizationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * The data needed to update a Organization.
     */
    data: XOR<OrganizationUpdateInput, OrganizationUncheckedUpdateInput>
    /**
     * Choose, which Organization to update.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization updateMany
   */
  export type OrganizationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Organizations.
     */
    data: XOR<OrganizationUpdateManyMutationInput, OrganizationUncheckedUpdateManyInput>
    /**
     * Filter which Organizations to update
     */
    where?: OrganizationWhereInput
  }

  /**
   * Organization upsert
   */
  export type OrganizationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * The filter to search for the Organization to update in case it exists.
     */
    where: OrganizationWhereUniqueInput
    /**
     * In case the Organization found by the `where` argument doesn't exist, create a new Organization with this data.
     */
    create: XOR<OrganizationCreateInput, OrganizationUncheckedCreateInput>
    /**
     * In case the Organization was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrganizationUpdateInput, OrganizationUncheckedUpdateInput>
  }

  /**
   * Organization delete
   */
  export type OrganizationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter which Organization to delete.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization deleteMany
   */
  export type OrganizationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Organizations to delete
     */
    where?: OrganizationWhereInput
  }

  /**
   * Organization findRaw
   */
  export type OrganizationFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Organization aggregateRaw
   */
  export type OrganizationAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Organization.business
   */
  export type Organization$businessArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessInclude<ExtArgs> | null
    where?: BusinessWhereInput
    orderBy?: BusinessOrderByWithRelationInput | BusinessOrderByWithRelationInput[]
    cursor?: BusinessWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BusinessScalarFieldEnum | BusinessScalarFieldEnum[]
  }

  /**
   * Organization.Doctype
   */
  export type Organization$DoctypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctype
     */
    select?: DoctypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctypeInclude<ExtArgs> | null
    where?: DoctypeWhereInput
    orderBy?: DoctypeOrderByWithRelationInput | DoctypeOrderByWithRelationInput[]
    cursor?: DoctypeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DoctypeScalarFieldEnum | DoctypeScalarFieldEnum[]
  }

  /**
   * Organization.Documents
   */
  export type Organization$DocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Documents
     */
    select?: DocumentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentsInclude<ExtArgs> | null
    where?: DocumentsWhereInput
    orderBy?: DocumentsOrderByWithRelationInput | DocumentsOrderByWithRelationInput[]
    cursor?: DocumentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentsScalarFieldEnum | DocumentsScalarFieldEnum[]
  }

  /**
   * Organization.entity
   */
  export type Organization$entityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entity
     */
    select?: EntitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntityInclude<ExtArgs> | null
    where?: EntityWhereInput
    orderBy?: EntityOrderByWithRelationInput | EntityOrderByWithRelationInput[]
    cursor?: EntityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EntityScalarFieldEnum | EntityScalarFieldEnum[]
  }

  /**
   * Organization.entityType
   */
  export type Organization$entityTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntityType
     */
    select?: EntityTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntityTypeInclude<ExtArgs> | null
    where?: EntityTypeWhereInput
    orderBy?: EntityTypeOrderByWithRelationInput | EntityTypeOrderByWithRelationInput[]
    cursor?: EntityTypeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EntityTypeScalarFieldEnum | EntityTypeScalarFieldEnum[]
  }

  /**
   * Organization.location
   */
  export type Organization$locationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    where?: LocationWhereInput
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    cursor?: LocationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Organization.role
   */
  export type Organization$roleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    where?: RoleWhereInput
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    cursor?: RoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Organization.section
   */
  export type Organization$sectionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
    where?: SectionWhereInput
    orderBy?: SectionOrderByWithRelationInput | SectionOrderByWithRelationInput[]
    cursor?: SectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SectionScalarFieldEnum | SectionScalarFieldEnum[]
  }

  /**
   * Organization.systemType
   */
  export type Organization$systemTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemType
     */
    select?: SystemTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemTypeInclude<ExtArgs> | null
    where?: SystemTypeWhereInput
    orderBy?: SystemTypeOrderByWithRelationInput | SystemTypeOrderByWithRelationInput[]
    cursor?: SystemTypeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SystemTypeScalarFieldEnum | SystemTypeScalarFieldEnum[]
  }

  /**
   * Organization.user
   */
  export type Organization$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Organization.userPersonalisation
   */
  export type Organization$userPersonalisationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userPersonalisation
     */
    select?: userPersonalisationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userPersonalisationInclude<ExtArgs> | null
    where?: userPersonalisationWhereInput
    orderBy?: userPersonalisationOrderByWithRelationInput | userPersonalisationOrderByWithRelationInput[]
    cursor?: userPersonalisationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserPersonalisationScalarFieldEnum | UserPersonalisationScalarFieldEnum[]
  }

  /**
   * Organization.ConnectedApps
   */
  export type Organization$ConnectedAppsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConnectedApps
     */
    select?: ConnectedAppsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectedAppsInclude<ExtArgs> | null
    where?: ConnectedAppsWhereInput
    orderBy?: ConnectedAppsOrderByWithRelationInput | ConnectedAppsOrderByWithRelationInput[]
    cursor?: ConnectedAppsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConnectedAppsScalarFieldEnum | ConnectedAppsScalarFieldEnum[]
  }

  /**
   * Organization.unitOfMeasurement
   */
  export type Organization$unitOfMeasurementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the unitType
     */
    select?: unitTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: unitTypeInclude<ExtArgs> | null
    where?: unitTypeWhereInput
    orderBy?: unitTypeOrderByWithRelationInput | unitTypeOrderByWithRelationInput[]
    cursor?: unitTypeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UnitTypeScalarFieldEnum | UnitTypeScalarFieldEnum[]
  }

  /**
   * Organization.kpi
   */
  export type Organization$kpiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kpi
     */
    select?: kpiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kpiInclude<ExtArgs> | null
    where?: kpiWhereInput
    orderBy?: kpiOrderByWithRelationInput | kpiOrderByWithRelationInput[]
    cursor?: kpiWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KpiScalarFieldEnum | KpiScalarFieldEnum[]
  }

  /**
   * Organization.businessType
   */
  export type Organization$businessTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the businessType
     */
    select?: businessTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: businessTypeInclude<ExtArgs> | null
    where?: businessTypeWhereInput
    orderBy?: businessTypeOrderByWithRelationInput | businessTypeOrderByWithRelationInput[]
    cursor?: businessTypeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BusinessTypeScalarFieldEnum | BusinessTypeScalarFieldEnum[]
  }

  /**
   * Organization.prefixSuffix
   */
  export type Organization$prefixSuffixArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prefixSuffix
     */
    select?: prefixSuffixSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: prefixSuffixInclude<ExtArgs> | null
    where?: prefixSuffixWhereInput
    orderBy?: prefixSuffixOrderByWithRelationInput | prefixSuffixOrderByWithRelationInput[]
    cursor?: prefixSuffixWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PrefixSuffixScalarFieldEnum | PrefixSuffixScalarFieldEnum[]
  }

  /**
   * Organization.serialNumber
   */
  export type Organization$serialNumberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serialNumber
     */
    select?: serialNumberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serialNumberInclude<ExtArgs> | null
    where?: serialNumberWhereInput
    orderBy?: serialNumberOrderByWithRelationInput | serialNumberOrderByWithRelationInput[]
    cursor?: serialNumberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SerialNumberScalarFieldEnum | SerialNumberScalarFieldEnum[]
  }

  /**
   * Organization.function
   */
  export type Organization$functionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Functions
     */
    select?: FunctionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FunctionsInclude<ExtArgs> | null
    where?: FunctionsWhereInput
    orderBy?: FunctionsOrderByWithRelationInput | FunctionsOrderByWithRelationInput[]
    cursor?: FunctionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FunctionsScalarFieldEnum | FunctionsScalarFieldEnum[]
  }

  /**
   * Organization.rolesTable
   */
  export type Organization$rolesTableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rolesTable
     */
    select?: rolesTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesTableInclude<ExtArgs> | null
    where?: rolesTableWhereInput
    orderBy?: rolesTableOrderByWithRelationInput | rolesTableOrderByWithRelationInput[]
    cursor?: rolesTableWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RolesTableScalarFieldEnum | RolesTableScalarFieldEnum[]
  }

  /**
   * Organization.problem
   */
  export type Organization$problemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Problem
     */
    select?: ProblemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProblemInclude<ExtArgs> | null
    where?: ProblemWhereInput
    orderBy?: ProblemOrderByWithRelationInput | ProblemOrderByWithRelationInput[]
    cursor?: ProblemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProblemScalarFieldEnum | ProblemScalarFieldEnum[]
  }

  /**
   * Organization.parts
   */
  export type Organization$partsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parts
     */
    select?: PartsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartsInclude<ExtArgs> | null
    where?: PartsWhereInput
    orderBy?: PartsOrderByWithRelationInput | PartsOrderByWithRelationInput[]
    cursor?: PartsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PartsScalarFieldEnum | PartsScalarFieldEnum[]
  }

  /**
   * Organization.Models
   */
  export type Organization$ModelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Models
     */
    select?: ModelsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelsInclude<ExtArgs> | null
    where?: ModelsWhereInput
    orderBy?: ModelsOrderByWithRelationInput | ModelsOrderByWithRelationInput[]
    cursor?: ModelsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ModelsScalarFieldEnum | ModelsScalarFieldEnum[]
  }

  /**
   * Organization without action
   */
  export type OrganizationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
  }


  /**
   * Model Role
   */

  export type AggregateRole = {
    _count: RoleCountAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  export type RoleMinAggregateOutputType = {
    id: string | null
    kcId: string | null
    roleName: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
    deleted: boolean | null
    organizationId: string | null
    locationId: string | null
  }

  export type RoleMaxAggregateOutputType = {
    id: string | null
    kcId: string | null
    roleName: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
    deleted: boolean | null
    organizationId: string | null
    locationId: string | null
  }

  export type RoleCountAggregateOutputType = {
    id: number
    kcId: number
    roleName: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    deleted: number
    organizationId: number
    locationId: number
    _all: number
  }


  export type RoleMinAggregateInputType = {
    id?: true
    kcId?: true
    roleName?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    deleted?: true
    organizationId?: true
    locationId?: true
  }

  export type RoleMaxAggregateInputType = {
    id?: true
    kcId?: true
    roleName?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    deleted?: true
    organizationId?: true
    locationId?: true
  }

  export type RoleCountAggregateInputType = {
    id?: true
    kcId?: true
    roleName?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    deleted?: true
    organizationId?: true
    locationId?: true
    _all?: true
  }

  export type RoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Role to aggregate.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Roles
    **/
    _count?: true | RoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleMaxAggregateInputType
  }

  export type GetRoleAggregateType<T extends RoleAggregateArgs> = {
        [P in keyof T & keyof AggregateRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRole[P]>
      : GetScalarType<T[P], AggregateRole[P]>
  }




  export type RoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleWhereInput
    orderBy?: RoleOrderByWithAggregationInput | RoleOrderByWithAggregationInput[]
    by: RoleScalarFieldEnum[] | RoleScalarFieldEnum
    having?: RoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleCountAggregateInputType | true
    _min?: RoleMinAggregateInputType
    _max?: RoleMaxAggregateInputType
  }

  export type RoleGroupByOutputType = {
    id: string
    kcId: string | null
    roleName: string | null
    createdAt: Date
    createdBy: string | null
    updatedAt: Date
    updatedBy: string | null
    deleted: boolean | null
    organizationId: string | null
    locationId: string | null
    _count: RoleCountAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  type GetRoleGroupByPayload<T extends RoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleGroupByOutputType[P]>
            : GetScalarType<T[P], RoleGroupByOutputType[P]>
        }
      >
    >


  export type RoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    kcId?: boolean
    roleName?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    deleted?: boolean
    organizationId?: boolean
    locationId?: boolean
    organization?: boolean | Role$organizationArgs<ExtArgs>
    Location?: boolean | Role$LocationArgs<ExtArgs>
  }, ExtArgs["result"]["role"]>


  export type RoleSelectScalar = {
    id?: boolean
    kcId?: boolean
    roleName?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    deleted?: boolean
    organizationId?: boolean
    locationId?: boolean
  }

  export type RoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | Role$organizationArgs<ExtArgs>
    Location?: boolean | Role$LocationArgs<ExtArgs>
  }

  export type $RolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Role"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs> | null
      Location: Prisma.$LocationPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      kcId: string | null
      roleName: string | null
      createdAt: Date
      createdBy: string | null
      updatedAt: Date
      updatedBy: string | null
      deleted: boolean | null
      organizationId: string | null
      locationId: string | null
    }, ExtArgs["result"]["role"]>
    composites: {}
  }

  type RoleGetPayload<S extends boolean | null | undefined | RoleDefaultArgs> = $Result.GetResult<Prisma.$RolePayload, S>

  type RoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RoleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RoleCountAggregateInputType | true
    }

  export interface RoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Role'], meta: { name: 'Role' } }
    /**
     * Find zero or one Role that matches the filter.
     * @param {RoleFindUniqueArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoleFindUniqueArgs>(args: SelectSubset<T, RoleFindUniqueArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Role that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RoleFindUniqueOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoleFindUniqueOrThrowArgs>(args: SelectSubset<T, RoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Role that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoleFindFirstArgs>(args?: SelectSubset<T, RoleFindFirstArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Role that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoleFindFirstOrThrowArgs>(args?: SelectSubset<T, RoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.role.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.role.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roleWithIdOnly = await prisma.role.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoleFindManyArgs>(args?: SelectSubset<T, RoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Role.
     * @param {RoleCreateArgs} args - Arguments to create a Role.
     * @example
     * // Create one Role
     * const Role = await prisma.role.create({
     *   data: {
     *     // ... data to create a Role
     *   }
     * })
     * 
     */
    create<T extends RoleCreateArgs>(args: SelectSubset<T, RoleCreateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Roles.
     * @param {RoleCreateManyArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoleCreateManyArgs>(args?: SelectSubset<T, RoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Role.
     * @param {RoleDeleteArgs} args - Arguments to delete one Role.
     * @example
     * // Delete one Role
     * const Role = await prisma.role.delete({
     *   where: {
     *     // ... filter to delete one Role
     *   }
     * })
     * 
     */
    delete<T extends RoleDeleteArgs>(args: SelectSubset<T, RoleDeleteArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Role.
     * @param {RoleUpdateArgs} args - Arguments to update one Role.
     * @example
     * // Update one Role
     * const role = await prisma.role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoleUpdateArgs>(args: SelectSubset<T, RoleUpdateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Roles.
     * @param {RoleDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoleDeleteManyArgs>(args?: SelectSubset<T, RoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoleUpdateManyArgs>(args: SelectSubset<T, RoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Role.
     * @param {RoleUpsertArgs} args - Arguments to update or create a Role.
     * @example
     * // Update or create a Role
     * const role = await prisma.role.upsert({
     *   create: {
     *     // ... data to create a Role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Role we want to update
     *   }
     * })
     */
    upsert<T extends RoleUpsertArgs>(args: SelectSubset<T, RoleUpsertArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Roles that matches the filter.
     * @param {RoleFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const role = await prisma.role.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: RoleFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Role.
     * @param {RoleAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const role = await prisma.role.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: RoleAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.role.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends RoleCountArgs>(
      args?: Subset<T, RoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleAggregateArgs>(args: Subset<T, RoleAggregateArgs>): Prisma.PrismaPromise<GetRoleAggregateType<T>>

    /**
     * Group by Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoleGroupByArgs['orderBy'] }
        : { orderBy?: RoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Role model
   */
  readonly fields: RoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organization<T extends Role$organizationArgs<ExtArgs> = {}>(args?: Subset<T, Role$organizationArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    Location<T extends Role$LocationArgs<ExtArgs> = {}>(args?: Subset<T, Role$LocationArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Role model
   */ 
  interface RoleFieldRefs {
    readonly id: FieldRef<"Role", 'String'>
    readonly kcId: FieldRef<"Role", 'String'>
    readonly roleName: FieldRef<"Role", 'String'>
    readonly createdAt: FieldRef<"Role", 'DateTime'>
    readonly createdBy: FieldRef<"Role", 'String'>
    readonly updatedAt: FieldRef<"Role", 'DateTime'>
    readonly updatedBy: FieldRef<"Role", 'String'>
    readonly deleted: FieldRef<"Role", 'Boolean'>
    readonly organizationId: FieldRef<"Role", 'String'>
    readonly locationId: FieldRef<"Role", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Role findUnique
   */
  export type RoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findUniqueOrThrow
   */
  export type RoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findFirst
   */
  export type RoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findFirstOrThrow
   */
  export type RoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findMany
   */
  export type RoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role create
   */
  export type RoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to create a Role.
     */
    data: XOR<RoleCreateInput, RoleUncheckedCreateInput>
  }

  /**
   * Role createMany
   */
  export type RoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
  }

  /**
   * Role update
   */
  export type RoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to update a Role.
     */
    data: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
    /**
     * Choose, which Role to update.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role updateMany
   */
  export type RoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
  }

  /**
   * Role upsert
   */
  export type RoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The filter to search for the Role to update in case it exists.
     */
    where: RoleWhereUniqueInput
    /**
     * In case the Role found by the `where` argument doesn't exist, create a new Role with this data.
     */
    create: XOR<RoleCreateInput, RoleUncheckedCreateInput>
    /**
     * In case the Role was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
  }

  /**
   * Role delete
   */
  export type RoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter which Role to delete.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role deleteMany
   */
  export type RoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Roles to delete
     */
    where?: RoleWhereInput
  }

  /**
   * Role findRaw
   */
  export type RoleFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Role aggregateRaw
   */
  export type RoleAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Role.organization
   */
  export type Role$organizationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    where?: OrganizationWhereInput
  }

  /**
   * Role.Location
   */
  export type Role$LocationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    where?: LocationWhereInput
  }

  /**
   * Role without action
   */
  export type RoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
  }


  /**
   * Model SystemType
   */

  export type AggregateSystemType = {
    _count: SystemTypeCountAggregateOutputType | null
    _min: SystemTypeMinAggregateOutputType | null
    _max: SystemTypeMaxAggregateOutputType | null
  }

  export type SystemTypeMinAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    color: string | null
    updatedBy: string | null
    deleted: boolean | null
    organizationId: string | null
  }

  export type SystemTypeMaxAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    color: string | null
    updatedBy: string | null
    deleted: boolean | null
    organizationId: string | null
  }

  export type SystemTypeCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    createdBy: number
    updatedAt: number
    color: number
    updatedBy: number
    deleted: number
    organizationId: number
    _all: number
  }


  export type SystemTypeMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    color?: true
    updatedBy?: true
    deleted?: true
    organizationId?: true
  }

  export type SystemTypeMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    color?: true
    updatedBy?: true
    deleted?: true
    organizationId?: true
  }

  export type SystemTypeCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    color?: true
    updatedBy?: true
    deleted?: true
    organizationId?: true
    _all?: true
  }

  export type SystemTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemType to aggregate.
     */
    where?: SystemTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemTypes to fetch.
     */
    orderBy?: SystemTypeOrderByWithRelationInput | SystemTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SystemTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SystemTypes
    **/
    _count?: true | SystemTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SystemTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SystemTypeMaxAggregateInputType
  }

  export type GetSystemTypeAggregateType<T extends SystemTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateSystemType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSystemType[P]>
      : GetScalarType<T[P], AggregateSystemType[P]>
  }




  export type SystemTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SystemTypeWhereInput
    orderBy?: SystemTypeOrderByWithAggregationInput | SystemTypeOrderByWithAggregationInput[]
    by: SystemTypeScalarFieldEnum[] | SystemTypeScalarFieldEnum
    having?: SystemTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SystemTypeCountAggregateInputType | true
    _min?: SystemTypeMinAggregateInputType
    _max?: SystemTypeMaxAggregateInputType
  }

  export type SystemTypeGroupByOutputType = {
    id: string
    name: string | null
    createdAt: Date
    createdBy: string | null
    updatedAt: Date
    color: string | null
    updatedBy: string | null
    deleted: boolean | null
    organizationId: string | null
    _count: SystemTypeCountAggregateOutputType | null
    _min: SystemTypeMinAggregateOutputType | null
    _max: SystemTypeMaxAggregateOutputType | null
  }

  type GetSystemTypeGroupByPayload<T extends SystemTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SystemTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SystemTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SystemTypeGroupByOutputType[P]>
            : GetScalarType<T[P], SystemTypeGroupByOutputType[P]>
        }
      >
    >


  export type SystemTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    color?: boolean
    updatedBy?: boolean
    deleted?: boolean
    organizationId?: boolean
    organization?: boolean | SystemType$organizationArgs<ExtArgs>
  }, ExtArgs["result"]["systemType"]>


  export type SystemTypeSelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    color?: boolean
    updatedBy?: boolean
    deleted?: boolean
    organizationId?: boolean
  }

  export type SystemTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | SystemType$organizationArgs<ExtArgs>
  }

  export type $SystemTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SystemType"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string | null
      createdAt: Date
      createdBy: string | null
      updatedAt: Date
      color: string | null
      updatedBy: string | null
      deleted: boolean | null
      organizationId: string | null
    }, ExtArgs["result"]["systemType"]>
    composites: {}
  }

  type SystemTypeGetPayload<S extends boolean | null | undefined | SystemTypeDefaultArgs> = $Result.GetResult<Prisma.$SystemTypePayload, S>

  type SystemTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SystemTypeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SystemTypeCountAggregateInputType | true
    }

  export interface SystemTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SystemType'], meta: { name: 'SystemType' } }
    /**
     * Find zero or one SystemType that matches the filter.
     * @param {SystemTypeFindUniqueArgs} args - Arguments to find a SystemType
     * @example
     * // Get one SystemType
     * const systemType = await prisma.systemType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SystemTypeFindUniqueArgs>(args: SelectSubset<T, SystemTypeFindUniqueArgs<ExtArgs>>): Prisma__SystemTypeClient<$Result.GetResult<Prisma.$SystemTypePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SystemType that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SystemTypeFindUniqueOrThrowArgs} args - Arguments to find a SystemType
     * @example
     * // Get one SystemType
     * const systemType = await prisma.systemType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SystemTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, SystemTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SystemTypeClient<$Result.GetResult<Prisma.$SystemTypePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SystemType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemTypeFindFirstArgs} args - Arguments to find a SystemType
     * @example
     * // Get one SystemType
     * const systemType = await prisma.systemType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SystemTypeFindFirstArgs>(args?: SelectSubset<T, SystemTypeFindFirstArgs<ExtArgs>>): Prisma__SystemTypeClient<$Result.GetResult<Prisma.$SystemTypePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SystemType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemTypeFindFirstOrThrowArgs} args - Arguments to find a SystemType
     * @example
     * // Get one SystemType
     * const systemType = await prisma.systemType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SystemTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, SystemTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__SystemTypeClient<$Result.GetResult<Prisma.$SystemTypePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SystemTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SystemTypes
     * const systemTypes = await prisma.systemType.findMany()
     * 
     * // Get first 10 SystemTypes
     * const systemTypes = await prisma.systemType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const systemTypeWithIdOnly = await prisma.systemType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SystemTypeFindManyArgs>(args?: SelectSubset<T, SystemTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemTypePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SystemType.
     * @param {SystemTypeCreateArgs} args - Arguments to create a SystemType.
     * @example
     * // Create one SystemType
     * const SystemType = await prisma.systemType.create({
     *   data: {
     *     // ... data to create a SystemType
     *   }
     * })
     * 
     */
    create<T extends SystemTypeCreateArgs>(args: SelectSubset<T, SystemTypeCreateArgs<ExtArgs>>): Prisma__SystemTypeClient<$Result.GetResult<Prisma.$SystemTypePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SystemTypes.
     * @param {SystemTypeCreateManyArgs} args - Arguments to create many SystemTypes.
     * @example
     * // Create many SystemTypes
     * const systemType = await prisma.systemType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SystemTypeCreateManyArgs>(args?: SelectSubset<T, SystemTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SystemType.
     * @param {SystemTypeDeleteArgs} args - Arguments to delete one SystemType.
     * @example
     * // Delete one SystemType
     * const SystemType = await prisma.systemType.delete({
     *   where: {
     *     // ... filter to delete one SystemType
     *   }
     * })
     * 
     */
    delete<T extends SystemTypeDeleteArgs>(args: SelectSubset<T, SystemTypeDeleteArgs<ExtArgs>>): Prisma__SystemTypeClient<$Result.GetResult<Prisma.$SystemTypePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SystemType.
     * @param {SystemTypeUpdateArgs} args - Arguments to update one SystemType.
     * @example
     * // Update one SystemType
     * const systemType = await prisma.systemType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SystemTypeUpdateArgs>(args: SelectSubset<T, SystemTypeUpdateArgs<ExtArgs>>): Prisma__SystemTypeClient<$Result.GetResult<Prisma.$SystemTypePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SystemTypes.
     * @param {SystemTypeDeleteManyArgs} args - Arguments to filter SystemTypes to delete.
     * @example
     * // Delete a few SystemTypes
     * const { count } = await prisma.systemType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SystemTypeDeleteManyArgs>(args?: SelectSubset<T, SystemTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SystemTypes
     * const systemType = await prisma.systemType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SystemTypeUpdateManyArgs>(args: SelectSubset<T, SystemTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SystemType.
     * @param {SystemTypeUpsertArgs} args - Arguments to update or create a SystemType.
     * @example
     * // Update or create a SystemType
     * const systemType = await prisma.systemType.upsert({
     *   create: {
     *     // ... data to create a SystemType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SystemType we want to update
     *   }
     * })
     */
    upsert<T extends SystemTypeUpsertArgs>(args: SelectSubset<T, SystemTypeUpsertArgs<ExtArgs>>): Prisma__SystemTypeClient<$Result.GetResult<Prisma.$SystemTypePayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more SystemTypes that matches the filter.
     * @param {SystemTypeFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const systemType = await prisma.systemType.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: SystemTypeFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a SystemType.
     * @param {SystemTypeAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const systemType = await prisma.systemType.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: SystemTypeAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of SystemTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemTypeCountArgs} args - Arguments to filter SystemTypes to count.
     * @example
     * // Count the number of SystemTypes
     * const count = await prisma.systemType.count({
     *   where: {
     *     // ... the filter for the SystemTypes we want to count
     *   }
     * })
    **/
    count<T extends SystemTypeCountArgs>(
      args?: Subset<T, SystemTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SystemTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SystemType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SystemTypeAggregateArgs>(args: Subset<T, SystemTypeAggregateArgs>): Prisma.PrismaPromise<GetSystemTypeAggregateType<T>>

    /**
     * Group by SystemType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SystemTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SystemTypeGroupByArgs['orderBy'] }
        : { orderBy?: SystemTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SystemTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSystemTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SystemType model
   */
  readonly fields: SystemTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SystemType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SystemTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organization<T extends SystemType$organizationArgs<ExtArgs> = {}>(args?: Subset<T, SystemType$organizationArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SystemType model
   */ 
  interface SystemTypeFieldRefs {
    readonly id: FieldRef<"SystemType", 'String'>
    readonly name: FieldRef<"SystemType", 'String'>
    readonly createdAt: FieldRef<"SystemType", 'DateTime'>
    readonly createdBy: FieldRef<"SystemType", 'String'>
    readonly updatedAt: FieldRef<"SystemType", 'DateTime'>
    readonly color: FieldRef<"SystemType", 'String'>
    readonly updatedBy: FieldRef<"SystemType", 'String'>
    readonly deleted: FieldRef<"SystemType", 'Boolean'>
    readonly organizationId: FieldRef<"SystemType", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SystemType findUnique
   */
  export type SystemTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemType
     */
    select?: SystemTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemTypeInclude<ExtArgs> | null
    /**
     * Filter, which SystemType to fetch.
     */
    where: SystemTypeWhereUniqueInput
  }

  /**
   * SystemType findUniqueOrThrow
   */
  export type SystemTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemType
     */
    select?: SystemTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemTypeInclude<ExtArgs> | null
    /**
     * Filter, which SystemType to fetch.
     */
    where: SystemTypeWhereUniqueInput
  }

  /**
   * SystemType findFirst
   */
  export type SystemTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemType
     */
    select?: SystemTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemTypeInclude<ExtArgs> | null
    /**
     * Filter, which SystemType to fetch.
     */
    where?: SystemTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemTypes to fetch.
     */
    orderBy?: SystemTypeOrderByWithRelationInput | SystemTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemTypes.
     */
    cursor?: SystemTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemTypes.
     */
    distinct?: SystemTypeScalarFieldEnum | SystemTypeScalarFieldEnum[]
  }

  /**
   * SystemType findFirstOrThrow
   */
  export type SystemTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemType
     */
    select?: SystemTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemTypeInclude<ExtArgs> | null
    /**
     * Filter, which SystemType to fetch.
     */
    where?: SystemTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemTypes to fetch.
     */
    orderBy?: SystemTypeOrderByWithRelationInput | SystemTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemTypes.
     */
    cursor?: SystemTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemTypes.
     */
    distinct?: SystemTypeScalarFieldEnum | SystemTypeScalarFieldEnum[]
  }

  /**
   * SystemType findMany
   */
  export type SystemTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemType
     */
    select?: SystemTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemTypeInclude<ExtArgs> | null
    /**
     * Filter, which SystemTypes to fetch.
     */
    where?: SystemTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemTypes to fetch.
     */
    orderBy?: SystemTypeOrderByWithRelationInput | SystemTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SystemTypes.
     */
    cursor?: SystemTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemTypes.
     */
    skip?: number
    distinct?: SystemTypeScalarFieldEnum | SystemTypeScalarFieldEnum[]
  }

  /**
   * SystemType create
   */
  export type SystemTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemType
     */
    select?: SystemTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a SystemType.
     */
    data: XOR<SystemTypeCreateInput, SystemTypeUncheckedCreateInput>
  }

  /**
   * SystemType createMany
   */
  export type SystemTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SystemTypes.
     */
    data: SystemTypeCreateManyInput | SystemTypeCreateManyInput[]
  }

  /**
   * SystemType update
   */
  export type SystemTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemType
     */
    select?: SystemTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a SystemType.
     */
    data: XOR<SystemTypeUpdateInput, SystemTypeUncheckedUpdateInput>
    /**
     * Choose, which SystemType to update.
     */
    where: SystemTypeWhereUniqueInput
  }

  /**
   * SystemType updateMany
   */
  export type SystemTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SystemTypes.
     */
    data: XOR<SystemTypeUpdateManyMutationInput, SystemTypeUncheckedUpdateManyInput>
    /**
     * Filter which SystemTypes to update
     */
    where?: SystemTypeWhereInput
  }

  /**
   * SystemType upsert
   */
  export type SystemTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemType
     */
    select?: SystemTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the SystemType to update in case it exists.
     */
    where: SystemTypeWhereUniqueInput
    /**
     * In case the SystemType found by the `where` argument doesn't exist, create a new SystemType with this data.
     */
    create: XOR<SystemTypeCreateInput, SystemTypeUncheckedCreateInput>
    /**
     * In case the SystemType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SystemTypeUpdateInput, SystemTypeUncheckedUpdateInput>
  }

  /**
   * SystemType delete
   */
  export type SystemTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemType
     */
    select?: SystemTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemTypeInclude<ExtArgs> | null
    /**
     * Filter which SystemType to delete.
     */
    where: SystemTypeWhereUniqueInput
  }

  /**
   * SystemType deleteMany
   */
  export type SystemTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemTypes to delete
     */
    where?: SystemTypeWhereInput
  }

  /**
   * SystemType findRaw
   */
  export type SystemTypeFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * SystemType aggregateRaw
   */
  export type SystemTypeAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * SystemType.organization
   */
  export type SystemType$organizationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    where?: OrganizationWhereInput
  }

  /**
   * SystemType without action
   */
  export type SystemTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemType
     */
    select?: SystemTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemTypeInclude<ExtArgs> | null
  }


  /**
   * Model EntityType
   */

  export type AggregateEntityType = {
    _count: EntityTypeCountAggregateOutputType | null
    _min: EntityTypeMinAggregateOutputType | null
    _max: EntityTypeMaxAggregateOutputType | null
  }

  export type EntityTypeMinAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
    organizationId: string | null
    deleted: boolean | null
  }

  export type EntityTypeMaxAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
    organizationId: string | null
    deleted: boolean | null
  }

  export type EntityTypeCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    organizationId: number
    deleted: number
    _all: number
  }


  export type EntityTypeMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    organizationId?: true
    deleted?: true
  }

  export type EntityTypeMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    organizationId?: true
    deleted?: true
  }

  export type EntityTypeCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    organizationId?: true
    deleted?: true
    _all?: true
  }

  export type EntityTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EntityType to aggregate.
     */
    where?: EntityTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EntityTypes to fetch.
     */
    orderBy?: EntityTypeOrderByWithRelationInput | EntityTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EntityTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EntityTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EntityTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EntityTypes
    **/
    _count?: true | EntityTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EntityTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EntityTypeMaxAggregateInputType
  }

  export type GetEntityTypeAggregateType<T extends EntityTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateEntityType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEntityType[P]>
      : GetScalarType<T[P], AggregateEntityType[P]>
  }




  export type EntityTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EntityTypeWhereInput
    orderBy?: EntityTypeOrderByWithAggregationInput | EntityTypeOrderByWithAggregationInput[]
    by: EntityTypeScalarFieldEnum[] | EntityTypeScalarFieldEnum
    having?: EntityTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EntityTypeCountAggregateInputType | true
    _min?: EntityTypeMinAggregateInputType
    _max?: EntityTypeMaxAggregateInputType
  }

  export type EntityTypeGroupByOutputType = {
    id: string
    name: string | null
    createdAt: Date
    createdBy: string | null
    updatedAt: Date
    updatedBy: string | null
    organizationId: string | null
    deleted: boolean | null
    _count: EntityTypeCountAggregateOutputType | null
    _min: EntityTypeMinAggregateOutputType | null
    _max: EntityTypeMaxAggregateOutputType | null
  }

  type GetEntityTypeGroupByPayload<T extends EntityTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EntityTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EntityTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EntityTypeGroupByOutputType[P]>
            : GetScalarType<T[P], EntityTypeGroupByOutputType[P]>
        }
      >
    >


  export type EntityTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    organizationId?: boolean
    deleted?: boolean
    organization?: boolean | EntityType$organizationArgs<ExtArgs>
    entity?: boolean | EntityType$entityArgs<ExtArgs>
    _count?: boolean | EntityTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["entityType"]>


  export type EntityTypeSelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    organizationId?: boolean
    deleted?: boolean
  }

  export type EntityTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | EntityType$organizationArgs<ExtArgs>
    entity?: boolean | EntityType$entityArgs<ExtArgs>
    _count?: boolean | EntityTypeCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $EntityTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EntityType"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs> | null
      entity: Prisma.$EntityPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string | null
      createdAt: Date
      createdBy: string | null
      updatedAt: Date
      updatedBy: string | null
      organizationId: string | null
      deleted: boolean | null
    }, ExtArgs["result"]["entityType"]>
    composites: {}
  }

  type EntityTypeGetPayload<S extends boolean | null | undefined | EntityTypeDefaultArgs> = $Result.GetResult<Prisma.$EntityTypePayload, S>

  type EntityTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EntityTypeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EntityTypeCountAggregateInputType | true
    }

  export interface EntityTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EntityType'], meta: { name: 'EntityType' } }
    /**
     * Find zero or one EntityType that matches the filter.
     * @param {EntityTypeFindUniqueArgs} args - Arguments to find a EntityType
     * @example
     * // Get one EntityType
     * const entityType = await prisma.entityType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EntityTypeFindUniqueArgs>(args: SelectSubset<T, EntityTypeFindUniqueArgs<ExtArgs>>): Prisma__EntityTypeClient<$Result.GetResult<Prisma.$EntityTypePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EntityType that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EntityTypeFindUniqueOrThrowArgs} args - Arguments to find a EntityType
     * @example
     * // Get one EntityType
     * const entityType = await prisma.entityType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EntityTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, EntityTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EntityTypeClient<$Result.GetResult<Prisma.$EntityTypePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EntityType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntityTypeFindFirstArgs} args - Arguments to find a EntityType
     * @example
     * // Get one EntityType
     * const entityType = await prisma.entityType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EntityTypeFindFirstArgs>(args?: SelectSubset<T, EntityTypeFindFirstArgs<ExtArgs>>): Prisma__EntityTypeClient<$Result.GetResult<Prisma.$EntityTypePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EntityType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntityTypeFindFirstOrThrowArgs} args - Arguments to find a EntityType
     * @example
     * // Get one EntityType
     * const entityType = await prisma.entityType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EntityTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, EntityTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__EntityTypeClient<$Result.GetResult<Prisma.$EntityTypePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EntityTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntityTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EntityTypes
     * const entityTypes = await prisma.entityType.findMany()
     * 
     * // Get first 10 EntityTypes
     * const entityTypes = await prisma.entityType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const entityTypeWithIdOnly = await prisma.entityType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EntityTypeFindManyArgs>(args?: SelectSubset<T, EntityTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EntityTypePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EntityType.
     * @param {EntityTypeCreateArgs} args - Arguments to create a EntityType.
     * @example
     * // Create one EntityType
     * const EntityType = await prisma.entityType.create({
     *   data: {
     *     // ... data to create a EntityType
     *   }
     * })
     * 
     */
    create<T extends EntityTypeCreateArgs>(args: SelectSubset<T, EntityTypeCreateArgs<ExtArgs>>): Prisma__EntityTypeClient<$Result.GetResult<Prisma.$EntityTypePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EntityTypes.
     * @param {EntityTypeCreateManyArgs} args - Arguments to create many EntityTypes.
     * @example
     * // Create many EntityTypes
     * const entityType = await prisma.entityType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EntityTypeCreateManyArgs>(args?: SelectSubset<T, EntityTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EntityType.
     * @param {EntityTypeDeleteArgs} args - Arguments to delete one EntityType.
     * @example
     * // Delete one EntityType
     * const EntityType = await prisma.entityType.delete({
     *   where: {
     *     // ... filter to delete one EntityType
     *   }
     * })
     * 
     */
    delete<T extends EntityTypeDeleteArgs>(args: SelectSubset<T, EntityTypeDeleteArgs<ExtArgs>>): Prisma__EntityTypeClient<$Result.GetResult<Prisma.$EntityTypePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EntityType.
     * @param {EntityTypeUpdateArgs} args - Arguments to update one EntityType.
     * @example
     * // Update one EntityType
     * const entityType = await prisma.entityType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EntityTypeUpdateArgs>(args: SelectSubset<T, EntityTypeUpdateArgs<ExtArgs>>): Prisma__EntityTypeClient<$Result.GetResult<Prisma.$EntityTypePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EntityTypes.
     * @param {EntityTypeDeleteManyArgs} args - Arguments to filter EntityTypes to delete.
     * @example
     * // Delete a few EntityTypes
     * const { count } = await prisma.entityType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EntityTypeDeleteManyArgs>(args?: SelectSubset<T, EntityTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EntityTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntityTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EntityTypes
     * const entityType = await prisma.entityType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EntityTypeUpdateManyArgs>(args: SelectSubset<T, EntityTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EntityType.
     * @param {EntityTypeUpsertArgs} args - Arguments to update or create a EntityType.
     * @example
     * // Update or create a EntityType
     * const entityType = await prisma.entityType.upsert({
     *   create: {
     *     // ... data to create a EntityType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EntityType we want to update
     *   }
     * })
     */
    upsert<T extends EntityTypeUpsertArgs>(args: SelectSubset<T, EntityTypeUpsertArgs<ExtArgs>>): Prisma__EntityTypeClient<$Result.GetResult<Prisma.$EntityTypePayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more EntityTypes that matches the filter.
     * @param {EntityTypeFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const entityType = await prisma.entityType.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: EntityTypeFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a EntityType.
     * @param {EntityTypeAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const entityType = await prisma.entityType.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: EntityTypeAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of EntityTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntityTypeCountArgs} args - Arguments to filter EntityTypes to count.
     * @example
     * // Count the number of EntityTypes
     * const count = await prisma.entityType.count({
     *   where: {
     *     // ... the filter for the EntityTypes we want to count
     *   }
     * })
    **/
    count<T extends EntityTypeCountArgs>(
      args?: Subset<T, EntityTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EntityTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EntityType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntityTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EntityTypeAggregateArgs>(args: Subset<T, EntityTypeAggregateArgs>): Prisma.PrismaPromise<GetEntityTypeAggregateType<T>>

    /**
     * Group by EntityType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntityTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EntityTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EntityTypeGroupByArgs['orderBy'] }
        : { orderBy?: EntityTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EntityTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEntityTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EntityType model
   */
  readonly fields: EntityTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EntityType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EntityTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organization<T extends EntityType$organizationArgs<ExtArgs> = {}>(args?: Subset<T, EntityType$organizationArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    entity<T extends EntityType$entityArgs<ExtArgs> = {}>(args?: Subset<T, EntityType$entityArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EntityPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EntityType model
   */ 
  interface EntityTypeFieldRefs {
    readonly id: FieldRef<"EntityType", 'String'>
    readonly name: FieldRef<"EntityType", 'String'>
    readonly createdAt: FieldRef<"EntityType", 'DateTime'>
    readonly createdBy: FieldRef<"EntityType", 'String'>
    readonly updatedAt: FieldRef<"EntityType", 'DateTime'>
    readonly updatedBy: FieldRef<"EntityType", 'String'>
    readonly organizationId: FieldRef<"EntityType", 'String'>
    readonly deleted: FieldRef<"EntityType", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * EntityType findUnique
   */
  export type EntityTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntityType
     */
    select?: EntityTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntityTypeInclude<ExtArgs> | null
    /**
     * Filter, which EntityType to fetch.
     */
    where: EntityTypeWhereUniqueInput
  }

  /**
   * EntityType findUniqueOrThrow
   */
  export type EntityTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntityType
     */
    select?: EntityTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntityTypeInclude<ExtArgs> | null
    /**
     * Filter, which EntityType to fetch.
     */
    where: EntityTypeWhereUniqueInput
  }

  /**
   * EntityType findFirst
   */
  export type EntityTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntityType
     */
    select?: EntityTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntityTypeInclude<ExtArgs> | null
    /**
     * Filter, which EntityType to fetch.
     */
    where?: EntityTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EntityTypes to fetch.
     */
    orderBy?: EntityTypeOrderByWithRelationInput | EntityTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EntityTypes.
     */
    cursor?: EntityTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EntityTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EntityTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EntityTypes.
     */
    distinct?: EntityTypeScalarFieldEnum | EntityTypeScalarFieldEnum[]
  }

  /**
   * EntityType findFirstOrThrow
   */
  export type EntityTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntityType
     */
    select?: EntityTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntityTypeInclude<ExtArgs> | null
    /**
     * Filter, which EntityType to fetch.
     */
    where?: EntityTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EntityTypes to fetch.
     */
    orderBy?: EntityTypeOrderByWithRelationInput | EntityTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EntityTypes.
     */
    cursor?: EntityTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EntityTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EntityTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EntityTypes.
     */
    distinct?: EntityTypeScalarFieldEnum | EntityTypeScalarFieldEnum[]
  }

  /**
   * EntityType findMany
   */
  export type EntityTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntityType
     */
    select?: EntityTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntityTypeInclude<ExtArgs> | null
    /**
     * Filter, which EntityTypes to fetch.
     */
    where?: EntityTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EntityTypes to fetch.
     */
    orderBy?: EntityTypeOrderByWithRelationInput | EntityTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EntityTypes.
     */
    cursor?: EntityTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EntityTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EntityTypes.
     */
    skip?: number
    distinct?: EntityTypeScalarFieldEnum | EntityTypeScalarFieldEnum[]
  }

  /**
   * EntityType create
   */
  export type EntityTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntityType
     */
    select?: EntityTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntityTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a EntityType.
     */
    data: XOR<EntityTypeCreateInput, EntityTypeUncheckedCreateInput>
  }

  /**
   * EntityType createMany
   */
  export type EntityTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EntityTypes.
     */
    data: EntityTypeCreateManyInput | EntityTypeCreateManyInput[]
  }

  /**
   * EntityType update
   */
  export type EntityTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntityType
     */
    select?: EntityTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntityTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a EntityType.
     */
    data: XOR<EntityTypeUpdateInput, EntityTypeUncheckedUpdateInput>
    /**
     * Choose, which EntityType to update.
     */
    where: EntityTypeWhereUniqueInput
  }

  /**
   * EntityType updateMany
   */
  export type EntityTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EntityTypes.
     */
    data: XOR<EntityTypeUpdateManyMutationInput, EntityTypeUncheckedUpdateManyInput>
    /**
     * Filter which EntityTypes to update
     */
    where?: EntityTypeWhereInput
  }

  /**
   * EntityType upsert
   */
  export type EntityTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntityType
     */
    select?: EntityTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntityTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the EntityType to update in case it exists.
     */
    where: EntityTypeWhereUniqueInput
    /**
     * In case the EntityType found by the `where` argument doesn't exist, create a new EntityType with this data.
     */
    create: XOR<EntityTypeCreateInput, EntityTypeUncheckedCreateInput>
    /**
     * In case the EntityType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EntityTypeUpdateInput, EntityTypeUncheckedUpdateInput>
  }

  /**
   * EntityType delete
   */
  export type EntityTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntityType
     */
    select?: EntityTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntityTypeInclude<ExtArgs> | null
    /**
     * Filter which EntityType to delete.
     */
    where: EntityTypeWhereUniqueInput
  }

  /**
   * EntityType deleteMany
   */
  export type EntityTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EntityTypes to delete
     */
    where?: EntityTypeWhereInput
  }

  /**
   * EntityType findRaw
   */
  export type EntityTypeFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * EntityType aggregateRaw
   */
  export type EntityTypeAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * EntityType.organization
   */
  export type EntityType$organizationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    where?: OrganizationWhereInput
  }

  /**
   * EntityType.entity
   */
  export type EntityType$entityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entity
     */
    select?: EntitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntityInclude<ExtArgs> | null
    where?: EntityWhereInput
    orderBy?: EntityOrderByWithRelationInput | EntityOrderByWithRelationInput[]
    cursor?: EntityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EntityScalarFieldEnum | EntityScalarFieldEnum[]
  }

  /**
   * EntityType without action
   */
  export type EntityTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntityType
     */
    select?: EntityTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntityTypeInclude<ExtArgs> | null
  }


  /**
   * Model businessType
   */

  export type AggregateBusinessType = {
    _count: BusinessTypeCountAggregateOutputType | null
    _min: BusinessTypeMinAggregateOutputType | null
    _max: BusinessTypeMaxAggregateOutputType | null
  }

  export type BusinessTypeMinAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    createdBy: string | null
    deleted: boolean | null
    organizationId: string | null
  }

  export type BusinessTypeMaxAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    createdBy: string | null
    deleted: boolean | null
    organizationId: string | null
  }

  export type BusinessTypeCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    createdBy: number
    deleted: number
    organizationId: number
    _all: number
  }


  export type BusinessTypeMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    createdBy?: true
    deleted?: true
    organizationId?: true
  }

  export type BusinessTypeMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    createdBy?: true
    deleted?: true
    organizationId?: true
  }

  export type BusinessTypeCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    createdBy?: true
    deleted?: true
    organizationId?: true
    _all?: true
  }

  export type BusinessTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which businessType to aggregate.
     */
    where?: businessTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of businessTypes to fetch.
     */
    orderBy?: businessTypeOrderByWithRelationInput | businessTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: businessTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` businessTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` businessTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned businessTypes
    **/
    _count?: true | BusinessTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BusinessTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BusinessTypeMaxAggregateInputType
  }

  export type GetBusinessTypeAggregateType<T extends BusinessTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateBusinessType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBusinessType[P]>
      : GetScalarType<T[P], AggregateBusinessType[P]>
  }




  export type businessTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: businessTypeWhereInput
    orderBy?: businessTypeOrderByWithAggregationInput | businessTypeOrderByWithAggregationInput[]
    by: BusinessTypeScalarFieldEnum[] | BusinessTypeScalarFieldEnum
    having?: businessTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BusinessTypeCountAggregateInputType | true
    _min?: BusinessTypeMinAggregateInputType
    _max?: BusinessTypeMaxAggregateInputType
  }

  export type BusinessTypeGroupByOutputType = {
    id: string
    name: string | null
    createdAt: Date
    createdBy: string | null
    deleted: boolean | null
    organizationId: string | null
    _count: BusinessTypeCountAggregateOutputType | null
    _min: BusinessTypeMinAggregateOutputType | null
    _max: BusinessTypeMaxAggregateOutputType | null
  }

  type GetBusinessTypeGroupByPayload<T extends businessTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BusinessTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BusinessTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BusinessTypeGroupByOutputType[P]>
            : GetScalarType<T[P], BusinessTypeGroupByOutputType[P]>
        }
      >
    >


  export type businessTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    createdBy?: boolean
    deleted?: boolean
    organizationId?: boolean
    organization?: boolean | businessType$organizationArgs<ExtArgs>
  }, ExtArgs["result"]["businessType"]>


  export type businessTypeSelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    createdBy?: boolean
    deleted?: boolean
    organizationId?: boolean
  }

  export type businessTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | businessType$organizationArgs<ExtArgs>
  }

  export type $businessTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "businessType"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string | null
      createdAt: Date
      createdBy: string | null
      deleted: boolean | null
      organizationId: string | null
    }, ExtArgs["result"]["businessType"]>
    composites: {}
  }

  type businessTypeGetPayload<S extends boolean | null | undefined | businessTypeDefaultArgs> = $Result.GetResult<Prisma.$businessTypePayload, S>

  type businessTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<businessTypeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BusinessTypeCountAggregateInputType | true
    }

  export interface businessTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['businessType'], meta: { name: 'businessType' } }
    /**
     * Find zero or one BusinessType that matches the filter.
     * @param {businessTypeFindUniqueArgs} args - Arguments to find a BusinessType
     * @example
     * // Get one BusinessType
     * const businessType = await prisma.businessType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends businessTypeFindUniqueArgs>(args: SelectSubset<T, businessTypeFindUniqueArgs<ExtArgs>>): Prisma__businessTypeClient<$Result.GetResult<Prisma.$businessTypePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BusinessType that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {businessTypeFindUniqueOrThrowArgs} args - Arguments to find a BusinessType
     * @example
     * // Get one BusinessType
     * const businessType = await prisma.businessType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends businessTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, businessTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__businessTypeClient<$Result.GetResult<Prisma.$businessTypePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BusinessType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {businessTypeFindFirstArgs} args - Arguments to find a BusinessType
     * @example
     * // Get one BusinessType
     * const businessType = await prisma.businessType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends businessTypeFindFirstArgs>(args?: SelectSubset<T, businessTypeFindFirstArgs<ExtArgs>>): Prisma__businessTypeClient<$Result.GetResult<Prisma.$businessTypePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BusinessType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {businessTypeFindFirstOrThrowArgs} args - Arguments to find a BusinessType
     * @example
     * // Get one BusinessType
     * const businessType = await prisma.businessType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends businessTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, businessTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__businessTypeClient<$Result.GetResult<Prisma.$businessTypePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BusinessTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {businessTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BusinessTypes
     * const businessTypes = await prisma.businessType.findMany()
     * 
     * // Get first 10 BusinessTypes
     * const businessTypes = await prisma.businessType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const businessTypeWithIdOnly = await prisma.businessType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends businessTypeFindManyArgs>(args?: SelectSubset<T, businessTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$businessTypePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BusinessType.
     * @param {businessTypeCreateArgs} args - Arguments to create a BusinessType.
     * @example
     * // Create one BusinessType
     * const BusinessType = await prisma.businessType.create({
     *   data: {
     *     // ... data to create a BusinessType
     *   }
     * })
     * 
     */
    create<T extends businessTypeCreateArgs>(args: SelectSubset<T, businessTypeCreateArgs<ExtArgs>>): Prisma__businessTypeClient<$Result.GetResult<Prisma.$businessTypePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BusinessTypes.
     * @param {businessTypeCreateManyArgs} args - Arguments to create many BusinessTypes.
     * @example
     * // Create many BusinessTypes
     * const businessType = await prisma.businessType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends businessTypeCreateManyArgs>(args?: SelectSubset<T, businessTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BusinessType.
     * @param {businessTypeDeleteArgs} args - Arguments to delete one BusinessType.
     * @example
     * // Delete one BusinessType
     * const BusinessType = await prisma.businessType.delete({
     *   where: {
     *     // ... filter to delete one BusinessType
     *   }
     * })
     * 
     */
    delete<T extends businessTypeDeleteArgs>(args: SelectSubset<T, businessTypeDeleteArgs<ExtArgs>>): Prisma__businessTypeClient<$Result.GetResult<Prisma.$businessTypePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BusinessType.
     * @param {businessTypeUpdateArgs} args - Arguments to update one BusinessType.
     * @example
     * // Update one BusinessType
     * const businessType = await prisma.businessType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends businessTypeUpdateArgs>(args: SelectSubset<T, businessTypeUpdateArgs<ExtArgs>>): Prisma__businessTypeClient<$Result.GetResult<Prisma.$businessTypePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BusinessTypes.
     * @param {businessTypeDeleteManyArgs} args - Arguments to filter BusinessTypes to delete.
     * @example
     * // Delete a few BusinessTypes
     * const { count } = await prisma.businessType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends businessTypeDeleteManyArgs>(args?: SelectSubset<T, businessTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BusinessTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {businessTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BusinessTypes
     * const businessType = await prisma.businessType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends businessTypeUpdateManyArgs>(args: SelectSubset<T, businessTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BusinessType.
     * @param {businessTypeUpsertArgs} args - Arguments to update or create a BusinessType.
     * @example
     * // Update or create a BusinessType
     * const businessType = await prisma.businessType.upsert({
     *   create: {
     *     // ... data to create a BusinessType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BusinessType we want to update
     *   }
     * })
     */
    upsert<T extends businessTypeUpsertArgs>(args: SelectSubset<T, businessTypeUpsertArgs<ExtArgs>>): Prisma__businessTypeClient<$Result.GetResult<Prisma.$businessTypePayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more BusinessTypes that matches the filter.
     * @param {businessTypeFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const businessType = await prisma.businessType.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: businessTypeFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a BusinessType.
     * @param {businessTypeAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const businessType = await prisma.businessType.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: businessTypeAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of BusinessTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {businessTypeCountArgs} args - Arguments to filter BusinessTypes to count.
     * @example
     * // Count the number of BusinessTypes
     * const count = await prisma.businessType.count({
     *   where: {
     *     // ... the filter for the BusinessTypes we want to count
     *   }
     * })
    **/
    count<T extends businessTypeCountArgs>(
      args?: Subset<T, businessTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BusinessTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BusinessType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BusinessTypeAggregateArgs>(args: Subset<T, BusinessTypeAggregateArgs>): Prisma.PrismaPromise<GetBusinessTypeAggregateType<T>>

    /**
     * Group by BusinessType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {businessTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends businessTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: businessTypeGroupByArgs['orderBy'] }
        : { orderBy?: businessTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, businessTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBusinessTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the businessType model
   */
  readonly fields: businessTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for businessType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__businessTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organization<T extends businessType$organizationArgs<ExtArgs> = {}>(args?: Subset<T, businessType$organizationArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the businessType model
   */ 
  interface businessTypeFieldRefs {
    readonly id: FieldRef<"businessType", 'String'>
    readonly name: FieldRef<"businessType", 'String'>
    readonly createdAt: FieldRef<"businessType", 'DateTime'>
    readonly createdBy: FieldRef<"businessType", 'String'>
    readonly deleted: FieldRef<"businessType", 'Boolean'>
    readonly organizationId: FieldRef<"businessType", 'String'>
  }
    

  // Custom InputTypes
  /**
   * businessType findUnique
   */
  export type businessTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the businessType
     */
    select?: businessTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: businessTypeInclude<ExtArgs> | null
    /**
     * Filter, which businessType to fetch.
     */
    where: businessTypeWhereUniqueInput
  }

  /**
   * businessType findUniqueOrThrow
   */
  export type businessTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the businessType
     */
    select?: businessTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: businessTypeInclude<ExtArgs> | null
    /**
     * Filter, which businessType to fetch.
     */
    where: businessTypeWhereUniqueInput
  }

  /**
   * businessType findFirst
   */
  export type businessTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the businessType
     */
    select?: businessTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: businessTypeInclude<ExtArgs> | null
    /**
     * Filter, which businessType to fetch.
     */
    where?: businessTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of businessTypes to fetch.
     */
    orderBy?: businessTypeOrderByWithRelationInput | businessTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for businessTypes.
     */
    cursor?: businessTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` businessTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` businessTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of businessTypes.
     */
    distinct?: BusinessTypeScalarFieldEnum | BusinessTypeScalarFieldEnum[]
  }

  /**
   * businessType findFirstOrThrow
   */
  export type businessTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the businessType
     */
    select?: businessTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: businessTypeInclude<ExtArgs> | null
    /**
     * Filter, which businessType to fetch.
     */
    where?: businessTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of businessTypes to fetch.
     */
    orderBy?: businessTypeOrderByWithRelationInput | businessTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for businessTypes.
     */
    cursor?: businessTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` businessTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` businessTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of businessTypes.
     */
    distinct?: BusinessTypeScalarFieldEnum | BusinessTypeScalarFieldEnum[]
  }

  /**
   * businessType findMany
   */
  export type businessTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the businessType
     */
    select?: businessTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: businessTypeInclude<ExtArgs> | null
    /**
     * Filter, which businessTypes to fetch.
     */
    where?: businessTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of businessTypes to fetch.
     */
    orderBy?: businessTypeOrderByWithRelationInput | businessTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing businessTypes.
     */
    cursor?: businessTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` businessTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` businessTypes.
     */
    skip?: number
    distinct?: BusinessTypeScalarFieldEnum | BusinessTypeScalarFieldEnum[]
  }

  /**
   * businessType create
   */
  export type businessTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the businessType
     */
    select?: businessTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: businessTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a businessType.
     */
    data?: XOR<businessTypeCreateInput, businessTypeUncheckedCreateInput>
  }

  /**
   * businessType createMany
   */
  export type businessTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many businessTypes.
     */
    data: businessTypeCreateManyInput | businessTypeCreateManyInput[]
  }

  /**
   * businessType update
   */
  export type businessTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the businessType
     */
    select?: businessTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: businessTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a businessType.
     */
    data: XOR<businessTypeUpdateInput, businessTypeUncheckedUpdateInput>
    /**
     * Choose, which businessType to update.
     */
    where: businessTypeWhereUniqueInput
  }

  /**
   * businessType updateMany
   */
  export type businessTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update businessTypes.
     */
    data: XOR<businessTypeUpdateManyMutationInput, businessTypeUncheckedUpdateManyInput>
    /**
     * Filter which businessTypes to update
     */
    where?: businessTypeWhereInput
  }

  /**
   * businessType upsert
   */
  export type businessTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the businessType
     */
    select?: businessTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: businessTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the businessType to update in case it exists.
     */
    where: businessTypeWhereUniqueInput
    /**
     * In case the businessType found by the `where` argument doesn't exist, create a new businessType with this data.
     */
    create: XOR<businessTypeCreateInput, businessTypeUncheckedCreateInput>
    /**
     * In case the businessType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<businessTypeUpdateInput, businessTypeUncheckedUpdateInput>
  }

  /**
   * businessType delete
   */
  export type businessTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the businessType
     */
    select?: businessTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: businessTypeInclude<ExtArgs> | null
    /**
     * Filter which businessType to delete.
     */
    where: businessTypeWhereUniqueInput
  }

  /**
   * businessType deleteMany
   */
  export type businessTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which businessTypes to delete
     */
    where?: businessTypeWhereInput
  }

  /**
   * businessType findRaw
   */
  export type businessTypeFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * businessType aggregateRaw
   */
  export type businessTypeAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * businessType.organization
   */
  export type businessType$organizationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    where?: OrganizationWhereInput
  }

  /**
   * businessType without action
   */
  export type businessTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the businessType
     */
    select?: businessTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: businessTypeInclude<ExtArgs> | null
  }


  /**
   * Model Business
   */

  export type AggregateBusiness = {
    _count: BusinessCountAggregateOutputType | null
    _min: BusinessMinAggregateOutputType | null
    _max: BusinessMaxAggregateOutputType | null
  }

  export type BusinessMinAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
    organizationId: string | null
    deleted: boolean | null
  }

  export type BusinessMaxAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
    organizationId: string | null
    deleted: boolean | null
  }

  export type BusinessCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    organizationId: number
    deleted: number
    _all: number
  }


  export type BusinessMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    organizationId?: true
    deleted?: true
  }

  export type BusinessMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    organizationId?: true
    deleted?: true
  }

  export type BusinessCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    organizationId?: true
    deleted?: true
    _all?: true
  }

  export type BusinessAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Business to aggregate.
     */
    where?: BusinessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Businesses to fetch.
     */
    orderBy?: BusinessOrderByWithRelationInput | BusinessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BusinessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Businesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Businesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Businesses
    **/
    _count?: true | BusinessCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BusinessMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BusinessMaxAggregateInputType
  }

  export type GetBusinessAggregateType<T extends BusinessAggregateArgs> = {
        [P in keyof T & keyof AggregateBusiness]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBusiness[P]>
      : GetScalarType<T[P], AggregateBusiness[P]>
  }




  export type BusinessGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BusinessWhereInput
    orderBy?: BusinessOrderByWithAggregationInput | BusinessOrderByWithAggregationInput[]
    by: BusinessScalarFieldEnum[] | BusinessScalarFieldEnum
    having?: BusinessScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BusinessCountAggregateInputType | true
    _min?: BusinessMinAggregateInputType
    _max?: BusinessMaxAggregateInputType
  }

  export type BusinessGroupByOutputType = {
    id: string
    name: string | null
    createdAt: Date
    createdBy: string | null
    updatedAt: Date
    updatedBy: string | null
    organizationId: string | null
    deleted: boolean | null
    _count: BusinessCountAggregateOutputType | null
    _min: BusinessMinAggregateOutputType | null
    _max: BusinessMaxAggregateOutputType | null
  }

  type GetBusinessGroupByPayload<T extends BusinessGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BusinessGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BusinessGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BusinessGroupByOutputType[P]>
            : GetScalarType<T[P], BusinessGroupByOutputType[P]>
        }
      >
    >


  export type BusinessSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    organizationId?: boolean
    deleted?: boolean
    organization?: boolean | Business$organizationArgs<ExtArgs>
    location?: boolean | Business$locationArgs<ExtArgs>
    _count?: boolean | BusinessCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["business"]>


  export type BusinessSelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    organizationId?: boolean
    deleted?: boolean
  }

  export type BusinessInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | Business$organizationArgs<ExtArgs>
    location?: boolean | Business$locationArgs<ExtArgs>
    _count?: boolean | BusinessCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $BusinessPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Business"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs> | null
      location: Prisma.$LocationBusinessPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string | null
      createdAt: Date
      createdBy: string | null
      updatedAt: Date
      updatedBy: string | null
      organizationId: string | null
      deleted: boolean | null
    }, ExtArgs["result"]["business"]>
    composites: {}
  }

  type BusinessGetPayload<S extends boolean | null | undefined | BusinessDefaultArgs> = $Result.GetResult<Prisma.$BusinessPayload, S>

  type BusinessCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BusinessFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BusinessCountAggregateInputType | true
    }

  export interface BusinessDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Business'], meta: { name: 'Business' } }
    /**
     * Find zero or one Business that matches the filter.
     * @param {BusinessFindUniqueArgs} args - Arguments to find a Business
     * @example
     * // Get one Business
     * const business = await prisma.business.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BusinessFindUniqueArgs>(args: SelectSubset<T, BusinessFindUniqueArgs<ExtArgs>>): Prisma__BusinessClient<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Business that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BusinessFindUniqueOrThrowArgs} args - Arguments to find a Business
     * @example
     * // Get one Business
     * const business = await prisma.business.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BusinessFindUniqueOrThrowArgs>(args: SelectSubset<T, BusinessFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BusinessClient<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Business that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessFindFirstArgs} args - Arguments to find a Business
     * @example
     * // Get one Business
     * const business = await prisma.business.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BusinessFindFirstArgs>(args?: SelectSubset<T, BusinessFindFirstArgs<ExtArgs>>): Prisma__BusinessClient<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Business that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessFindFirstOrThrowArgs} args - Arguments to find a Business
     * @example
     * // Get one Business
     * const business = await prisma.business.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BusinessFindFirstOrThrowArgs>(args?: SelectSubset<T, BusinessFindFirstOrThrowArgs<ExtArgs>>): Prisma__BusinessClient<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Businesses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Businesses
     * const businesses = await prisma.business.findMany()
     * 
     * // Get first 10 Businesses
     * const businesses = await prisma.business.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const businessWithIdOnly = await prisma.business.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BusinessFindManyArgs>(args?: SelectSubset<T, BusinessFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Business.
     * @param {BusinessCreateArgs} args - Arguments to create a Business.
     * @example
     * // Create one Business
     * const Business = await prisma.business.create({
     *   data: {
     *     // ... data to create a Business
     *   }
     * })
     * 
     */
    create<T extends BusinessCreateArgs>(args: SelectSubset<T, BusinessCreateArgs<ExtArgs>>): Prisma__BusinessClient<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Businesses.
     * @param {BusinessCreateManyArgs} args - Arguments to create many Businesses.
     * @example
     * // Create many Businesses
     * const business = await prisma.business.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BusinessCreateManyArgs>(args?: SelectSubset<T, BusinessCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Business.
     * @param {BusinessDeleteArgs} args - Arguments to delete one Business.
     * @example
     * // Delete one Business
     * const Business = await prisma.business.delete({
     *   where: {
     *     // ... filter to delete one Business
     *   }
     * })
     * 
     */
    delete<T extends BusinessDeleteArgs>(args: SelectSubset<T, BusinessDeleteArgs<ExtArgs>>): Prisma__BusinessClient<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Business.
     * @param {BusinessUpdateArgs} args - Arguments to update one Business.
     * @example
     * // Update one Business
     * const business = await prisma.business.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BusinessUpdateArgs>(args: SelectSubset<T, BusinessUpdateArgs<ExtArgs>>): Prisma__BusinessClient<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Businesses.
     * @param {BusinessDeleteManyArgs} args - Arguments to filter Businesses to delete.
     * @example
     * // Delete a few Businesses
     * const { count } = await prisma.business.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BusinessDeleteManyArgs>(args?: SelectSubset<T, BusinessDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Businesses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Businesses
     * const business = await prisma.business.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BusinessUpdateManyArgs>(args: SelectSubset<T, BusinessUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Business.
     * @param {BusinessUpsertArgs} args - Arguments to update or create a Business.
     * @example
     * // Update or create a Business
     * const business = await prisma.business.upsert({
     *   create: {
     *     // ... data to create a Business
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Business we want to update
     *   }
     * })
     */
    upsert<T extends BusinessUpsertArgs>(args: SelectSubset<T, BusinessUpsertArgs<ExtArgs>>): Prisma__BusinessClient<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Businesses that matches the filter.
     * @param {BusinessFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const business = await prisma.business.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: BusinessFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Business.
     * @param {BusinessAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const business = await prisma.business.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: BusinessAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Businesses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessCountArgs} args - Arguments to filter Businesses to count.
     * @example
     * // Count the number of Businesses
     * const count = await prisma.business.count({
     *   where: {
     *     // ... the filter for the Businesses we want to count
     *   }
     * })
    **/
    count<T extends BusinessCountArgs>(
      args?: Subset<T, BusinessCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BusinessCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Business.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BusinessAggregateArgs>(args: Subset<T, BusinessAggregateArgs>): Prisma.PrismaPromise<GetBusinessAggregateType<T>>

    /**
     * Group by Business.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BusinessGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BusinessGroupByArgs['orderBy'] }
        : { orderBy?: BusinessGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BusinessGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBusinessGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Business model
   */
  readonly fields: BusinessFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Business.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BusinessClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organization<T extends Business$organizationArgs<ExtArgs> = {}>(args?: Subset<T, Business$organizationArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    location<T extends Business$locationArgs<ExtArgs> = {}>(args?: Subset<T, Business$locationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationBusinessPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Business model
   */ 
  interface BusinessFieldRefs {
    readonly id: FieldRef<"Business", 'String'>
    readonly name: FieldRef<"Business", 'String'>
    readonly createdAt: FieldRef<"Business", 'DateTime'>
    readonly createdBy: FieldRef<"Business", 'String'>
    readonly updatedAt: FieldRef<"Business", 'DateTime'>
    readonly updatedBy: FieldRef<"Business", 'String'>
    readonly organizationId: FieldRef<"Business", 'String'>
    readonly deleted: FieldRef<"Business", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Business findUnique
   */
  export type BusinessFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessInclude<ExtArgs> | null
    /**
     * Filter, which Business to fetch.
     */
    where: BusinessWhereUniqueInput
  }

  /**
   * Business findUniqueOrThrow
   */
  export type BusinessFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessInclude<ExtArgs> | null
    /**
     * Filter, which Business to fetch.
     */
    where: BusinessWhereUniqueInput
  }

  /**
   * Business findFirst
   */
  export type BusinessFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessInclude<ExtArgs> | null
    /**
     * Filter, which Business to fetch.
     */
    where?: BusinessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Businesses to fetch.
     */
    orderBy?: BusinessOrderByWithRelationInput | BusinessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Businesses.
     */
    cursor?: BusinessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Businesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Businesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Businesses.
     */
    distinct?: BusinessScalarFieldEnum | BusinessScalarFieldEnum[]
  }

  /**
   * Business findFirstOrThrow
   */
  export type BusinessFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessInclude<ExtArgs> | null
    /**
     * Filter, which Business to fetch.
     */
    where?: BusinessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Businesses to fetch.
     */
    orderBy?: BusinessOrderByWithRelationInput | BusinessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Businesses.
     */
    cursor?: BusinessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Businesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Businesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Businesses.
     */
    distinct?: BusinessScalarFieldEnum | BusinessScalarFieldEnum[]
  }

  /**
   * Business findMany
   */
  export type BusinessFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessInclude<ExtArgs> | null
    /**
     * Filter, which Businesses to fetch.
     */
    where?: BusinessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Businesses to fetch.
     */
    orderBy?: BusinessOrderByWithRelationInput | BusinessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Businesses.
     */
    cursor?: BusinessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Businesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Businesses.
     */
    skip?: number
    distinct?: BusinessScalarFieldEnum | BusinessScalarFieldEnum[]
  }

  /**
   * Business create
   */
  export type BusinessCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessInclude<ExtArgs> | null
    /**
     * The data needed to create a Business.
     */
    data: XOR<BusinessCreateInput, BusinessUncheckedCreateInput>
  }

  /**
   * Business createMany
   */
  export type BusinessCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Businesses.
     */
    data: BusinessCreateManyInput | BusinessCreateManyInput[]
  }

  /**
   * Business update
   */
  export type BusinessUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessInclude<ExtArgs> | null
    /**
     * The data needed to update a Business.
     */
    data: XOR<BusinessUpdateInput, BusinessUncheckedUpdateInput>
    /**
     * Choose, which Business to update.
     */
    where: BusinessWhereUniqueInput
  }

  /**
   * Business updateMany
   */
  export type BusinessUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Businesses.
     */
    data: XOR<BusinessUpdateManyMutationInput, BusinessUncheckedUpdateManyInput>
    /**
     * Filter which Businesses to update
     */
    where?: BusinessWhereInput
  }

  /**
   * Business upsert
   */
  export type BusinessUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessInclude<ExtArgs> | null
    /**
     * The filter to search for the Business to update in case it exists.
     */
    where: BusinessWhereUniqueInput
    /**
     * In case the Business found by the `where` argument doesn't exist, create a new Business with this data.
     */
    create: XOR<BusinessCreateInput, BusinessUncheckedCreateInput>
    /**
     * In case the Business was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BusinessUpdateInput, BusinessUncheckedUpdateInput>
  }

  /**
   * Business delete
   */
  export type BusinessDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessInclude<ExtArgs> | null
    /**
     * Filter which Business to delete.
     */
    where: BusinessWhereUniqueInput
  }

  /**
   * Business deleteMany
   */
  export type BusinessDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Businesses to delete
     */
    where?: BusinessWhereInput
  }

  /**
   * Business findRaw
   */
  export type BusinessFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Business aggregateRaw
   */
  export type BusinessAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Business.organization
   */
  export type Business$organizationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    where?: OrganizationWhereInput
  }

  /**
   * Business.location
   */
  export type Business$locationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationBusiness
     */
    select?: LocationBusinessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationBusinessInclude<ExtArgs> | null
    where?: LocationBusinessWhereInput
    orderBy?: LocationBusinessOrderByWithRelationInput | LocationBusinessOrderByWithRelationInput[]
    cursor?: LocationBusinessWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LocationBusinessScalarFieldEnum | LocationBusinessScalarFieldEnum[]
  }

  /**
   * Business without action
   */
  export type BusinessDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessInclude<ExtArgs> | null
  }


  /**
   * Model Functions
   */

  export type AggregateFunctions = {
    _count: FunctionsCountAggregateOutputType | null
    _min: FunctionsMinAggregateOutputType | null
    _max: FunctionsMaxAggregateOutputType | null
  }

  export type FunctionsMinAggregateOutputType = {
    id: string | null
    name: string | null
    functionId: string | null
    description: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
    deleted: boolean | null
    organizationId: string | null
    type: boolean | null
    unitId: string | null
  }

  export type FunctionsMaxAggregateOutputType = {
    id: string | null
    name: string | null
    functionId: string | null
    description: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
    deleted: boolean | null
    organizationId: string | null
    type: boolean | null
    unitId: string | null
  }

  export type FunctionsCountAggregateOutputType = {
    id: number
    name: number
    functionId: number
    description: number
    functionHead: number
    functionSpoc: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    deleted: number
    organizationId: number
    type: number
    locationId: number
    businessId: number
    unitId: number
    _all: number
  }


  export type FunctionsMinAggregateInputType = {
    id?: true
    name?: true
    functionId?: true
    description?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    deleted?: true
    organizationId?: true
    type?: true
    unitId?: true
  }

  export type FunctionsMaxAggregateInputType = {
    id?: true
    name?: true
    functionId?: true
    description?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    deleted?: true
    organizationId?: true
    type?: true
    unitId?: true
  }

  export type FunctionsCountAggregateInputType = {
    id?: true
    name?: true
    functionId?: true
    description?: true
    functionHead?: true
    functionSpoc?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    deleted?: true
    organizationId?: true
    type?: true
    locationId?: true
    businessId?: true
    unitId?: true
    _all?: true
  }

  export type FunctionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Functions to aggregate.
     */
    where?: FunctionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Functions to fetch.
     */
    orderBy?: FunctionsOrderByWithRelationInput | FunctionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FunctionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Functions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Functions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Functions
    **/
    _count?: true | FunctionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FunctionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FunctionsMaxAggregateInputType
  }

  export type GetFunctionsAggregateType<T extends FunctionsAggregateArgs> = {
        [P in keyof T & keyof AggregateFunctions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFunctions[P]>
      : GetScalarType<T[P], AggregateFunctions[P]>
  }




  export type FunctionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FunctionsWhereInput
    orderBy?: FunctionsOrderByWithAggregationInput | FunctionsOrderByWithAggregationInput[]
    by: FunctionsScalarFieldEnum[] | FunctionsScalarFieldEnum
    having?: FunctionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FunctionsCountAggregateInputType | true
    _min?: FunctionsMinAggregateInputType
    _max?: FunctionsMaxAggregateInputType
  }

  export type FunctionsGroupByOutputType = {
    id: string
    name: string | null
    functionId: string | null
    description: string | null
    functionHead: string[]
    functionSpoc: string[]
    createdAt: Date
    createdBy: string | null
    updatedAt: Date
    updatedBy: string | null
    deleted: boolean | null
    organizationId: string | null
    type: boolean
    locationId: string[]
    businessId: string[]
    unitId: string | null
    _count: FunctionsCountAggregateOutputType | null
    _min: FunctionsMinAggregateOutputType | null
    _max: FunctionsMaxAggregateOutputType | null
  }

  type GetFunctionsGroupByPayload<T extends FunctionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FunctionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FunctionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FunctionsGroupByOutputType[P]>
            : GetScalarType<T[P], FunctionsGroupByOutputType[P]>
        }
      >
    >


  export type FunctionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    functionId?: boolean
    description?: boolean
    functionHead?: boolean
    functionSpoc?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    deleted?: boolean
    organizationId?: boolean
    type?: boolean
    locationId?: boolean
    businessId?: boolean
    unitId?: boolean
    organization?: boolean | Functions$organizationArgs<ExtArgs>
    entity?: boolean | Functions$entityArgs<ExtArgs>
    _count?: boolean | FunctionsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["functions"]>


  export type FunctionsSelectScalar = {
    id?: boolean
    name?: boolean
    functionId?: boolean
    description?: boolean
    functionHead?: boolean
    functionSpoc?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    deleted?: boolean
    organizationId?: boolean
    type?: boolean
    locationId?: boolean
    businessId?: boolean
    unitId?: boolean
  }

  export type FunctionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | Functions$organizationArgs<ExtArgs>
    entity?: boolean | Functions$entityArgs<ExtArgs>
    _count?: boolean | FunctionsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $FunctionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Functions"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs> | null
      entity: Prisma.$EntityPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string | null
      functionId: string | null
      description: string | null
      functionHead: string[]
      functionSpoc: string[]
      createdAt: Date
      createdBy: string | null
      updatedAt: Date
      updatedBy: string | null
      deleted: boolean | null
      organizationId: string | null
      type: boolean
      locationId: string[]
      businessId: string[]
      unitId: string | null
    }, ExtArgs["result"]["functions"]>
    composites: {}
  }

  type FunctionsGetPayload<S extends boolean | null | undefined | FunctionsDefaultArgs> = $Result.GetResult<Prisma.$FunctionsPayload, S>

  type FunctionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FunctionsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FunctionsCountAggregateInputType | true
    }

  export interface FunctionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Functions'], meta: { name: 'Functions' } }
    /**
     * Find zero or one Functions that matches the filter.
     * @param {FunctionsFindUniqueArgs} args - Arguments to find a Functions
     * @example
     * // Get one Functions
     * const functions = await prisma.functions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FunctionsFindUniqueArgs>(args: SelectSubset<T, FunctionsFindUniqueArgs<ExtArgs>>): Prisma__FunctionsClient<$Result.GetResult<Prisma.$FunctionsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Functions that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FunctionsFindUniqueOrThrowArgs} args - Arguments to find a Functions
     * @example
     * // Get one Functions
     * const functions = await prisma.functions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FunctionsFindUniqueOrThrowArgs>(args: SelectSubset<T, FunctionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FunctionsClient<$Result.GetResult<Prisma.$FunctionsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Functions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FunctionsFindFirstArgs} args - Arguments to find a Functions
     * @example
     * // Get one Functions
     * const functions = await prisma.functions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FunctionsFindFirstArgs>(args?: SelectSubset<T, FunctionsFindFirstArgs<ExtArgs>>): Prisma__FunctionsClient<$Result.GetResult<Prisma.$FunctionsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Functions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FunctionsFindFirstOrThrowArgs} args - Arguments to find a Functions
     * @example
     * // Get one Functions
     * const functions = await prisma.functions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FunctionsFindFirstOrThrowArgs>(args?: SelectSubset<T, FunctionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__FunctionsClient<$Result.GetResult<Prisma.$FunctionsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Functions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FunctionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Functions
     * const functions = await prisma.functions.findMany()
     * 
     * // Get first 10 Functions
     * const functions = await prisma.functions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const functionsWithIdOnly = await prisma.functions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FunctionsFindManyArgs>(args?: SelectSubset<T, FunctionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FunctionsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Functions.
     * @param {FunctionsCreateArgs} args - Arguments to create a Functions.
     * @example
     * // Create one Functions
     * const Functions = await prisma.functions.create({
     *   data: {
     *     // ... data to create a Functions
     *   }
     * })
     * 
     */
    create<T extends FunctionsCreateArgs>(args: SelectSubset<T, FunctionsCreateArgs<ExtArgs>>): Prisma__FunctionsClient<$Result.GetResult<Prisma.$FunctionsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Functions.
     * @param {FunctionsCreateManyArgs} args - Arguments to create many Functions.
     * @example
     * // Create many Functions
     * const functions = await prisma.functions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FunctionsCreateManyArgs>(args?: SelectSubset<T, FunctionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Functions.
     * @param {FunctionsDeleteArgs} args - Arguments to delete one Functions.
     * @example
     * // Delete one Functions
     * const Functions = await prisma.functions.delete({
     *   where: {
     *     // ... filter to delete one Functions
     *   }
     * })
     * 
     */
    delete<T extends FunctionsDeleteArgs>(args: SelectSubset<T, FunctionsDeleteArgs<ExtArgs>>): Prisma__FunctionsClient<$Result.GetResult<Prisma.$FunctionsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Functions.
     * @param {FunctionsUpdateArgs} args - Arguments to update one Functions.
     * @example
     * // Update one Functions
     * const functions = await prisma.functions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FunctionsUpdateArgs>(args: SelectSubset<T, FunctionsUpdateArgs<ExtArgs>>): Prisma__FunctionsClient<$Result.GetResult<Prisma.$FunctionsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Functions.
     * @param {FunctionsDeleteManyArgs} args - Arguments to filter Functions to delete.
     * @example
     * // Delete a few Functions
     * const { count } = await prisma.functions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FunctionsDeleteManyArgs>(args?: SelectSubset<T, FunctionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Functions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FunctionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Functions
     * const functions = await prisma.functions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FunctionsUpdateManyArgs>(args: SelectSubset<T, FunctionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Functions.
     * @param {FunctionsUpsertArgs} args - Arguments to update or create a Functions.
     * @example
     * // Update or create a Functions
     * const functions = await prisma.functions.upsert({
     *   create: {
     *     // ... data to create a Functions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Functions we want to update
     *   }
     * })
     */
    upsert<T extends FunctionsUpsertArgs>(args: SelectSubset<T, FunctionsUpsertArgs<ExtArgs>>): Prisma__FunctionsClient<$Result.GetResult<Prisma.$FunctionsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Functions that matches the filter.
     * @param {FunctionsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const functions = await prisma.functions.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: FunctionsFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Functions.
     * @param {FunctionsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const functions = await prisma.functions.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: FunctionsAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Functions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FunctionsCountArgs} args - Arguments to filter Functions to count.
     * @example
     * // Count the number of Functions
     * const count = await prisma.functions.count({
     *   where: {
     *     // ... the filter for the Functions we want to count
     *   }
     * })
    **/
    count<T extends FunctionsCountArgs>(
      args?: Subset<T, FunctionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FunctionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Functions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FunctionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FunctionsAggregateArgs>(args: Subset<T, FunctionsAggregateArgs>): Prisma.PrismaPromise<GetFunctionsAggregateType<T>>

    /**
     * Group by Functions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FunctionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FunctionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FunctionsGroupByArgs['orderBy'] }
        : { orderBy?: FunctionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FunctionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFunctionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Functions model
   */
  readonly fields: FunctionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Functions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FunctionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organization<T extends Functions$organizationArgs<ExtArgs> = {}>(args?: Subset<T, Functions$organizationArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    entity<T extends Functions$entityArgs<ExtArgs> = {}>(args?: Subset<T, Functions$entityArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EntityPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Functions model
   */ 
  interface FunctionsFieldRefs {
    readonly id: FieldRef<"Functions", 'String'>
    readonly name: FieldRef<"Functions", 'String'>
    readonly functionId: FieldRef<"Functions", 'String'>
    readonly description: FieldRef<"Functions", 'String'>
    readonly functionHead: FieldRef<"Functions", 'String[]'>
    readonly functionSpoc: FieldRef<"Functions", 'String[]'>
    readonly createdAt: FieldRef<"Functions", 'DateTime'>
    readonly createdBy: FieldRef<"Functions", 'String'>
    readonly updatedAt: FieldRef<"Functions", 'DateTime'>
    readonly updatedBy: FieldRef<"Functions", 'String'>
    readonly deleted: FieldRef<"Functions", 'Boolean'>
    readonly organizationId: FieldRef<"Functions", 'String'>
    readonly type: FieldRef<"Functions", 'Boolean'>
    readonly locationId: FieldRef<"Functions", 'String[]'>
    readonly businessId: FieldRef<"Functions", 'String[]'>
    readonly unitId: FieldRef<"Functions", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Functions findUnique
   */
  export type FunctionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Functions
     */
    select?: FunctionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FunctionsInclude<ExtArgs> | null
    /**
     * Filter, which Functions to fetch.
     */
    where: FunctionsWhereUniqueInput
  }

  /**
   * Functions findUniqueOrThrow
   */
  export type FunctionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Functions
     */
    select?: FunctionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FunctionsInclude<ExtArgs> | null
    /**
     * Filter, which Functions to fetch.
     */
    where: FunctionsWhereUniqueInput
  }

  /**
   * Functions findFirst
   */
  export type FunctionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Functions
     */
    select?: FunctionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FunctionsInclude<ExtArgs> | null
    /**
     * Filter, which Functions to fetch.
     */
    where?: FunctionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Functions to fetch.
     */
    orderBy?: FunctionsOrderByWithRelationInput | FunctionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Functions.
     */
    cursor?: FunctionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Functions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Functions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Functions.
     */
    distinct?: FunctionsScalarFieldEnum | FunctionsScalarFieldEnum[]
  }

  /**
   * Functions findFirstOrThrow
   */
  export type FunctionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Functions
     */
    select?: FunctionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FunctionsInclude<ExtArgs> | null
    /**
     * Filter, which Functions to fetch.
     */
    where?: FunctionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Functions to fetch.
     */
    orderBy?: FunctionsOrderByWithRelationInput | FunctionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Functions.
     */
    cursor?: FunctionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Functions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Functions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Functions.
     */
    distinct?: FunctionsScalarFieldEnum | FunctionsScalarFieldEnum[]
  }

  /**
   * Functions findMany
   */
  export type FunctionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Functions
     */
    select?: FunctionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FunctionsInclude<ExtArgs> | null
    /**
     * Filter, which Functions to fetch.
     */
    where?: FunctionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Functions to fetch.
     */
    orderBy?: FunctionsOrderByWithRelationInput | FunctionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Functions.
     */
    cursor?: FunctionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Functions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Functions.
     */
    skip?: number
    distinct?: FunctionsScalarFieldEnum | FunctionsScalarFieldEnum[]
  }

  /**
   * Functions create
   */
  export type FunctionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Functions
     */
    select?: FunctionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FunctionsInclude<ExtArgs> | null
    /**
     * The data needed to create a Functions.
     */
    data: XOR<FunctionsCreateInput, FunctionsUncheckedCreateInput>
  }

  /**
   * Functions createMany
   */
  export type FunctionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Functions.
     */
    data: FunctionsCreateManyInput | FunctionsCreateManyInput[]
  }

  /**
   * Functions update
   */
  export type FunctionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Functions
     */
    select?: FunctionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FunctionsInclude<ExtArgs> | null
    /**
     * The data needed to update a Functions.
     */
    data: XOR<FunctionsUpdateInput, FunctionsUncheckedUpdateInput>
    /**
     * Choose, which Functions to update.
     */
    where: FunctionsWhereUniqueInput
  }

  /**
   * Functions updateMany
   */
  export type FunctionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Functions.
     */
    data: XOR<FunctionsUpdateManyMutationInput, FunctionsUncheckedUpdateManyInput>
    /**
     * Filter which Functions to update
     */
    where?: FunctionsWhereInput
  }

  /**
   * Functions upsert
   */
  export type FunctionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Functions
     */
    select?: FunctionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FunctionsInclude<ExtArgs> | null
    /**
     * The filter to search for the Functions to update in case it exists.
     */
    where: FunctionsWhereUniqueInput
    /**
     * In case the Functions found by the `where` argument doesn't exist, create a new Functions with this data.
     */
    create: XOR<FunctionsCreateInput, FunctionsUncheckedCreateInput>
    /**
     * In case the Functions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FunctionsUpdateInput, FunctionsUncheckedUpdateInput>
  }

  /**
   * Functions delete
   */
  export type FunctionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Functions
     */
    select?: FunctionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FunctionsInclude<ExtArgs> | null
    /**
     * Filter which Functions to delete.
     */
    where: FunctionsWhereUniqueInput
  }

  /**
   * Functions deleteMany
   */
  export type FunctionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Functions to delete
     */
    where?: FunctionsWhereInput
  }

  /**
   * Functions findRaw
   */
  export type FunctionsFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Functions aggregateRaw
   */
  export type FunctionsAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Functions.organization
   */
  export type Functions$organizationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    where?: OrganizationWhereInput
  }

  /**
   * Functions.entity
   */
  export type Functions$entityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entity
     */
    select?: EntitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntityInclude<ExtArgs> | null
    where?: EntityWhereInput
    orderBy?: EntityOrderByWithRelationInput | EntityOrderByWithRelationInput[]
    cursor?: EntityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EntityScalarFieldEnum | EntityScalarFieldEnum[]
  }

  /**
   * Functions without action
   */
  export type FunctionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Functions
     */
    select?: FunctionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FunctionsInclude<ExtArgs> | null
  }


  /**
   * Model Section
   */

  export type AggregateSection = {
    _count: SectionCountAggregateOutputType | null
    _min: SectionMinAggregateOutputType | null
    _max: SectionMaxAggregateOutputType | null
  }

  export type SectionMinAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
    organizationId: string | null
    deleted: boolean | null
  }

  export type SectionMaxAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
    organizationId: string | null
    deleted: boolean | null
  }

  export type SectionCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    organizationId: number
    deleted: number
    _all: number
  }


  export type SectionMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    organizationId?: true
    deleted?: true
  }

  export type SectionMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    organizationId?: true
    deleted?: true
  }

  export type SectionCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    organizationId?: true
    deleted?: true
    _all?: true
  }

  export type SectionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Section to aggregate.
     */
    where?: SectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sections to fetch.
     */
    orderBy?: SectionOrderByWithRelationInput | SectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sections
    **/
    _count?: true | SectionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SectionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SectionMaxAggregateInputType
  }

  export type GetSectionAggregateType<T extends SectionAggregateArgs> = {
        [P in keyof T & keyof AggregateSection]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSection[P]>
      : GetScalarType<T[P], AggregateSection[P]>
  }




  export type SectionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SectionWhereInput
    orderBy?: SectionOrderByWithAggregationInput | SectionOrderByWithAggregationInput[]
    by: SectionScalarFieldEnum[] | SectionScalarFieldEnum
    having?: SectionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SectionCountAggregateInputType | true
    _min?: SectionMinAggregateInputType
    _max?: SectionMaxAggregateInputType
  }

  export type SectionGroupByOutputType = {
    id: string
    name: string | null
    createdAt: Date
    createdBy: string | null
    updatedAt: Date
    updatedBy: string | null
    organizationId: string | null
    deleted: boolean | null
    _count: SectionCountAggregateOutputType | null
    _min: SectionMinAggregateOutputType | null
    _max: SectionMaxAggregateOutputType | null
  }

  type GetSectionGroupByPayload<T extends SectionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SectionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SectionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SectionGroupByOutputType[P]>
            : GetScalarType<T[P], SectionGroupByOutputType[P]>
        }
      >
    >


  export type SectionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    organizationId?: boolean
    deleted?: boolean
    organization?: boolean | Section$organizationArgs<ExtArgs>
  }, ExtArgs["result"]["section"]>


  export type SectionSelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    organizationId?: boolean
    deleted?: boolean
  }

  export type SectionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | Section$organizationArgs<ExtArgs>
  }

  export type $SectionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Section"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string | null
      createdAt: Date
      createdBy: string | null
      updatedAt: Date
      updatedBy: string | null
      organizationId: string | null
      deleted: boolean | null
    }, ExtArgs["result"]["section"]>
    composites: {}
  }

  type SectionGetPayload<S extends boolean | null | undefined | SectionDefaultArgs> = $Result.GetResult<Prisma.$SectionPayload, S>

  type SectionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SectionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SectionCountAggregateInputType | true
    }

  export interface SectionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Section'], meta: { name: 'Section' } }
    /**
     * Find zero or one Section that matches the filter.
     * @param {SectionFindUniqueArgs} args - Arguments to find a Section
     * @example
     * // Get one Section
     * const section = await prisma.section.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SectionFindUniqueArgs>(args: SelectSubset<T, SectionFindUniqueArgs<ExtArgs>>): Prisma__SectionClient<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Section that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SectionFindUniqueOrThrowArgs} args - Arguments to find a Section
     * @example
     * // Get one Section
     * const section = await prisma.section.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SectionFindUniqueOrThrowArgs>(args: SelectSubset<T, SectionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SectionClient<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Section that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionFindFirstArgs} args - Arguments to find a Section
     * @example
     * // Get one Section
     * const section = await prisma.section.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SectionFindFirstArgs>(args?: SelectSubset<T, SectionFindFirstArgs<ExtArgs>>): Prisma__SectionClient<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Section that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionFindFirstOrThrowArgs} args - Arguments to find a Section
     * @example
     * // Get one Section
     * const section = await prisma.section.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SectionFindFirstOrThrowArgs>(args?: SelectSubset<T, SectionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SectionClient<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Sections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sections
     * const sections = await prisma.section.findMany()
     * 
     * // Get first 10 Sections
     * const sections = await prisma.section.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sectionWithIdOnly = await prisma.section.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SectionFindManyArgs>(args?: SelectSubset<T, SectionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Section.
     * @param {SectionCreateArgs} args - Arguments to create a Section.
     * @example
     * // Create one Section
     * const Section = await prisma.section.create({
     *   data: {
     *     // ... data to create a Section
     *   }
     * })
     * 
     */
    create<T extends SectionCreateArgs>(args: SelectSubset<T, SectionCreateArgs<ExtArgs>>): Prisma__SectionClient<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Sections.
     * @param {SectionCreateManyArgs} args - Arguments to create many Sections.
     * @example
     * // Create many Sections
     * const section = await prisma.section.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SectionCreateManyArgs>(args?: SelectSubset<T, SectionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Section.
     * @param {SectionDeleteArgs} args - Arguments to delete one Section.
     * @example
     * // Delete one Section
     * const Section = await prisma.section.delete({
     *   where: {
     *     // ... filter to delete one Section
     *   }
     * })
     * 
     */
    delete<T extends SectionDeleteArgs>(args: SelectSubset<T, SectionDeleteArgs<ExtArgs>>): Prisma__SectionClient<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Section.
     * @param {SectionUpdateArgs} args - Arguments to update one Section.
     * @example
     * // Update one Section
     * const section = await prisma.section.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SectionUpdateArgs>(args: SelectSubset<T, SectionUpdateArgs<ExtArgs>>): Prisma__SectionClient<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Sections.
     * @param {SectionDeleteManyArgs} args - Arguments to filter Sections to delete.
     * @example
     * // Delete a few Sections
     * const { count } = await prisma.section.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SectionDeleteManyArgs>(args?: SelectSubset<T, SectionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sections
     * const section = await prisma.section.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SectionUpdateManyArgs>(args: SelectSubset<T, SectionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Section.
     * @param {SectionUpsertArgs} args - Arguments to update or create a Section.
     * @example
     * // Update or create a Section
     * const section = await prisma.section.upsert({
     *   create: {
     *     // ... data to create a Section
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Section we want to update
     *   }
     * })
     */
    upsert<T extends SectionUpsertArgs>(args: SelectSubset<T, SectionUpsertArgs<ExtArgs>>): Prisma__SectionClient<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Sections that matches the filter.
     * @param {SectionFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const section = await prisma.section.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: SectionFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Section.
     * @param {SectionAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const section = await prisma.section.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: SectionAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Sections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionCountArgs} args - Arguments to filter Sections to count.
     * @example
     * // Count the number of Sections
     * const count = await prisma.section.count({
     *   where: {
     *     // ... the filter for the Sections we want to count
     *   }
     * })
    **/
    count<T extends SectionCountArgs>(
      args?: Subset<T, SectionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SectionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Section.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SectionAggregateArgs>(args: Subset<T, SectionAggregateArgs>): Prisma.PrismaPromise<GetSectionAggregateType<T>>

    /**
     * Group by Section.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SectionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SectionGroupByArgs['orderBy'] }
        : { orderBy?: SectionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SectionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSectionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Section model
   */
  readonly fields: SectionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Section.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SectionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organization<T extends Section$organizationArgs<ExtArgs> = {}>(args?: Subset<T, Section$organizationArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Section model
   */ 
  interface SectionFieldRefs {
    readonly id: FieldRef<"Section", 'String'>
    readonly name: FieldRef<"Section", 'String'>
    readonly createdAt: FieldRef<"Section", 'DateTime'>
    readonly createdBy: FieldRef<"Section", 'String'>
    readonly updatedAt: FieldRef<"Section", 'DateTime'>
    readonly updatedBy: FieldRef<"Section", 'String'>
    readonly organizationId: FieldRef<"Section", 'String'>
    readonly deleted: FieldRef<"Section", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Section findUnique
   */
  export type SectionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
    /**
     * Filter, which Section to fetch.
     */
    where: SectionWhereUniqueInput
  }

  /**
   * Section findUniqueOrThrow
   */
  export type SectionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
    /**
     * Filter, which Section to fetch.
     */
    where: SectionWhereUniqueInput
  }

  /**
   * Section findFirst
   */
  export type SectionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
    /**
     * Filter, which Section to fetch.
     */
    where?: SectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sections to fetch.
     */
    orderBy?: SectionOrderByWithRelationInput | SectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sections.
     */
    cursor?: SectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sections.
     */
    distinct?: SectionScalarFieldEnum | SectionScalarFieldEnum[]
  }

  /**
   * Section findFirstOrThrow
   */
  export type SectionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
    /**
     * Filter, which Section to fetch.
     */
    where?: SectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sections to fetch.
     */
    orderBy?: SectionOrderByWithRelationInput | SectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sections.
     */
    cursor?: SectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sections.
     */
    distinct?: SectionScalarFieldEnum | SectionScalarFieldEnum[]
  }

  /**
   * Section findMany
   */
  export type SectionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
    /**
     * Filter, which Sections to fetch.
     */
    where?: SectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sections to fetch.
     */
    orderBy?: SectionOrderByWithRelationInput | SectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sections.
     */
    cursor?: SectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sections.
     */
    skip?: number
    distinct?: SectionScalarFieldEnum | SectionScalarFieldEnum[]
  }

  /**
   * Section create
   */
  export type SectionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
    /**
     * The data needed to create a Section.
     */
    data: XOR<SectionCreateInput, SectionUncheckedCreateInput>
  }

  /**
   * Section createMany
   */
  export type SectionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sections.
     */
    data: SectionCreateManyInput | SectionCreateManyInput[]
  }

  /**
   * Section update
   */
  export type SectionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
    /**
     * The data needed to update a Section.
     */
    data: XOR<SectionUpdateInput, SectionUncheckedUpdateInput>
    /**
     * Choose, which Section to update.
     */
    where: SectionWhereUniqueInput
  }

  /**
   * Section updateMany
   */
  export type SectionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sections.
     */
    data: XOR<SectionUpdateManyMutationInput, SectionUncheckedUpdateManyInput>
    /**
     * Filter which Sections to update
     */
    where?: SectionWhereInput
  }

  /**
   * Section upsert
   */
  export type SectionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
    /**
     * The filter to search for the Section to update in case it exists.
     */
    where: SectionWhereUniqueInput
    /**
     * In case the Section found by the `where` argument doesn't exist, create a new Section with this data.
     */
    create: XOR<SectionCreateInput, SectionUncheckedCreateInput>
    /**
     * In case the Section was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SectionUpdateInput, SectionUncheckedUpdateInput>
  }

  /**
   * Section delete
   */
  export type SectionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
    /**
     * Filter which Section to delete.
     */
    where: SectionWhereUniqueInput
  }

  /**
   * Section deleteMany
   */
  export type SectionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sections to delete
     */
    where?: SectionWhereInput
  }

  /**
   * Section findRaw
   */
  export type SectionFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Section aggregateRaw
   */
  export type SectionAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Section.organization
   */
  export type Section$organizationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    where?: OrganizationWhereInput
  }

  /**
   * Section without action
   */
  export type SectionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
  }


  /**
   * Model Location
   */

  export type AggregateLocation = {
    _count: LocationCountAggregateOutputType | null
    _min: LocationMinAggregateOutputType | null
    _max: LocationMaxAggregateOutputType | null
  }

  export type LocationMinAggregateOutputType = {
    id: string | null
    locationName: string | null
    locationType: string | null
    locationId: string | null
    description: string | null
    status: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
    updatedBy: string | null
    deleted: boolean | null
    organizationId: string | null
    businessTypeId: string | null
    type: string | null
  }

  export type LocationMaxAggregateOutputType = {
    id: string | null
    locationName: string | null
    locationType: string | null
    locationId: string | null
    description: string | null
    status: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
    updatedBy: string | null
    deleted: boolean | null
    organizationId: string | null
    businessTypeId: string | null
    type: string | null
  }

  export type LocationCountAggregateOutputType = {
    id: number
    locationName: number
    locationType: number
    locationId: number
    description: number
    status: number
    createdBy: number
    createdAt: number
    updatedAt: number
    updatedBy: number
    functionId: number
    deleted: number
    organizationId: number
    users: number
    businessTypeId: number
    type: number
    _all: number
  }


  export type LocationMinAggregateInputType = {
    id?: true
    locationName?: true
    locationType?: true
    locationId?: true
    description?: true
    status?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    updatedBy?: true
    deleted?: true
    organizationId?: true
    businessTypeId?: true
    type?: true
  }

  export type LocationMaxAggregateInputType = {
    id?: true
    locationName?: true
    locationType?: true
    locationId?: true
    description?: true
    status?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    updatedBy?: true
    deleted?: true
    organizationId?: true
    businessTypeId?: true
    type?: true
  }

  export type LocationCountAggregateInputType = {
    id?: true
    locationName?: true
    locationType?: true
    locationId?: true
    description?: true
    status?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    updatedBy?: true
    functionId?: true
    deleted?: true
    organizationId?: true
    users?: true
    businessTypeId?: true
    type?: true
    _all?: true
  }

  export type LocationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Location to aggregate.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Locations
    **/
    _count?: true | LocationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LocationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LocationMaxAggregateInputType
  }

  export type GetLocationAggregateType<T extends LocationAggregateArgs> = {
        [P in keyof T & keyof AggregateLocation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLocation[P]>
      : GetScalarType<T[P], AggregateLocation[P]>
  }




  export type LocationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LocationWhereInput
    orderBy?: LocationOrderByWithAggregationInput | LocationOrderByWithAggregationInput[]
    by: LocationScalarFieldEnum[] | LocationScalarFieldEnum
    having?: LocationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LocationCountAggregateInputType | true
    _min?: LocationMinAggregateInputType
    _max?: LocationMaxAggregateInputType
  }

  export type LocationGroupByOutputType = {
    id: string
    locationName: string | null
    locationType: string | null
    locationId: string | null
    description: string | null
    status: string | null
    createdBy: string | null
    createdAt: Date
    updatedAt: Date
    updatedBy: string | null
    functionId: string[]
    deleted: boolean | null
    organizationId: string | null
    users: JsonValue[]
    businessTypeId: string | null
    type: string | null
    _count: LocationCountAggregateOutputType | null
    _min: LocationMinAggregateOutputType | null
    _max: LocationMaxAggregateOutputType | null
  }

  type GetLocationGroupByPayload<T extends LocationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LocationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LocationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LocationGroupByOutputType[P]>
            : GetScalarType<T[P], LocationGroupByOutputType[P]>
        }
      >
    >


  export type LocationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    locationName?: boolean
    locationType?: boolean
    locationId?: boolean
    description?: boolean
    status?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    functionId?: boolean
    deleted?: boolean
    organizationId?: boolean
    users?: boolean
    businessTypeId?: boolean
    type?: boolean
    organization?: boolean | Location$organizationArgs<ExtArgs>
    Documents?: boolean | Location$DocumentsArgs<ExtArgs>
    entity?: boolean | Location$entityArgs<ExtArgs>
    business?: boolean | Location$businessArgs<ExtArgs>
    user?: boolean | Location$userArgs<ExtArgs>
    uom?: boolean | Location$uomArgs<ExtArgs>
    rolesTable?: boolean | Location$rolesTableArgs<ExtArgs>
    Role?: boolean | Location$RoleArgs<ExtArgs>
    _count?: boolean | LocationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["location"]>


  export type LocationSelectScalar = {
    id?: boolean
    locationName?: boolean
    locationType?: boolean
    locationId?: boolean
    description?: boolean
    status?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    functionId?: boolean
    deleted?: boolean
    organizationId?: boolean
    users?: boolean
    businessTypeId?: boolean
    type?: boolean
  }

  export type LocationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | Location$organizationArgs<ExtArgs>
    Documents?: boolean | Location$DocumentsArgs<ExtArgs>
    entity?: boolean | Location$entityArgs<ExtArgs>
    business?: boolean | Location$businessArgs<ExtArgs>
    user?: boolean | Location$userArgs<ExtArgs>
    uom?: boolean | Location$uomArgs<ExtArgs>
    rolesTable?: boolean | Location$rolesTableArgs<ExtArgs>
    Role?: boolean | Location$RoleArgs<ExtArgs>
    _count?: boolean | LocationCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $LocationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Location"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs> | null
      Documents: Prisma.$DocumentsPayload<ExtArgs>[]
      entity: Prisma.$EntityPayload<ExtArgs>[]
      business: Prisma.$LocationBusinessPayload<ExtArgs>[]
      user: Prisma.$UserPayload<ExtArgs>[]
      uom: Prisma.$unitTypePayload<ExtArgs>[]
      rolesTable: Prisma.$rolesTablePayload<ExtArgs>[]
      Role: Prisma.$RolePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      locationName: string | null
      locationType: string | null
      locationId: string | null
      description: string | null
      status: string | null
      createdBy: string | null
      createdAt: Date
      updatedAt: Date
      updatedBy: string | null
      functionId: string[]
      deleted: boolean | null
      organizationId: string | null
      users: Prisma.JsonValue[]
      businessTypeId: string | null
      type: string | null
    }, ExtArgs["result"]["location"]>
    composites: {}
  }

  type LocationGetPayload<S extends boolean | null | undefined | LocationDefaultArgs> = $Result.GetResult<Prisma.$LocationPayload, S>

  type LocationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LocationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LocationCountAggregateInputType | true
    }

  export interface LocationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Location'], meta: { name: 'Location' } }
    /**
     * Find zero or one Location that matches the filter.
     * @param {LocationFindUniqueArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LocationFindUniqueArgs>(args: SelectSubset<T, LocationFindUniqueArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Location that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LocationFindUniqueOrThrowArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LocationFindUniqueOrThrowArgs>(args: SelectSubset<T, LocationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Location that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationFindFirstArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LocationFindFirstArgs>(args?: SelectSubset<T, LocationFindFirstArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Location that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationFindFirstOrThrowArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LocationFindFirstOrThrowArgs>(args?: SelectSubset<T, LocationFindFirstOrThrowArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Locations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Locations
     * const locations = await prisma.location.findMany()
     * 
     * // Get first 10 Locations
     * const locations = await prisma.location.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const locationWithIdOnly = await prisma.location.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LocationFindManyArgs>(args?: SelectSubset<T, LocationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Location.
     * @param {LocationCreateArgs} args - Arguments to create a Location.
     * @example
     * // Create one Location
     * const Location = await prisma.location.create({
     *   data: {
     *     // ... data to create a Location
     *   }
     * })
     * 
     */
    create<T extends LocationCreateArgs>(args: SelectSubset<T, LocationCreateArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Locations.
     * @param {LocationCreateManyArgs} args - Arguments to create many Locations.
     * @example
     * // Create many Locations
     * const location = await prisma.location.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LocationCreateManyArgs>(args?: SelectSubset<T, LocationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Location.
     * @param {LocationDeleteArgs} args - Arguments to delete one Location.
     * @example
     * // Delete one Location
     * const Location = await prisma.location.delete({
     *   where: {
     *     // ... filter to delete one Location
     *   }
     * })
     * 
     */
    delete<T extends LocationDeleteArgs>(args: SelectSubset<T, LocationDeleteArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Location.
     * @param {LocationUpdateArgs} args - Arguments to update one Location.
     * @example
     * // Update one Location
     * const location = await prisma.location.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LocationUpdateArgs>(args: SelectSubset<T, LocationUpdateArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Locations.
     * @param {LocationDeleteManyArgs} args - Arguments to filter Locations to delete.
     * @example
     * // Delete a few Locations
     * const { count } = await prisma.location.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LocationDeleteManyArgs>(args?: SelectSubset<T, LocationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Locations
     * const location = await prisma.location.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LocationUpdateManyArgs>(args: SelectSubset<T, LocationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Location.
     * @param {LocationUpsertArgs} args - Arguments to update or create a Location.
     * @example
     * // Update or create a Location
     * const location = await prisma.location.upsert({
     *   create: {
     *     // ... data to create a Location
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Location we want to update
     *   }
     * })
     */
    upsert<T extends LocationUpsertArgs>(args: SelectSubset<T, LocationUpsertArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Locations that matches the filter.
     * @param {LocationFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const location = await prisma.location.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: LocationFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Location.
     * @param {LocationAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const location = await prisma.location.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: LocationAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationCountArgs} args - Arguments to filter Locations to count.
     * @example
     * // Count the number of Locations
     * const count = await prisma.location.count({
     *   where: {
     *     // ... the filter for the Locations we want to count
     *   }
     * })
    **/
    count<T extends LocationCountArgs>(
      args?: Subset<T, LocationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LocationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Location.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LocationAggregateArgs>(args: Subset<T, LocationAggregateArgs>): Prisma.PrismaPromise<GetLocationAggregateType<T>>

    /**
     * Group by Location.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LocationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LocationGroupByArgs['orderBy'] }
        : { orderBy?: LocationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LocationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLocationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Location model
   */
  readonly fields: LocationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Location.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LocationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organization<T extends Location$organizationArgs<ExtArgs> = {}>(args?: Subset<T, Location$organizationArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    Documents<T extends Location$DocumentsArgs<ExtArgs> = {}>(args?: Subset<T, Location$DocumentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentsPayload<ExtArgs>, T, "findMany"> | Null>
    entity<T extends Location$entityArgs<ExtArgs> = {}>(args?: Subset<T, Location$entityArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EntityPayload<ExtArgs>, T, "findMany"> | Null>
    business<T extends Location$businessArgs<ExtArgs> = {}>(args?: Subset<T, Location$businessArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationBusinessPayload<ExtArgs>, T, "findMany"> | Null>
    user<T extends Location$userArgs<ExtArgs> = {}>(args?: Subset<T, Location$userArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany"> | Null>
    uom<T extends Location$uomArgs<ExtArgs> = {}>(args?: Subset<T, Location$uomArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$unitTypePayload<ExtArgs>, T, "findMany"> | Null>
    rolesTable<T extends Location$rolesTableArgs<ExtArgs> = {}>(args?: Subset<T, Location$rolesTableArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rolesTablePayload<ExtArgs>, T, "findMany"> | Null>
    Role<T extends Location$RoleArgs<ExtArgs> = {}>(args?: Subset<T, Location$RoleArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Location model
   */ 
  interface LocationFieldRefs {
    readonly id: FieldRef<"Location", 'String'>
    readonly locationName: FieldRef<"Location", 'String'>
    readonly locationType: FieldRef<"Location", 'String'>
    readonly locationId: FieldRef<"Location", 'String'>
    readonly description: FieldRef<"Location", 'String'>
    readonly status: FieldRef<"Location", 'String'>
    readonly createdBy: FieldRef<"Location", 'String'>
    readonly createdAt: FieldRef<"Location", 'DateTime'>
    readonly updatedAt: FieldRef<"Location", 'DateTime'>
    readonly updatedBy: FieldRef<"Location", 'String'>
    readonly functionId: FieldRef<"Location", 'String[]'>
    readonly deleted: FieldRef<"Location", 'Boolean'>
    readonly organizationId: FieldRef<"Location", 'String'>
    readonly users: FieldRef<"Location", 'Json[]'>
    readonly businessTypeId: FieldRef<"Location", 'String'>
    readonly type: FieldRef<"Location", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Location findUnique
   */
  export type LocationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location findUniqueOrThrow
   */
  export type LocationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location findFirst
   */
  export type LocationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Locations.
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Locations.
     */
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Location findFirstOrThrow
   */
  export type LocationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Locations.
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Locations.
     */
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Location findMany
   */
  export type LocationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Locations to fetch.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Locations.
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Location create
   */
  export type LocationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * The data needed to create a Location.
     */
    data: XOR<LocationCreateInput, LocationUncheckedCreateInput>
  }

  /**
   * Location createMany
   */
  export type LocationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Locations.
     */
    data: LocationCreateManyInput | LocationCreateManyInput[]
  }

  /**
   * Location update
   */
  export type LocationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * The data needed to update a Location.
     */
    data: XOR<LocationUpdateInput, LocationUncheckedUpdateInput>
    /**
     * Choose, which Location to update.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location updateMany
   */
  export type LocationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Locations.
     */
    data: XOR<LocationUpdateManyMutationInput, LocationUncheckedUpdateManyInput>
    /**
     * Filter which Locations to update
     */
    where?: LocationWhereInput
  }

  /**
   * Location upsert
   */
  export type LocationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * The filter to search for the Location to update in case it exists.
     */
    where: LocationWhereUniqueInput
    /**
     * In case the Location found by the `where` argument doesn't exist, create a new Location with this data.
     */
    create: XOR<LocationCreateInput, LocationUncheckedCreateInput>
    /**
     * In case the Location was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LocationUpdateInput, LocationUncheckedUpdateInput>
  }

  /**
   * Location delete
   */
  export type LocationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter which Location to delete.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location deleteMany
   */
  export type LocationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Locations to delete
     */
    where?: LocationWhereInput
  }

  /**
   * Location findRaw
   */
  export type LocationFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Location aggregateRaw
   */
  export type LocationAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Location.organization
   */
  export type Location$organizationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    where?: OrganizationWhereInput
  }

  /**
   * Location.Documents
   */
  export type Location$DocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Documents
     */
    select?: DocumentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentsInclude<ExtArgs> | null
    where?: DocumentsWhereInput
    orderBy?: DocumentsOrderByWithRelationInput | DocumentsOrderByWithRelationInput[]
    cursor?: DocumentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentsScalarFieldEnum | DocumentsScalarFieldEnum[]
  }

  /**
   * Location.entity
   */
  export type Location$entityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entity
     */
    select?: EntitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntityInclude<ExtArgs> | null
    where?: EntityWhereInput
    orderBy?: EntityOrderByWithRelationInput | EntityOrderByWithRelationInput[]
    cursor?: EntityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EntityScalarFieldEnum | EntityScalarFieldEnum[]
  }

  /**
   * Location.business
   */
  export type Location$businessArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationBusiness
     */
    select?: LocationBusinessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationBusinessInclude<ExtArgs> | null
    where?: LocationBusinessWhereInput
    orderBy?: LocationBusinessOrderByWithRelationInput | LocationBusinessOrderByWithRelationInput[]
    cursor?: LocationBusinessWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LocationBusinessScalarFieldEnum | LocationBusinessScalarFieldEnum[]
  }

  /**
   * Location.user
   */
  export type Location$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Location.uom
   */
  export type Location$uomArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the unitType
     */
    select?: unitTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: unitTypeInclude<ExtArgs> | null
    where?: unitTypeWhereInput
    orderBy?: unitTypeOrderByWithRelationInput | unitTypeOrderByWithRelationInput[]
    cursor?: unitTypeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UnitTypeScalarFieldEnum | UnitTypeScalarFieldEnum[]
  }

  /**
   * Location.rolesTable
   */
  export type Location$rolesTableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rolesTable
     */
    select?: rolesTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesTableInclude<ExtArgs> | null
    where?: rolesTableWhereInput
    orderBy?: rolesTableOrderByWithRelationInput | rolesTableOrderByWithRelationInput[]
    cursor?: rolesTableWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RolesTableScalarFieldEnum | RolesTableScalarFieldEnum[]
  }

  /**
   * Location.Role
   */
  export type Location$RoleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    where?: RoleWhereInput
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    cursor?: RoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Location without action
   */
  export type LocationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
  }


  /**
   * Model Entity
   */

  export type AggregateEntity = {
    _count: EntityCountAggregateOutputType | null
    _min: EntityMinAggregateOutputType | null
    _max: EntityMaxAggregateOutputType | null
  }

  export type EntityMinAggregateOutputType = {
    id: string | null
    entityName: string | null
    description: string | null
    entityTypeId: string | null
    organizationId: string | null
    locationId: string | null
    createdBy: string | null
    entityId: string | null
    deleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    updatedBy: string | null
    functionId: string | null
  }

  export type EntityMaxAggregateOutputType = {
    id: string | null
    entityName: string | null
    description: string | null
    entityTypeId: string | null
    organizationId: string | null
    locationId: string | null
    createdBy: string | null
    entityId: string | null
    deleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    updatedBy: string | null
    functionId: string | null
  }

  export type EntityCountAggregateOutputType = {
    id: number
    entityName: number
    description: number
    entityTypeId: number
    organizationId: number
    locationId: number
    createdBy: number
    entityId: number
    deleted: number
    createdAt: number
    updatedAt: number
    updatedBy: number
    users: number
    sections: number
    functionId: number
    _all: number
  }


  export type EntityMinAggregateInputType = {
    id?: true
    entityName?: true
    description?: true
    entityTypeId?: true
    organizationId?: true
    locationId?: true
    createdBy?: true
    entityId?: true
    deleted?: true
    createdAt?: true
    updatedAt?: true
    updatedBy?: true
    functionId?: true
  }

  export type EntityMaxAggregateInputType = {
    id?: true
    entityName?: true
    description?: true
    entityTypeId?: true
    organizationId?: true
    locationId?: true
    createdBy?: true
    entityId?: true
    deleted?: true
    createdAt?: true
    updatedAt?: true
    updatedBy?: true
    functionId?: true
  }

  export type EntityCountAggregateInputType = {
    id?: true
    entityName?: true
    description?: true
    entityTypeId?: true
    organizationId?: true
    locationId?: true
    createdBy?: true
    entityId?: true
    deleted?: true
    createdAt?: true
    updatedAt?: true
    updatedBy?: true
    users?: true
    sections?: true
    functionId?: true
    _all?: true
  }

  export type EntityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Entity to aggregate.
     */
    where?: EntityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Entities to fetch.
     */
    orderBy?: EntityOrderByWithRelationInput | EntityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EntityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Entities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Entities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Entities
    **/
    _count?: true | EntityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EntityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EntityMaxAggregateInputType
  }

  export type GetEntityAggregateType<T extends EntityAggregateArgs> = {
        [P in keyof T & keyof AggregateEntity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEntity[P]>
      : GetScalarType<T[P], AggregateEntity[P]>
  }




  export type EntityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EntityWhereInput
    orderBy?: EntityOrderByWithAggregationInput | EntityOrderByWithAggregationInput[]
    by: EntityScalarFieldEnum[] | EntityScalarFieldEnum
    having?: EntityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EntityCountAggregateInputType | true
    _min?: EntityMinAggregateInputType
    _max?: EntityMaxAggregateInputType
  }

  export type EntityGroupByOutputType = {
    id: string
    entityName: string | null
    description: string | null
    entityTypeId: string | null
    organizationId: string | null
    locationId: string | null
    createdBy: string | null
    entityId: string | null
    deleted: boolean | null
    createdAt: Date
    updatedAt: Date
    updatedBy: string | null
    users: string[]
    sections: string[]
    functionId: string | null
    _count: EntityCountAggregateOutputType | null
    _min: EntityMinAggregateOutputType | null
    _max: EntityMaxAggregateOutputType | null
  }

  type GetEntityGroupByPayload<T extends EntityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EntityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EntityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EntityGroupByOutputType[P]>
            : GetScalarType<T[P], EntityGroupByOutputType[P]>
        }
      >
    >


  export type EntitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entityName?: boolean
    description?: boolean
    entityTypeId?: boolean
    organizationId?: boolean
    locationId?: boolean
    createdBy?: boolean
    entityId?: boolean
    deleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    users?: boolean
    sections?: boolean
    functionId?: boolean
    entityType?: boolean | Entity$entityTypeArgs<ExtArgs>
    location?: boolean | Entity$locationArgs<ExtArgs>
    organization?: boolean | Entity$organizationArgs<ExtArgs>
    Doctype?: boolean | Entity$DoctypeArgs<ExtArgs>
    Documents?: boolean | Entity$DocumentsArgs<ExtArgs>
    user?: boolean | Entity$userArgs<ExtArgs>
    parts?: boolean | Entity$partsArgs<ExtArgs>
    claimToEntity?: boolean | Entity$claimToEntityArgs<ExtArgs>
    function?: boolean | Entity$functionArgs<ExtArgs>
    _count?: boolean | EntityCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["entity"]>


  export type EntitySelectScalar = {
    id?: boolean
    entityName?: boolean
    description?: boolean
    entityTypeId?: boolean
    organizationId?: boolean
    locationId?: boolean
    createdBy?: boolean
    entityId?: boolean
    deleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    users?: boolean
    sections?: boolean
    functionId?: boolean
  }

  export type EntityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    entityType?: boolean | Entity$entityTypeArgs<ExtArgs>
    location?: boolean | Entity$locationArgs<ExtArgs>
    organization?: boolean | Entity$organizationArgs<ExtArgs>
    Doctype?: boolean | Entity$DoctypeArgs<ExtArgs>
    Documents?: boolean | Entity$DocumentsArgs<ExtArgs>
    user?: boolean | Entity$userArgs<ExtArgs>
    parts?: boolean | Entity$partsArgs<ExtArgs>
    claimToEntity?: boolean | Entity$claimToEntityArgs<ExtArgs>
    function?: boolean | Entity$functionArgs<ExtArgs>
    _count?: boolean | EntityCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $EntityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Entity"
    objects: {
      entityType: Prisma.$EntityTypePayload<ExtArgs> | null
      location: Prisma.$LocationPayload<ExtArgs> | null
      organization: Prisma.$OrganizationPayload<ExtArgs> | null
      Doctype: Prisma.$DoctypePayload<ExtArgs>[]
      Documents: Prisma.$DocumentsPayload<ExtArgs>[]
      user: Prisma.$UserPayload<ExtArgs>[]
      parts: Prisma.$PartsPayload<ExtArgs>[]
      claimToEntity: Prisma.$ClaimToEntityPayload<ExtArgs>[]
      function: Prisma.$FunctionsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      entityName: string | null
      description: string | null
      entityTypeId: string | null
      organizationId: string | null
      locationId: string | null
      createdBy: string | null
      entityId: string | null
      deleted: boolean | null
      createdAt: Date
      updatedAt: Date
      updatedBy: string | null
      users: string[]
      sections: string[]
      functionId: string | null
    }, ExtArgs["result"]["entity"]>
    composites: {}
  }

  type EntityGetPayload<S extends boolean | null | undefined | EntityDefaultArgs> = $Result.GetResult<Prisma.$EntityPayload, S>

  type EntityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EntityFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EntityCountAggregateInputType | true
    }

  export interface EntityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Entity'], meta: { name: 'Entity' } }
    /**
     * Find zero or one Entity that matches the filter.
     * @param {EntityFindUniqueArgs} args - Arguments to find a Entity
     * @example
     * // Get one Entity
     * const entity = await prisma.entity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EntityFindUniqueArgs>(args: SelectSubset<T, EntityFindUniqueArgs<ExtArgs>>): Prisma__EntityClient<$Result.GetResult<Prisma.$EntityPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Entity that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EntityFindUniqueOrThrowArgs} args - Arguments to find a Entity
     * @example
     * // Get one Entity
     * const entity = await prisma.entity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EntityFindUniqueOrThrowArgs>(args: SelectSubset<T, EntityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EntityClient<$Result.GetResult<Prisma.$EntityPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Entity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntityFindFirstArgs} args - Arguments to find a Entity
     * @example
     * // Get one Entity
     * const entity = await prisma.entity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EntityFindFirstArgs>(args?: SelectSubset<T, EntityFindFirstArgs<ExtArgs>>): Prisma__EntityClient<$Result.GetResult<Prisma.$EntityPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Entity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntityFindFirstOrThrowArgs} args - Arguments to find a Entity
     * @example
     * // Get one Entity
     * const entity = await prisma.entity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EntityFindFirstOrThrowArgs>(args?: SelectSubset<T, EntityFindFirstOrThrowArgs<ExtArgs>>): Prisma__EntityClient<$Result.GetResult<Prisma.$EntityPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Entities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Entities
     * const entities = await prisma.entity.findMany()
     * 
     * // Get first 10 Entities
     * const entities = await prisma.entity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const entityWithIdOnly = await prisma.entity.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EntityFindManyArgs>(args?: SelectSubset<T, EntityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EntityPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Entity.
     * @param {EntityCreateArgs} args - Arguments to create a Entity.
     * @example
     * // Create one Entity
     * const Entity = await prisma.entity.create({
     *   data: {
     *     // ... data to create a Entity
     *   }
     * })
     * 
     */
    create<T extends EntityCreateArgs>(args: SelectSubset<T, EntityCreateArgs<ExtArgs>>): Prisma__EntityClient<$Result.GetResult<Prisma.$EntityPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Entities.
     * @param {EntityCreateManyArgs} args - Arguments to create many Entities.
     * @example
     * // Create many Entities
     * const entity = await prisma.entity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EntityCreateManyArgs>(args?: SelectSubset<T, EntityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Entity.
     * @param {EntityDeleteArgs} args - Arguments to delete one Entity.
     * @example
     * // Delete one Entity
     * const Entity = await prisma.entity.delete({
     *   where: {
     *     // ... filter to delete one Entity
     *   }
     * })
     * 
     */
    delete<T extends EntityDeleteArgs>(args: SelectSubset<T, EntityDeleteArgs<ExtArgs>>): Prisma__EntityClient<$Result.GetResult<Prisma.$EntityPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Entity.
     * @param {EntityUpdateArgs} args - Arguments to update one Entity.
     * @example
     * // Update one Entity
     * const entity = await prisma.entity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EntityUpdateArgs>(args: SelectSubset<T, EntityUpdateArgs<ExtArgs>>): Prisma__EntityClient<$Result.GetResult<Prisma.$EntityPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Entities.
     * @param {EntityDeleteManyArgs} args - Arguments to filter Entities to delete.
     * @example
     * // Delete a few Entities
     * const { count } = await prisma.entity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EntityDeleteManyArgs>(args?: SelectSubset<T, EntityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Entities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Entities
     * const entity = await prisma.entity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EntityUpdateManyArgs>(args: SelectSubset<T, EntityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Entity.
     * @param {EntityUpsertArgs} args - Arguments to update or create a Entity.
     * @example
     * // Update or create a Entity
     * const entity = await prisma.entity.upsert({
     *   create: {
     *     // ... data to create a Entity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Entity we want to update
     *   }
     * })
     */
    upsert<T extends EntityUpsertArgs>(args: SelectSubset<T, EntityUpsertArgs<ExtArgs>>): Prisma__EntityClient<$Result.GetResult<Prisma.$EntityPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Entities that matches the filter.
     * @param {EntityFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const entity = await prisma.entity.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: EntityFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Entity.
     * @param {EntityAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const entity = await prisma.entity.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: EntityAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Entities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntityCountArgs} args - Arguments to filter Entities to count.
     * @example
     * // Count the number of Entities
     * const count = await prisma.entity.count({
     *   where: {
     *     // ... the filter for the Entities we want to count
     *   }
     * })
    **/
    count<T extends EntityCountArgs>(
      args?: Subset<T, EntityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EntityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Entity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EntityAggregateArgs>(args: Subset<T, EntityAggregateArgs>): Prisma.PrismaPromise<GetEntityAggregateType<T>>

    /**
     * Group by Entity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EntityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EntityGroupByArgs['orderBy'] }
        : { orderBy?: EntityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EntityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEntityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Entity model
   */
  readonly fields: EntityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Entity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EntityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    entityType<T extends Entity$entityTypeArgs<ExtArgs> = {}>(args?: Subset<T, Entity$entityTypeArgs<ExtArgs>>): Prisma__EntityTypeClient<$Result.GetResult<Prisma.$EntityTypePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    location<T extends Entity$locationArgs<ExtArgs> = {}>(args?: Subset<T, Entity$locationArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    organization<T extends Entity$organizationArgs<ExtArgs> = {}>(args?: Subset<T, Entity$organizationArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    Doctype<T extends Entity$DoctypeArgs<ExtArgs> = {}>(args?: Subset<T, Entity$DoctypeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DoctypePayload<ExtArgs>, T, "findMany"> | Null>
    Documents<T extends Entity$DocumentsArgs<ExtArgs> = {}>(args?: Subset<T, Entity$DocumentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentsPayload<ExtArgs>, T, "findMany"> | Null>
    user<T extends Entity$userArgs<ExtArgs> = {}>(args?: Subset<T, Entity$userArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany"> | Null>
    parts<T extends Entity$partsArgs<ExtArgs> = {}>(args?: Subset<T, Entity$partsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PartsPayload<ExtArgs>, T, "findMany"> | Null>
    claimToEntity<T extends Entity$claimToEntityArgs<ExtArgs> = {}>(args?: Subset<T, Entity$claimToEntityArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClaimToEntityPayload<ExtArgs>, T, "findMany"> | Null>
    function<T extends Entity$functionArgs<ExtArgs> = {}>(args?: Subset<T, Entity$functionArgs<ExtArgs>>): Prisma__FunctionsClient<$Result.GetResult<Prisma.$FunctionsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Entity model
   */ 
  interface EntityFieldRefs {
    readonly id: FieldRef<"Entity", 'String'>
    readonly entityName: FieldRef<"Entity", 'String'>
    readonly description: FieldRef<"Entity", 'String'>
    readonly entityTypeId: FieldRef<"Entity", 'String'>
    readonly organizationId: FieldRef<"Entity", 'String'>
    readonly locationId: FieldRef<"Entity", 'String'>
    readonly createdBy: FieldRef<"Entity", 'String'>
    readonly entityId: FieldRef<"Entity", 'String'>
    readonly deleted: FieldRef<"Entity", 'Boolean'>
    readonly createdAt: FieldRef<"Entity", 'DateTime'>
    readonly updatedAt: FieldRef<"Entity", 'DateTime'>
    readonly updatedBy: FieldRef<"Entity", 'String'>
    readonly users: FieldRef<"Entity", 'String[]'>
    readonly sections: FieldRef<"Entity", 'String[]'>
    readonly functionId: FieldRef<"Entity", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Entity findUnique
   */
  export type EntityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entity
     */
    select?: EntitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntityInclude<ExtArgs> | null
    /**
     * Filter, which Entity to fetch.
     */
    where: EntityWhereUniqueInput
  }

  /**
   * Entity findUniqueOrThrow
   */
  export type EntityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entity
     */
    select?: EntitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntityInclude<ExtArgs> | null
    /**
     * Filter, which Entity to fetch.
     */
    where: EntityWhereUniqueInput
  }

  /**
   * Entity findFirst
   */
  export type EntityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entity
     */
    select?: EntitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntityInclude<ExtArgs> | null
    /**
     * Filter, which Entity to fetch.
     */
    where?: EntityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Entities to fetch.
     */
    orderBy?: EntityOrderByWithRelationInput | EntityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Entities.
     */
    cursor?: EntityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Entities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Entities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Entities.
     */
    distinct?: EntityScalarFieldEnum | EntityScalarFieldEnum[]
  }

  /**
   * Entity findFirstOrThrow
   */
  export type EntityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entity
     */
    select?: EntitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntityInclude<ExtArgs> | null
    /**
     * Filter, which Entity to fetch.
     */
    where?: EntityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Entities to fetch.
     */
    orderBy?: EntityOrderByWithRelationInput | EntityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Entities.
     */
    cursor?: EntityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Entities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Entities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Entities.
     */
    distinct?: EntityScalarFieldEnum | EntityScalarFieldEnum[]
  }

  /**
   * Entity findMany
   */
  export type EntityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entity
     */
    select?: EntitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntityInclude<ExtArgs> | null
    /**
     * Filter, which Entities to fetch.
     */
    where?: EntityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Entities to fetch.
     */
    orderBy?: EntityOrderByWithRelationInput | EntityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Entities.
     */
    cursor?: EntityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Entities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Entities.
     */
    skip?: number
    distinct?: EntityScalarFieldEnum | EntityScalarFieldEnum[]
  }

  /**
   * Entity create
   */
  export type EntityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entity
     */
    select?: EntitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntityInclude<ExtArgs> | null
    /**
     * The data needed to create a Entity.
     */
    data: XOR<EntityCreateInput, EntityUncheckedCreateInput>
  }

  /**
   * Entity createMany
   */
  export type EntityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Entities.
     */
    data: EntityCreateManyInput | EntityCreateManyInput[]
  }

  /**
   * Entity update
   */
  export type EntityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entity
     */
    select?: EntitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntityInclude<ExtArgs> | null
    /**
     * The data needed to update a Entity.
     */
    data: XOR<EntityUpdateInput, EntityUncheckedUpdateInput>
    /**
     * Choose, which Entity to update.
     */
    where: EntityWhereUniqueInput
  }

  /**
   * Entity updateMany
   */
  export type EntityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Entities.
     */
    data: XOR<EntityUpdateManyMutationInput, EntityUncheckedUpdateManyInput>
    /**
     * Filter which Entities to update
     */
    where?: EntityWhereInput
  }

  /**
   * Entity upsert
   */
  export type EntityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entity
     */
    select?: EntitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntityInclude<ExtArgs> | null
    /**
     * The filter to search for the Entity to update in case it exists.
     */
    where: EntityWhereUniqueInput
    /**
     * In case the Entity found by the `where` argument doesn't exist, create a new Entity with this data.
     */
    create: XOR<EntityCreateInput, EntityUncheckedCreateInput>
    /**
     * In case the Entity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EntityUpdateInput, EntityUncheckedUpdateInput>
  }

  /**
   * Entity delete
   */
  export type EntityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entity
     */
    select?: EntitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntityInclude<ExtArgs> | null
    /**
     * Filter which Entity to delete.
     */
    where: EntityWhereUniqueInput
  }

  /**
   * Entity deleteMany
   */
  export type EntityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Entities to delete
     */
    where?: EntityWhereInput
  }

  /**
   * Entity findRaw
   */
  export type EntityFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Entity aggregateRaw
   */
  export type EntityAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Entity.entityType
   */
  export type Entity$entityTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntityType
     */
    select?: EntityTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntityTypeInclude<ExtArgs> | null
    where?: EntityTypeWhereInput
  }

  /**
   * Entity.location
   */
  export type Entity$locationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    where?: LocationWhereInput
  }

  /**
   * Entity.organization
   */
  export type Entity$organizationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    where?: OrganizationWhereInput
  }

  /**
   * Entity.Doctype
   */
  export type Entity$DoctypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctype
     */
    select?: DoctypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctypeInclude<ExtArgs> | null
    where?: DoctypeWhereInput
    orderBy?: DoctypeOrderByWithRelationInput | DoctypeOrderByWithRelationInput[]
    cursor?: DoctypeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DoctypeScalarFieldEnum | DoctypeScalarFieldEnum[]
  }

  /**
   * Entity.Documents
   */
  export type Entity$DocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Documents
     */
    select?: DocumentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentsInclude<ExtArgs> | null
    where?: DocumentsWhereInput
    orderBy?: DocumentsOrderByWithRelationInput | DocumentsOrderByWithRelationInput[]
    cursor?: DocumentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentsScalarFieldEnum | DocumentsScalarFieldEnum[]
  }

  /**
   * Entity.user
   */
  export type Entity$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Entity.parts
   */
  export type Entity$partsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parts
     */
    select?: PartsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartsInclude<ExtArgs> | null
    where?: PartsWhereInput
    orderBy?: PartsOrderByWithRelationInput | PartsOrderByWithRelationInput[]
    cursor?: PartsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PartsScalarFieldEnum | PartsScalarFieldEnum[]
  }

  /**
   * Entity.claimToEntity
   */
  export type Entity$claimToEntityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClaimToEntity
     */
    select?: ClaimToEntitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaimToEntityInclude<ExtArgs> | null
    where?: ClaimToEntityWhereInput
    orderBy?: ClaimToEntityOrderByWithRelationInput | ClaimToEntityOrderByWithRelationInput[]
    cursor?: ClaimToEntityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClaimToEntityScalarFieldEnum | ClaimToEntityScalarFieldEnum[]
  }

  /**
   * Entity.function
   */
  export type Entity$functionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Functions
     */
    select?: FunctionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FunctionsInclude<ExtArgs> | null
    where?: FunctionsWhereInput
  }

  /**
   * Entity without action
   */
  export type EntityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entity
     */
    select?: EntitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntityInclude<ExtArgs> | null
  }


  /**
   * Model LocationBusiness
   */

  export type AggregateLocationBusiness = {
    _count: LocationBusinessCountAggregateOutputType | null
    _min: LocationBusinessMinAggregateOutputType | null
    _max: LocationBusinessMaxAggregateOutputType | null
  }

  export type LocationBusinessMinAggregateOutputType = {
    id: string | null
    locationId: string | null
    businessId: string | null
  }

  export type LocationBusinessMaxAggregateOutputType = {
    id: string | null
    locationId: string | null
    businessId: string | null
  }

  export type LocationBusinessCountAggregateOutputType = {
    id: number
    locationId: number
    businessId: number
    _all: number
  }


  export type LocationBusinessMinAggregateInputType = {
    id?: true
    locationId?: true
    businessId?: true
  }

  export type LocationBusinessMaxAggregateInputType = {
    id?: true
    locationId?: true
    businessId?: true
  }

  export type LocationBusinessCountAggregateInputType = {
    id?: true
    locationId?: true
    businessId?: true
    _all?: true
  }

  export type LocationBusinessAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LocationBusiness to aggregate.
     */
    where?: LocationBusinessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LocationBusinesses to fetch.
     */
    orderBy?: LocationBusinessOrderByWithRelationInput | LocationBusinessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LocationBusinessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LocationBusinesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LocationBusinesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LocationBusinesses
    **/
    _count?: true | LocationBusinessCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LocationBusinessMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LocationBusinessMaxAggregateInputType
  }

  export type GetLocationBusinessAggregateType<T extends LocationBusinessAggregateArgs> = {
        [P in keyof T & keyof AggregateLocationBusiness]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLocationBusiness[P]>
      : GetScalarType<T[P], AggregateLocationBusiness[P]>
  }




  export type LocationBusinessGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LocationBusinessWhereInput
    orderBy?: LocationBusinessOrderByWithAggregationInput | LocationBusinessOrderByWithAggregationInput[]
    by: LocationBusinessScalarFieldEnum[] | LocationBusinessScalarFieldEnum
    having?: LocationBusinessScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LocationBusinessCountAggregateInputType | true
    _min?: LocationBusinessMinAggregateInputType
    _max?: LocationBusinessMaxAggregateInputType
  }

  export type LocationBusinessGroupByOutputType = {
    id: string
    locationId: string | null
    businessId: string | null
    _count: LocationBusinessCountAggregateOutputType | null
    _min: LocationBusinessMinAggregateOutputType | null
    _max: LocationBusinessMaxAggregateOutputType | null
  }

  type GetLocationBusinessGroupByPayload<T extends LocationBusinessGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LocationBusinessGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LocationBusinessGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LocationBusinessGroupByOutputType[P]>
            : GetScalarType<T[P], LocationBusinessGroupByOutputType[P]>
        }
      >
    >


  export type LocationBusinessSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    locationId?: boolean
    businessId?: boolean
    business?: boolean | LocationBusiness$businessArgs<ExtArgs>
    location?: boolean | LocationBusiness$locationArgs<ExtArgs>
  }, ExtArgs["result"]["locationBusiness"]>


  export type LocationBusinessSelectScalar = {
    id?: boolean
    locationId?: boolean
    businessId?: boolean
  }

  export type LocationBusinessInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    business?: boolean | LocationBusiness$businessArgs<ExtArgs>
    location?: boolean | LocationBusiness$locationArgs<ExtArgs>
  }

  export type $LocationBusinessPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LocationBusiness"
    objects: {
      business: Prisma.$BusinessPayload<ExtArgs> | null
      location: Prisma.$LocationPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      locationId: string | null
      businessId: string | null
    }, ExtArgs["result"]["locationBusiness"]>
    composites: {}
  }

  type LocationBusinessGetPayload<S extends boolean | null | undefined | LocationBusinessDefaultArgs> = $Result.GetResult<Prisma.$LocationBusinessPayload, S>

  type LocationBusinessCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LocationBusinessFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LocationBusinessCountAggregateInputType | true
    }

  export interface LocationBusinessDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LocationBusiness'], meta: { name: 'LocationBusiness' } }
    /**
     * Find zero or one LocationBusiness that matches the filter.
     * @param {LocationBusinessFindUniqueArgs} args - Arguments to find a LocationBusiness
     * @example
     * // Get one LocationBusiness
     * const locationBusiness = await prisma.locationBusiness.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LocationBusinessFindUniqueArgs>(args: SelectSubset<T, LocationBusinessFindUniqueArgs<ExtArgs>>): Prisma__LocationBusinessClient<$Result.GetResult<Prisma.$LocationBusinessPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one LocationBusiness that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LocationBusinessFindUniqueOrThrowArgs} args - Arguments to find a LocationBusiness
     * @example
     * // Get one LocationBusiness
     * const locationBusiness = await prisma.locationBusiness.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LocationBusinessFindUniqueOrThrowArgs>(args: SelectSubset<T, LocationBusinessFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LocationBusinessClient<$Result.GetResult<Prisma.$LocationBusinessPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first LocationBusiness that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationBusinessFindFirstArgs} args - Arguments to find a LocationBusiness
     * @example
     * // Get one LocationBusiness
     * const locationBusiness = await prisma.locationBusiness.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LocationBusinessFindFirstArgs>(args?: SelectSubset<T, LocationBusinessFindFirstArgs<ExtArgs>>): Prisma__LocationBusinessClient<$Result.GetResult<Prisma.$LocationBusinessPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first LocationBusiness that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationBusinessFindFirstOrThrowArgs} args - Arguments to find a LocationBusiness
     * @example
     * // Get one LocationBusiness
     * const locationBusiness = await prisma.locationBusiness.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LocationBusinessFindFirstOrThrowArgs>(args?: SelectSubset<T, LocationBusinessFindFirstOrThrowArgs<ExtArgs>>): Prisma__LocationBusinessClient<$Result.GetResult<Prisma.$LocationBusinessPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more LocationBusinesses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationBusinessFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LocationBusinesses
     * const locationBusinesses = await prisma.locationBusiness.findMany()
     * 
     * // Get first 10 LocationBusinesses
     * const locationBusinesses = await prisma.locationBusiness.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const locationBusinessWithIdOnly = await prisma.locationBusiness.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LocationBusinessFindManyArgs>(args?: SelectSubset<T, LocationBusinessFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationBusinessPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a LocationBusiness.
     * @param {LocationBusinessCreateArgs} args - Arguments to create a LocationBusiness.
     * @example
     * // Create one LocationBusiness
     * const LocationBusiness = await prisma.locationBusiness.create({
     *   data: {
     *     // ... data to create a LocationBusiness
     *   }
     * })
     * 
     */
    create<T extends LocationBusinessCreateArgs>(args: SelectSubset<T, LocationBusinessCreateArgs<ExtArgs>>): Prisma__LocationBusinessClient<$Result.GetResult<Prisma.$LocationBusinessPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many LocationBusinesses.
     * @param {LocationBusinessCreateManyArgs} args - Arguments to create many LocationBusinesses.
     * @example
     * // Create many LocationBusinesses
     * const locationBusiness = await prisma.locationBusiness.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LocationBusinessCreateManyArgs>(args?: SelectSubset<T, LocationBusinessCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a LocationBusiness.
     * @param {LocationBusinessDeleteArgs} args - Arguments to delete one LocationBusiness.
     * @example
     * // Delete one LocationBusiness
     * const LocationBusiness = await prisma.locationBusiness.delete({
     *   where: {
     *     // ... filter to delete one LocationBusiness
     *   }
     * })
     * 
     */
    delete<T extends LocationBusinessDeleteArgs>(args: SelectSubset<T, LocationBusinessDeleteArgs<ExtArgs>>): Prisma__LocationBusinessClient<$Result.GetResult<Prisma.$LocationBusinessPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one LocationBusiness.
     * @param {LocationBusinessUpdateArgs} args - Arguments to update one LocationBusiness.
     * @example
     * // Update one LocationBusiness
     * const locationBusiness = await prisma.locationBusiness.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LocationBusinessUpdateArgs>(args: SelectSubset<T, LocationBusinessUpdateArgs<ExtArgs>>): Prisma__LocationBusinessClient<$Result.GetResult<Prisma.$LocationBusinessPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more LocationBusinesses.
     * @param {LocationBusinessDeleteManyArgs} args - Arguments to filter LocationBusinesses to delete.
     * @example
     * // Delete a few LocationBusinesses
     * const { count } = await prisma.locationBusiness.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LocationBusinessDeleteManyArgs>(args?: SelectSubset<T, LocationBusinessDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LocationBusinesses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationBusinessUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LocationBusinesses
     * const locationBusiness = await prisma.locationBusiness.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LocationBusinessUpdateManyArgs>(args: SelectSubset<T, LocationBusinessUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LocationBusiness.
     * @param {LocationBusinessUpsertArgs} args - Arguments to update or create a LocationBusiness.
     * @example
     * // Update or create a LocationBusiness
     * const locationBusiness = await prisma.locationBusiness.upsert({
     *   create: {
     *     // ... data to create a LocationBusiness
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LocationBusiness we want to update
     *   }
     * })
     */
    upsert<T extends LocationBusinessUpsertArgs>(args: SelectSubset<T, LocationBusinessUpsertArgs<ExtArgs>>): Prisma__LocationBusinessClient<$Result.GetResult<Prisma.$LocationBusinessPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more LocationBusinesses that matches the filter.
     * @param {LocationBusinessFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const locationBusiness = await prisma.locationBusiness.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: LocationBusinessFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a LocationBusiness.
     * @param {LocationBusinessAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const locationBusiness = await prisma.locationBusiness.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: LocationBusinessAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of LocationBusinesses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationBusinessCountArgs} args - Arguments to filter LocationBusinesses to count.
     * @example
     * // Count the number of LocationBusinesses
     * const count = await prisma.locationBusiness.count({
     *   where: {
     *     // ... the filter for the LocationBusinesses we want to count
     *   }
     * })
    **/
    count<T extends LocationBusinessCountArgs>(
      args?: Subset<T, LocationBusinessCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LocationBusinessCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LocationBusiness.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationBusinessAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LocationBusinessAggregateArgs>(args: Subset<T, LocationBusinessAggregateArgs>): Prisma.PrismaPromise<GetLocationBusinessAggregateType<T>>

    /**
     * Group by LocationBusiness.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationBusinessGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LocationBusinessGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LocationBusinessGroupByArgs['orderBy'] }
        : { orderBy?: LocationBusinessGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LocationBusinessGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLocationBusinessGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LocationBusiness model
   */
  readonly fields: LocationBusinessFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LocationBusiness.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LocationBusinessClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    business<T extends LocationBusiness$businessArgs<ExtArgs> = {}>(args?: Subset<T, LocationBusiness$businessArgs<ExtArgs>>): Prisma__BusinessClient<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    location<T extends LocationBusiness$locationArgs<ExtArgs> = {}>(args?: Subset<T, LocationBusiness$locationArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LocationBusiness model
   */ 
  interface LocationBusinessFieldRefs {
    readonly id: FieldRef<"LocationBusiness", 'String'>
    readonly locationId: FieldRef<"LocationBusiness", 'String'>
    readonly businessId: FieldRef<"LocationBusiness", 'String'>
  }
    

  // Custom InputTypes
  /**
   * LocationBusiness findUnique
   */
  export type LocationBusinessFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationBusiness
     */
    select?: LocationBusinessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationBusinessInclude<ExtArgs> | null
    /**
     * Filter, which LocationBusiness to fetch.
     */
    where: LocationBusinessWhereUniqueInput
  }

  /**
   * LocationBusiness findUniqueOrThrow
   */
  export type LocationBusinessFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationBusiness
     */
    select?: LocationBusinessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationBusinessInclude<ExtArgs> | null
    /**
     * Filter, which LocationBusiness to fetch.
     */
    where: LocationBusinessWhereUniqueInput
  }

  /**
   * LocationBusiness findFirst
   */
  export type LocationBusinessFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationBusiness
     */
    select?: LocationBusinessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationBusinessInclude<ExtArgs> | null
    /**
     * Filter, which LocationBusiness to fetch.
     */
    where?: LocationBusinessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LocationBusinesses to fetch.
     */
    orderBy?: LocationBusinessOrderByWithRelationInput | LocationBusinessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LocationBusinesses.
     */
    cursor?: LocationBusinessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LocationBusinesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LocationBusinesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LocationBusinesses.
     */
    distinct?: LocationBusinessScalarFieldEnum | LocationBusinessScalarFieldEnum[]
  }

  /**
   * LocationBusiness findFirstOrThrow
   */
  export type LocationBusinessFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationBusiness
     */
    select?: LocationBusinessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationBusinessInclude<ExtArgs> | null
    /**
     * Filter, which LocationBusiness to fetch.
     */
    where?: LocationBusinessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LocationBusinesses to fetch.
     */
    orderBy?: LocationBusinessOrderByWithRelationInput | LocationBusinessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LocationBusinesses.
     */
    cursor?: LocationBusinessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LocationBusinesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LocationBusinesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LocationBusinesses.
     */
    distinct?: LocationBusinessScalarFieldEnum | LocationBusinessScalarFieldEnum[]
  }

  /**
   * LocationBusiness findMany
   */
  export type LocationBusinessFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationBusiness
     */
    select?: LocationBusinessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationBusinessInclude<ExtArgs> | null
    /**
     * Filter, which LocationBusinesses to fetch.
     */
    where?: LocationBusinessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LocationBusinesses to fetch.
     */
    orderBy?: LocationBusinessOrderByWithRelationInput | LocationBusinessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LocationBusinesses.
     */
    cursor?: LocationBusinessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LocationBusinesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LocationBusinesses.
     */
    skip?: number
    distinct?: LocationBusinessScalarFieldEnum | LocationBusinessScalarFieldEnum[]
  }

  /**
   * LocationBusiness create
   */
  export type LocationBusinessCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationBusiness
     */
    select?: LocationBusinessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationBusinessInclude<ExtArgs> | null
    /**
     * The data needed to create a LocationBusiness.
     */
    data?: XOR<LocationBusinessCreateInput, LocationBusinessUncheckedCreateInput>
  }

  /**
   * LocationBusiness createMany
   */
  export type LocationBusinessCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LocationBusinesses.
     */
    data: LocationBusinessCreateManyInput | LocationBusinessCreateManyInput[]
  }

  /**
   * LocationBusiness update
   */
  export type LocationBusinessUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationBusiness
     */
    select?: LocationBusinessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationBusinessInclude<ExtArgs> | null
    /**
     * The data needed to update a LocationBusiness.
     */
    data: XOR<LocationBusinessUpdateInput, LocationBusinessUncheckedUpdateInput>
    /**
     * Choose, which LocationBusiness to update.
     */
    where: LocationBusinessWhereUniqueInput
  }

  /**
   * LocationBusiness updateMany
   */
  export type LocationBusinessUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LocationBusinesses.
     */
    data: XOR<LocationBusinessUpdateManyMutationInput, LocationBusinessUncheckedUpdateManyInput>
    /**
     * Filter which LocationBusinesses to update
     */
    where?: LocationBusinessWhereInput
  }

  /**
   * LocationBusiness upsert
   */
  export type LocationBusinessUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationBusiness
     */
    select?: LocationBusinessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationBusinessInclude<ExtArgs> | null
    /**
     * The filter to search for the LocationBusiness to update in case it exists.
     */
    where: LocationBusinessWhereUniqueInput
    /**
     * In case the LocationBusiness found by the `where` argument doesn't exist, create a new LocationBusiness with this data.
     */
    create: XOR<LocationBusinessCreateInput, LocationBusinessUncheckedCreateInput>
    /**
     * In case the LocationBusiness was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LocationBusinessUpdateInput, LocationBusinessUncheckedUpdateInput>
  }

  /**
   * LocationBusiness delete
   */
  export type LocationBusinessDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationBusiness
     */
    select?: LocationBusinessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationBusinessInclude<ExtArgs> | null
    /**
     * Filter which LocationBusiness to delete.
     */
    where: LocationBusinessWhereUniqueInput
  }

  /**
   * LocationBusiness deleteMany
   */
  export type LocationBusinessDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LocationBusinesses to delete
     */
    where?: LocationBusinessWhereInput
  }

  /**
   * LocationBusiness findRaw
   */
  export type LocationBusinessFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * LocationBusiness aggregateRaw
   */
  export type LocationBusinessAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * LocationBusiness.business
   */
  export type LocationBusiness$businessArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessInclude<ExtArgs> | null
    where?: BusinessWhereInput
  }

  /**
   * LocationBusiness.location
   */
  export type LocationBusiness$locationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    where?: LocationWhereInput
  }

  /**
   * LocationBusiness without action
   */
  export type LocationBusinessDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationBusiness
     */
    select?: LocationBusinessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationBusinessInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    type: string | null
    text: string | null
    content: string | null
    receiver: string | null
    creator: string | null
    date: Date | null
    style: string | null
    read: boolean | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    type: string | null
    text: string | null
    content: string | null
    receiver: string | null
    creator: string | null
    date: Date | null
    style: string | null
    read: boolean | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    type: number
    text: number
    content: number
    receiver: number
    creator: number
    date: number
    style: number
    read: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    type?: true
    text?: true
    content?: true
    receiver?: true
    creator?: true
    date?: true
    style?: true
    read?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    type?: true
    text?: true
    content?: true
    receiver?: true
    creator?: true
    date?: true
    style?: true
    read?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    type?: true
    text?: true
    content?: true
    receiver?: true
    creator?: true
    date?: true
    style?: true
    read?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    type: string | null
    text: string
    content: string
    receiver: string | null
    creator: string | null
    date: Date
    style: string | null
    read: boolean
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    text?: boolean
    content?: boolean
    receiver?: boolean
    creator?: boolean
    date?: boolean
    style?: boolean
    read?: boolean
    user?: boolean | Notification$userArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>


  export type NotificationSelectScalar = {
    id?: boolean
    type?: boolean
    text?: boolean
    content?: boolean
    receiver?: boolean
    creator?: boolean
    date?: boolean
    style?: boolean
    read?: boolean
  }

  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Notification$userArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: string | null
      text: string
      content: string
      receiver: string | null
      creator: string | null
      date: Date
      style: string | null
      read: boolean
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Notifications that matches the filter.
     * @param {NotificationFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const notification = await prisma.notification.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: NotificationFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Notification.
     * @param {NotificationAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const notification = await prisma.notification.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: NotificationAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends Notification$userArgs<ExtArgs> = {}>(args?: Subset<T, Notification$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */ 
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'String'>
    readonly text: FieldRef<"Notification", 'String'>
    readonly content: FieldRef<"Notification", 'String'>
    readonly receiver: FieldRef<"Notification", 'String'>
    readonly creator: FieldRef<"Notification", 'String'>
    readonly date: FieldRef<"Notification", 'DateTime'>
    readonly style: FieldRef<"Notification", 'String'>
    readonly read: FieldRef<"Notification", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification findRaw
   */
  export type NotificationFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Notification aggregateRaw
   */
  export type NotificationAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Notification.user
   */
  export type Notification$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model Doctype
   */

  export type AggregateDoctype = {
    _count: DoctypeCountAggregateOutputType | null
    _avg: DoctypeAvgAggregateOutputType | null
    _sum: DoctypeSumAggregateOutputType | null
    _min: DoctypeMinAggregateOutputType | null
    _max: DoctypeMaxAggregateOutputType | null
  }

  export type DoctypeAvgAggregateOutputType = {
    reviewFrequency: number | null
    revisionRemind: number | null
  }

  export type DoctypeSumAggregateOutputType = {
    reviewFrequency: number | null
    revisionRemind: number | null
  }

  export type DoctypeMinAggregateOutputType = {
    id: string | null
    documentTypeName: string | null
    documentNumbering: string | null
    reviewFrequency: number | null
    revisionRemind: number | null
    prefix: string | null
    suffix: string | null
    organizationId: string | null
    readAccess: string | null
    createdAt: Date | null
    updatedAt: Date | null
    updatedBy: string | null
    createdBy: string | null
    document_classification: string | null
    entityId: string | null
    currentVersion: string | null
    distributionList: string | null
  }

  export type DoctypeMaxAggregateOutputType = {
    id: string | null
    documentTypeName: string | null
    documentNumbering: string | null
    reviewFrequency: number | null
    revisionRemind: number | null
    prefix: string | null
    suffix: string | null
    organizationId: string | null
    readAccess: string | null
    createdAt: Date | null
    updatedAt: Date | null
    updatedBy: string | null
    createdBy: string | null
    document_classification: string | null
    entityId: string | null
    currentVersion: string | null
    distributionList: string | null
  }

  export type DoctypeCountAggregateOutputType = {
    id: number
    locationId: number
    documentTypeName: number
    documentNumbering: number
    reviewFrequency: number
    revisionRemind: number
    prefix: number
    suffix: number
    organizationId: number
    readAccess: number
    readAccessUsers: number
    createdAt: number
    updatedAt: number
    updatedBy: number
    createdBy: number
    applicable_systems: number
    users: number
    document_classification: number
    entityId: number
    distributionUsers: number
    currentVersion: number
    distributionList: number
    _all: number
  }


  export type DoctypeAvgAggregateInputType = {
    reviewFrequency?: true
    revisionRemind?: true
  }

  export type DoctypeSumAggregateInputType = {
    reviewFrequency?: true
    revisionRemind?: true
  }

  export type DoctypeMinAggregateInputType = {
    id?: true
    documentTypeName?: true
    documentNumbering?: true
    reviewFrequency?: true
    revisionRemind?: true
    prefix?: true
    suffix?: true
    organizationId?: true
    readAccess?: true
    createdAt?: true
    updatedAt?: true
    updatedBy?: true
    createdBy?: true
    document_classification?: true
    entityId?: true
    currentVersion?: true
    distributionList?: true
  }

  export type DoctypeMaxAggregateInputType = {
    id?: true
    documentTypeName?: true
    documentNumbering?: true
    reviewFrequency?: true
    revisionRemind?: true
    prefix?: true
    suffix?: true
    organizationId?: true
    readAccess?: true
    createdAt?: true
    updatedAt?: true
    updatedBy?: true
    createdBy?: true
    document_classification?: true
    entityId?: true
    currentVersion?: true
    distributionList?: true
  }

  export type DoctypeCountAggregateInputType = {
    id?: true
    locationId?: true
    documentTypeName?: true
    documentNumbering?: true
    reviewFrequency?: true
    revisionRemind?: true
    prefix?: true
    suffix?: true
    organizationId?: true
    readAccess?: true
    readAccessUsers?: true
    createdAt?: true
    updatedAt?: true
    updatedBy?: true
    createdBy?: true
    applicable_systems?: true
    users?: true
    document_classification?: true
    entityId?: true
    distributionUsers?: true
    currentVersion?: true
    distributionList?: true
    _all?: true
  }

  export type DoctypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Doctype to aggregate.
     */
    where?: DoctypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Doctypes to fetch.
     */
    orderBy?: DoctypeOrderByWithRelationInput | DoctypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DoctypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Doctypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Doctypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Doctypes
    **/
    _count?: true | DoctypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DoctypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DoctypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DoctypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DoctypeMaxAggregateInputType
  }

  export type GetDoctypeAggregateType<T extends DoctypeAggregateArgs> = {
        [P in keyof T & keyof AggregateDoctype]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDoctype[P]>
      : GetScalarType<T[P], AggregateDoctype[P]>
  }




  export type DoctypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DoctypeWhereInput
    orderBy?: DoctypeOrderByWithAggregationInput | DoctypeOrderByWithAggregationInput[]
    by: DoctypeScalarFieldEnum[] | DoctypeScalarFieldEnum
    having?: DoctypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DoctypeCountAggregateInputType | true
    _avg?: DoctypeAvgAggregateInputType
    _sum?: DoctypeSumAggregateInputType
    _min?: DoctypeMinAggregateInputType
    _max?: DoctypeMaxAggregateInputType
  }

  export type DoctypeGroupByOutputType = {
    id: string
    locationId: string[]
    documentTypeName: string | null
    documentNumbering: string | null
    reviewFrequency: number | null
    revisionRemind: number | null
    prefix: string | null
    suffix: string | null
    organizationId: string | null
    readAccess: string | null
    readAccessUsers: JsonValue[]
    createdAt: Date
    updatedAt: Date
    updatedBy: string | null
    createdBy: string | null
    applicable_systems: JsonValue[]
    users: JsonValue[]
    document_classification: string | null
    entityId: string | null
    distributionUsers: JsonValue[]
    currentVersion: string
    distributionList: string | null
    _count: DoctypeCountAggregateOutputType | null
    _avg: DoctypeAvgAggregateOutputType | null
    _sum: DoctypeSumAggregateOutputType | null
    _min: DoctypeMinAggregateOutputType | null
    _max: DoctypeMaxAggregateOutputType | null
  }

  type GetDoctypeGroupByPayload<T extends DoctypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DoctypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DoctypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DoctypeGroupByOutputType[P]>
            : GetScalarType<T[P], DoctypeGroupByOutputType[P]>
        }
      >
    >


  export type DoctypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    locationId?: boolean
    documentTypeName?: boolean
    documentNumbering?: boolean
    reviewFrequency?: boolean
    revisionRemind?: boolean
    prefix?: boolean
    suffix?: boolean
    organizationId?: boolean
    readAccess?: boolean
    readAccessUsers?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    createdBy?: boolean
    applicable_systems?: boolean
    users?: boolean
    document_classification?: boolean
    entityId?: boolean
    distributionUsers?: boolean
    currentVersion?: boolean
    distributionList?: boolean
    organization?: boolean | Doctype$organizationArgs<ExtArgs>
    Entity?: boolean | Doctype$EntityArgs<ExtArgs>
    Documents?: boolean | Doctype$DocumentsArgs<ExtArgs>
    documentAdmins?: boolean | Doctype$documentAdminsArgs<ExtArgs>
    _count?: boolean | DoctypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["doctype"]>


  export type DoctypeSelectScalar = {
    id?: boolean
    locationId?: boolean
    documentTypeName?: boolean
    documentNumbering?: boolean
    reviewFrequency?: boolean
    revisionRemind?: boolean
    prefix?: boolean
    suffix?: boolean
    organizationId?: boolean
    readAccess?: boolean
    readAccessUsers?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    createdBy?: boolean
    applicable_systems?: boolean
    users?: boolean
    document_classification?: boolean
    entityId?: boolean
    distributionUsers?: boolean
    currentVersion?: boolean
    distributionList?: boolean
  }

  export type DoctypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | Doctype$organizationArgs<ExtArgs>
    Entity?: boolean | Doctype$EntityArgs<ExtArgs>
    Documents?: boolean | Doctype$DocumentsArgs<ExtArgs>
    documentAdmins?: boolean | Doctype$documentAdminsArgs<ExtArgs>
    _count?: boolean | DoctypeCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $DoctypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Doctype"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs> | null
      Entity: Prisma.$EntityPayload<ExtArgs> | null
      Documents: Prisma.$DocumentsPayload<ExtArgs>[]
      documentAdmins: Prisma.$documentAdminsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      locationId: string[]
      documentTypeName: string | null
      documentNumbering: string | null
      reviewFrequency: number | null
      revisionRemind: number | null
      prefix: string | null
      suffix: string | null
      organizationId: string | null
      readAccess: string | null
      readAccessUsers: Prisma.JsonValue[]
      createdAt: Date
      updatedAt: Date
      updatedBy: string | null
      createdBy: string | null
      applicable_systems: Prisma.JsonValue[]
      users: Prisma.JsonValue[]
      document_classification: string | null
      entityId: string | null
      distributionUsers: Prisma.JsonValue[]
      currentVersion: string
      distributionList: string | null
    }, ExtArgs["result"]["doctype"]>
    composites: {}
  }

  type DoctypeGetPayload<S extends boolean | null | undefined | DoctypeDefaultArgs> = $Result.GetResult<Prisma.$DoctypePayload, S>

  type DoctypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DoctypeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DoctypeCountAggregateInputType | true
    }

  export interface DoctypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Doctype'], meta: { name: 'Doctype' } }
    /**
     * Find zero or one Doctype that matches the filter.
     * @param {DoctypeFindUniqueArgs} args - Arguments to find a Doctype
     * @example
     * // Get one Doctype
     * const doctype = await prisma.doctype.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DoctypeFindUniqueArgs>(args: SelectSubset<T, DoctypeFindUniqueArgs<ExtArgs>>): Prisma__DoctypeClient<$Result.GetResult<Prisma.$DoctypePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Doctype that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DoctypeFindUniqueOrThrowArgs} args - Arguments to find a Doctype
     * @example
     * // Get one Doctype
     * const doctype = await prisma.doctype.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DoctypeFindUniqueOrThrowArgs>(args: SelectSubset<T, DoctypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DoctypeClient<$Result.GetResult<Prisma.$DoctypePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Doctype that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctypeFindFirstArgs} args - Arguments to find a Doctype
     * @example
     * // Get one Doctype
     * const doctype = await prisma.doctype.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DoctypeFindFirstArgs>(args?: SelectSubset<T, DoctypeFindFirstArgs<ExtArgs>>): Prisma__DoctypeClient<$Result.GetResult<Prisma.$DoctypePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Doctype that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctypeFindFirstOrThrowArgs} args - Arguments to find a Doctype
     * @example
     * // Get one Doctype
     * const doctype = await prisma.doctype.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DoctypeFindFirstOrThrowArgs>(args?: SelectSubset<T, DoctypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__DoctypeClient<$Result.GetResult<Prisma.$DoctypePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Doctypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Doctypes
     * const doctypes = await prisma.doctype.findMany()
     * 
     * // Get first 10 Doctypes
     * const doctypes = await prisma.doctype.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const doctypeWithIdOnly = await prisma.doctype.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DoctypeFindManyArgs>(args?: SelectSubset<T, DoctypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DoctypePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Doctype.
     * @param {DoctypeCreateArgs} args - Arguments to create a Doctype.
     * @example
     * // Create one Doctype
     * const Doctype = await prisma.doctype.create({
     *   data: {
     *     // ... data to create a Doctype
     *   }
     * })
     * 
     */
    create<T extends DoctypeCreateArgs>(args: SelectSubset<T, DoctypeCreateArgs<ExtArgs>>): Prisma__DoctypeClient<$Result.GetResult<Prisma.$DoctypePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Doctypes.
     * @param {DoctypeCreateManyArgs} args - Arguments to create many Doctypes.
     * @example
     * // Create many Doctypes
     * const doctype = await prisma.doctype.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DoctypeCreateManyArgs>(args?: SelectSubset<T, DoctypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Doctype.
     * @param {DoctypeDeleteArgs} args - Arguments to delete one Doctype.
     * @example
     * // Delete one Doctype
     * const Doctype = await prisma.doctype.delete({
     *   where: {
     *     // ... filter to delete one Doctype
     *   }
     * })
     * 
     */
    delete<T extends DoctypeDeleteArgs>(args: SelectSubset<T, DoctypeDeleteArgs<ExtArgs>>): Prisma__DoctypeClient<$Result.GetResult<Prisma.$DoctypePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Doctype.
     * @param {DoctypeUpdateArgs} args - Arguments to update one Doctype.
     * @example
     * // Update one Doctype
     * const doctype = await prisma.doctype.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DoctypeUpdateArgs>(args: SelectSubset<T, DoctypeUpdateArgs<ExtArgs>>): Prisma__DoctypeClient<$Result.GetResult<Prisma.$DoctypePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Doctypes.
     * @param {DoctypeDeleteManyArgs} args - Arguments to filter Doctypes to delete.
     * @example
     * // Delete a few Doctypes
     * const { count } = await prisma.doctype.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DoctypeDeleteManyArgs>(args?: SelectSubset<T, DoctypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Doctypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Doctypes
     * const doctype = await prisma.doctype.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DoctypeUpdateManyArgs>(args: SelectSubset<T, DoctypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Doctype.
     * @param {DoctypeUpsertArgs} args - Arguments to update or create a Doctype.
     * @example
     * // Update or create a Doctype
     * const doctype = await prisma.doctype.upsert({
     *   create: {
     *     // ... data to create a Doctype
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Doctype we want to update
     *   }
     * })
     */
    upsert<T extends DoctypeUpsertArgs>(args: SelectSubset<T, DoctypeUpsertArgs<ExtArgs>>): Prisma__DoctypeClient<$Result.GetResult<Prisma.$DoctypePayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Doctypes that matches the filter.
     * @param {DoctypeFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const doctype = await prisma.doctype.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: DoctypeFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Doctype.
     * @param {DoctypeAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const doctype = await prisma.doctype.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: DoctypeAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Doctypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctypeCountArgs} args - Arguments to filter Doctypes to count.
     * @example
     * // Count the number of Doctypes
     * const count = await prisma.doctype.count({
     *   where: {
     *     // ... the filter for the Doctypes we want to count
     *   }
     * })
    **/
    count<T extends DoctypeCountArgs>(
      args?: Subset<T, DoctypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DoctypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Doctype.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DoctypeAggregateArgs>(args: Subset<T, DoctypeAggregateArgs>): Prisma.PrismaPromise<GetDoctypeAggregateType<T>>

    /**
     * Group by Doctype.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DoctypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DoctypeGroupByArgs['orderBy'] }
        : { orderBy?: DoctypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DoctypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDoctypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Doctype model
   */
  readonly fields: DoctypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Doctype.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DoctypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organization<T extends Doctype$organizationArgs<ExtArgs> = {}>(args?: Subset<T, Doctype$organizationArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    Entity<T extends Doctype$EntityArgs<ExtArgs> = {}>(args?: Subset<T, Doctype$EntityArgs<ExtArgs>>): Prisma__EntityClient<$Result.GetResult<Prisma.$EntityPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    Documents<T extends Doctype$DocumentsArgs<ExtArgs> = {}>(args?: Subset<T, Doctype$DocumentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentsPayload<ExtArgs>, T, "findMany"> | Null>
    documentAdmins<T extends Doctype$documentAdminsArgs<ExtArgs> = {}>(args?: Subset<T, Doctype$documentAdminsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$documentAdminsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Doctype model
   */ 
  interface DoctypeFieldRefs {
    readonly id: FieldRef<"Doctype", 'String'>
    readonly locationId: FieldRef<"Doctype", 'String[]'>
    readonly documentTypeName: FieldRef<"Doctype", 'String'>
    readonly documentNumbering: FieldRef<"Doctype", 'String'>
    readonly reviewFrequency: FieldRef<"Doctype", 'Int'>
    readonly revisionRemind: FieldRef<"Doctype", 'Int'>
    readonly prefix: FieldRef<"Doctype", 'String'>
    readonly suffix: FieldRef<"Doctype", 'String'>
    readonly organizationId: FieldRef<"Doctype", 'String'>
    readonly readAccess: FieldRef<"Doctype", 'String'>
    readonly readAccessUsers: FieldRef<"Doctype", 'Json[]'>
    readonly createdAt: FieldRef<"Doctype", 'DateTime'>
    readonly updatedAt: FieldRef<"Doctype", 'DateTime'>
    readonly updatedBy: FieldRef<"Doctype", 'String'>
    readonly createdBy: FieldRef<"Doctype", 'String'>
    readonly applicable_systems: FieldRef<"Doctype", 'Json[]'>
    readonly users: FieldRef<"Doctype", 'Json[]'>
    readonly document_classification: FieldRef<"Doctype", 'String'>
    readonly entityId: FieldRef<"Doctype", 'String'>
    readonly distributionUsers: FieldRef<"Doctype", 'Json[]'>
    readonly currentVersion: FieldRef<"Doctype", 'String'>
    readonly distributionList: FieldRef<"Doctype", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Doctype findUnique
   */
  export type DoctypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctype
     */
    select?: DoctypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctypeInclude<ExtArgs> | null
    /**
     * Filter, which Doctype to fetch.
     */
    where: DoctypeWhereUniqueInput
  }

  /**
   * Doctype findUniqueOrThrow
   */
  export type DoctypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctype
     */
    select?: DoctypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctypeInclude<ExtArgs> | null
    /**
     * Filter, which Doctype to fetch.
     */
    where: DoctypeWhereUniqueInput
  }

  /**
   * Doctype findFirst
   */
  export type DoctypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctype
     */
    select?: DoctypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctypeInclude<ExtArgs> | null
    /**
     * Filter, which Doctype to fetch.
     */
    where?: DoctypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Doctypes to fetch.
     */
    orderBy?: DoctypeOrderByWithRelationInput | DoctypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Doctypes.
     */
    cursor?: DoctypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Doctypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Doctypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Doctypes.
     */
    distinct?: DoctypeScalarFieldEnum | DoctypeScalarFieldEnum[]
  }

  /**
   * Doctype findFirstOrThrow
   */
  export type DoctypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctype
     */
    select?: DoctypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctypeInclude<ExtArgs> | null
    /**
     * Filter, which Doctype to fetch.
     */
    where?: DoctypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Doctypes to fetch.
     */
    orderBy?: DoctypeOrderByWithRelationInput | DoctypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Doctypes.
     */
    cursor?: DoctypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Doctypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Doctypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Doctypes.
     */
    distinct?: DoctypeScalarFieldEnum | DoctypeScalarFieldEnum[]
  }

  /**
   * Doctype findMany
   */
  export type DoctypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctype
     */
    select?: DoctypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctypeInclude<ExtArgs> | null
    /**
     * Filter, which Doctypes to fetch.
     */
    where?: DoctypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Doctypes to fetch.
     */
    orderBy?: DoctypeOrderByWithRelationInput | DoctypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Doctypes.
     */
    cursor?: DoctypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Doctypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Doctypes.
     */
    skip?: number
    distinct?: DoctypeScalarFieldEnum | DoctypeScalarFieldEnum[]
  }

  /**
   * Doctype create
   */
  export type DoctypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctype
     */
    select?: DoctypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctypeInclude<ExtArgs> | null
    /**
     * The data needed to create a Doctype.
     */
    data: XOR<DoctypeCreateInput, DoctypeUncheckedCreateInput>
  }

  /**
   * Doctype createMany
   */
  export type DoctypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Doctypes.
     */
    data: DoctypeCreateManyInput | DoctypeCreateManyInput[]
  }

  /**
   * Doctype update
   */
  export type DoctypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctype
     */
    select?: DoctypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctypeInclude<ExtArgs> | null
    /**
     * The data needed to update a Doctype.
     */
    data: XOR<DoctypeUpdateInput, DoctypeUncheckedUpdateInput>
    /**
     * Choose, which Doctype to update.
     */
    where: DoctypeWhereUniqueInput
  }

  /**
   * Doctype updateMany
   */
  export type DoctypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Doctypes.
     */
    data: XOR<DoctypeUpdateManyMutationInput, DoctypeUncheckedUpdateManyInput>
    /**
     * Filter which Doctypes to update
     */
    where?: DoctypeWhereInput
  }

  /**
   * Doctype upsert
   */
  export type DoctypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctype
     */
    select?: DoctypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctypeInclude<ExtArgs> | null
    /**
     * The filter to search for the Doctype to update in case it exists.
     */
    where: DoctypeWhereUniqueInput
    /**
     * In case the Doctype found by the `where` argument doesn't exist, create a new Doctype with this data.
     */
    create: XOR<DoctypeCreateInput, DoctypeUncheckedCreateInput>
    /**
     * In case the Doctype was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DoctypeUpdateInput, DoctypeUncheckedUpdateInput>
  }

  /**
   * Doctype delete
   */
  export type DoctypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctype
     */
    select?: DoctypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctypeInclude<ExtArgs> | null
    /**
     * Filter which Doctype to delete.
     */
    where: DoctypeWhereUniqueInput
  }

  /**
   * Doctype deleteMany
   */
  export type DoctypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Doctypes to delete
     */
    where?: DoctypeWhereInput
  }

  /**
   * Doctype findRaw
   */
  export type DoctypeFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Doctype aggregateRaw
   */
  export type DoctypeAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Doctype.organization
   */
  export type Doctype$organizationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    where?: OrganizationWhereInput
  }

  /**
   * Doctype.Entity
   */
  export type Doctype$EntityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entity
     */
    select?: EntitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntityInclude<ExtArgs> | null
    where?: EntityWhereInput
  }

  /**
   * Doctype.Documents
   */
  export type Doctype$DocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Documents
     */
    select?: DocumentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentsInclude<ExtArgs> | null
    where?: DocumentsWhereInput
    orderBy?: DocumentsOrderByWithRelationInput | DocumentsOrderByWithRelationInput[]
    cursor?: DocumentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentsScalarFieldEnum | DocumentsScalarFieldEnum[]
  }

  /**
   * Doctype.documentAdmins
   */
  export type Doctype$documentAdminsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the documentAdmins
     */
    select?: documentAdminsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: documentAdminsInclude<ExtArgs> | null
    where?: documentAdminsWhereInput
    orderBy?: documentAdminsOrderByWithRelationInput | documentAdminsOrderByWithRelationInput[]
    cursor?: documentAdminsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentAdminsScalarFieldEnum | DocumentAdminsScalarFieldEnum[]
  }

  /**
   * Doctype without action
   */
  export type DoctypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctype
     */
    select?: DoctypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctypeInclude<ExtArgs> | null
  }


  /**
   * Model Documents
   */

  export type AggregateDocuments = {
    _count: DocumentsCountAggregateOutputType | null
    _avg: DocumentsAvgAggregateOutputType | null
    _sum: DocumentsSumAggregateOutputType | null
    _min: DocumentsMinAggregateOutputType | null
    _max: DocumentsMaxAggregateOutputType | null
  }

  export type DocumentsAvgAggregateOutputType = {
    countNumber: number | null
  }

  export type DocumentsSumAggregateOutputType = {
    countNumber: number | null
  }

  export type DocumentsMinAggregateOutputType = {
    id: string | null
    doctypeId: string | null
    organizationId: string | null
    documentName: string | null
    documentNumbering: string | null
    reasonOfCreation: string | null
    effectiveDate: Date | null
    nextRevisionDate: Date | null
    currentVersion: string | null
    documentLink: string | null
    description: string | null
    documentState: string | null
    locationId: string | null
    entityId: string | null
    section: string | null
    revertComment: string | null
    docType: string | null
    documentClassification: string | null
    issueNumber: string | null
    retireComment: string | null
    revisionReminderFlag: boolean | null
    isVersion: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    approvedDate: Date | null
    countNumber: number | null
    createdBy: string | null
    distributionList: string | null
    documentId: string | null
    readAccess: string | null
  }

  export type DocumentsMaxAggregateOutputType = {
    id: string | null
    doctypeId: string | null
    organizationId: string | null
    documentName: string | null
    documentNumbering: string | null
    reasonOfCreation: string | null
    effectiveDate: Date | null
    nextRevisionDate: Date | null
    currentVersion: string | null
    documentLink: string | null
    description: string | null
    documentState: string | null
    locationId: string | null
    entityId: string | null
    section: string | null
    revertComment: string | null
    docType: string | null
    documentClassification: string | null
    issueNumber: string | null
    retireComment: string | null
    revisionReminderFlag: boolean | null
    isVersion: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    approvedDate: Date | null
    countNumber: number | null
    createdBy: string | null
    distributionList: string | null
    documentId: string | null
    readAccess: string | null
  }

  export type DocumentsCountAggregateOutputType = {
    id: number
    doctypeId: number
    organizationId: number
    documentName: number
    documentNumbering: number
    reasonOfCreation: number
    effectiveDate: number
    nextRevisionDate: number
    currentVersion: number
    documentLink: number
    description: number
    tags: number
    documentState: number
    locationId: number
    entityId: number
    system: number
    section: number
    revertComment: number
    docType: number
    documentClassification: number
    issueNumber: number
    retireComment: number
    revisionReminderFlag: number
    isVersion: number
    createdAt: number
    updatedAt: number
    approvedDate: number
    countNumber: number
    createdBy: number
    distributionList: number
    documentId: number
    reviewers: number
    approvers: number
    creators: number
    distributionUsers: number
    readAccess: number
    readAccessUsers: number
    versionInfo: number
    _all: number
  }


  export type DocumentsAvgAggregateInputType = {
    countNumber?: true
  }

  export type DocumentsSumAggregateInputType = {
    countNumber?: true
  }

  export type DocumentsMinAggregateInputType = {
    id?: true
    doctypeId?: true
    organizationId?: true
    documentName?: true
    documentNumbering?: true
    reasonOfCreation?: true
    effectiveDate?: true
    nextRevisionDate?: true
    currentVersion?: true
    documentLink?: true
    description?: true
    documentState?: true
    locationId?: true
    entityId?: true
    section?: true
    revertComment?: true
    docType?: true
    documentClassification?: true
    issueNumber?: true
    retireComment?: true
    revisionReminderFlag?: true
    isVersion?: true
    createdAt?: true
    updatedAt?: true
    approvedDate?: true
    countNumber?: true
    createdBy?: true
    distributionList?: true
    documentId?: true
    readAccess?: true
  }

  export type DocumentsMaxAggregateInputType = {
    id?: true
    doctypeId?: true
    organizationId?: true
    documentName?: true
    documentNumbering?: true
    reasonOfCreation?: true
    effectiveDate?: true
    nextRevisionDate?: true
    currentVersion?: true
    documentLink?: true
    description?: true
    documentState?: true
    locationId?: true
    entityId?: true
    section?: true
    revertComment?: true
    docType?: true
    documentClassification?: true
    issueNumber?: true
    retireComment?: true
    revisionReminderFlag?: true
    isVersion?: true
    createdAt?: true
    updatedAt?: true
    approvedDate?: true
    countNumber?: true
    createdBy?: true
    distributionList?: true
    documentId?: true
    readAccess?: true
  }

  export type DocumentsCountAggregateInputType = {
    id?: true
    doctypeId?: true
    organizationId?: true
    documentName?: true
    documentNumbering?: true
    reasonOfCreation?: true
    effectiveDate?: true
    nextRevisionDate?: true
    currentVersion?: true
    documentLink?: true
    description?: true
    tags?: true
    documentState?: true
    locationId?: true
    entityId?: true
    system?: true
    section?: true
    revertComment?: true
    docType?: true
    documentClassification?: true
    issueNumber?: true
    retireComment?: true
    revisionReminderFlag?: true
    isVersion?: true
    createdAt?: true
    updatedAt?: true
    approvedDate?: true
    countNumber?: true
    createdBy?: true
    distributionList?: true
    documentId?: true
    reviewers?: true
    approvers?: true
    creators?: true
    distributionUsers?: true
    readAccess?: true
    readAccessUsers?: true
    versionInfo?: true
    _all?: true
  }

  export type DocumentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Documents to aggregate.
     */
    where?: DocumentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentsOrderByWithRelationInput | DocumentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DocumentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Documents
    **/
    _count?: true | DocumentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DocumentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DocumentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentsMaxAggregateInputType
  }

  export type GetDocumentsAggregateType<T extends DocumentsAggregateArgs> = {
        [P in keyof T & keyof AggregateDocuments]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocuments[P]>
      : GetScalarType<T[P], AggregateDocuments[P]>
  }




  export type DocumentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentsWhereInput
    orderBy?: DocumentsOrderByWithAggregationInput | DocumentsOrderByWithAggregationInput[]
    by: DocumentsScalarFieldEnum[] | DocumentsScalarFieldEnum
    having?: DocumentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentsCountAggregateInputType | true
    _avg?: DocumentsAvgAggregateInputType
    _sum?: DocumentsSumAggregateInputType
    _min?: DocumentsMinAggregateInputType
    _max?: DocumentsMaxAggregateInputType
  }

  export type DocumentsGroupByOutputType = {
    id: string
    doctypeId: string | null
    organizationId: string | null
    documentName: string | null
    documentNumbering: string | null
    reasonOfCreation: string | null
    effectiveDate: Date | null
    nextRevisionDate: Date | null
    currentVersion: string | null
    documentLink: string | null
    description: string | null
    tags: string[]
    documentState: string | null
    locationId: string
    entityId: string | null
    system: string[]
    section: string | null
    revertComment: string | null
    docType: string | null
    documentClassification: string | null
    issueNumber: string | null
    retireComment: string | null
    revisionReminderFlag: boolean | null
    isVersion: boolean | null
    createdAt: Date
    updatedAt: Date
    approvedDate: Date | null
    countNumber: number | null
    createdBy: string | null
    distributionList: string | null
    documentId: string | null
    reviewers: string[]
    approvers: string[]
    creators: string[]
    distributionUsers: JsonValue[]
    readAccess: string | null
    readAccessUsers: JsonValue[]
    versionInfo: JsonValue[]
    _count: DocumentsCountAggregateOutputType | null
    _avg: DocumentsAvgAggregateOutputType | null
    _sum: DocumentsSumAggregateOutputType | null
    _min: DocumentsMinAggregateOutputType | null
    _max: DocumentsMaxAggregateOutputType | null
  }

  type GetDocumentsGroupByPayload<T extends DocumentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DocumentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentsGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentsGroupByOutputType[P]>
        }
      >
    >


  export type DocumentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    doctypeId?: boolean
    organizationId?: boolean
    documentName?: boolean
    documentNumbering?: boolean
    reasonOfCreation?: boolean
    effectiveDate?: boolean
    nextRevisionDate?: boolean
    currentVersion?: boolean
    documentLink?: boolean
    description?: boolean
    tags?: boolean
    documentState?: boolean
    locationId?: boolean
    entityId?: boolean
    system?: boolean
    section?: boolean
    revertComment?: boolean
    docType?: boolean
    documentClassification?: boolean
    issueNumber?: boolean
    retireComment?: boolean
    revisionReminderFlag?: boolean
    isVersion?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    approvedDate?: boolean
    countNumber?: boolean
    createdBy?: boolean
    distributionList?: boolean
    documentId?: boolean
    reviewers?: boolean
    approvers?: boolean
    creators?: boolean
    distributionUsers?: boolean
    readAccess?: boolean
    readAccessUsers?: boolean
    versionInfo?: boolean
    doctype?: boolean | Documents$doctypeArgs<ExtArgs>
    organization?: boolean | Documents$organizationArgs<ExtArgs>
    creatorLocation?: boolean | Documents$creatorLocationArgs<ExtArgs>
    creatorEntity?: boolean | Documents$creatorEntityArgs<ExtArgs>
    ReferenceDocuments?: boolean | Documents$ReferenceDocumentsArgs<ExtArgs>
    DocumentVersions?: boolean | Documents$DocumentVersionsArgs<ExtArgs>
    DocumentComments?: boolean | Documents$DocumentCommentsArgs<ExtArgs>
    DocumentWorkFlowHistory?: boolean | Documents$DocumentWorkFlowHistoryArgs<ExtArgs>
    AdditionalDocumentAdmins?: boolean | Documents$AdditionalDocumentAdminsArgs<ExtArgs>
    VersionReferenceDocuments?: boolean | Documents$VersionReferenceDocumentsArgs<ExtArgs>
    _count?: boolean | DocumentsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["documents"]>


  export type DocumentsSelectScalar = {
    id?: boolean
    doctypeId?: boolean
    organizationId?: boolean
    documentName?: boolean
    documentNumbering?: boolean
    reasonOfCreation?: boolean
    effectiveDate?: boolean
    nextRevisionDate?: boolean
    currentVersion?: boolean
    documentLink?: boolean
    description?: boolean
    tags?: boolean
    documentState?: boolean
    locationId?: boolean
    entityId?: boolean
    system?: boolean
    section?: boolean
    revertComment?: boolean
    docType?: boolean
    documentClassification?: boolean
    issueNumber?: boolean
    retireComment?: boolean
    revisionReminderFlag?: boolean
    isVersion?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    approvedDate?: boolean
    countNumber?: boolean
    createdBy?: boolean
    distributionList?: boolean
    documentId?: boolean
    reviewers?: boolean
    approvers?: boolean
    creators?: boolean
    distributionUsers?: boolean
    readAccess?: boolean
    readAccessUsers?: boolean
    versionInfo?: boolean
  }

  export type DocumentsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    doctype?: boolean | Documents$doctypeArgs<ExtArgs>
    organization?: boolean | Documents$organizationArgs<ExtArgs>
    creatorLocation?: boolean | Documents$creatorLocationArgs<ExtArgs>
    creatorEntity?: boolean | Documents$creatorEntityArgs<ExtArgs>
    ReferenceDocuments?: boolean | Documents$ReferenceDocumentsArgs<ExtArgs>
    DocumentVersions?: boolean | Documents$DocumentVersionsArgs<ExtArgs>
    DocumentComments?: boolean | Documents$DocumentCommentsArgs<ExtArgs>
    DocumentWorkFlowHistory?: boolean | Documents$DocumentWorkFlowHistoryArgs<ExtArgs>
    AdditionalDocumentAdmins?: boolean | Documents$AdditionalDocumentAdminsArgs<ExtArgs>
    VersionReferenceDocuments?: boolean | Documents$VersionReferenceDocumentsArgs<ExtArgs>
    _count?: boolean | DocumentsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $DocumentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Documents"
    objects: {
      doctype: Prisma.$DoctypePayload<ExtArgs> | null
      organization: Prisma.$OrganizationPayload<ExtArgs> | null
      creatorLocation: Prisma.$LocationPayload<ExtArgs> | null
      creatorEntity: Prisma.$EntityPayload<ExtArgs> | null
      ReferenceDocuments: Prisma.$ReferenceDocumentsPayload<ExtArgs>[]
      DocumentVersions: Prisma.$DocumentVersionsPayload<ExtArgs>[]
      DocumentComments: Prisma.$DocumentCommentsPayload<ExtArgs>[]
      DocumentWorkFlowHistory: Prisma.$DocumentWorkFlowHistoryPayload<ExtArgs>[]
      AdditionalDocumentAdmins: Prisma.$AdditionalDocumentAdminsPayload<ExtArgs>[]
      VersionReferenceDocuments: Prisma.$VersionReferenceDocumentsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      doctypeId: string | null
      organizationId: string | null
      documentName: string | null
      documentNumbering: string | null
      reasonOfCreation: string | null
      effectiveDate: Date | null
      nextRevisionDate: Date | null
      currentVersion: string | null
      documentLink: string | null
      description: string | null
      tags: string[]
      documentState: string | null
      locationId: string
      entityId: string | null
      system: string[]
      section: string | null
      revertComment: string | null
      docType: string | null
      documentClassification: string | null
      issueNumber: string | null
      retireComment: string | null
      revisionReminderFlag: boolean | null
      isVersion: boolean | null
      createdAt: Date
      updatedAt: Date
      approvedDate: Date | null
      countNumber: number | null
      createdBy: string | null
      distributionList: string | null
      documentId: string | null
      reviewers: string[]
      approvers: string[]
      creators: string[]
      distributionUsers: Prisma.JsonValue[]
      readAccess: string | null
      readAccessUsers: Prisma.JsonValue[]
      versionInfo: Prisma.JsonValue[]
    }, ExtArgs["result"]["documents"]>
    composites: {}
  }

  type DocumentsGetPayload<S extends boolean | null | undefined | DocumentsDefaultArgs> = $Result.GetResult<Prisma.$DocumentsPayload, S>

  type DocumentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DocumentsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DocumentsCountAggregateInputType | true
    }

  export interface DocumentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Documents'], meta: { name: 'Documents' } }
    /**
     * Find zero or one Documents that matches the filter.
     * @param {DocumentsFindUniqueArgs} args - Arguments to find a Documents
     * @example
     * // Get one Documents
     * const documents = await prisma.documents.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DocumentsFindUniqueArgs>(args: SelectSubset<T, DocumentsFindUniqueArgs<ExtArgs>>): Prisma__DocumentsClient<$Result.GetResult<Prisma.$DocumentsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Documents that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DocumentsFindUniqueOrThrowArgs} args - Arguments to find a Documents
     * @example
     * // Get one Documents
     * const documents = await prisma.documents.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DocumentsFindUniqueOrThrowArgs>(args: SelectSubset<T, DocumentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DocumentsClient<$Result.GetResult<Prisma.$DocumentsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Documents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentsFindFirstArgs} args - Arguments to find a Documents
     * @example
     * // Get one Documents
     * const documents = await prisma.documents.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DocumentsFindFirstArgs>(args?: SelectSubset<T, DocumentsFindFirstArgs<ExtArgs>>): Prisma__DocumentsClient<$Result.GetResult<Prisma.$DocumentsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Documents that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentsFindFirstOrThrowArgs} args - Arguments to find a Documents
     * @example
     * // Get one Documents
     * const documents = await prisma.documents.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DocumentsFindFirstOrThrowArgs>(args?: SelectSubset<T, DocumentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__DocumentsClient<$Result.GetResult<Prisma.$DocumentsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Documents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Documents
     * const documents = await prisma.documents.findMany()
     * 
     * // Get first 10 Documents
     * const documents = await prisma.documents.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documentsWithIdOnly = await prisma.documents.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DocumentsFindManyArgs>(args?: SelectSubset<T, DocumentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Documents.
     * @param {DocumentsCreateArgs} args - Arguments to create a Documents.
     * @example
     * // Create one Documents
     * const Documents = await prisma.documents.create({
     *   data: {
     *     // ... data to create a Documents
     *   }
     * })
     * 
     */
    create<T extends DocumentsCreateArgs>(args: SelectSubset<T, DocumentsCreateArgs<ExtArgs>>): Prisma__DocumentsClient<$Result.GetResult<Prisma.$DocumentsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Documents.
     * @param {DocumentsCreateManyArgs} args - Arguments to create many Documents.
     * @example
     * // Create many Documents
     * const documents = await prisma.documents.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DocumentsCreateManyArgs>(args?: SelectSubset<T, DocumentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Documents.
     * @param {DocumentsDeleteArgs} args - Arguments to delete one Documents.
     * @example
     * // Delete one Documents
     * const Documents = await prisma.documents.delete({
     *   where: {
     *     // ... filter to delete one Documents
     *   }
     * })
     * 
     */
    delete<T extends DocumentsDeleteArgs>(args: SelectSubset<T, DocumentsDeleteArgs<ExtArgs>>): Prisma__DocumentsClient<$Result.GetResult<Prisma.$DocumentsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Documents.
     * @param {DocumentsUpdateArgs} args - Arguments to update one Documents.
     * @example
     * // Update one Documents
     * const documents = await prisma.documents.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DocumentsUpdateArgs>(args: SelectSubset<T, DocumentsUpdateArgs<ExtArgs>>): Prisma__DocumentsClient<$Result.GetResult<Prisma.$DocumentsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Documents.
     * @param {DocumentsDeleteManyArgs} args - Arguments to filter Documents to delete.
     * @example
     * // Delete a few Documents
     * const { count } = await prisma.documents.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DocumentsDeleteManyArgs>(args?: SelectSubset<T, DocumentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Documents
     * const documents = await prisma.documents.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DocumentsUpdateManyArgs>(args: SelectSubset<T, DocumentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Documents.
     * @param {DocumentsUpsertArgs} args - Arguments to update or create a Documents.
     * @example
     * // Update or create a Documents
     * const documents = await prisma.documents.upsert({
     *   create: {
     *     // ... data to create a Documents
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Documents we want to update
     *   }
     * })
     */
    upsert<T extends DocumentsUpsertArgs>(args: SelectSubset<T, DocumentsUpsertArgs<ExtArgs>>): Prisma__DocumentsClient<$Result.GetResult<Prisma.$DocumentsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Documents that matches the filter.
     * @param {DocumentsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const documents = await prisma.documents.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: DocumentsFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Documents.
     * @param {DocumentsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const documents = await prisma.documents.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: DocumentsAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentsCountArgs} args - Arguments to filter Documents to count.
     * @example
     * // Count the number of Documents
     * const count = await prisma.documents.count({
     *   where: {
     *     // ... the filter for the Documents we want to count
     *   }
     * })
    **/
    count<T extends DocumentsCountArgs>(
      args?: Subset<T, DocumentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentsAggregateArgs>(args: Subset<T, DocumentsAggregateArgs>): Prisma.PrismaPromise<GetDocumentsAggregateType<T>>

    /**
     * Group by Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DocumentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentsGroupByArgs['orderBy'] }
        : { orderBy?: DocumentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DocumentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Documents model
   */
  readonly fields: DocumentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Documents.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DocumentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    doctype<T extends Documents$doctypeArgs<ExtArgs> = {}>(args?: Subset<T, Documents$doctypeArgs<ExtArgs>>): Prisma__DoctypeClient<$Result.GetResult<Prisma.$DoctypePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    organization<T extends Documents$organizationArgs<ExtArgs> = {}>(args?: Subset<T, Documents$organizationArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    creatorLocation<T extends Documents$creatorLocationArgs<ExtArgs> = {}>(args?: Subset<T, Documents$creatorLocationArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    creatorEntity<T extends Documents$creatorEntityArgs<ExtArgs> = {}>(args?: Subset<T, Documents$creatorEntityArgs<ExtArgs>>): Prisma__EntityClient<$Result.GetResult<Prisma.$EntityPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    ReferenceDocuments<T extends Documents$ReferenceDocumentsArgs<ExtArgs> = {}>(args?: Subset<T, Documents$ReferenceDocumentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferenceDocumentsPayload<ExtArgs>, T, "findMany"> | Null>
    DocumentVersions<T extends Documents$DocumentVersionsArgs<ExtArgs> = {}>(args?: Subset<T, Documents$DocumentVersionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentVersionsPayload<ExtArgs>, T, "findMany"> | Null>
    DocumentComments<T extends Documents$DocumentCommentsArgs<ExtArgs> = {}>(args?: Subset<T, Documents$DocumentCommentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentCommentsPayload<ExtArgs>, T, "findMany"> | Null>
    DocumentWorkFlowHistory<T extends Documents$DocumentWorkFlowHistoryArgs<ExtArgs> = {}>(args?: Subset<T, Documents$DocumentWorkFlowHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentWorkFlowHistoryPayload<ExtArgs>, T, "findMany"> | Null>
    AdditionalDocumentAdmins<T extends Documents$AdditionalDocumentAdminsArgs<ExtArgs> = {}>(args?: Subset<T, Documents$AdditionalDocumentAdminsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdditionalDocumentAdminsPayload<ExtArgs>, T, "findMany"> | Null>
    VersionReferenceDocuments<T extends Documents$VersionReferenceDocumentsArgs<ExtArgs> = {}>(args?: Subset<T, Documents$VersionReferenceDocumentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VersionReferenceDocumentsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Documents model
   */ 
  interface DocumentsFieldRefs {
    readonly id: FieldRef<"Documents", 'String'>
    readonly doctypeId: FieldRef<"Documents", 'String'>
    readonly organizationId: FieldRef<"Documents", 'String'>
    readonly documentName: FieldRef<"Documents", 'String'>
    readonly documentNumbering: FieldRef<"Documents", 'String'>
    readonly reasonOfCreation: FieldRef<"Documents", 'String'>
    readonly effectiveDate: FieldRef<"Documents", 'DateTime'>
    readonly nextRevisionDate: FieldRef<"Documents", 'DateTime'>
    readonly currentVersion: FieldRef<"Documents", 'String'>
    readonly documentLink: FieldRef<"Documents", 'String'>
    readonly description: FieldRef<"Documents", 'String'>
    readonly tags: FieldRef<"Documents", 'String[]'>
    readonly documentState: FieldRef<"Documents", 'String'>
    readonly locationId: FieldRef<"Documents", 'String'>
    readonly entityId: FieldRef<"Documents", 'String'>
    readonly system: FieldRef<"Documents", 'String[]'>
    readonly section: FieldRef<"Documents", 'String'>
    readonly revertComment: FieldRef<"Documents", 'String'>
    readonly docType: FieldRef<"Documents", 'String'>
    readonly documentClassification: FieldRef<"Documents", 'String'>
    readonly issueNumber: FieldRef<"Documents", 'String'>
    readonly retireComment: FieldRef<"Documents", 'String'>
    readonly revisionReminderFlag: FieldRef<"Documents", 'Boolean'>
    readonly isVersion: FieldRef<"Documents", 'Boolean'>
    readonly createdAt: FieldRef<"Documents", 'DateTime'>
    readonly updatedAt: FieldRef<"Documents", 'DateTime'>
    readonly approvedDate: FieldRef<"Documents", 'DateTime'>
    readonly countNumber: FieldRef<"Documents", 'Int'>
    readonly createdBy: FieldRef<"Documents", 'String'>
    readonly distributionList: FieldRef<"Documents", 'String'>
    readonly documentId: FieldRef<"Documents", 'String'>
    readonly reviewers: FieldRef<"Documents", 'String[]'>
    readonly approvers: FieldRef<"Documents", 'String[]'>
    readonly creators: FieldRef<"Documents", 'String[]'>
    readonly distributionUsers: FieldRef<"Documents", 'Json[]'>
    readonly readAccess: FieldRef<"Documents", 'String'>
    readonly readAccessUsers: FieldRef<"Documents", 'Json[]'>
    readonly versionInfo: FieldRef<"Documents", 'Json[]'>
  }
    

  // Custom InputTypes
  /**
   * Documents findUnique
   */
  export type DocumentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Documents
     */
    select?: DocumentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentsInclude<ExtArgs> | null
    /**
     * Filter, which Documents to fetch.
     */
    where: DocumentsWhereUniqueInput
  }

  /**
   * Documents findUniqueOrThrow
   */
  export type DocumentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Documents
     */
    select?: DocumentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentsInclude<ExtArgs> | null
    /**
     * Filter, which Documents to fetch.
     */
    where: DocumentsWhereUniqueInput
  }

  /**
   * Documents findFirst
   */
  export type DocumentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Documents
     */
    select?: DocumentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentsInclude<ExtArgs> | null
    /**
     * Filter, which Documents to fetch.
     */
    where?: DocumentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentsOrderByWithRelationInput | DocumentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: DocumentsScalarFieldEnum | DocumentsScalarFieldEnum[]
  }

  /**
   * Documents findFirstOrThrow
   */
  export type DocumentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Documents
     */
    select?: DocumentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentsInclude<ExtArgs> | null
    /**
     * Filter, which Documents to fetch.
     */
    where?: DocumentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentsOrderByWithRelationInput | DocumentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: DocumentsScalarFieldEnum | DocumentsScalarFieldEnum[]
  }

  /**
   * Documents findMany
   */
  export type DocumentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Documents
     */
    select?: DocumentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentsInclude<ExtArgs> | null
    /**
     * Filter, which Documents to fetch.
     */
    where?: DocumentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentsOrderByWithRelationInput | DocumentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Documents.
     */
    cursor?: DocumentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    distinct?: DocumentsScalarFieldEnum | DocumentsScalarFieldEnum[]
  }

  /**
   * Documents create
   */
  export type DocumentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Documents
     */
    select?: DocumentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentsInclude<ExtArgs> | null
    /**
     * The data needed to create a Documents.
     */
    data: XOR<DocumentsCreateInput, DocumentsUncheckedCreateInput>
  }

  /**
   * Documents createMany
   */
  export type DocumentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Documents.
     */
    data: DocumentsCreateManyInput | DocumentsCreateManyInput[]
  }

  /**
   * Documents update
   */
  export type DocumentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Documents
     */
    select?: DocumentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentsInclude<ExtArgs> | null
    /**
     * The data needed to update a Documents.
     */
    data: XOR<DocumentsUpdateInput, DocumentsUncheckedUpdateInput>
    /**
     * Choose, which Documents to update.
     */
    where: DocumentsWhereUniqueInput
  }

  /**
   * Documents updateMany
   */
  export type DocumentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Documents.
     */
    data: XOR<DocumentsUpdateManyMutationInput, DocumentsUncheckedUpdateManyInput>
    /**
     * Filter which Documents to update
     */
    where?: DocumentsWhereInput
  }

  /**
   * Documents upsert
   */
  export type DocumentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Documents
     */
    select?: DocumentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentsInclude<ExtArgs> | null
    /**
     * The filter to search for the Documents to update in case it exists.
     */
    where: DocumentsWhereUniqueInput
    /**
     * In case the Documents found by the `where` argument doesn't exist, create a new Documents with this data.
     */
    create: XOR<DocumentsCreateInput, DocumentsUncheckedCreateInput>
    /**
     * In case the Documents was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DocumentsUpdateInput, DocumentsUncheckedUpdateInput>
  }

  /**
   * Documents delete
   */
  export type DocumentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Documents
     */
    select?: DocumentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentsInclude<ExtArgs> | null
    /**
     * Filter which Documents to delete.
     */
    where: DocumentsWhereUniqueInput
  }

  /**
   * Documents deleteMany
   */
  export type DocumentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Documents to delete
     */
    where?: DocumentsWhereInput
  }

  /**
   * Documents findRaw
   */
  export type DocumentsFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Documents aggregateRaw
   */
  export type DocumentsAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Documents.doctype
   */
  export type Documents$doctypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctype
     */
    select?: DoctypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctypeInclude<ExtArgs> | null
    where?: DoctypeWhereInput
  }

  /**
   * Documents.organization
   */
  export type Documents$organizationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    where?: OrganizationWhereInput
  }

  /**
   * Documents.creatorLocation
   */
  export type Documents$creatorLocationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    where?: LocationWhereInput
  }

  /**
   * Documents.creatorEntity
   */
  export type Documents$creatorEntityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entity
     */
    select?: EntitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntityInclude<ExtArgs> | null
    where?: EntityWhereInput
  }

  /**
   * Documents.ReferenceDocuments
   */
  export type Documents$ReferenceDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferenceDocuments
     */
    select?: ReferenceDocumentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferenceDocumentsInclude<ExtArgs> | null
    where?: ReferenceDocumentsWhereInput
    orderBy?: ReferenceDocumentsOrderByWithRelationInput | ReferenceDocumentsOrderByWithRelationInput[]
    cursor?: ReferenceDocumentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReferenceDocumentsScalarFieldEnum | ReferenceDocumentsScalarFieldEnum[]
  }

  /**
   * Documents.DocumentVersions
   */
  export type Documents$DocumentVersionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentVersions
     */
    select?: DocumentVersionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentVersionsInclude<ExtArgs> | null
    where?: DocumentVersionsWhereInput
    orderBy?: DocumentVersionsOrderByWithRelationInput | DocumentVersionsOrderByWithRelationInput[]
    cursor?: DocumentVersionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentVersionsScalarFieldEnum | DocumentVersionsScalarFieldEnum[]
  }

  /**
   * Documents.DocumentComments
   */
  export type Documents$DocumentCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentComments
     */
    select?: DocumentCommentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentCommentsInclude<ExtArgs> | null
    where?: DocumentCommentsWhereInput
    orderBy?: DocumentCommentsOrderByWithRelationInput | DocumentCommentsOrderByWithRelationInput[]
    cursor?: DocumentCommentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentCommentsScalarFieldEnum | DocumentCommentsScalarFieldEnum[]
  }

  /**
   * Documents.DocumentWorkFlowHistory
   */
  export type Documents$DocumentWorkFlowHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentWorkFlowHistory
     */
    select?: DocumentWorkFlowHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentWorkFlowHistoryInclude<ExtArgs> | null
    where?: DocumentWorkFlowHistoryWhereInput
    orderBy?: DocumentWorkFlowHistoryOrderByWithRelationInput | DocumentWorkFlowHistoryOrderByWithRelationInput[]
    cursor?: DocumentWorkFlowHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentWorkFlowHistoryScalarFieldEnum | DocumentWorkFlowHistoryScalarFieldEnum[]
  }

  /**
   * Documents.AdditionalDocumentAdmins
   */
  export type Documents$AdditionalDocumentAdminsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdditionalDocumentAdmins
     */
    select?: AdditionalDocumentAdminsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdditionalDocumentAdminsInclude<ExtArgs> | null
    where?: AdditionalDocumentAdminsWhereInput
    orderBy?: AdditionalDocumentAdminsOrderByWithRelationInput | AdditionalDocumentAdminsOrderByWithRelationInput[]
    cursor?: AdditionalDocumentAdminsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdditionalDocumentAdminsScalarFieldEnum | AdditionalDocumentAdminsScalarFieldEnum[]
  }

  /**
   * Documents.VersionReferenceDocuments
   */
  export type Documents$VersionReferenceDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VersionReferenceDocuments
     */
    select?: VersionReferenceDocumentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VersionReferenceDocumentsInclude<ExtArgs> | null
    where?: VersionReferenceDocumentsWhereInput
    orderBy?: VersionReferenceDocumentsOrderByWithRelationInput | VersionReferenceDocumentsOrderByWithRelationInput[]
    cursor?: VersionReferenceDocumentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VersionReferenceDocumentsScalarFieldEnum | VersionReferenceDocumentsScalarFieldEnum[]
  }

  /**
   * Documents without action
   */
  export type DocumentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Documents
     */
    select?: DocumentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentsInclude<ExtArgs> | null
  }


  /**
   * Model documentAttachmentHistory
   */

  export type AggregateDocumentAttachmentHistory = {
    _count: DocumentAttachmentHistoryCountAggregateOutputType | null
    _min: DocumentAttachmentHistoryMinAggregateOutputType | null
    _max: DocumentAttachmentHistoryMaxAggregateOutputType | null
  }

  export type DocumentAttachmentHistoryMinAggregateOutputType = {
    id: string | null
    documentId: string | null
    updatedLink: string | null
    updatedBy: string | null
    updatedAt: Date | null
  }

  export type DocumentAttachmentHistoryMaxAggregateOutputType = {
    id: string | null
    documentId: string | null
    updatedLink: string | null
    updatedBy: string | null
    updatedAt: Date | null
  }

  export type DocumentAttachmentHistoryCountAggregateOutputType = {
    id: number
    documentId: number
    updatedLink: number
    updatedBy: number
    updatedAt: number
    _all: number
  }


  export type DocumentAttachmentHistoryMinAggregateInputType = {
    id?: true
    documentId?: true
    updatedLink?: true
    updatedBy?: true
    updatedAt?: true
  }

  export type DocumentAttachmentHistoryMaxAggregateInputType = {
    id?: true
    documentId?: true
    updatedLink?: true
    updatedBy?: true
    updatedAt?: true
  }

  export type DocumentAttachmentHistoryCountAggregateInputType = {
    id?: true
    documentId?: true
    updatedLink?: true
    updatedBy?: true
    updatedAt?: true
    _all?: true
  }

  export type DocumentAttachmentHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which documentAttachmentHistory to aggregate.
     */
    where?: documentAttachmentHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of documentAttachmentHistories to fetch.
     */
    orderBy?: documentAttachmentHistoryOrderByWithRelationInput | documentAttachmentHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: documentAttachmentHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` documentAttachmentHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` documentAttachmentHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned documentAttachmentHistories
    **/
    _count?: true | DocumentAttachmentHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentAttachmentHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentAttachmentHistoryMaxAggregateInputType
  }

  export type GetDocumentAttachmentHistoryAggregateType<T extends DocumentAttachmentHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateDocumentAttachmentHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocumentAttachmentHistory[P]>
      : GetScalarType<T[P], AggregateDocumentAttachmentHistory[P]>
  }




  export type documentAttachmentHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: documentAttachmentHistoryWhereInput
    orderBy?: documentAttachmentHistoryOrderByWithAggregationInput | documentAttachmentHistoryOrderByWithAggregationInput[]
    by: DocumentAttachmentHistoryScalarFieldEnum[] | DocumentAttachmentHistoryScalarFieldEnum
    having?: documentAttachmentHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentAttachmentHistoryCountAggregateInputType | true
    _min?: DocumentAttachmentHistoryMinAggregateInputType
    _max?: DocumentAttachmentHistoryMaxAggregateInputType
  }

  export type DocumentAttachmentHistoryGroupByOutputType = {
    id: string
    documentId: string | null
    updatedLink: string | null
    updatedBy: string | null
    updatedAt: Date
    _count: DocumentAttachmentHistoryCountAggregateOutputType | null
    _min: DocumentAttachmentHistoryMinAggregateOutputType | null
    _max: DocumentAttachmentHistoryMaxAggregateOutputType | null
  }

  type GetDocumentAttachmentHistoryGroupByPayload<T extends documentAttachmentHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DocumentAttachmentHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentAttachmentHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentAttachmentHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentAttachmentHistoryGroupByOutputType[P]>
        }
      >
    >


  export type documentAttachmentHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    documentId?: boolean
    updatedLink?: boolean
    updatedBy?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["documentAttachmentHistory"]>


  export type documentAttachmentHistorySelectScalar = {
    id?: boolean
    documentId?: boolean
    updatedLink?: boolean
    updatedBy?: boolean
    updatedAt?: boolean
  }


  export type $documentAttachmentHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "documentAttachmentHistory"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      documentId: string | null
      updatedLink: string | null
      updatedBy: string | null
      updatedAt: Date
    }, ExtArgs["result"]["documentAttachmentHistory"]>
    composites: {}
  }

  type documentAttachmentHistoryGetPayload<S extends boolean | null | undefined | documentAttachmentHistoryDefaultArgs> = $Result.GetResult<Prisma.$documentAttachmentHistoryPayload, S>

  type documentAttachmentHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<documentAttachmentHistoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DocumentAttachmentHistoryCountAggregateInputType | true
    }

  export interface documentAttachmentHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['documentAttachmentHistory'], meta: { name: 'documentAttachmentHistory' } }
    /**
     * Find zero or one DocumentAttachmentHistory that matches the filter.
     * @param {documentAttachmentHistoryFindUniqueArgs} args - Arguments to find a DocumentAttachmentHistory
     * @example
     * // Get one DocumentAttachmentHistory
     * const documentAttachmentHistory = await prisma.documentAttachmentHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends documentAttachmentHistoryFindUniqueArgs>(args: SelectSubset<T, documentAttachmentHistoryFindUniqueArgs<ExtArgs>>): Prisma__documentAttachmentHistoryClient<$Result.GetResult<Prisma.$documentAttachmentHistoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DocumentAttachmentHistory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {documentAttachmentHistoryFindUniqueOrThrowArgs} args - Arguments to find a DocumentAttachmentHistory
     * @example
     * // Get one DocumentAttachmentHistory
     * const documentAttachmentHistory = await prisma.documentAttachmentHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends documentAttachmentHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, documentAttachmentHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__documentAttachmentHistoryClient<$Result.GetResult<Prisma.$documentAttachmentHistoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DocumentAttachmentHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {documentAttachmentHistoryFindFirstArgs} args - Arguments to find a DocumentAttachmentHistory
     * @example
     * // Get one DocumentAttachmentHistory
     * const documentAttachmentHistory = await prisma.documentAttachmentHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends documentAttachmentHistoryFindFirstArgs>(args?: SelectSubset<T, documentAttachmentHistoryFindFirstArgs<ExtArgs>>): Prisma__documentAttachmentHistoryClient<$Result.GetResult<Prisma.$documentAttachmentHistoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DocumentAttachmentHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {documentAttachmentHistoryFindFirstOrThrowArgs} args - Arguments to find a DocumentAttachmentHistory
     * @example
     * // Get one DocumentAttachmentHistory
     * const documentAttachmentHistory = await prisma.documentAttachmentHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends documentAttachmentHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, documentAttachmentHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__documentAttachmentHistoryClient<$Result.GetResult<Prisma.$documentAttachmentHistoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DocumentAttachmentHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {documentAttachmentHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DocumentAttachmentHistories
     * const documentAttachmentHistories = await prisma.documentAttachmentHistory.findMany()
     * 
     * // Get first 10 DocumentAttachmentHistories
     * const documentAttachmentHistories = await prisma.documentAttachmentHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documentAttachmentHistoryWithIdOnly = await prisma.documentAttachmentHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends documentAttachmentHistoryFindManyArgs>(args?: SelectSubset<T, documentAttachmentHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$documentAttachmentHistoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DocumentAttachmentHistory.
     * @param {documentAttachmentHistoryCreateArgs} args - Arguments to create a DocumentAttachmentHistory.
     * @example
     * // Create one DocumentAttachmentHistory
     * const DocumentAttachmentHistory = await prisma.documentAttachmentHistory.create({
     *   data: {
     *     // ... data to create a DocumentAttachmentHistory
     *   }
     * })
     * 
     */
    create<T extends documentAttachmentHistoryCreateArgs>(args: SelectSubset<T, documentAttachmentHistoryCreateArgs<ExtArgs>>): Prisma__documentAttachmentHistoryClient<$Result.GetResult<Prisma.$documentAttachmentHistoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DocumentAttachmentHistories.
     * @param {documentAttachmentHistoryCreateManyArgs} args - Arguments to create many DocumentAttachmentHistories.
     * @example
     * // Create many DocumentAttachmentHistories
     * const documentAttachmentHistory = await prisma.documentAttachmentHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends documentAttachmentHistoryCreateManyArgs>(args?: SelectSubset<T, documentAttachmentHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DocumentAttachmentHistory.
     * @param {documentAttachmentHistoryDeleteArgs} args - Arguments to delete one DocumentAttachmentHistory.
     * @example
     * // Delete one DocumentAttachmentHistory
     * const DocumentAttachmentHistory = await prisma.documentAttachmentHistory.delete({
     *   where: {
     *     // ... filter to delete one DocumentAttachmentHistory
     *   }
     * })
     * 
     */
    delete<T extends documentAttachmentHistoryDeleteArgs>(args: SelectSubset<T, documentAttachmentHistoryDeleteArgs<ExtArgs>>): Prisma__documentAttachmentHistoryClient<$Result.GetResult<Prisma.$documentAttachmentHistoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DocumentAttachmentHistory.
     * @param {documentAttachmentHistoryUpdateArgs} args - Arguments to update one DocumentAttachmentHistory.
     * @example
     * // Update one DocumentAttachmentHistory
     * const documentAttachmentHistory = await prisma.documentAttachmentHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends documentAttachmentHistoryUpdateArgs>(args: SelectSubset<T, documentAttachmentHistoryUpdateArgs<ExtArgs>>): Prisma__documentAttachmentHistoryClient<$Result.GetResult<Prisma.$documentAttachmentHistoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DocumentAttachmentHistories.
     * @param {documentAttachmentHistoryDeleteManyArgs} args - Arguments to filter DocumentAttachmentHistories to delete.
     * @example
     * // Delete a few DocumentAttachmentHistories
     * const { count } = await prisma.documentAttachmentHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends documentAttachmentHistoryDeleteManyArgs>(args?: SelectSubset<T, documentAttachmentHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DocumentAttachmentHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {documentAttachmentHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DocumentAttachmentHistories
     * const documentAttachmentHistory = await prisma.documentAttachmentHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends documentAttachmentHistoryUpdateManyArgs>(args: SelectSubset<T, documentAttachmentHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DocumentAttachmentHistory.
     * @param {documentAttachmentHistoryUpsertArgs} args - Arguments to update or create a DocumentAttachmentHistory.
     * @example
     * // Update or create a DocumentAttachmentHistory
     * const documentAttachmentHistory = await prisma.documentAttachmentHistory.upsert({
     *   create: {
     *     // ... data to create a DocumentAttachmentHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DocumentAttachmentHistory we want to update
     *   }
     * })
     */
    upsert<T extends documentAttachmentHistoryUpsertArgs>(args: SelectSubset<T, documentAttachmentHistoryUpsertArgs<ExtArgs>>): Prisma__documentAttachmentHistoryClient<$Result.GetResult<Prisma.$documentAttachmentHistoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more DocumentAttachmentHistories that matches the filter.
     * @param {documentAttachmentHistoryFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const documentAttachmentHistory = await prisma.documentAttachmentHistory.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: documentAttachmentHistoryFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a DocumentAttachmentHistory.
     * @param {documentAttachmentHistoryAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const documentAttachmentHistory = await prisma.documentAttachmentHistory.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: documentAttachmentHistoryAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of DocumentAttachmentHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {documentAttachmentHistoryCountArgs} args - Arguments to filter DocumentAttachmentHistories to count.
     * @example
     * // Count the number of DocumentAttachmentHistories
     * const count = await prisma.documentAttachmentHistory.count({
     *   where: {
     *     // ... the filter for the DocumentAttachmentHistories we want to count
     *   }
     * })
    **/
    count<T extends documentAttachmentHistoryCountArgs>(
      args?: Subset<T, documentAttachmentHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentAttachmentHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DocumentAttachmentHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentAttachmentHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentAttachmentHistoryAggregateArgs>(args: Subset<T, DocumentAttachmentHistoryAggregateArgs>): Prisma.PrismaPromise<GetDocumentAttachmentHistoryAggregateType<T>>

    /**
     * Group by DocumentAttachmentHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {documentAttachmentHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends documentAttachmentHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: documentAttachmentHistoryGroupByArgs['orderBy'] }
        : { orderBy?: documentAttachmentHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, documentAttachmentHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentAttachmentHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the documentAttachmentHistory model
   */
  readonly fields: documentAttachmentHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for documentAttachmentHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__documentAttachmentHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the documentAttachmentHistory model
   */ 
  interface documentAttachmentHistoryFieldRefs {
    readonly id: FieldRef<"documentAttachmentHistory", 'String'>
    readonly documentId: FieldRef<"documentAttachmentHistory", 'String'>
    readonly updatedLink: FieldRef<"documentAttachmentHistory", 'String'>
    readonly updatedBy: FieldRef<"documentAttachmentHistory", 'String'>
    readonly updatedAt: FieldRef<"documentAttachmentHistory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * documentAttachmentHistory findUnique
   */
  export type documentAttachmentHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the documentAttachmentHistory
     */
    select?: documentAttachmentHistorySelect<ExtArgs> | null
    /**
     * Filter, which documentAttachmentHistory to fetch.
     */
    where: documentAttachmentHistoryWhereUniqueInput
  }

  /**
   * documentAttachmentHistory findUniqueOrThrow
   */
  export type documentAttachmentHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the documentAttachmentHistory
     */
    select?: documentAttachmentHistorySelect<ExtArgs> | null
    /**
     * Filter, which documentAttachmentHistory to fetch.
     */
    where: documentAttachmentHistoryWhereUniqueInput
  }

  /**
   * documentAttachmentHistory findFirst
   */
  export type documentAttachmentHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the documentAttachmentHistory
     */
    select?: documentAttachmentHistorySelect<ExtArgs> | null
    /**
     * Filter, which documentAttachmentHistory to fetch.
     */
    where?: documentAttachmentHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of documentAttachmentHistories to fetch.
     */
    orderBy?: documentAttachmentHistoryOrderByWithRelationInput | documentAttachmentHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for documentAttachmentHistories.
     */
    cursor?: documentAttachmentHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` documentAttachmentHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` documentAttachmentHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of documentAttachmentHistories.
     */
    distinct?: DocumentAttachmentHistoryScalarFieldEnum | DocumentAttachmentHistoryScalarFieldEnum[]
  }

  /**
   * documentAttachmentHistory findFirstOrThrow
   */
  export type documentAttachmentHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the documentAttachmentHistory
     */
    select?: documentAttachmentHistorySelect<ExtArgs> | null
    /**
     * Filter, which documentAttachmentHistory to fetch.
     */
    where?: documentAttachmentHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of documentAttachmentHistories to fetch.
     */
    orderBy?: documentAttachmentHistoryOrderByWithRelationInput | documentAttachmentHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for documentAttachmentHistories.
     */
    cursor?: documentAttachmentHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` documentAttachmentHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` documentAttachmentHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of documentAttachmentHistories.
     */
    distinct?: DocumentAttachmentHistoryScalarFieldEnum | DocumentAttachmentHistoryScalarFieldEnum[]
  }

  /**
   * documentAttachmentHistory findMany
   */
  export type documentAttachmentHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the documentAttachmentHistory
     */
    select?: documentAttachmentHistorySelect<ExtArgs> | null
    /**
     * Filter, which documentAttachmentHistories to fetch.
     */
    where?: documentAttachmentHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of documentAttachmentHistories to fetch.
     */
    orderBy?: documentAttachmentHistoryOrderByWithRelationInput | documentAttachmentHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing documentAttachmentHistories.
     */
    cursor?: documentAttachmentHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` documentAttachmentHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` documentAttachmentHistories.
     */
    skip?: number
    distinct?: DocumentAttachmentHistoryScalarFieldEnum | DocumentAttachmentHistoryScalarFieldEnum[]
  }

  /**
   * documentAttachmentHistory create
   */
  export type documentAttachmentHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the documentAttachmentHistory
     */
    select?: documentAttachmentHistorySelect<ExtArgs> | null
    /**
     * The data needed to create a documentAttachmentHistory.
     */
    data: XOR<documentAttachmentHistoryCreateInput, documentAttachmentHistoryUncheckedCreateInput>
  }

  /**
   * documentAttachmentHistory createMany
   */
  export type documentAttachmentHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many documentAttachmentHistories.
     */
    data: documentAttachmentHistoryCreateManyInput | documentAttachmentHistoryCreateManyInput[]
  }

  /**
   * documentAttachmentHistory update
   */
  export type documentAttachmentHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the documentAttachmentHistory
     */
    select?: documentAttachmentHistorySelect<ExtArgs> | null
    /**
     * The data needed to update a documentAttachmentHistory.
     */
    data: XOR<documentAttachmentHistoryUpdateInput, documentAttachmentHistoryUncheckedUpdateInput>
    /**
     * Choose, which documentAttachmentHistory to update.
     */
    where: documentAttachmentHistoryWhereUniqueInput
  }

  /**
   * documentAttachmentHistory updateMany
   */
  export type documentAttachmentHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update documentAttachmentHistories.
     */
    data: XOR<documentAttachmentHistoryUpdateManyMutationInput, documentAttachmentHistoryUncheckedUpdateManyInput>
    /**
     * Filter which documentAttachmentHistories to update
     */
    where?: documentAttachmentHistoryWhereInput
  }

  /**
   * documentAttachmentHistory upsert
   */
  export type documentAttachmentHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the documentAttachmentHistory
     */
    select?: documentAttachmentHistorySelect<ExtArgs> | null
    /**
     * The filter to search for the documentAttachmentHistory to update in case it exists.
     */
    where: documentAttachmentHistoryWhereUniqueInput
    /**
     * In case the documentAttachmentHistory found by the `where` argument doesn't exist, create a new documentAttachmentHistory with this data.
     */
    create: XOR<documentAttachmentHistoryCreateInput, documentAttachmentHistoryUncheckedCreateInput>
    /**
     * In case the documentAttachmentHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<documentAttachmentHistoryUpdateInput, documentAttachmentHistoryUncheckedUpdateInput>
  }

  /**
   * documentAttachmentHistory delete
   */
  export type documentAttachmentHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the documentAttachmentHistory
     */
    select?: documentAttachmentHistorySelect<ExtArgs> | null
    /**
     * Filter which documentAttachmentHistory to delete.
     */
    where: documentAttachmentHistoryWhereUniqueInput
  }

  /**
   * documentAttachmentHistory deleteMany
   */
  export type documentAttachmentHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which documentAttachmentHistories to delete
     */
    where?: documentAttachmentHistoryWhereInput
  }

  /**
   * documentAttachmentHistory findRaw
   */
  export type documentAttachmentHistoryFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * documentAttachmentHistory aggregateRaw
   */
  export type documentAttachmentHistoryAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * documentAttachmentHistory without action
   */
  export type documentAttachmentHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the documentAttachmentHistory
     */
    select?: documentAttachmentHistorySelect<ExtArgs> | null
  }


  /**
   * Model ReferenceDocuments
   */

  export type AggregateReferenceDocuments = {
    _count: ReferenceDocumentsCountAggregateOutputType | null
    _min: ReferenceDocumentsMinAggregateOutputType | null
    _max: ReferenceDocumentsMaxAggregateOutputType | null
  }

  export type ReferenceDocumentsMinAggregateOutputType = {
    id: string | null
    documentLink: string | null
    type: string | null
    documentName: string | null
    version: string | null
    documentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    referenceDocId: string | null
    versionId: string | null
  }

  export type ReferenceDocumentsMaxAggregateOutputType = {
    id: string | null
    documentLink: string | null
    type: string | null
    documentName: string | null
    version: string | null
    documentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    referenceDocId: string | null
    versionId: string | null
  }

  export type ReferenceDocumentsCountAggregateOutputType = {
    id: number
    documentLink: number
    type: number
    documentName: number
    version: number
    documentId: number
    createdAt: number
    updatedAt: number
    referenceDocId: number
    versionId: number
    _all: number
  }


  export type ReferenceDocumentsMinAggregateInputType = {
    id?: true
    documentLink?: true
    type?: true
    documentName?: true
    version?: true
    documentId?: true
    createdAt?: true
    updatedAt?: true
    referenceDocId?: true
    versionId?: true
  }

  export type ReferenceDocumentsMaxAggregateInputType = {
    id?: true
    documentLink?: true
    type?: true
    documentName?: true
    version?: true
    documentId?: true
    createdAt?: true
    updatedAt?: true
    referenceDocId?: true
    versionId?: true
  }

  export type ReferenceDocumentsCountAggregateInputType = {
    id?: true
    documentLink?: true
    type?: true
    documentName?: true
    version?: true
    documentId?: true
    createdAt?: true
    updatedAt?: true
    referenceDocId?: true
    versionId?: true
    _all?: true
  }

  export type ReferenceDocumentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReferenceDocuments to aggregate.
     */
    where?: ReferenceDocumentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReferenceDocuments to fetch.
     */
    orderBy?: ReferenceDocumentsOrderByWithRelationInput | ReferenceDocumentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReferenceDocumentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReferenceDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReferenceDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReferenceDocuments
    **/
    _count?: true | ReferenceDocumentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReferenceDocumentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReferenceDocumentsMaxAggregateInputType
  }

  export type GetReferenceDocumentsAggregateType<T extends ReferenceDocumentsAggregateArgs> = {
        [P in keyof T & keyof AggregateReferenceDocuments]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReferenceDocuments[P]>
      : GetScalarType<T[P], AggregateReferenceDocuments[P]>
  }




  export type ReferenceDocumentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReferenceDocumentsWhereInput
    orderBy?: ReferenceDocumentsOrderByWithAggregationInput | ReferenceDocumentsOrderByWithAggregationInput[]
    by: ReferenceDocumentsScalarFieldEnum[] | ReferenceDocumentsScalarFieldEnum
    having?: ReferenceDocumentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReferenceDocumentsCountAggregateInputType | true
    _min?: ReferenceDocumentsMinAggregateInputType
    _max?: ReferenceDocumentsMaxAggregateInputType
  }

  export type ReferenceDocumentsGroupByOutputType = {
    id: string
    documentLink: string | null
    type: string | null
    documentName: string | null
    version: string | null
    documentId: string | null
    createdAt: Date
    updatedAt: Date
    referenceDocId: string | null
    versionId: string | null
    _count: ReferenceDocumentsCountAggregateOutputType | null
    _min: ReferenceDocumentsMinAggregateOutputType | null
    _max: ReferenceDocumentsMaxAggregateOutputType | null
  }

  type GetReferenceDocumentsGroupByPayload<T extends ReferenceDocumentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReferenceDocumentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReferenceDocumentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReferenceDocumentsGroupByOutputType[P]>
            : GetScalarType<T[P], ReferenceDocumentsGroupByOutputType[P]>
        }
      >
    >


  export type ReferenceDocumentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    documentLink?: boolean
    type?: boolean
    documentName?: boolean
    version?: boolean
    documentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    referenceDocId?: boolean
    versionId?: boolean
    document?: boolean | ReferenceDocuments$documentArgs<ExtArgs>
    versionsLinkedWith?: boolean | ReferenceDocuments$versionsLinkedWithArgs<ExtArgs>
  }, ExtArgs["result"]["referenceDocuments"]>


  export type ReferenceDocumentsSelectScalar = {
    id?: boolean
    documentLink?: boolean
    type?: boolean
    documentName?: boolean
    version?: boolean
    documentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    referenceDocId?: boolean
    versionId?: boolean
  }

  export type ReferenceDocumentsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    document?: boolean | ReferenceDocuments$documentArgs<ExtArgs>
    versionsLinkedWith?: boolean | ReferenceDocuments$versionsLinkedWithArgs<ExtArgs>
  }

  export type $ReferenceDocumentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReferenceDocuments"
    objects: {
      document: Prisma.$DocumentsPayload<ExtArgs> | null
      versionsLinkedWith: Prisma.$DocumentVersionsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      documentLink: string | null
      type: string | null
      documentName: string | null
      version: string | null
      documentId: string | null
      createdAt: Date
      updatedAt: Date
      referenceDocId: string | null
      versionId: string | null
    }, ExtArgs["result"]["referenceDocuments"]>
    composites: {}
  }

  type ReferenceDocumentsGetPayload<S extends boolean | null | undefined | ReferenceDocumentsDefaultArgs> = $Result.GetResult<Prisma.$ReferenceDocumentsPayload, S>

  type ReferenceDocumentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ReferenceDocumentsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ReferenceDocumentsCountAggregateInputType | true
    }

  export interface ReferenceDocumentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReferenceDocuments'], meta: { name: 'ReferenceDocuments' } }
    /**
     * Find zero or one ReferenceDocuments that matches the filter.
     * @param {ReferenceDocumentsFindUniqueArgs} args - Arguments to find a ReferenceDocuments
     * @example
     * // Get one ReferenceDocuments
     * const referenceDocuments = await prisma.referenceDocuments.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReferenceDocumentsFindUniqueArgs>(args: SelectSubset<T, ReferenceDocumentsFindUniqueArgs<ExtArgs>>): Prisma__ReferenceDocumentsClient<$Result.GetResult<Prisma.$ReferenceDocumentsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ReferenceDocuments that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ReferenceDocumentsFindUniqueOrThrowArgs} args - Arguments to find a ReferenceDocuments
     * @example
     * // Get one ReferenceDocuments
     * const referenceDocuments = await prisma.referenceDocuments.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReferenceDocumentsFindUniqueOrThrowArgs>(args: SelectSubset<T, ReferenceDocumentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReferenceDocumentsClient<$Result.GetResult<Prisma.$ReferenceDocumentsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ReferenceDocuments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferenceDocumentsFindFirstArgs} args - Arguments to find a ReferenceDocuments
     * @example
     * // Get one ReferenceDocuments
     * const referenceDocuments = await prisma.referenceDocuments.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReferenceDocumentsFindFirstArgs>(args?: SelectSubset<T, ReferenceDocumentsFindFirstArgs<ExtArgs>>): Prisma__ReferenceDocumentsClient<$Result.GetResult<Prisma.$ReferenceDocumentsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ReferenceDocuments that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferenceDocumentsFindFirstOrThrowArgs} args - Arguments to find a ReferenceDocuments
     * @example
     * // Get one ReferenceDocuments
     * const referenceDocuments = await prisma.referenceDocuments.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReferenceDocumentsFindFirstOrThrowArgs>(args?: SelectSubset<T, ReferenceDocumentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReferenceDocumentsClient<$Result.GetResult<Prisma.$ReferenceDocumentsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ReferenceDocuments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferenceDocumentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReferenceDocuments
     * const referenceDocuments = await prisma.referenceDocuments.findMany()
     * 
     * // Get first 10 ReferenceDocuments
     * const referenceDocuments = await prisma.referenceDocuments.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const referenceDocumentsWithIdOnly = await prisma.referenceDocuments.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReferenceDocumentsFindManyArgs>(args?: SelectSubset<T, ReferenceDocumentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferenceDocumentsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ReferenceDocuments.
     * @param {ReferenceDocumentsCreateArgs} args - Arguments to create a ReferenceDocuments.
     * @example
     * // Create one ReferenceDocuments
     * const ReferenceDocuments = await prisma.referenceDocuments.create({
     *   data: {
     *     // ... data to create a ReferenceDocuments
     *   }
     * })
     * 
     */
    create<T extends ReferenceDocumentsCreateArgs>(args: SelectSubset<T, ReferenceDocumentsCreateArgs<ExtArgs>>): Prisma__ReferenceDocumentsClient<$Result.GetResult<Prisma.$ReferenceDocumentsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ReferenceDocuments.
     * @param {ReferenceDocumentsCreateManyArgs} args - Arguments to create many ReferenceDocuments.
     * @example
     * // Create many ReferenceDocuments
     * const referenceDocuments = await prisma.referenceDocuments.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReferenceDocumentsCreateManyArgs>(args?: SelectSubset<T, ReferenceDocumentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ReferenceDocuments.
     * @param {ReferenceDocumentsDeleteArgs} args - Arguments to delete one ReferenceDocuments.
     * @example
     * // Delete one ReferenceDocuments
     * const ReferenceDocuments = await prisma.referenceDocuments.delete({
     *   where: {
     *     // ... filter to delete one ReferenceDocuments
     *   }
     * })
     * 
     */
    delete<T extends ReferenceDocumentsDeleteArgs>(args: SelectSubset<T, ReferenceDocumentsDeleteArgs<ExtArgs>>): Prisma__ReferenceDocumentsClient<$Result.GetResult<Prisma.$ReferenceDocumentsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ReferenceDocuments.
     * @param {ReferenceDocumentsUpdateArgs} args - Arguments to update one ReferenceDocuments.
     * @example
     * // Update one ReferenceDocuments
     * const referenceDocuments = await prisma.referenceDocuments.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReferenceDocumentsUpdateArgs>(args: SelectSubset<T, ReferenceDocumentsUpdateArgs<ExtArgs>>): Prisma__ReferenceDocumentsClient<$Result.GetResult<Prisma.$ReferenceDocumentsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ReferenceDocuments.
     * @param {ReferenceDocumentsDeleteManyArgs} args - Arguments to filter ReferenceDocuments to delete.
     * @example
     * // Delete a few ReferenceDocuments
     * const { count } = await prisma.referenceDocuments.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReferenceDocumentsDeleteManyArgs>(args?: SelectSubset<T, ReferenceDocumentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReferenceDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferenceDocumentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReferenceDocuments
     * const referenceDocuments = await prisma.referenceDocuments.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReferenceDocumentsUpdateManyArgs>(args: SelectSubset<T, ReferenceDocumentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ReferenceDocuments.
     * @param {ReferenceDocumentsUpsertArgs} args - Arguments to update or create a ReferenceDocuments.
     * @example
     * // Update or create a ReferenceDocuments
     * const referenceDocuments = await prisma.referenceDocuments.upsert({
     *   create: {
     *     // ... data to create a ReferenceDocuments
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReferenceDocuments we want to update
     *   }
     * })
     */
    upsert<T extends ReferenceDocumentsUpsertArgs>(args: SelectSubset<T, ReferenceDocumentsUpsertArgs<ExtArgs>>): Prisma__ReferenceDocumentsClient<$Result.GetResult<Prisma.$ReferenceDocumentsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more ReferenceDocuments that matches the filter.
     * @param {ReferenceDocumentsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const referenceDocuments = await prisma.referenceDocuments.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: ReferenceDocumentsFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a ReferenceDocuments.
     * @param {ReferenceDocumentsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const referenceDocuments = await prisma.referenceDocuments.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: ReferenceDocumentsAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of ReferenceDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferenceDocumentsCountArgs} args - Arguments to filter ReferenceDocuments to count.
     * @example
     * // Count the number of ReferenceDocuments
     * const count = await prisma.referenceDocuments.count({
     *   where: {
     *     // ... the filter for the ReferenceDocuments we want to count
     *   }
     * })
    **/
    count<T extends ReferenceDocumentsCountArgs>(
      args?: Subset<T, ReferenceDocumentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReferenceDocumentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReferenceDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferenceDocumentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReferenceDocumentsAggregateArgs>(args: Subset<T, ReferenceDocumentsAggregateArgs>): Prisma.PrismaPromise<GetReferenceDocumentsAggregateType<T>>

    /**
     * Group by ReferenceDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferenceDocumentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReferenceDocumentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReferenceDocumentsGroupByArgs['orderBy'] }
        : { orderBy?: ReferenceDocumentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReferenceDocumentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReferenceDocumentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReferenceDocuments model
   */
  readonly fields: ReferenceDocumentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReferenceDocuments.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReferenceDocumentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    document<T extends ReferenceDocuments$documentArgs<ExtArgs> = {}>(args?: Subset<T, ReferenceDocuments$documentArgs<ExtArgs>>): Prisma__DocumentsClient<$Result.GetResult<Prisma.$DocumentsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    versionsLinkedWith<T extends ReferenceDocuments$versionsLinkedWithArgs<ExtArgs> = {}>(args?: Subset<T, ReferenceDocuments$versionsLinkedWithArgs<ExtArgs>>): Prisma__DocumentVersionsClient<$Result.GetResult<Prisma.$DocumentVersionsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ReferenceDocuments model
   */ 
  interface ReferenceDocumentsFieldRefs {
    readonly id: FieldRef<"ReferenceDocuments", 'String'>
    readonly documentLink: FieldRef<"ReferenceDocuments", 'String'>
    readonly type: FieldRef<"ReferenceDocuments", 'String'>
    readonly documentName: FieldRef<"ReferenceDocuments", 'String'>
    readonly version: FieldRef<"ReferenceDocuments", 'String'>
    readonly documentId: FieldRef<"ReferenceDocuments", 'String'>
    readonly createdAt: FieldRef<"ReferenceDocuments", 'DateTime'>
    readonly updatedAt: FieldRef<"ReferenceDocuments", 'DateTime'>
    readonly referenceDocId: FieldRef<"ReferenceDocuments", 'String'>
    readonly versionId: FieldRef<"ReferenceDocuments", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ReferenceDocuments findUnique
   */
  export type ReferenceDocumentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferenceDocuments
     */
    select?: ReferenceDocumentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferenceDocumentsInclude<ExtArgs> | null
    /**
     * Filter, which ReferenceDocuments to fetch.
     */
    where: ReferenceDocumentsWhereUniqueInput
  }

  /**
   * ReferenceDocuments findUniqueOrThrow
   */
  export type ReferenceDocumentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferenceDocuments
     */
    select?: ReferenceDocumentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferenceDocumentsInclude<ExtArgs> | null
    /**
     * Filter, which ReferenceDocuments to fetch.
     */
    where: ReferenceDocumentsWhereUniqueInput
  }

  /**
   * ReferenceDocuments findFirst
   */
  export type ReferenceDocumentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferenceDocuments
     */
    select?: ReferenceDocumentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferenceDocumentsInclude<ExtArgs> | null
    /**
     * Filter, which ReferenceDocuments to fetch.
     */
    where?: ReferenceDocumentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReferenceDocuments to fetch.
     */
    orderBy?: ReferenceDocumentsOrderByWithRelationInput | ReferenceDocumentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReferenceDocuments.
     */
    cursor?: ReferenceDocumentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReferenceDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReferenceDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReferenceDocuments.
     */
    distinct?: ReferenceDocumentsScalarFieldEnum | ReferenceDocumentsScalarFieldEnum[]
  }

  /**
   * ReferenceDocuments findFirstOrThrow
   */
  export type ReferenceDocumentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferenceDocuments
     */
    select?: ReferenceDocumentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferenceDocumentsInclude<ExtArgs> | null
    /**
     * Filter, which ReferenceDocuments to fetch.
     */
    where?: ReferenceDocumentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReferenceDocuments to fetch.
     */
    orderBy?: ReferenceDocumentsOrderByWithRelationInput | ReferenceDocumentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReferenceDocuments.
     */
    cursor?: ReferenceDocumentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReferenceDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReferenceDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReferenceDocuments.
     */
    distinct?: ReferenceDocumentsScalarFieldEnum | ReferenceDocumentsScalarFieldEnum[]
  }

  /**
   * ReferenceDocuments findMany
   */
  export type ReferenceDocumentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferenceDocuments
     */
    select?: ReferenceDocumentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferenceDocumentsInclude<ExtArgs> | null
    /**
     * Filter, which ReferenceDocuments to fetch.
     */
    where?: ReferenceDocumentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReferenceDocuments to fetch.
     */
    orderBy?: ReferenceDocumentsOrderByWithRelationInput | ReferenceDocumentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReferenceDocuments.
     */
    cursor?: ReferenceDocumentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReferenceDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReferenceDocuments.
     */
    skip?: number
    distinct?: ReferenceDocumentsScalarFieldEnum | ReferenceDocumentsScalarFieldEnum[]
  }

  /**
   * ReferenceDocuments create
   */
  export type ReferenceDocumentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferenceDocuments
     */
    select?: ReferenceDocumentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferenceDocumentsInclude<ExtArgs> | null
    /**
     * The data needed to create a ReferenceDocuments.
     */
    data: XOR<ReferenceDocumentsCreateInput, ReferenceDocumentsUncheckedCreateInput>
  }

  /**
   * ReferenceDocuments createMany
   */
  export type ReferenceDocumentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReferenceDocuments.
     */
    data: ReferenceDocumentsCreateManyInput | ReferenceDocumentsCreateManyInput[]
  }

  /**
   * ReferenceDocuments update
   */
  export type ReferenceDocumentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferenceDocuments
     */
    select?: ReferenceDocumentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferenceDocumentsInclude<ExtArgs> | null
    /**
     * The data needed to update a ReferenceDocuments.
     */
    data: XOR<ReferenceDocumentsUpdateInput, ReferenceDocumentsUncheckedUpdateInput>
    /**
     * Choose, which ReferenceDocuments to update.
     */
    where: ReferenceDocumentsWhereUniqueInput
  }

  /**
   * ReferenceDocuments updateMany
   */
  export type ReferenceDocumentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReferenceDocuments.
     */
    data: XOR<ReferenceDocumentsUpdateManyMutationInput, ReferenceDocumentsUncheckedUpdateManyInput>
    /**
     * Filter which ReferenceDocuments to update
     */
    where?: ReferenceDocumentsWhereInput
  }

  /**
   * ReferenceDocuments upsert
   */
  export type ReferenceDocumentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferenceDocuments
     */
    select?: ReferenceDocumentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferenceDocumentsInclude<ExtArgs> | null
    /**
     * The filter to search for the ReferenceDocuments to update in case it exists.
     */
    where: ReferenceDocumentsWhereUniqueInput
    /**
     * In case the ReferenceDocuments found by the `where` argument doesn't exist, create a new ReferenceDocuments with this data.
     */
    create: XOR<ReferenceDocumentsCreateInput, ReferenceDocumentsUncheckedCreateInput>
    /**
     * In case the ReferenceDocuments was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReferenceDocumentsUpdateInput, ReferenceDocumentsUncheckedUpdateInput>
  }

  /**
   * ReferenceDocuments delete
   */
  export type ReferenceDocumentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferenceDocuments
     */
    select?: ReferenceDocumentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferenceDocumentsInclude<ExtArgs> | null
    /**
     * Filter which ReferenceDocuments to delete.
     */
    where: ReferenceDocumentsWhereUniqueInput
  }

  /**
   * ReferenceDocuments deleteMany
   */
  export type ReferenceDocumentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReferenceDocuments to delete
     */
    where?: ReferenceDocumentsWhereInput
  }

  /**
   * ReferenceDocuments findRaw
   */
  export type ReferenceDocumentsFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * ReferenceDocuments aggregateRaw
   */
  export type ReferenceDocumentsAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * ReferenceDocuments.document
   */
  export type ReferenceDocuments$documentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Documents
     */
    select?: DocumentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentsInclude<ExtArgs> | null
    where?: DocumentsWhereInput
  }

  /**
   * ReferenceDocuments.versionsLinkedWith
   */
  export type ReferenceDocuments$versionsLinkedWithArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentVersions
     */
    select?: DocumentVersionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentVersionsInclude<ExtArgs> | null
    where?: DocumentVersionsWhereInput
  }

  /**
   * ReferenceDocuments without action
   */
  export type ReferenceDocumentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferenceDocuments
     */
    select?: ReferenceDocumentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferenceDocumentsInclude<ExtArgs> | null
  }


  /**
   * Model VersionReferenceDocuments
   */

  export type AggregateVersionReferenceDocuments = {
    _count: VersionReferenceDocumentsCountAggregateOutputType | null
    _min: VersionReferenceDocumentsMinAggregateOutputType | null
    _max: VersionReferenceDocumentsMaxAggregateOutputType | null
  }

  export type VersionReferenceDocumentsMinAggregateOutputType = {
    id: string | null
    documentLink: string | null
    type: string | null
    documentName: string | null
    version: string | null
    createdAt: Date | null
    updatedAt: Date | null
    referenceDocId: string | null
    versionId: string | null
    documentsId: string | null
  }

  export type VersionReferenceDocumentsMaxAggregateOutputType = {
    id: string | null
    documentLink: string | null
    type: string | null
    documentName: string | null
    version: string | null
    createdAt: Date | null
    updatedAt: Date | null
    referenceDocId: string | null
    versionId: string | null
    documentsId: string | null
  }

  export type VersionReferenceDocumentsCountAggregateOutputType = {
    id: number
    documentLink: number
    type: number
    documentName: number
    version: number
    createdAt: number
    updatedAt: number
    referenceDocId: number
    versionId: number
    documentsId: number
    _all: number
  }


  export type VersionReferenceDocumentsMinAggregateInputType = {
    id?: true
    documentLink?: true
    type?: true
    documentName?: true
    version?: true
    createdAt?: true
    updatedAt?: true
    referenceDocId?: true
    versionId?: true
    documentsId?: true
  }

  export type VersionReferenceDocumentsMaxAggregateInputType = {
    id?: true
    documentLink?: true
    type?: true
    documentName?: true
    version?: true
    createdAt?: true
    updatedAt?: true
    referenceDocId?: true
    versionId?: true
    documentsId?: true
  }

  export type VersionReferenceDocumentsCountAggregateInputType = {
    id?: true
    documentLink?: true
    type?: true
    documentName?: true
    version?: true
    createdAt?: true
    updatedAt?: true
    referenceDocId?: true
    versionId?: true
    documentsId?: true
    _all?: true
  }

  export type VersionReferenceDocumentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VersionReferenceDocuments to aggregate.
     */
    where?: VersionReferenceDocumentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VersionReferenceDocuments to fetch.
     */
    orderBy?: VersionReferenceDocumentsOrderByWithRelationInput | VersionReferenceDocumentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VersionReferenceDocumentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VersionReferenceDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VersionReferenceDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VersionReferenceDocuments
    **/
    _count?: true | VersionReferenceDocumentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VersionReferenceDocumentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VersionReferenceDocumentsMaxAggregateInputType
  }

  export type GetVersionReferenceDocumentsAggregateType<T extends VersionReferenceDocumentsAggregateArgs> = {
        [P in keyof T & keyof AggregateVersionReferenceDocuments]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVersionReferenceDocuments[P]>
      : GetScalarType<T[P], AggregateVersionReferenceDocuments[P]>
  }




  export type VersionReferenceDocumentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VersionReferenceDocumentsWhereInput
    orderBy?: VersionReferenceDocumentsOrderByWithAggregationInput | VersionReferenceDocumentsOrderByWithAggregationInput[]
    by: VersionReferenceDocumentsScalarFieldEnum[] | VersionReferenceDocumentsScalarFieldEnum
    having?: VersionReferenceDocumentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VersionReferenceDocumentsCountAggregateInputType | true
    _min?: VersionReferenceDocumentsMinAggregateInputType
    _max?: VersionReferenceDocumentsMaxAggregateInputType
  }

  export type VersionReferenceDocumentsGroupByOutputType = {
    id: string
    documentLink: string | null
    type: string | null
    documentName: string | null
    version: string | null
    createdAt: Date
    updatedAt: Date
    referenceDocId: string | null
    versionId: string | null
    documentsId: string | null
    _count: VersionReferenceDocumentsCountAggregateOutputType | null
    _min: VersionReferenceDocumentsMinAggregateOutputType | null
    _max: VersionReferenceDocumentsMaxAggregateOutputType | null
  }

  type GetVersionReferenceDocumentsGroupByPayload<T extends VersionReferenceDocumentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VersionReferenceDocumentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VersionReferenceDocumentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VersionReferenceDocumentsGroupByOutputType[P]>
            : GetScalarType<T[P], VersionReferenceDocumentsGroupByOutputType[P]>
        }
      >
    >


  export type VersionReferenceDocumentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    documentLink?: boolean
    type?: boolean
    documentName?: boolean
    version?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    referenceDocId?: boolean
    versionId?: boolean
    documentsId?: boolean
    Documents?: boolean | VersionReferenceDocuments$DocumentsArgs<ExtArgs>
    versionsLinkedWith?: boolean | VersionReferenceDocuments$versionsLinkedWithArgs<ExtArgs>
  }, ExtArgs["result"]["versionReferenceDocuments"]>


  export type VersionReferenceDocumentsSelectScalar = {
    id?: boolean
    documentLink?: boolean
    type?: boolean
    documentName?: boolean
    version?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    referenceDocId?: boolean
    versionId?: boolean
    documentsId?: boolean
  }

  export type VersionReferenceDocumentsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Documents?: boolean | VersionReferenceDocuments$DocumentsArgs<ExtArgs>
    versionsLinkedWith?: boolean | VersionReferenceDocuments$versionsLinkedWithArgs<ExtArgs>
  }

  export type $VersionReferenceDocumentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VersionReferenceDocuments"
    objects: {
      Documents: Prisma.$DocumentsPayload<ExtArgs> | null
      versionsLinkedWith: Prisma.$DocumentVersionsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      documentLink: string | null
      type: string | null
      documentName: string | null
      version: string | null
      createdAt: Date
      updatedAt: Date
      referenceDocId: string | null
      versionId: string | null
      documentsId: string | null
    }, ExtArgs["result"]["versionReferenceDocuments"]>
    composites: {}
  }

  type VersionReferenceDocumentsGetPayload<S extends boolean | null | undefined | VersionReferenceDocumentsDefaultArgs> = $Result.GetResult<Prisma.$VersionReferenceDocumentsPayload, S>

  type VersionReferenceDocumentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VersionReferenceDocumentsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VersionReferenceDocumentsCountAggregateInputType | true
    }

  export interface VersionReferenceDocumentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VersionReferenceDocuments'], meta: { name: 'VersionReferenceDocuments' } }
    /**
     * Find zero or one VersionReferenceDocuments that matches the filter.
     * @param {VersionReferenceDocumentsFindUniqueArgs} args - Arguments to find a VersionReferenceDocuments
     * @example
     * // Get one VersionReferenceDocuments
     * const versionReferenceDocuments = await prisma.versionReferenceDocuments.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VersionReferenceDocumentsFindUniqueArgs>(args: SelectSubset<T, VersionReferenceDocumentsFindUniqueArgs<ExtArgs>>): Prisma__VersionReferenceDocumentsClient<$Result.GetResult<Prisma.$VersionReferenceDocumentsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one VersionReferenceDocuments that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {VersionReferenceDocumentsFindUniqueOrThrowArgs} args - Arguments to find a VersionReferenceDocuments
     * @example
     * // Get one VersionReferenceDocuments
     * const versionReferenceDocuments = await prisma.versionReferenceDocuments.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VersionReferenceDocumentsFindUniqueOrThrowArgs>(args: SelectSubset<T, VersionReferenceDocumentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VersionReferenceDocumentsClient<$Result.GetResult<Prisma.$VersionReferenceDocumentsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first VersionReferenceDocuments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VersionReferenceDocumentsFindFirstArgs} args - Arguments to find a VersionReferenceDocuments
     * @example
     * // Get one VersionReferenceDocuments
     * const versionReferenceDocuments = await prisma.versionReferenceDocuments.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VersionReferenceDocumentsFindFirstArgs>(args?: SelectSubset<T, VersionReferenceDocumentsFindFirstArgs<ExtArgs>>): Prisma__VersionReferenceDocumentsClient<$Result.GetResult<Prisma.$VersionReferenceDocumentsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first VersionReferenceDocuments that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VersionReferenceDocumentsFindFirstOrThrowArgs} args - Arguments to find a VersionReferenceDocuments
     * @example
     * // Get one VersionReferenceDocuments
     * const versionReferenceDocuments = await prisma.versionReferenceDocuments.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VersionReferenceDocumentsFindFirstOrThrowArgs>(args?: SelectSubset<T, VersionReferenceDocumentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__VersionReferenceDocumentsClient<$Result.GetResult<Prisma.$VersionReferenceDocumentsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more VersionReferenceDocuments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VersionReferenceDocumentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VersionReferenceDocuments
     * const versionReferenceDocuments = await prisma.versionReferenceDocuments.findMany()
     * 
     * // Get first 10 VersionReferenceDocuments
     * const versionReferenceDocuments = await prisma.versionReferenceDocuments.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const versionReferenceDocumentsWithIdOnly = await prisma.versionReferenceDocuments.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VersionReferenceDocumentsFindManyArgs>(args?: SelectSubset<T, VersionReferenceDocumentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VersionReferenceDocumentsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a VersionReferenceDocuments.
     * @param {VersionReferenceDocumentsCreateArgs} args - Arguments to create a VersionReferenceDocuments.
     * @example
     * // Create one VersionReferenceDocuments
     * const VersionReferenceDocuments = await prisma.versionReferenceDocuments.create({
     *   data: {
     *     // ... data to create a VersionReferenceDocuments
     *   }
     * })
     * 
     */
    create<T extends VersionReferenceDocumentsCreateArgs>(args: SelectSubset<T, VersionReferenceDocumentsCreateArgs<ExtArgs>>): Prisma__VersionReferenceDocumentsClient<$Result.GetResult<Prisma.$VersionReferenceDocumentsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many VersionReferenceDocuments.
     * @param {VersionReferenceDocumentsCreateManyArgs} args - Arguments to create many VersionReferenceDocuments.
     * @example
     * // Create many VersionReferenceDocuments
     * const versionReferenceDocuments = await prisma.versionReferenceDocuments.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VersionReferenceDocumentsCreateManyArgs>(args?: SelectSubset<T, VersionReferenceDocumentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a VersionReferenceDocuments.
     * @param {VersionReferenceDocumentsDeleteArgs} args - Arguments to delete one VersionReferenceDocuments.
     * @example
     * // Delete one VersionReferenceDocuments
     * const VersionReferenceDocuments = await prisma.versionReferenceDocuments.delete({
     *   where: {
     *     // ... filter to delete one VersionReferenceDocuments
     *   }
     * })
     * 
     */
    delete<T extends VersionReferenceDocumentsDeleteArgs>(args: SelectSubset<T, VersionReferenceDocumentsDeleteArgs<ExtArgs>>): Prisma__VersionReferenceDocumentsClient<$Result.GetResult<Prisma.$VersionReferenceDocumentsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one VersionReferenceDocuments.
     * @param {VersionReferenceDocumentsUpdateArgs} args - Arguments to update one VersionReferenceDocuments.
     * @example
     * // Update one VersionReferenceDocuments
     * const versionReferenceDocuments = await prisma.versionReferenceDocuments.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VersionReferenceDocumentsUpdateArgs>(args: SelectSubset<T, VersionReferenceDocumentsUpdateArgs<ExtArgs>>): Prisma__VersionReferenceDocumentsClient<$Result.GetResult<Prisma.$VersionReferenceDocumentsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more VersionReferenceDocuments.
     * @param {VersionReferenceDocumentsDeleteManyArgs} args - Arguments to filter VersionReferenceDocuments to delete.
     * @example
     * // Delete a few VersionReferenceDocuments
     * const { count } = await prisma.versionReferenceDocuments.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VersionReferenceDocumentsDeleteManyArgs>(args?: SelectSubset<T, VersionReferenceDocumentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VersionReferenceDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VersionReferenceDocumentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VersionReferenceDocuments
     * const versionReferenceDocuments = await prisma.versionReferenceDocuments.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VersionReferenceDocumentsUpdateManyArgs>(args: SelectSubset<T, VersionReferenceDocumentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one VersionReferenceDocuments.
     * @param {VersionReferenceDocumentsUpsertArgs} args - Arguments to update or create a VersionReferenceDocuments.
     * @example
     * // Update or create a VersionReferenceDocuments
     * const versionReferenceDocuments = await prisma.versionReferenceDocuments.upsert({
     *   create: {
     *     // ... data to create a VersionReferenceDocuments
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VersionReferenceDocuments we want to update
     *   }
     * })
     */
    upsert<T extends VersionReferenceDocumentsUpsertArgs>(args: SelectSubset<T, VersionReferenceDocumentsUpsertArgs<ExtArgs>>): Prisma__VersionReferenceDocumentsClient<$Result.GetResult<Prisma.$VersionReferenceDocumentsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more VersionReferenceDocuments that matches the filter.
     * @param {VersionReferenceDocumentsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const versionReferenceDocuments = await prisma.versionReferenceDocuments.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: VersionReferenceDocumentsFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a VersionReferenceDocuments.
     * @param {VersionReferenceDocumentsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const versionReferenceDocuments = await prisma.versionReferenceDocuments.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: VersionReferenceDocumentsAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of VersionReferenceDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VersionReferenceDocumentsCountArgs} args - Arguments to filter VersionReferenceDocuments to count.
     * @example
     * // Count the number of VersionReferenceDocuments
     * const count = await prisma.versionReferenceDocuments.count({
     *   where: {
     *     // ... the filter for the VersionReferenceDocuments we want to count
     *   }
     * })
    **/
    count<T extends VersionReferenceDocumentsCountArgs>(
      args?: Subset<T, VersionReferenceDocumentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VersionReferenceDocumentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VersionReferenceDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VersionReferenceDocumentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VersionReferenceDocumentsAggregateArgs>(args: Subset<T, VersionReferenceDocumentsAggregateArgs>): Prisma.PrismaPromise<GetVersionReferenceDocumentsAggregateType<T>>

    /**
     * Group by VersionReferenceDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VersionReferenceDocumentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VersionReferenceDocumentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VersionReferenceDocumentsGroupByArgs['orderBy'] }
        : { orderBy?: VersionReferenceDocumentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VersionReferenceDocumentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVersionReferenceDocumentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VersionReferenceDocuments model
   */
  readonly fields: VersionReferenceDocumentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VersionReferenceDocuments.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VersionReferenceDocumentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Documents<T extends VersionReferenceDocuments$DocumentsArgs<ExtArgs> = {}>(args?: Subset<T, VersionReferenceDocuments$DocumentsArgs<ExtArgs>>): Prisma__DocumentsClient<$Result.GetResult<Prisma.$DocumentsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    versionsLinkedWith<T extends VersionReferenceDocuments$versionsLinkedWithArgs<ExtArgs> = {}>(args?: Subset<T, VersionReferenceDocuments$versionsLinkedWithArgs<ExtArgs>>): Prisma__DocumentVersionsClient<$Result.GetResult<Prisma.$DocumentVersionsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VersionReferenceDocuments model
   */ 
  interface VersionReferenceDocumentsFieldRefs {
    readonly id: FieldRef<"VersionReferenceDocuments", 'String'>
    readonly documentLink: FieldRef<"VersionReferenceDocuments", 'String'>
    readonly type: FieldRef<"VersionReferenceDocuments", 'String'>
    readonly documentName: FieldRef<"VersionReferenceDocuments", 'String'>
    readonly version: FieldRef<"VersionReferenceDocuments", 'String'>
    readonly createdAt: FieldRef<"VersionReferenceDocuments", 'DateTime'>
    readonly updatedAt: FieldRef<"VersionReferenceDocuments", 'DateTime'>
    readonly referenceDocId: FieldRef<"VersionReferenceDocuments", 'String'>
    readonly versionId: FieldRef<"VersionReferenceDocuments", 'String'>
    readonly documentsId: FieldRef<"VersionReferenceDocuments", 'String'>
  }
    

  // Custom InputTypes
  /**
   * VersionReferenceDocuments findUnique
   */
  export type VersionReferenceDocumentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VersionReferenceDocuments
     */
    select?: VersionReferenceDocumentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VersionReferenceDocumentsInclude<ExtArgs> | null
    /**
     * Filter, which VersionReferenceDocuments to fetch.
     */
    where: VersionReferenceDocumentsWhereUniqueInput
  }

  /**
   * VersionReferenceDocuments findUniqueOrThrow
   */
  export type VersionReferenceDocumentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VersionReferenceDocuments
     */
    select?: VersionReferenceDocumentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VersionReferenceDocumentsInclude<ExtArgs> | null
    /**
     * Filter, which VersionReferenceDocuments to fetch.
     */
    where: VersionReferenceDocumentsWhereUniqueInput
  }

  /**
   * VersionReferenceDocuments findFirst
   */
  export type VersionReferenceDocumentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VersionReferenceDocuments
     */
    select?: VersionReferenceDocumentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VersionReferenceDocumentsInclude<ExtArgs> | null
    /**
     * Filter, which VersionReferenceDocuments to fetch.
     */
    where?: VersionReferenceDocumentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VersionReferenceDocuments to fetch.
     */
    orderBy?: VersionReferenceDocumentsOrderByWithRelationInput | VersionReferenceDocumentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VersionReferenceDocuments.
     */
    cursor?: VersionReferenceDocumentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VersionReferenceDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VersionReferenceDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VersionReferenceDocuments.
     */
    distinct?: VersionReferenceDocumentsScalarFieldEnum | VersionReferenceDocumentsScalarFieldEnum[]
  }

  /**
   * VersionReferenceDocuments findFirstOrThrow
   */
  export type VersionReferenceDocumentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VersionReferenceDocuments
     */
    select?: VersionReferenceDocumentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VersionReferenceDocumentsInclude<ExtArgs> | null
    /**
     * Filter, which VersionReferenceDocuments to fetch.
     */
    where?: VersionReferenceDocumentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VersionReferenceDocuments to fetch.
     */
    orderBy?: VersionReferenceDocumentsOrderByWithRelationInput | VersionReferenceDocumentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VersionReferenceDocuments.
     */
    cursor?: VersionReferenceDocumentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VersionReferenceDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VersionReferenceDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VersionReferenceDocuments.
     */
    distinct?: VersionReferenceDocumentsScalarFieldEnum | VersionReferenceDocumentsScalarFieldEnum[]
  }

  /**
   * VersionReferenceDocuments findMany
   */
  export type VersionReferenceDocumentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VersionReferenceDocuments
     */
    select?: VersionReferenceDocumentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VersionReferenceDocumentsInclude<ExtArgs> | null
    /**
     * Filter, which VersionReferenceDocuments to fetch.
     */
    where?: VersionReferenceDocumentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VersionReferenceDocuments to fetch.
     */
    orderBy?: VersionReferenceDocumentsOrderByWithRelationInput | VersionReferenceDocumentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VersionReferenceDocuments.
     */
    cursor?: VersionReferenceDocumentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VersionReferenceDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VersionReferenceDocuments.
     */
    skip?: number
    distinct?: VersionReferenceDocumentsScalarFieldEnum | VersionReferenceDocumentsScalarFieldEnum[]
  }

  /**
   * VersionReferenceDocuments create
   */
  export type VersionReferenceDocumentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VersionReferenceDocuments
     */
    select?: VersionReferenceDocumentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VersionReferenceDocumentsInclude<ExtArgs> | null
    /**
     * The data needed to create a VersionReferenceDocuments.
     */
    data: XOR<VersionReferenceDocumentsCreateInput, VersionReferenceDocumentsUncheckedCreateInput>
  }

  /**
   * VersionReferenceDocuments createMany
   */
  export type VersionReferenceDocumentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VersionReferenceDocuments.
     */
    data: VersionReferenceDocumentsCreateManyInput | VersionReferenceDocumentsCreateManyInput[]
  }

  /**
   * VersionReferenceDocuments update
   */
  export type VersionReferenceDocumentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VersionReferenceDocuments
     */
    select?: VersionReferenceDocumentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VersionReferenceDocumentsInclude<ExtArgs> | null
    /**
     * The data needed to update a VersionReferenceDocuments.
     */
    data: XOR<VersionReferenceDocumentsUpdateInput, VersionReferenceDocumentsUncheckedUpdateInput>
    /**
     * Choose, which VersionReferenceDocuments to update.
     */
    where: VersionReferenceDocumentsWhereUniqueInput
  }

  /**
   * VersionReferenceDocuments updateMany
   */
  export type VersionReferenceDocumentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VersionReferenceDocuments.
     */
    data: XOR<VersionReferenceDocumentsUpdateManyMutationInput, VersionReferenceDocumentsUncheckedUpdateManyInput>
    /**
     * Filter which VersionReferenceDocuments to update
     */
    where?: VersionReferenceDocumentsWhereInput
  }

  /**
   * VersionReferenceDocuments upsert
   */
  export type VersionReferenceDocumentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VersionReferenceDocuments
     */
    select?: VersionReferenceDocumentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VersionReferenceDocumentsInclude<ExtArgs> | null
    /**
     * The filter to search for the VersionReferenceDocuments to update in case it exists.
     */
    where: VersionReferenceDocumentsWhereUniqueInput
    /**
     * In case the VersionReferenceDocuments found by the `where` argument doesn't exist, create a new VersionReferenceDocuments with this data.
     */
    create: XOR<VersionReferenceDocumentsCreateInput, VersionReferenceDocumentsUncheckedCreateInput>
    /**
     * In case the VersionReferenceDocuments was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VersionReferenceDocumentsUpdateInput, VersionReferenceDocumentsUncheckedUpdateInput>
  }

  /**
   * VersionReferenceDocuments delete
   */
  export type VersionReferenceDocumentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VersionReferenceDocuments
     */
    select?: VersionReferenceDocumentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VersionReferenceDocumentsInclude<ExtArgs> | null
    /**
     * Filter which VersionReferenceDocuments to delete.
     */
    where: VersionReferenceDocumentsWhereUniqueInput
  }

  /**
   * VersionReferenceDocuments deleteMany
   */
  export type VersionReferenceDocumentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VersionReferenceDocuments to delete
     */
    where?: VersionReferenceDocumentsWhereInput
  }

  /**
   * VersionReferenceDocuments findRaw
   */
  export type VersionReferenceDocumentsFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * VersionReferenceDocuments aggregateRaw
   */
  export type VersionReferenceDocumentsAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * VersionReferenceDocuments.Documents
   */
  export type VersionReferenceDocuments$DocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Documents
     */
    select?: DocumentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentsInclude<ExtArgs> | null
    where?: DocumentsWhereInput
  }

  /**
   * VersionReferenceDocuments.versionsLinkedWith
   */
  export type VersionReferenceDocuments$versionsLinkedWithArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentVersions
     */
    select?: DocumentVersionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentVersionsInclude<ExtArgs> | null
    where?: DocumentVersionsWhereInput
  }

  /**
   * VersionReferenceDocuments without action
   */
  export type VersionReferenceDocumentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VersionReferenceDocuments
     */
    select?: VersionReferenceDocumentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VersionReferenceDocumentsInclude<ExtArgs> | null
  }


  /**
   * Model DocumentVersions
   */

  export type AggregateDocumentVersions = {
    _count: DocumentVersionsCountAggregateOutputType | null
    _min: DocumentVersionsMinAggregateOutputType | null
    _max: DocumentVersionsMaxAggregateOutputType | null
  }

  export type DocumentVersionsMinAggregateOutputType = {
    id: string | null
    versionName: string | null
    userId: string | null
    by: string | null
    approvedDate: Date | null
    versionLink: string | null
    documentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    documentName: string | null
    documentNumbering: string | null
    reasonOfCreation: string | null
    effectiveDate: Date | null
    description: string | null
    issueNumber: string | null
  }

  export type DocumentVersionsMaxAggregateOutputType = {
    id: string | null
    versionName: string | null
    userId: string | null
    by: string | null
    approvedDate: Date | null
    versionLink: string | null
    documentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    documentName: string | null
    documentNumbering: string | null
    reasonOfCreation: string | null
    effectiveDate: Date | null
    description: string | null
    issueNumber: string | null
  }

  export type DocumentVersionsCountAggregateOutputType = {
    id: number
    versionName: number
    userId: number
    by: number
    approvedDate: number
    versionLink: number
    documentId: number
    createdAt: number
    updatedAt: number
    documentName: number
    documentNumbering: number
    reasonOfCreation: number
    effectiveDate: number
    description: number
    issueNumber: number
    _all: number
  }


  export type DocumentVersionsMinAggregateInputType = {
    id?: true
    versionName?: true
    userId?: true
    by?: true
    approvedDate?: true
    versionLink?: true
    documentId?: true
    createdAt?: true
    updatedAt?: true
    documentName?: true
    documentNumbering?: true
    reasonOfCreation?: true
    effectiveDate?: true
    description?: true
    issueNumber?: true
  }

  export type DocumentVersionsMaxAggregateInputType = {
    id?: true
    versionName?: true
    userId?: true
    by?: true
    approvedDate?: true
    versionLink?: true
    documentId?: true
    createdAt?: true
    updatedAt?: true
    documentName?: true
    documentNumbering?: true
    reasonOfCreation?: true
    effectiveDate?: true
    description?: true
    issueNumber?: true
  }

  export type DocumentVersionsCountAggregateInputType = {
    id?: true
    versionName?: true
    userId?: true
    by?: true
    approvedDate?: true
    versionLink?: true
    documentId?: true
    createdAt?: true
    updatedAt?: true
    documentName?: true
    documentNumbering?: true
    reasonOfCreation?: true
    effectiveDate?: true
    description?: true
    issueNumber?: true
    _all?: true
  }

  export type DocumentVersionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DocumentVersions to aggregate.
     */
    where?: DocumentVersionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentVersions to fetch.
     */
    orderBy?: DocumentVersionsOrderByWithRelationInput | DocumentVersionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DocumentVersionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DocumentVersions
    **/
    _count?: true | DocumentVersionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentVersionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentVersionsMaxAggregateInputType
  }

  export type GetDocumentVersionsAggregateType<T extends DocumentVersionsAggregateArgs> = {
        [P in keyof T & keyof AggregateDocumentVersions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocumentVersions[P]>
      : GetScalarType<T[P], AggregateDocumentVersions[P]>
  }




  export type DocumentVersionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentVersionsWhereInput
    orderBy?: DocumentVersionsOrderByWithAggregationInput | DocumentVersionsOrderByWithAggregationInput[]
    by: DocumentVersionsScalarFieldEnum[] | DocumentVersionsScalarFieldEnum
    having?: DocumentVersionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentVersionsCountAggregateInputType | true
    _min?: DocumentVersionsMinAggregateInputType
    _max?: DocumentVersionsMaxAggregateInputType
  }

  export type DocumentVersionsGroupByOutputType = {
    id: string
    versionName: string
    userId: string | null
    by: string | null
    approvedDate: Date | null
    versionLink: string
    documentId: string | null
    createdAt: Date
    updatedAt: Date
    documentName: string | null
    documentNumbering: string | null
    reasonOfCreation: string | null
    effectiveDate: Date | null
    description: string | null
    issueNumber: string | null
    _count: DocumentVersionsCountAggregateOutputType | null
    _min: DocumentVersionsMinAggregateOutputType | null
    _max: DocumentVersionsMaxAggregateOutputType | null
  }

  type GetDocumentVersionsGroupByPayload<T extends DocumentVersionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DocumentVersionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentVersionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentVersionsGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentVersionsGroupByOutputType[P]>
        }
      >
    >


  export type DocumentVersionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    versionName?: boolean
    userId?: boolean
    by?: boolean
    approvedDate?: boolean
    versionLink?: boolean
    documentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    documentName?: boolean
    documentNumbering?: boolean
    reasonOfCreation?: boolean
    effectiveDate?: boolean
    description?: boolean
    issueNumber?: boolean
    document?: boolean | DocumentVersions$documentArgs<ExtArgs>
    user?: boolean | DocumentVersions$userArgs<ExtArgs>
    ReferenceDocuments?: boolean | DocumentVersions$ReferenceDocumentsArgs<ExtArgs>
    VersionReferenceDocuments?: boolean | DocumentVersions$VersionReferenceDocumentsArgs<ExtArgs>
    _count?: boolean | DocumentVersionsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["documentVersions"]>


  export type DocumentVersionsSelectScalar = {
    id?: boolean
    versionName?: boolean
    userId?: boolean
    by?: boolean
    approvedDate?: boolean
    versionLink?: boolean
    documentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    documentName?: boolean
    documentNumbering?: boolean
    reasonOfCreation?: boolean
    effectiveDate?: boolean
    description?: boolean
    issueNumber?: boolean
  }

  export type DocumentVersionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    document?: boolean | DocumentVersions$documentArgs<ExtArgs>
    user?: boolean | DocumentVersions$userArgs<ExtArgs>
    ReferenceDocuments?: boolean | DocumentVersions$ReferenceDocumentsArgs<ExtArgs>
    VersionReferenceDocuments?: boolean | DocumentVersions$VersionReferenceDocumentsArgs<ExtArgs>
    _count?: boolean | DocumentVersionsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $DocumentVersionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DocumentVersions"
    objects: {
      document: Prisma.$DocumentsPayload<ExtArgs> | null
      user: Prisma.$UserPayload<ExtArgs> | null
      ReferenceDocuments: Prisma.$ReferenceDocumentsPayload<ExtArgs>[]
      VersionReferenceDocuments: Prisma.$VersionReferenceDocumentsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      versionName: string
      userId: string | null
      by: string | null
      approvedDate: Date | null
      versionLink: string
      documentId: string | null
      createdAt: Date
      updatedAt: Date
      documentName: string | null
      documentNumbering: string | null
      reasonOfCreation: string | null
      effectiveDate: Date | null
      description: string | null
      issueNumber: string | null
    }, ExtArgs["result"]["documentVersions"]>
    composites: {}
  }

  type DocumentVersionsGetPayload<S extends boolean | null | undefined | DocumentVersionsDefaultArgs> = $Result.GetResult<Prisma.$DocumentVersionsPayload, S>

  type DocumentVersionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DocumentVersionsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DocumentVersionsCountAggregateInputType | true
    }

  export interface DocumentVersionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DocumentVersions'], meta: { name: 'DocumentVersions' } }
    /**
     * Find zero or one DocumentVersions that matches the filter.
     * @param {DocumentVersionsFindUniqueArgs} args - Arguments to find a DocumentVersions
     * @example
     * // Get one DocumentVersions
     * const documentVersions = await prisma.documentVersions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DocumentVersionsFindUniqueArgs>(args: SelectSubset<T, DocumentVersionsFindUniqueArgs<ExtArgs>>): Prisma__DocumentVersionsClient<$Result.GetResult<Prisma.$DocumentVersionsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DocumentVersions that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DocumentVersionsFindUniqueOrThrowArgs} args - Arguments to find a DocumentVersions
     * @example
     * // Get one DocumentVersions
     * const documentVersions = await prisma.documentVersions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DocumentVersionsFindUniqueOrThrowArgs>(args: SelectSubset<T, DocumentVersionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DocumentVersionsClient<$Result.GetResult<Prisma.$DocumentVersionsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DocumentVersions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentVersionsFindFirstArgs} args - Arguments to find a DocumentVersions
     * @example
     * // Get one DocumentVersions
     * const documentVersions = await prisma.documentVersions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DocumentVersionsFindFirstArgs>(args?: SelectSubset<T, DocumentVersionsFindFirstArgs<ExtArgs>>): Prisma__DocumentVersionsClient<$Result.GetResult<Prisma.$DocumentVersionsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DocumentVersions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentVersionsFindFirstOrThrowArgs} args - Arguments to find a DocumentVersions
     * @example
     * // Get one DocumentVersions
     * const documentVersions = await prisma.documentVersions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DocumentVersionsFindFirstOrThrowArgs>(args?: SelectSubset<T, DocumentVersionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__DocumentVersionsClient<$Result.GetResult<Prisma.$DocumentVersionsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DocumentVersions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentVersionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DocumentVersions
     * const documentVersions = await prisma.documentVersions.findMany()
     * 
     * // Get first 10 DocumentVersions
     * const documentVersions = await prisma.documentVersions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documentVersionsWithIdOnly = await prisma.documentVersions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DocumentVersionsFindManyArgs>(args?: SelectSubset<T, DocumentVersionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentVersionsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DocumentVersions.
     * @param {DocumentVersionsCreateArgs} args - Arguments to create a DocumentVersions.
     * @example
     * // Create one DocumentVersions
     * const DocumentVersions = await prisma.documentVersions.create({
     *   data: {
     *     // ... data to create a DocumentVersions
     *   }
     * })
     * 
     */
    create<T extends DocumentVersionsCreateArgs>(args: SelectSubset<T, DocumentVersionsCreateArgs<ExtArgs>>): Prisma__DocumentVersionsClient<$Result.GetResult<Prisma.$DocumentVersionsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DocumentVersions.
     * @param {DocumentVersionsCreateManyArgs} args - Arguments to create many DocumentVersions.
     * @example
     * // Create many DocumentVersions
     * const documentVersions = await prisma.documentVersions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DocumentVersionsCreateManyArgs>(args?: SelectSubset<T, DocumentVersionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DocumentVersions.
     * @param {DocumentVersionsDeleteArgs} args - Arguments to delete one DocumentVersions.
     * @example
     * // Delete one DocumentVersions
     * const DocumentVersions = await prisma.documentVersions.delete({
     *   where: {
     *     // ... filter to delete one DocumentVersions
     *   }
     * })
     * 
     */
    delete<T extends DocumentVersionsDeleteArgs>(args: SelectSubset<T, DocumentVersionsDeleteArgs<ExtArgs>>): Prisma__DocumentVersionsClient<$Result.GetResult<Prisma.$DocumentVersionsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DocumentVersions.
     * @param {DocumentVersionsUpdateArgs} args - Arguments to update one DocumentVersions.
     * @example
     * // Update one DocumentVersions
     * const documentVersions = await prisma.documentVersions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DocumentVersionsUpdateArgs>(args: SelectSubset<T, DocumentVersionsUpdateArgs<ExtArgs>>): Prisma__DocumentVersionsClient<$Result.GetResult<Prisma.$DocumentVersionsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DocumentVersions.
     * @param {DocumentVersionsDeleteManyArgs} args - Arguments to filter DocumentVersions to delete.
     * @example
     * // Delete a few DocumentVersions
     * const { count } = await prisma.documentVersions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DocumentVersionsDeleteManyArgs>(args?: SelectSubset<T, DocumentVersionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DocumentVersions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentVersionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DocumentVersions
     * const documentVersions = await prisma.documentVersions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DocumentVersionsUpdateManyArgs>(args: SelectSubset<T, DocumentVersionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DocumentVersions.
     * @param {DocumentVersionsUpsertArgs} args - Arguments to update or create a DocumentVersions.
     * @example
     * // Update or create a DocumentVersions
     * const documentVersions = await prisma.documentVersions.upsert({
     *   create: {
     *     // ... data to create a DocumentVersions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DocumentVersions we want to update
     *   }
     * })
     */
    upsert<T extends DocumentVersionsUpsertArgs>(args: SelectSubset<T, DocumentVersionsUpsertArgs<ExtArgs>>): Prisma__DocumentVersionsClient<$Result.GetResult<Prisma.$DocumentVersionsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more DocumentVersions that matches the filter.
     * @param {DocumentVersionsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const documentVersions = await prisma.documentVersions.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: DocumentVersionsFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a DocumentVersions.
     * @param {DocumentVersionsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const documentVersions = await prisma.documentVersions.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: DocumentVersionsAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of DocumentVersions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentVersionsCountArgs} args - Arguments to filter DocumentVersions to count.
     * @example
     * // Count the number of DocumentVersions
     * const count = await prisma.documentVersions.count({
     *   where: {
     *     // ... the filter for the DocumentVersions we want to count
     *   }
     * })
    **/
    count<T extends DocumentVersionsCountArgs>(
      args?: Subset<T, DocumentVersionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentVersionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DocumentVersions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentVersionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentVersionsAggregateArgs>(args: Subset<T, DocumentVersionsAggregateArgs>): Prisma.PrismaPromise<GetDocumentVersionsAggregateType<T>>

    /**
     * Group by DocumentVersions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentVersionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DocumentVersionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentVersionsGroupByArgs['orderBy'] }
        : { orderBy?: DocumentVersionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DocumentVersionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentVersionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DocumentVersions model
   */
  readonly fields: DocumentVersionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DocumentVersions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DocumentVersionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    document<T extends DocumentVersions$documentArgs<ExtArgs> = {}>(args?: Subset<T, DocumentVersions$documentArgs<ExtArgs>>): Prisma__DocumentsClient<$Result.GetResult<Prisma.$DocumentsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    user<T extends DocumentVersions$userArgs<ExtArgs> = {}>(args?: Subset<T, DocumentVersions$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    ReferenceDocuments<T extends DocumentVersions$ReferenceDocumentsArgs<ExtArgs> = {}>(args?: Subset<T, DocumentVersions$ReferenceDocumentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferenceDocumentsPayload<ExtArgs>, T, "findMany"> | Null>
    VersionReferenceDocuments<T extends DocumentVersions$VersionReferenceDocumentsArgs<ExtArgs> = {}>(args?: Subset<T, DocumentVersions$VersionReferenceDocumentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VersionReferenceDocumentsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DocumentVersions model
   */ 
  interface DocumentVersionsFieldRefs {
    readonly id: FieldRef<"DocumentVersions", 'String'>
    readonly versionName: FieldRef<"DocumentVersions", 'String'>
    readonly userId: FieldRef<"DocumentVersions", 'String'>
    readonly by: FieldRef<"DocumentVersions", 'String'>
    readonly approvedDate: FieldRef<"DocumentVersions", 'DateTime'>
    readonly versionLink: FieldRef<"DocumentVersions", 'String'>
    readonly documentId: FieldRef<"DocumentVersions", 'String'>
    readonly createdAt: FieldRef<"DocumentVersions", 'DateTime'>
    readonly updatedAt: FieldRef<"DocumentVersions", 'DateTime'>
    readonly documentName: FieldRef<"DocumentVersions", 'String'>
    readonly documentNumbering: FieldRef<"DocumentVersions", 'String'>
    readonly reasonOfCreation: FieldRef<"DocumentVersions", 'String'>
    readonly effectiveDate: FieldRef<"DocumentVersions", 'DateTime'>
    readonly description: FieldRef<"DocumentVersions", 'String'>
    readonly issueNumber: FieldRef<"DocumentVersions", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DocumentVersions findUnique
   */
  export type DocumentVersionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentVersions
     */
    select?: DocumentVersionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentVersionsInclude<ExtArgs> | null
    /**
     * Filter, which DocumentVersions to fetch.
     */
    where: DocumentVersionsWhereUniqueInput
  }

  /**
   * DocumentVersions findUniqueOrThrow
   */
  export type DocumentVersionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentVersions
     */
    select?: DocumentVersionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentVersionsInclude<ExtArgs> | null
    /**
     * Filter, which DocumentVersions to fetch.
     */
    where: DocumentVersionsWhereUniqueInput
  }

  /**
   * DocumentVersions findFirst
   */
  export type DocumentVersionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentVersions
     */
    select?: DocumentVersionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentVersionsInclude<ExtArgs> | null
    /**
     * Filter, which DocumentVersions to fetch.
     */
    where?: DocumentVersionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentVersions to fetch.
     */
    orderBy?: DocumentVersionsOrderByWithRelationInput | DocumentVersionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DocumentVersions.
     */
    cursor?: DocumentVersionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DocumentVersions.
     */
    distinct?: DocumentVersionsScalarFieldEnum | DocumentVersionsScalarFieldEnum[]
  }

  /**
   * DocumentVersions findFirstOrThrow
   */
  export type DocumentVersionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentVersions
     */
    select?: DocumentVersionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentVersionsInclude<ExtArgs> | null
    /**
     * Filter, which DocumentVersions to fetch.
     */
    where?: DocumentVersionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentVersions to fetch.
     */
    orderBy?: DocumentVersionsOrderByWithRelationInput | DocumentVersionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DocumentVersions.
     */
    cursor?: DocumentVersionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DocumentVersions.
     */
    distinct?: DocumentVersionsScalarFieldEnum | DocumentVersionsScalarFieldEnum[]
  }

  /**
   * DocumentVersions findMany
   */
  export type DocumentVersionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentVersions
     */
    select?: DocumentVersionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentVersionsInclude<ExtArgs> | null
    /**
     * Filter, which DocumentVersions to fetch.
     */
    where?: DocumentVersionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentVersions to fetch.
     */
    orderBy?: DocumentVersionsOrderByWithRelationInput | DocumentVersionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DocumentVersions.
     */
    cursor?: DocumentVersionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentVersions.
     */
    skip?: number
    distinct?: DocumentVersionsScalarFieldEnum | DocumentVersionsScalarFieldEnum[]
  }

  /**
   * DocumentVersions create
   */
  export type DocumentVersionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentVersions
     */
    select?: DocumentVersionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentVersionsInclude<ExtArgs> | null
    /**
     * The data needed to create a DocumentVersions.
     */
    data: XOR<DocumentVersionsCreateInput, DocumentVersionsUncheckedCreateInput>
  }

  /**
   * DocumentVersions createMany
   */
  export type DocumentVersionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DocumentVersions.
     */
    data: DocumentVersionsCreateManyInput | DocumentVersionsCreateManyInput[]
  }

  /**
   * DocumentVersions update
   */
  export type DocumentVersionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentVersions
     */
    select?: DocumentVersionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentVersionsInclude<ExtArgs> | null
    /**
     * The data needed to update a DocumentVersions.
     */
    data: XOR<DocumentVersionsUpdateInput, DocumentVersionsUncheckedUpdateInput>
    /**
     * Choose, which DocumentVersions to update.
     */
    where: DocumentVersionsWhereUniqueInput
  }

  /**
   * DocumentVersions updateMany
   */
  export type DocumentVersionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DocumentVersions.
     */
    data: XOR<DocumentVersionsUpdateManyMutationInput, DocumentVersionsUncheckedUpdateManyInput>
    /**
     * Filter which DocumentVersions to update
     */
    where?: DocumentVersionsWhereInput
  }

  /**
   * DocumentVersions upsert
   */
  export type DocumentVersionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentVersions
     */
    select?: DocumentVersionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentVersionsInclude<ExtArgs> | null
    /**
     * The filter to search for the DocumentVersions to update in case it exists.
     */
    where: DocumentVersionsWhereUniqueInput
    /**
     * In case the DocumentVersions found by the `where` argument doesn't exist, create a new DocumentVersions with this data.
     */
    create: XOR<DocumentVersionsCreateInput, DocumentVersionsUncheckedCreateInput>
    /**
     * In case the DocumentVersions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DocumentVersionsUpdateInput, DocumentVersionsUncheckedUpdateInput>
  }

  /**
   * DocumentVersions delete
   */
  export type DocumentVersionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentVersions
     */
    select?: DocumentVersionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentVersionsInclude<ExtArgs> | null
    /**
     * Filter which DocumentVersions to delete.
     */
    where: DocumentVersionsWhereUniqueInput
  }

  /**
   * DocumentVersions deleteMany
   */
  export type DocumentVersionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DocumentVersions to delete
     */
    where?: DocumentVersionsWhereInput
  }

  /**
   * DocumentVersions findRaw
   */
  export type DocumentVersionsFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * DocumentVersions aggregateRaw
   */
  export type DocumentVersionsAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * DocumentVersions.document
   */
  export type DocumentVersions$documentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Documents
     */
    select?: DocumentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentsInclude<ExtArgs> | null
    where?: DocumentsWhereInput
  }

  /**
   * DocumentVersions.user
   */
  export type DocumentVersions$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * DocumentVersions.ReferenceDocuments
   */
  export type DocumentVersions$ReferenceDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferenceDocuments
     */
    select?: ReferenceDocumentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferenceDocumentsInclude<ExtArgs> | null
    where?: ReferenceDocumentsWhereInput
    orderBy?: ReferenceDocumentsOrderByWithRelationInput | ReferenceDocumentsOrderByWithRelationInput[]
    cursor?: ReferenceDocumentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReferenceDocumentsScalarFieldEnum | ReferenceDocumentsScalarFieldEnum[]
  }

  /**
   * DocumentVersions.VersionReferenceDocuments
   */
  export type DocumentVersions$VersionReferenceDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VersionReferenceDocuments
     */
    select?: VersionReferenceDocumentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VersionReferenceDocumentsInclude<ExtArgs> | null
    where?: VersionReferenceDocumentsWhereInput
    orderBy?: VersionReferenceDocumentsOrderByWithRelationInput | VersionReferenceDocumentsOrderByWithRelationInput[]
    cursor?: VersionReferenceDocumentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VersionReferenceDocumentsScalarFieldEnum | VersionReferenceDocumentsScalarFieldEnum[]
  }

  /**
   * DocumentVersions without action
   */
  export type DocumentVersionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentVersions
     */
    select?: DocumentVersionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentVersionsInclude<ExtArgs> | null
  }


  /**
   * Model DocumentComments
   */

  export type AggregateDocumentComments = {
    _count: DocumentCommentsCountAggregateOutputType | null
    _min: DocumentCommentsMinAggregateOutputType | null
    _max: DocumentCommentsMaxAggregateOutputType | null
  }

  export type DocumentCommentsMinAggregateOutputType = {
    id: string | null
    userId: string | null
    commentBy: string | null
    commentText: string | null
    documentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DocumentCommentsMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    commentBy: string | null
    commentText: string | null
    documentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DocumentCommentsCountAggregateOutputType = {
    id: number
    userId: number
    commentBy: number
    commentText: number
    documentId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DocumentCommentsMinAggregateInputType = {
    id?: true
    userId?: true
    commentBy?: true
    commentText?: true
    documentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DocumentCommentsMaxAggregateInputType = {
    id?: true
    userId?: true
    commentBy?: true
    commentText?: true
    documentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DocumentCommentsCountAggregateInputType = {
    id?: true
    userId?: true
    commentBy?: true
    commentText?: true
    documentId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DocumentCommentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DocumentComments to aggregate.
     */
    where?: DocumentCommentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentComments to fetch.
     */
    orderBy?: DocumentCommentsOrderByWithRelationInput | DocumentCommentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DocumentCommentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DocumentComments
    **/
    _count?: true | DocumentCommentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentCommentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentCommentsMaxAggregateInputType
  }

  export type GetDocumentCommentsAggregateType<T extends DocumentCommentsAggregateArgs> = {
        [P in keyof T & keyof AggregateDocumentComments]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocumentComments[P]>
      : GetScalarType<T[P], AggregateDocumentComments[P]>
  }




  export type DocumentCommentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentCommentsWhereInput
    orderBy?: DocumentCommentsOrderByWithAggregationInput | DocumentCommentsOrderByWithAggregationInput[]
    by: DocumentCommentsScalarFieldEnum[] | DocumentCommentsScalarFieldEnum
    having?: DocumentCommentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentCommentsCountAggregateInputType | true
    _min?: DocumentCommentsMinAggregateInputType
    _max?: DocumentCommentsMaxAggregateInputType
  }

  export type DocumentCommentsGroupByOutputType = {
    id: string
    userId: string | null
    commentBy: string | null
    commentText: string
    documentId: string | null
    createdAt: Date
    updatedAt: Date
    _count: DocumentCommentsCountAggregateOutputType | null
    _min: DocumentCommentsMinAggregateOutputType | null
    _max: DocumentCommentsMaxAggregateOutputType | null
  }

  type GetDocumentCommentsGroupByPayload<T extends DocumentCommentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DocumentCommentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentCommentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentCommentsGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentCommentsGroupByOutputType[P]>
        }
      >
    >


  export type DocumentCommentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    commentBy?: boolean
    commentText?: boolean
    documentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    document?: boolean | DocumentComments$documentArgs<ExtArgs>
    user?: boolean | DocumentComments$userArgs<ExtArgs>
  }, ExtArgs["result"]["documentComments"]>


  export type DocumentCommentsSelectScalar = {
    id?: boolean
    userId?: boolean
    commentBy?: boolean
    commentText?: boolean
    documentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DocumentCommentsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    document?: boolean | DocumentComments$documentArgs<ExtArgs>
    user?: boolean | DocumentComments$userArgs<ExtArgs>
  }

  export type $DocumentCommentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DocumentComments"
    objects: {
      document: Prisma.$DocumentsPayload<ExtArgs> | null
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      commentBy: string | null
      commentText: string
      documentId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["documentComments"]>
    composites: {}
  }

  type DocumentCommentsGetPayload<S extends boolean | null | undefined | DocumentCommentsDefaultArgs> = $Result.GetResult<Prisma.$DocumentCommentsPayload, S>

  type DocumentCommentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DocumentCommentsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DocumentCommentsCountAggregateInputType | true
    }

  export interface DocumentCommentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DocumentComments'], meta: { name: 'DocumentComments' } }
    /**
     * Find zero or one DocumentComments that matches the filter.
     * @param {DocumentCommentsFindUniqueArgs} args - Arguments to find a DocumentComments
     * @example
     * // Get one DocumentComments
     * const documentComments = await prisma.documentComments.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DocumentCommentsFindUniqueArgs>(args: SelectSubset<T, DocumentCommentsFindUniqueArgs<ExtArgs>>): Prisma__DocumentCommentsClient<$Result.GetResult<Prisma.$DocumentCommentsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DocumentComments that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DocumentCommentsFindUniqueOrThrowArgs} args - Arguments to find a DocumentComments
     * @example
     * // Get one DocumentComments
     * const documentComments = await prisma.documentComments.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DocumentCommentsFindUniqueOrThrowArgs>(args: SelectSubset<T, DocumentCommentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DocumentCommentsClient<$Result.GetResult<Prisma.$DocumentCommentsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DocumentComments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentCommentsFindFirstArgs} args - Arguments to find a DocumentComments
     * @example
     * // Get one DocumentComments
     * const documentComments = await prisma.documentComments.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DocumentCommentsFindFirstArgs>(args?: SelectSubset<T, DocumentCommentsFindFirstArgs<ExtArgs>>): Prisma__DocumentCommentsClient<$Result.GetResult<Prisma.$DocumentCommentsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DocumentComments that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentCommentsFindFirstOrThrowArgs} args - Arguments to find a DocumentComments
     * @example
     * // Get one DocumentComments
     * const documentComments = await prisma.documentComments.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DocumentCommentsFindFirstOrThrowArgs>(args?: SelectSubset<T, DocumentCommentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__DocumentCommentsClient<$Result.GetResult<Prisma.$DocumentCommentsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DocumentComments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentCommentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DocumentComments
     * const documentComments = await prisma.documentComments.findMany()
     * 
     * // Get first 10 DocumentComments
     * const documentComments = await prisma.documentComments.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documentCommentsWithIdOnly = await prisma.documentComments.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DocumentCommentsFindManyArgs>(args?: SelectSubset<T, DocumentCommentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentCommentsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DocumentComments.
     * @param {DocumentCommentsCreateArgs} args - Arguments to create a DocumentComments.
     * @example
     * // Create one DocumentComments
     * const DocumentComments = await prisma.documentComments.create({
     *   data: {
     *     // ... data to create a DocumentComments
     *   }
     * })
     * 
     */
    create<T extends DocumentCommentsCreateArgs>(args: SelectSubset<T, DocumentCommentsCreateArgs<ExtArgs>>): Prisma__DocumentCommentsClient<$Result.GetResult<Prisma.$DocumentCommentsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DocumentComments.
     * @param {DocumentCommentsCreateManyArgs} args - Arguments to create many DocumentComments.
     * @example
     * // Create many DocumentComments
     * const documentComments = await prisma.documentComments.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DocumentCommentsCreateManyArgs>(args?: SelectSubset<T, DocumentCommentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DocumentComments.
     * @param {DocumentCommentsDeleteArgs} args - Arguments to delete one DocumentComments.
     * @example
     * // Delete one DocumentComments
     * const DocumentComments = await prisma.documentComments.delete({
     *   where: {
     *     // ... filter to delete one DocumentComments
     *   }
     * })
     * 
     */
    delete<T extends DocumentCommentsDeleteArgs>(args: SelectSubset<T, DocumentCommentsDeleteArgs<ExtArgs>>): Prisma__DocumentCommentsClient<$Result.GetResult<Prisma.$DocumentCommentsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DocumentComments.
     * @param {DocumentCommentsUpdateArgs} args - Arguments to update one DocumentComments.
     * @example
     * // Update one DocumentComments
     * const documentComments = await prisma.documentComments.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DocumentCommentsUpdateArgs>(args: SelectSubset<T, DocumentCommentsUpdateArgs<ExtArgs>>): Prisma__DocumentCommentsClient<$Result.GetResult<Prisma.$DocumentCommentsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DocumentComments.
     * @param {DocumentCommentsDeleteManyArgs} args - Arguments to filter DocumentComments to delete.
     * @example
     * // Delete a few DocumentComments
     * const { count } = await prisma.documentComments.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DocumentCommentsDeleteManyArgs>(args?: SelectSubset<T, DocumentCommentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DocumentComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentCommentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DocumentComments
     * const documentComments = await prisma.documentComments.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DocumentCommentsUpdateManyArgs>(args: SelectSubset<T, DocumentCommentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DocumentComments.
     * @param {DocumentCommentsUpsertArgs} args - Arguments to update or create a DocumentComments.
     * @example
     * // Update or create a DocumentComments
     * const documentComments = await prisma.documentComments.upsert({
     *   create: {
     *     // ... data to create a DocumentComments
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DocumentComments we want to update
     *   }
     * })
     */
    upsert<T extends DocumentCommentsUpsertArgs>(args: SelectSubset<T, DocumentCommentsUpsertArgs<ExtArgs>>): Prisma__DocumentCommentsClient<$Result.GetResult<Prisma.$DocumentCommentsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more DocumentComments that matches the filter.
     * @param {DocumentCommentsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const documentComments = await prisma.documentComments.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: DocumentCommentsFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a DocumentComments.
     * @param {DocumentCommentsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const documentComments = await prisma.documentComments.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: DocumentCommentsAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of DocumentComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentCommentsCountArgs} args - Arguments to filter DocumentComments to count.
     * @example
     * // Count the number of DocumentComments
     * const count = await prisma.documentComments.count({
     *   where: {
     *     // ... the filter for the DocumentComments we want to count
     *   }
     * })
    **/
    count<T extends DocumentCommentsCountArgs>(
      args?: Subset<T, DocumentCommentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentCommentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DocumentComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentCommentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentCommentsAggregateArgs>(args: Subset<T, DocumentCommentsAggregateArgs>): Prisma.PrismaPromise<GetDocumentCommentsAggregateType<T>>

    /**
     * Group by DocumentComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentCommentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DocumentCommentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentCommentsGroupByArgs['orderBy'] }
        : { orderBy?: DocumentCommentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DocumentCommentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentCommentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DocumentComments model
   */
  readonly fields: DocumentCommentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DocumentComments.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DocumentCommentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    document<T extends DocumentComments$documentArgs<ExtArgs> = {}>(args?: Subset<T, DocumentComments$documentArgs<ExtArgs>>): Prisma__DocumentsClient<$Result.GetResult<Prisma.$DocumentsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    user<T extends DocumentComments$userArgs<ExtArgs> = {}>(args?: Subset<T, DocumentComments$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DocumentComments model
   */ 
  interface DocumentCommentsFieldRefs {
    readonly id: FieldRef<"DocumentComments", 'String'>
    readonly userId: FieldRef<"DocumentComments", 'String'>
    readonly commentBy: FieldRef<"DocumentComments", 'String'>
    readonly commentText: FieldRef<"DocumentComments", 'String'>
    readonly documentId: FieldRef<"DocumentComments", 'String'>
    readonly createdAt: FieldRef<"DocumentComments", 'DateTime'>
    readonly updatedAt: FieldRef<"DocumentComments", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DocumentComments findUnique
   */
  export type DocumentCommentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentComments
     */
    select?: DocumentCommentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentCommentsInclude<ExtArgs> | null
    /**
     * Filter, which DocumentComments to fetch.
     */
    where: DocumentCommentsWhereUniqueInput
  }

  /**
   * DocumentComments findUniqueOrThrow
   */
  export type DocumentCommentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentComments
     */
    select?: DocumentCommentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentCommentsInclude<ExtArgs> | null
    /**
     * Filter, which DocumentComments to fetch.
     */
    where: DocumentCommentsWhereUniqueInput
  }

  /**
   * DocumentComments findFirst
   */
  export type DocumentCommentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentComments
     */
    select?: DocumentCommentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentCommentsInclude<ExtArgs> | null
    /**
     * Filter, which DocumentComments to fetch.
     */
    where?: DocumentCommentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentComments to fetch.
     */
    orderBy?: DocumentCommentsOrderByWithRelationInput | DocumentCommentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DocumentComments.
     */
    cursor?: DocumentCommentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DocumentComments.
     */
    distinct?: DocumentCommentsScalarFieldEnum | DocumentCommentsScalarFieldEnum[]
  }

  /**
   * DocumentComments findFirstOrThrow
   */
  export type DocumentCommentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentComments
     */
    select?: DocumentCommentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentCommentsInclude<ExtArgs> | null
    /**
     * Filter, which DocumentComments to fetch.
     */
    where?: DocumentCommentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentComments to fetch.
     */
    orderBy?: DocumentCommentsOrderByWithRelationInput | DocumentCommentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DocumentComments.
     */
    cursor?: DocumentCommentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DocumentComments.
     */
    distinct?: DocumentCommentsScalarFieldEnum | DocumentCommentsScalarFieldEnum[]
  }

  /**
   * DocumentComments findMany
   */
  export type DocumentCommentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentComments
     */
    select?: DocumentCommentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentCommentsInclude<ExtArgs> | null
    /**
     * Filter, which DocumentComments to fetch.
     */
    where?: DocumentCommentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentComments to fetch.
     */
    orderBy?: DocumentCommentsOrderByWithRelationInput | DocumentCommentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DocumentComments.
     */
    cursor?: DocumentCommentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentComments.
     */
    skip?: number
    distinct?: DocumentCommentsScalarFieldEnum | DocumentCommentsScalarFieldEnum[]
  }

  /**
   * DocumentComments create
   */
  export type DocumentCommentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentComments
     */
    select?: DocumentCommentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentCommentsInclude<ExtArgs> | null
    /**
     * The data needed to create a DocumentComments.
     */
    data: XOR<DocumentCommentsCreateInput, DocumentCommentsUncheckedCreateInput>
  }

  /**
   * DocumentComments createMany
   */
  export type DocumentCommentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DocumentComments.
     */
    data: DocumentCommentsCreateManyInput | DocumentCommentsCreateManyInput[]
  }

  /**
   * DocumentComments update
   */
  export type DocumentCommentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentComments
     */
    select?: DocumentCommentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentCommentsInclude<ExtArgs> | null
    /**
     * The data needed to update a DocumentComments.
     */
    data: XOR<DocumentCommentsUpdateInput, DocumentCommentsUncheckedUpdateInput>
    /**
     * Choose, which DocumentComments to update.
     */
    where: DocumentCommentsWhereUniqueInput
  }

  /**
   * DocumentComments updateMany
   */
  export type DocumentCommentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DocumentComments.
     */
    data: XOR<DocumentCommentsUpdateManyMutationInput, DocumentCommentsUncheckedUpdateManyInput>
    /**
     * Filter which DocumentComments to update
     */
    where?: DocumentCommentsWhereInput
  }

  /**
   * DocumentComments upsert
   */
  export type DocumentCommentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentComments
     */
    select?: DocumentCommentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentCommentsInclude<ExtArgs> | null
    /**
     * The filter to search for the DocumentComments to update in case it exists.
     */
    where: DocumentCommentsWhereUniqueInput
    /**
     * In case the DocumentComments found by the `where` argument doesn't exist, create a new DocumentComments with this data.
     */
    create: XOR<DocumentCommentsCreateInput, DocumentCommentsUncheckedCreateInput>
    /**
     * In case the DocumentComments was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DocumentCommentsUpdateInput, DocumentCommentsUncheckedUpdateInput>
  }

  /**
   * DocumentComments delete
   */
  export type DocumentCommentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentComments
     */
    select?: DocumentCommentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentCommentsInclude<ExtArgs> | null
    /**
     * Filter which DocumentComments to delete.
     */
    where: DocumentCommentsWhereUniqueInput
  }

  /**
   * DocumentComments deleteMany
   */
  export type DocumentCommentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DocumentComments to delete
     */
    where?: DocumentCommentsWhereInput
  }

  /**
   * DocumentComments findRaw
   */
  export type DocumentCommentsFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * DocumentComments aggregateRaw
   */
  export type DocumentCommentsAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * DocumentComments.document
   */
  export type DocumentComments$documentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Documents
     */
    select?: DocumentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentsInclude<ExtArgs> | null
    where?: DocumentsWhereInput
  }

  /**
   * DocumentComments.user
   */
  export type DocumentComments$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * DocumentComments without action
   */
  export type DocumentCommentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentComments
     */
    select?: DocumentCommentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentCommentsInclude<ExtArgs> | null
  }


  /**
   * Model DocumentWorkFlowHistory
   */

  export type AggregateDocumentWorkFlowHistory = {
    _count: DocumentWorkFlowHistoryCountAggregateOutputType | null
    _min: DocumentWorkFlowHistoryMinAggregateOutputType | null
    _max: DocumentWorkFlowHistoryMaxAggregateOutputType | null
  }

  export type DocumentWorkFlowHistoryMinAggregateOutputType = {
    id: string | null
    actionName: string | null
    userId: string | null
    actionBy: string | null
    documentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DocumentWorkFlowHistoryMaxAggregateOutputType = {
    id: string | null
    actionName: string | null
    userId: string | null
    actionBy: string | null
    documentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DocumentWorkFlowHistoryCountAggregateOutputType = {
    id: number
    actionName: number
    userId: number
    actionBy: number
    documentId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DocumentWorkFlowHistoryMinAggregateInputType = {
    id?: true
    actionName?: true
    userId?: true
    actionBy?: true
    documentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DocumentWorkFlowHistoryMaxAggregateInputType = {
    id?: true
    actionName?: true
    userId?: true
    actionBy?: true
    documentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DocumentWorkFlowHistoryCountAggregateInputType = {
    id?: true
    actionName?: true
    userId?: true
    actionBy?: true
    documentId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DocumentWorkFlowHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DocumentWorkFlowHistory to aggregate.
     */
    where?: DocumentWorkFlowHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentWorkFlowHistories to fetch.
     */
    orderBy?: DocumentWorkFlowHistoryOrderByWithRelationInput | DocumentWorkFlowHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DocumentWorkFlowHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentWorkFlowHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentWorkFlowHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DocumentWorkFlowHistories
    **/
    _count?: true | DocumentWorkFlowHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentWorkFlowHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentWorkFlowHistoryMaxAggregateInputType
  }

  export type GetDocumentWorkFlowHistoryAggregateType<T extends DocumentWorkFlowHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateDocumentWorkFlowHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocumentWorkFlowHistory[P]>
      : GetScalarType<T[P], AggregateDocumentWorkFlowHistory[P]>
  }




  export type DocumentWorkFlowHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWorkFlowHistoryWhereInput
    orderBy?: DocumentWorkFlowHistoryOrderByWithAggregationInput | DocumentWorkFlowHistoryOrderByWithAggregationInput[]
    by: DocumentWorkFlowHistoryScalarFieldEnum[] | DocumentWorkFlowHistoryScalarFieldEnum
    having?: DocumentWorkFlowHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentWorkFlowHistoryCountAggregateInputType | true
    _min?: DocumentWorkFlowHistoryMinAggregateInputType
    _max?: DocumentWorkFlowHistoryMaxAggregateInputType
  }

  export type DocumentWorkFlowHistoryGroupByOutputType = {
    id: string
    actionName: string
    userId: string | null
    actionBy: string | null
    documentId: string | null
    createdAt: Date
    updatedAt: Date
    _count: DocumentWorkFlowHistoryCountAggregateOutputType | null
    _min: DocumentWorkFlowHistoryMinAggregateOutputType | null
    _max: DocumentWorkFlowHistoryMaxAggregateOutputType | null
  }

  type GetDocumentWorkFlowHistoryGroupByPayload<T extends DocumentWorkFlowHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DocumentWorkFlowHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentWorkFlowHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentWorkFlowHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentWorkFlowHistoryGroupByOutputType[P]>
        }
      >
    >


  export type DocumentWorkFlowHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    actionName?: boolean
    userId?: boolean
    actionBy?: boolean
    documentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    document?: boolean | DocumentWorkFlowHistory$documentArgs<ExtArgs>
    user?: boolean | DocumentWorkFlowHistory$userArgs<ExtArgs>
  }, ExtArgs["result"]["documentWorkFlowHistory"]>


  export type DocumentWorkFlowHistorySelectScalar = {
    id?: boolean
    actionName?: boolean
    userId?: boolean
    actionBy?: boolean
    documentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DocumentWorkFlowHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    document?: boolean | DocumentWorkFlowHistory$documentArgs<ExtArgs>
    user?: boolean | DocumentWorkFlowHistory$userArgs<ExtArgs>
  }

  export type $DocumentWorkFlowHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DocumentWorkFlowHistory"
    objects: {
      document: Prisma.$DocumentsPayload<ExtArgs> | null
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      actionName: string
      userId: string | null
      actionBy: string | null
      documentId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["documentWorkFlowHistory"]>
    composites: {}
  }

  type DocumentWorkFlowHistoryGetPayload<S extends boolean | null | undefined | DocumentWorkFlowHistoryDefaultArgs> = $Result.GetResult<Prisma.$DocumentWorkFlowHistoryPayload, S>

  type DocumentWorkFlowHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DocumentWorkFlowHistoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DocumentWorkFlowHistoryCountAggregateInputType | true
    }

  export interface DocumentWorkFlowHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DocumentWorkFlowHistory'], meta: { name: 'DocumentWorkFlowHistory' } }
    /**
     * Find zero or one DocumentWorkFlowHistory that matches the filter.
     * @param {DocumentWorkFlowHistoryFindUniqueArgs} args - Arguments to find a DocumentWorkFlowHistory
     * @example
     * // Get one DocumentWorkFlowHistory
     * const documentWorkFlowHistory = await prisma.documentWorkFlowHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DocumentWorkFlowHistoryFindUniqueArgs>(args: SelectSubset<T, DocumentWorkFlowHistoryFindUniqueArgs<ExtArgs>>): Prisma__DocumentWorkFlowHistoryClient<$Result.GetResult<Prisma.$DocumentWorkFlowHistoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DocumentWorkFlowHistory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DocumentWorkFlowHistoryFindUniqueOrThrowArgs} args - Arguments to find a DocumentWorkFlowHistory
     * @example
     * // Get one DocumentWorkFlowHistory
     * const documentWorkFlowHistory = await prisma.documentWorkFlowHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DocumentWorkFlowHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, DocumentWorkFlowHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DocumentWorkFlowHistoryClient<$Result.GetResult<Prisma.$DocumentWorkFlowHistoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DocumentWorkFlowHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentWorkFlowHistoryFindFirstArgs} args - Arguments to find a DocumentWorkFlowHistory
     * @example
     * // Get one DocumentWorkFlowHistory
     * const documentWorkFlowHistory = await prisma.documentWorkFlowHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DocumentWorkFlowHistoryFindFirstArgs>(args?: SelectSubset<T, DocumentWorkFlowHistoryFindFirstArgs<ExtArgs>>): Prisma__DocumentWorkFlowHistoryClient<$Result.GetResult<Prisma.$DocumentWorkFlowHistoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DocumentWorkFlowHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentWorkFlowHistoryFindFirstOrThrowArgs} args - Arguments to find a DocumentWorkFlowHistory
     * @example
     * // Get one DocumentWorkFlowHistory
     * const documentWorkFlowHistory = await prisma.documentWorkFlowHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DocumentWorkFlowHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, DocumentWorkFlowHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__DocumentWorkFlowHistoryClient<$Result.GetResult<Prisma.$DocumentWorkFlowHistoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DocumentWorkFlowHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentWorkFlowHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DocumentWorkFlowHistories
     * const documentWorkFlowHistories = await prisma.documentWorkFlowHistory.findMany()
     * 
     * // Get first 10 DocumentWorkFlowHistories
     * const documentWorkFlowHistories = await prisma.documentWorkFlowHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documentWorkFlowHistoryWithIdOnly = await prisma.documentWorkFlowHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DocumentWorkFlowHistoryFindManyArgs>(args?: SelectSubset<T, DocumentWorkFlowHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentWorkFlowHistoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DocumentWorkFlowHistory.
     * @param {DocumentWorkFlowHistoryCreateArgs} args - Arguments to create a DocumentWorkFlowHistory.
     * @example
     * // Create one DocumentWorkFlowHistory
     * const DocumentWorkFlowHistory = await prisma.documentWorkFlowHistory.create({
     *   data: {
     *     // ... data to create a DocumentWorkFlowHistory
     *   }
     * })
     * 
     */
    create<T extends DocumentWorkFlowHistoryCreateArgs>(args: SelectSubset<T, DocumentWorkFlowHistoryCreateArgs<ExtArgs>>): Prisma__DocumentWorkFlowHistoryClient<$Result.GetResult<Prisma.$DocumentWorkFlowHistoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DocumentWorkFlowHistories.
     * @param {DocumentWorkFlowHistoryCreateManyArgs} args - Arguments to create many DocumentWorkFlowHistories.
     * @example
     * // Create many DocumentWorkFlowHistories
     * const documentWorkFlowHistory = await prisma.documentWorkFlowHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DocumentWorkFlowHistoryCreateManyArgs>(args?: SelectSubset<T, DocumentWorkFlowHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DocumentWorkFlowHistory.
     * @param {DocumentWorkFlowHistoryDeleteArgs} args - Arguments to delete one DocumentWorkFlowHistory.
     * @example
     * // Delete one DocumentWorkFlowHistory
     * const DocumentWorkFlowHistory = await prisma.documentWorkFlowHistory.delete({
     *   where: {
     *     // ... filter to delete one DocumentWorkFlowHistory
     *   }
     * })
     * 
     */
    delete<T extends DocumentWorkFlowHistoryDeleteArgs>(args: SelectSubset<T, DocumentWorkFlowHistoryDeleteArgs<ExtArgs>>): Prisma__DocumentWorkFlowHistoryClient<$Result.GetResult<Prisma.$DocumentWorkFlowHistoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DocumentWorkFlowHistory.
     * @param {DocumentWorkFlowHistoryUpdateArgs} args - Arguments to update one DocumentWorkFlowHistory.
     * @example
     * // Update one DocumentWorkFlowHistory
     * const documentWorkFlowHistory = await prisma.documentWorkFlowHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DocumentWorkFlowHistoryUpdateArgs>(args: SelectSubset<T, DocumentWorkFlowHistoryUpdateArgs<ExtArgs>>): Prisma__DocumentWorkFlowHistoryClient<$Result.GetResult<Prisma.$DocumentWorkFlowHistoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DocumentWorkFlowHistories.
     * @param {DocumentWorkFlowHistoryDeleteManyArgs} args - Arguments to filter DocumentWorkFlowHistories to delete.
     * @example
     * // Delete a few DocumentWorkFlowHistories
     * const { count } = await prisma.documentWorkFlowHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DocumentWorkFlowHistoryDeleteManyArgs>(args?: SelectSubset<T, DocumentWorkFlowHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DocumentWorkFlowHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentWorkFlowHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DocumentWorkFlowHistories
     * const documentWorkFlowHistory = await prisma.documentWorkFlowHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DocumentWorkFlowHistoryUpdateManyArgs>(args: SelectSubset<T, DocumentWorkFlowHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DocumentWorkFlowHistory.
     * @param {DocumentWorkFlowHistoryUpsertArgs} args - Arguments to update or create a DocumentWorkFlowHistory.
     * @example
     * // Update or create a DocumentWorkFlowHistory
     * const documentWorkFlowHistory = await prisma.documentWorkFlowHistory.upsert({
     *   create: {
     *     // ... data to create a DocumentWorkFlowHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DocumentWorkFlowHistory we want to update
     *   }
     * })
     */
    upsert<T extends DocumentWorkFlowHistoryUpsertArgs>(args: SelectSubset<T, DocumentWorkFlowHistoryUpsertArgs<ExtArgs>>): Prisma__DocumentWorkFlowHistoryClient<$Result.GetResult<Prisma.$DocumentWorkFlowHistoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more DocumentWorkFlowHistories that matches the filter.
     * @param {DocumentWorkFlowHistoryFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const documentWorkFlowHistory = await prisma.documentWorkFlowHistory.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: DocumentWorkFlowHistoryFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a DocumentWorkFlowHistory.
     * @param {DocumentWorkFlowHistoryAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const documentWorkFlowHistory = await prisma.documentWorkFlowHistory.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: DocumentWorkFlowHistoryAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of DocumentWorkFlowHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentWorkFlowHistoryCountArgs} args - Arguments to filter DocumentWorkFlowHistories to count.
     * @example
     * // Count the number of DocumentWorkFlowHistories
     * const count = await prisma.documentWorkFlowHistory.count({
     *   where: {
     *     // ... the filter for the DocumentWorkFlowHistories we want to count
     *   }
     * })
    **/
    count<T extends DocumentWorkFlowHistoryCountArgs>(
      args?: Subset<T, DocumentWorkFlowHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentWorkFlowHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DocumentWorkFlowHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentWorkFlowHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentWorkFlowHistoryAggregateArgs>(args: Subset<T, DocumentWorkFlowHistoryAggregateArgs>): Prisma.PrismaPromise<GetDocumentWorkFlowHistoryAggregateType<T>>

    /**
     * Group by DocumentWorkFlowHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentWorkFlowHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DocumentWorkFlowHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentWorkFlowHistoryGroupByArgs['orderBy'] }
        : { orderBy?: DocumentWorkFlowHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DocumentWorkFlowHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentWorkFlowHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DocumentWorkFlowHistory model
   */
  readonly fields: DocumentWorkFlowHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DocumentWorkFlowHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DocumentWorkFlowHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    document<T extends DocumentWorkFlowHistory$documentArgs<ExtArgs> = {}>(args?: Subset<T, DocumentWorkFlowHistory$documentArgs<ExtArgs>>): Prisma__DocumentsClient<$Result.GetResult<Prisma.$DocumentsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    user<T extends DocumentWorkFlowHistory$userArgs<ExtArgs> = {}>(args?: Subset<T, DocumentWorkFlowHistory$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DocumentWorkFlowHistory model
   */ 
  interface DocumentWorkFlowHistoryFieldRefs {
    readonly id: FieldRef<"DocumentWorkFlowHistory", 'String'>
    readonly actionName: FieldRef<"DocumentWorkFlowHistory", 'String'>
    readonly userId: FieldRef<"DocumentWorkFlowHistory", 'String'>
    readonly actionBy: FieldRef<"DocumentWorkFlowHistory", 'String'>
    readonly documentId: FieldRef<"DocumentWorkFlowHistory", 'String'>
    readonly createdAt: FieldRef<"DocumentWorkFlowHistory", 'DateTime'>
    readonly updatedAt: FieldRef<"DocumentWorkFlowHistory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DocumentWorkFlowHistory findUnique
   */
  export type DocumentWorkFlowHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentWorkFlowHistory
     */
    select?: DocumentWorkFlowHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentWorkFlowHistoryInclude<ExtArgs> | null
    /**
     * Filter, which DocumentWorkFlowHistory to fetch.
     */
    where: DocumentWorkFlowHistoryWhereUniqueInput
  }

  /**
   * DocumentWorkFlowHistory findUniqueOrThrow
   */
  export type DocumentWorkFlowHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentWorkFlowHistory
     */
    select?: DocumentWorkFlowHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentWorkFlowHistoryInclude<ExtArgs> | null
    /**
     * Filter, which DocumentWorkFlowHistory to fetch.
     */
    where: DocumentWorkFlowHistoryWhereUniqueInput
  }

  /**
   * DocumentWorkFlowHistory findFirst
   */
  export type DocumentWorkFlowHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentWorkFlowHistory
     */
    select?: DocumentWorkFlowHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentWorkFlowHistoryInclude<ExtArgs> | null
    /**
     * Filter, which DocumentWorkFlowHistory to fetch.
     */
    where?: DocumentWorkFlowHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentWorkFlowHistories to fetch.
     */
    orderBy?: DocumentWorkFlowHistoryOrderByWithRelationInput | DocumentWorkFlowHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DocumentWorkFlowHistories.
     */
    cursor?: DocumentWorkFlowHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentWorkFlowHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentWorkFlowHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DocumentWorkFlowHistories.
     */
    distinct?: DocumentWorkFlowHistoryScalarFieldEnum | DocumentWorkFlowHistoryScalarFieldEnum[]
  }

  /**
   * DocumentWorkFlowHistory findFirstOrThrow
   */
  export type DocumentWorkFlowHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentWorkFlowHistory
     */
    select?: DocumentWorkFlowHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentWorkFlowHistoryInclude<ExtArgs> | null
    /**
     * Filter, which DocumentWorkFlowHistory to fetch.
     */
    where?: DocumentWorkFlowHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentWorkFlowHistories to fetch.
     */
    orderBy?: DocumentWorkFlowHistoryOrderByWithRelationInput | DocumentWorkFlowHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DocumentWorkFlowHistories.
     */
    cursor?: DocumentWorkFlowHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentWorkFlowHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentWorkFlowHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DocumentWorkFlowHistories.
     */
    distinct?: DocumentWorkFlowHistoryScalarFieldEnum | DocumentWorkFlowHistoryScalarFieldEnum[]
  }

  /**
   * DocumentWorkFlowHistory findMany
   */
  export type DocumentWorkFlowHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentWorkFlowHistory
     */
    select?: DocumentWorkFlowHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentWorkFlowHistoryInclude<ExtArgs> | null
    /**
     * Filter, which DocumentWorkFlowHistories to fetch.
     */
    where?: DocumentWorkFlowHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentWorkFlowHistories to fetch.
     */
    orderBy?: DocumentWorkFlowHistoryOrderByWithRelationInput | DocumentWorkFlowHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DocumentWorkFlowHistories.
     */
    cursor?: DocumentWorkFlowHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentWorkFlowHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentWorkFlowHistories.
     */
    skip?: number
    distinct?: DocumentWorkFlowHistoryScalarFieldEnum | DocumentWorkFlowHistoryScalarFieldEnum[]
  }

  /**
   * DocumentWorkFlowHistory create
   */
  export type DocumentWorkFlowHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentWorkFlowHistory
     */
    select?: DocumentWorkFlowHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentWorkFlowHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a DocumentWorkFlowHistory.
     */
    data: XOR<DocumentWorkFlowHistoryCreateInput, DocumentWorkFlowHistoryUncheckedCreateInput>
  }

  /**
   * DocumentWorkFlowHistory createMany
   */
  export type DocumentWorkFlowHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DocumentWorkFlowHistories.
     */
    data: DocumentWorkFlowHistoryCreateManyInput | DocumentWorkFlowHistoryCreateManyInput[]
  }

  /**
   * DocumentWorkFlowHistory update
   */
  export type DocumentWorkFlowHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentWorkFlowHistory
     */
    select?: DocumentWorkFlowHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentWorkFlowHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a DocumentWorkFlowHistory.
     */
    data: XOR<DocumentWorkFlowHistoryUpdateInput, DocumentWorkFlowHistoryUncheckedUpdateInput>
    /**
     * Choose, which DocumentWorkFlowHistory to update.
     */
    where: DocumentWorkFlowHistoryWhereUniqueInput
  }

  /**
   * DocumentWorkFlowHistory updateMany
   */
  export type DocumentWorkFlowHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DocumentWorkFlowHistories.
     */
    data: XOR<DocumentWorkFlowHistoryUpdateManyMutationInput, DocumentWorkFlowHistoryUncheckedUpdateManyInput>
    /**
     * Filter which DocumentWorkFlowHistories to update
     */
    where?: DocumentWorkFlowHistoryWhereInput
  }

  /**
   * DocumentWorkFlowHistory upsert
   */
  export type DocumentWorkFlowHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentWorkFlowHistory
     */
    select?: DocumentWorkFlowHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentWorkFlowHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the DocumentWorkFlowHistory to update in case it exists.
     */
    where: DocumentWorkFlowHistoryWhereUniqueInput
    /**
     * In case the DocumentWorkFlowHistory found by the `where` argument doesn't exist, create a new DocumentWorkFlowHistory with this data.
     */
    create: XOR<DocumentWorkFlowHistoryCreateInput, DocumentWorkFlowHistoryUncheckedCreateInput>
    /**
     * In case the DocumentWorkFlowHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DocumentWorkFlowHistoryUpdateInput, DocumentWorkFlowHistoryUncheckedUpdateInput>
  }

  /**
   * DocumentWorkFlowHistory delete
   */
  export type DocumentWorkFlowHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentWorkFlowHistory
     */
    select?: DocumentWorkFlowHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentWorkFlowHistoryInclude<ExtArgs> | null
    /**
     * Filter which DocumentWorkFlowHistory to delete.
     */
    where: DocumentWorkFlowHistoryWhereUniqueInput
  }

  /**
   * DocumentWorkFlowHistory deleteMany
   */
  export type DocumentWorkFlowHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DocumentWorkFlowHistories to delete
     */
    where?: DocumentWorkFlowHistoryWhereInput
  }

  /**
   * DocumentWorkFlowHistory findRaw
   */
  export type DocumentWorkFlowHistoryFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * DocumentWorkFlowHistory aggregateRaw
   */
  export type DocumentWorkFlowHistoryAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * DocumentWorkFlowHistory.document
   */
  export type DocumentWorkFlowHistory$documentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Documents
     */
    select?: DocumentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentsInclude<ExtArgs> | null
    where?: DocumentsWhereInput
  }

  /**
   * DocumentWorkFlowHistory.user
   */
  export type DocumentWorkFlowHistory$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * DocumentWorkFlowHistory without action
   */
  export type DocumentWorkFlowHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentWorkFlowHistory
     */
    select?: DocumentWorkFlowHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentWorkFlowHistoryInclude<ExtArgs> | null
  }


  /**
   * Model documentAdmins
   */

  export type AggregateDocumentAdmins = {
    _count: DocumentAdminsCountAggregateOutputType | null
    _min: DocumentAdminsMinAggregateOutputType | null
    _max: DocumentAdminsMaxAggregateOutputType | null
  }

  export type DocumentAdminsMinAggregateOutputType = {
    id: string | null
    type: string | null
    firstname: string | null
    lastname: string | null
    email: string | null
    userId: string | null
    doctypeId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DocumentAdminsMaxAggregateOutputType = {
    id: string | null
    type: string | null
    firstname: string | null
    lastname: string | null
    email: string | null
    userId: string | null
    doctypeId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DocumentAdminsCountAggregateOutputType = {
    id: number
    type: number
    firstname: number
    lastname: number
    email: number
    userId: number
    doctypeId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DocumentAdminsMinAggregateInputType = {
    id?: true
    type?: true
    firstname?: true
    lastname?: true
    email?: true
    userId?: true
    doctypeId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DocumentAdminsMaxAggregateInputType = {
    id?: true
    type?: true
    firstname?: true
    lastname?: true
    email?: true
    userId?: true
    doctypeId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DocumentAdminsCountAggregateInputType = {
    id?: true
    type?: true
    firstname?: true
    lastname?: true
    email?: true
    userId?: true
    doctypeId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DocumentAdminsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which documentAdmins to aggregate.
     */
    where?: documentAdminsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of documentAdmins to fetch.
     */
    orderBy?: documentAdminsOrderByWithRelationInput | documentAdminsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: documentAdminsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` documentAdmins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` documentAdmins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned documentAdmins
    **/
    _count?: true | DocumentAdminsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentAdminsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentAdminsMaxAggregateInputType
  }

  export type GetDocumentAdminsAggregateType<T extends DocumentAdminsAggregateArgs> = {
        [P in keyof T & keyof AggregateDocumentAdmins]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocumentAdmins[P]>
      : GetScalarType<T[P], AggregateDocumentAdmins[P]>
  }




  export type documentAdminsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: documentAdminsWhereInput
    orderBy?: documentAdminsOrderByWithAggregationInput | documentAdminsOrderByWithAggregationInput[]
    by: DocumentAdminsScalarFieldEnum[] | DocumentAdminsScalarFieldEnum
    having?: documentAdminsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentAdminsCountAggregateInputType | true
    _min?: DocumentAdminsMinAggregateInputType
    _max?: DocumentAdminsMaxAggregateInputType
  }

  export type DocumentAdminsGroupByOutputType = {
    id: string
    type: string
    firstname: string
    lastname: string
    email: string
    userId: string
    doctypeId: string | null
    createdAt: Date
    updatedAt: Date
    _count: DocumentAdminsCountAggregateOutputType | null
    _min: DocumentAdminsMinAggregateOutputType | null
    _max: DocumentAdminsMaxAggregateOutputType | null
  }

  type GetDocumentAdminsGroupByPayload<T extends documentAdminsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DocumentAdminsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentAdminsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentAdminsGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentAdminsGroupByOutputType[P]>
        }
      >
    >


  export type documentAdminsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    firstname?: boolean
    lastname?: boolean
    email?: boolean
    userId?: boolean
    doctypeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    doctype?: boolean | documentAdmins$doctypeArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["documentAdmins"]>


  export type documentAdminsSelectScalar = {
    id?: boolean
    type?: boolean
    firstname?: boolean
    lastname?: boolean
    email?: boolean
    userId?: boolean
    doctypeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type documentAdminsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    doctype?: boolean | documentAdmins$doctypeArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $documentAdminsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "documentAdmins"
    objects: {
      doctype: Prisma.$DoctypePayload<ExtArgs> | null
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: string
      firstname: string
      lastname: string
      email: string
      userId: string
      doctypeId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["documentAdmins"]>
    composites: {}
  }

  type documentAdminsGetPayload<S extends boolean | null | undefined | documentAdminsDefaultArgs> = $Result.GetResult<Prisma.$documentAdminsPayload, S>

  type documentAdminsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<documentAdminsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DocumentAdminsCountAggregateInputType | true
    }

  export interface documentAdminsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['documentAdmins'], meta: { name: 'documentAdmins' } }
    /**
     * Find zero or one DocumentAdmins that matches the filter.
     * @param {documentAdminsFindUniqueArgs} args - Arguments to find a DocumentAdmins
     * @example
     * // Get one DocumentAdmins
     * const documentAdmins = await prisma.documentAdmins.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends documentAdminsFindUniqueArgs>(args: SelectSubset<T, documentAdminsFindUniqueArgs<ExtArgs>>): Prisma__documentAdminsClient<$Result.GetResult<Prisma.$documentAdminsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DocumentAdmins that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {documentAdminsFindUniqueOrThrowArgs} args - Arguments to find a DocumentAdmins
     * @example
     * // Get one DocumentAdmins
     * const documentAdmins = await prisma.documentAdmins.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends documentAdminsFindUniqueOrThrowArgs>(args: SelectSubset<T, documentAdminsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__documentAdminsClient<$Result.GetResult<Prisma.$documentAdminsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DocumentAdmins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {documentAdminsFindFirstArgs} args - Arguments to find a DocumentAdmins
     * @example
     * // Get one DocumentAdmins
     * const documentAdmins = await prisma.documentAdmins.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends documentAdminsFindFirstArgs>(args?: SelectSubset<T, documentAdminsFindFirstArgs<ExtArgs>>): Prisma__documentAdminsClient<$Result.GetResult<Prisma.$documentAdminsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DocumentAdmins that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {documentAdminsFindFirstOrThrowArgs} args - Arguments to find a DocumentAdmins
     * @example
     * // Get one DocumentAdmins
     * const documentAdmins = await prisma.documentAdmins.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends documentAdminsFindFirstOrThrowArgs>(args?: SelectSubset<T, documentAdminsFindFirstOrThrowArgs<ExtArgs>>): Prisma__documentAdminsClient<$Result.GetResult<Prisma.$documentAdminsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DocumentAdmins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {documentAdminsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DocumentAdmins
     * const documentAdmins = await prisma.documentAdmins.findMany()
     * 
     * // Get first 10 DocumentAdmins
     * const documentAdmins = await prisma.documentAdmins.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documentAdminsWithIdOnly = await prisma.documentAdmins.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends documentAdminsFindManyArgs>(args?: SelectSubset<T, documentAdminsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$documentAdminsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DocumentAdmins.
     * @param {documentAdminsCreateArgs} args - Arguments to create a DocumentAdmins.
     * @example
     * // Create one DocumentAdmins
     * const DocumentAdmins = await prisma.documentAdmins.create({
     *   data: {
     *     // ... data to create a DocumentAdmins
     *   }
     * })
     * 
     */
    create<T extends documentAdminsCreateArgs>(args: SelectSubset<T, documentAdminsCreateArgs<ExtArgs>>): Prisma__documentAdminsClient<$Result.GetResult<Prisma.$documentAdminsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DocumentAdmins.
     * @param {documentAdminsCreateManyArgs} args - Arguments to create many DocumentAdmins.
     * @example
     * // Create many DocumentAdmins
     * const documentAdmins = await prisma.documentAdmins.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends documentAdminsCreateManyArgs>(args?: SelectSubset<T, documentAdminsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DocumentAdmins.
     * @param {documentAdminsDeleteArgs} args - Arguments to delete one DocumentAdmins.
     * @example
     * // Delete one DocumentAdmins
     * const DocumentAdmins = await prisma.documentAdmins.delete({
     *   where: {
     *     // ... filter to delete one DocumentAdmins
     *   }
     * })
     * 
     */
    delete<T extends documentAdminsDeleteArgs>(args: SelectSubset<T, documentAdminsDeleteArgs<ExtArgs>>): Prisma__documentAdminsClient<$Result.GetResult<Prisma.$documentAdminsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DocumentAdmins.
     * @param {documentAdminsUpdateArgs} args - Arguments to update one DocumentAdmins.
     * @example
     * // Update one DocumentAdmins
     * const documentAdmins = await prisma.documentAdmins.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends documentAdminsUpdateArgs>(args: SelectSubset<T, documentAdminsUpdateArgs<ExtArgs>>): Prisma__documentAdminsClient<$Result.GetResult<Prisma.$documentAdminsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DocumentAdmins.
     * @param {documentAdminsDeleteManyArgs} args - Arguments to filter DocumentAdmins to delete.
     * @example
     * // Delete a few DocumentAdmins
     * const { count } = await prisma.documentAdmins.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends documentAdminsDeleteManyArgs>(args?: SelectSubset<T, documentAdminsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DocumentAdmins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {documentAdminsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DocumentAdmins
     * const documentAdmins = await prisma.documentAdmins.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends documentAdminsUpdateManyArgs>(args: SelectSubset<T, documentAdminsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DocumentAdmins.
     * @param {documentAdminsUpsertArgs} args - Arguments to update or create a DocumentAdmins.
     * @example
     * // Update or create a DocumentAdmins
     * const documentAdmins = await prisma.documentAdmins.upsert({
     *   create: {
     *     // ... data to create a DocumentAdmins
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DocumentAdmins we want to update
     *   }
     * })
     */
    upsert<T extends documentAdminsUpsertArgs>(args: SelectSubset<T, documentAdminsUpsertArgs<ExtArgs>>): Prisma__documentAdminsClient<$Result.GetResult<Prisma.$documentAdminsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more DocumentAdmins that matches the filter.
     * @param {documentAdminsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const documentAdmins = await prisma.documentAdmins.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: documentAdminsFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a DocumentAdmins.
     * @param {documentAdminsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const documentAdmins = await prisma.documentAdmins.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: documentAdminsAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of DocumentAdmins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {documentAdminsCountArgs} args - Arguments to filter DocumentAdmins to count.
     * @example
     * // Count the number of DocumentAdmins
     * const count = await prisma.documentAdmins.count({
     *   where: {
     *     // ... the filter for the DocumentAdmins we want to count
     *   }
     * })
    **/
    count<T extends documentAdminsCountArgs>(
      args?: Subset<T, documentAdminsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentAdminsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DocumentAdmins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentAdminsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentAdminsAggregateArgs>(args: Subset<T, DocumentAdminsAggregateArgs>): Prisma.PrismaPromise<GetDocumentAdminsAggregateType<T>>

    /**
     * Group by DocumentAdmins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {documentAdminsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends documentAdminsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: documentAdminsGroupByArgs['orderBy'] }
        : { orderBy?: documentAdminsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, documentAdminsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentAdminsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the documentAdmins model
   */
  readonly fields: documentAdminsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for documentAdmins.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__documentAdminsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    doctype<T extends documentAdmins$doctypeArgs<ExtArgs> = {}>(args?: Subset<T, documentAdmins$doctypeArgs<ExtArgs>>): Prisma__DoctypeClient<$Result.GetResult<Prisma.$DoctypePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the documentAdmins model
   */ 
  interface documentAdminsFieldRefs {
    readonly id: FieldRef<"documentAdmins", 'String'>
    readonly type: FieldRef<"documentAdmins", 'String'>
    readonly firstname: FieldRef<"documentAdmins", 'String'>
    readonly lastname: FieldRef<"documentAdmins", 'String'>
    readonly email: FieldRef<"documentAdmins", 'String'>
    readonly userId: FieldRef<"documentAdmins", 'String'>
    readonly doctypeId: FieldRef<"documentAdmins", 'String'>
    readonly createdAt: FieldRef<"documentAdmins", 'DateTime'>
    readonly updatedAt: FieldRef<"documentAdmins", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * documentAdmins findUnique
   */
  export type documentAdminsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the documentAdmins
     */
    select?: documentAdminsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: documentAdminsInclude<ExtArgs> | null
    /**
     * Filter, which documentAdmins to fetch.
     */
    where: documentAdminsWhereUniqueInput
  }

  /**
   * documentAdmins findUniqueOrThrow
   */
  export type documentAdminsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the documentAdmins
     */
    select?: documentAdminsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: documentAdminsInclude<ExtArgs> | null
    /**
     * Filter, which documentAdmins to fetch.
     */
    where: documentAdminsWhereUniqueInput
  }

  /**
   * documentAdmins findFirst
   */
  export type documentAdminsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the documentAdmins
     */
    select?: documentAdminsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: documentAdminsInclude<ExtArgs> | null
    /**
     * Filter, which documentAdmins to fetch.
     */
    where?: documentAdminsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of documentAdmins to fetch.
     */
    orderBy?: documentAdminsOrderByWithRelationInput | documentAdminsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for documentAdmins.
     */
    cursor?: documentAdminsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` documentAdmins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` documentAdmins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of documentAdmins.
     */
    distinct?: DocumentAdminsScalarFieldEnum | DocumentAdminsScalarFieldEnum[]
  }

  /**
   * documentAdmins findFirstOrThrow
   */
  export type documentAdminsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the documentAdmins
     */
    select?: documentAdminsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: documentAdminsInclude<ExtArgs> | null
    /**
     * Filter, which documentAdmins to fetch.
     */
    where?: documentAdminsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of documentAdmins to fetch.
     */
    orderBy?: documentAdminsOrderByWithRelationInput | documentAdminsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for documentAdmins.
     */
    cursor?: documentAdminsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` documentAdmins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` documentAdmins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of documentAdmins.
     */
    distinct?: DocumentAdminsScalarFieldEnum | DocumentAdminsScalarFieldEnum[]
  }

  /**
   * documentAdmins findMany
   */
  export type documentAdminsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the documentAdmins
     */
    select?: documentAdminsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: documentAdminsInclude<ExtArgs> | null
    /**
     * Filter, which documentAdmins to fetch.
     */
    where?: documentAdminsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of documentAdmins to fetch.
     */
    orderBy?: documentAdminsOrderByWithRelationInput | documentAdminsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing documentAdmins.
     */
    cursor?: documentAdminsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` documentAdmins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` documentAdmins.
     */
    skip?: number
    distinct?: DocumentAdminsScalarFieldEnum | DocumentAdminsScalarFieldEnum[]
  }

  /**
   * documentAdmins create
   */
  export type documentAdminsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the documentAdmins
     */
    select?: documentAdminsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: documentAdminsInclude<ExtArgs> | null
    /**
     * The data needed to create a documentAdmins.
     */
    data: XOR<documentAdminsCreateInput, documentAdminsUncheckedCreateInput>
  }

  /**
   * documentAdmins createMany
   */
  export type documentAdminsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many documentAdmins.
     */
    data: documentAdminsCreateManyInput | documentAdminsCreateManyInput[]
  }

  /**
   * documentAdmins update
   */
  export type documentAdminsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the documentAdmins
     */
    select?: documentAdminsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: documentAdminsInclude<ExtArgs> | null
    /**
     * The data needed to update a documentAdmins.
     */
    data: XOR<documentAdminsUpdateInput, documentAdminsUncheckedUpdateInput>
    /**
     * Choose, which documentAdmins to update.
     */
    where: documentAdminsWhereUniqueInput
  }

  /**
   * documentAdmins updateMany
   */
  export type documentAdminsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update documentAdmins.
     */
    data: XOR<documentAdminsUpdateManyMutationInput, documentAdminsUncheckedUpdateManyInput>
    /**
     * Filter which documentAdmins to update
     */
    where?: documentAdminsWhereInput
  }

  /**
   * documentAdmins upsert
   */
  export type documentAdminsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the documentAdmins
     */
    select?: documentAdminsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: documentAdminsInclude<ExtArgs> | null
    /**
     * The filter to search for the documentAdmins to update in case it exists.
     */
    where: documentAdminsWhereUniqueInput
    /**
     * In case the documentAdmins found by the `where` argument doesn't exist, create a new documentAdmins with this data.
     */
    create: XOR<documentAdminsCreateInput, documentAdminsUncheckedCreateInput>
    /**
     * In case the documentAdmins was found with the provided `where` argument, update it with this data.
     */
    update: XOR<documentAdminsUpdateInput, documentAdminsUncheckedUpdateInput>
  }

  /**
   * documentAdmins delete
   */
  export type documentAdminsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the documentAdmins
     */
    select?: documentAdminsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: documentAdminsInclude<ExtArgs> | null
    /**
     * Filter which documentAdmins to delete.
     */
    where: documentAdminsWhereUniqueInput
  }

  /**
   * documentAdmins deleteMany
   */
  export type documentAdminsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which documentAdmins to delete
     */
    where?: documentAdminsWhereInput
  }

  /**
   * documentAdmins findRaw
   */
  export type documentAdminsFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * documentAdmins aggregateRaw
   */
  export type documentAdminsAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * documentAdmins.doctype
   */
  export type documentAdmins$doctypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctype
     */
    select?: DoctypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctypeInclude<ExtArgs> | null
    where?: DoctypeWhereInput
  }

  /**
   * documentAdmins without action
   */
  export type documentAdminsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the documentAdmins
     */
    select?: documentAdminsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: documentAdminsInclude<ExtArgs> | null
  }


  /**
   * Model AdditionalDocumentAdmins
   */

  export type AggregateAdditionalDocumentAdmins = {
    _count: AdditionalDocumentAdminsCountAggregateOutputType | null
    _min: AdditionalDocumentAdminsMinAggregateOutputType | null
    _max: AdditionalDocumentAdminsMaxAggregateOutputType | null
  }

  export type AdditionalDocumentAdminsMinAggregateOutputType = {
    id: string | null
    type: string | null
    firstname: string | null
    lastname: string | null
    email: string | null
    userId: string | null
    documentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdditionalDocumentAdminsMaxAggregateOutputType = {
    id: string | null
    type: string | null
    firstname: string | null
    lastname: string | null
    email: string | null
    userId: string | null
    documentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdditionalDocumentAdminsCountAggregateOutputType = {
    id: number
    type: number
    firstname: number
    lastname: number
    email: number
    userId: number
    documentId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AdditionalDocumentAdminsMinAggregateInputType = {
    id?: true
    type?: true
    firstname?: true
    lastname?: true
    email?: true
    userId?: true
    documentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdditionalDocumentAdminsMaxAggregateInputType = {
    id?: true
    type?: true
    firstname?: true
    lastname?: true
    email?: true
    userId?: true
    documentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdditionalDocumentAdminsCountAggregateInputType = {
    id?: true
    type?: true
    firstname?: true
    lastname?: true
    email?: true
    userId?: true
    documentId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AdditionalDocumentAdminsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdditionalDocumentAdmins to aggregate.
     */
    where?: AdditionalDocumentAdminsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdditionalDocumentAdmins to fetch.
     */
    orderBy?: AdditionalDocumentAdminsOrderByWithRelationInput | AdditionalDocumentAdminsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdditionalDocumentAdminsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdditionalDocumentAdmins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdditionalDocumentAdmins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdditionalDocumentAdmins
    **/
    _count?: true | AdditionalDocumentAdminsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdditionalDocumentAdminsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdditionalDocumentAdminsMaxAggregateInputType
  }

  export type GetAdditionalDocumentAdminsAggregateType<T extends AdditionalDocumentAdminsAggregateArgs> = {
        [P in keyof T & keyof AggregateAdditionalDocumentAdmins]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdditionalDocumentAdmins[P]>
      : GetScalarType<T[P], AggregateAdditionalDocumentAdmins[P]>
  }




  export type AdditionalDocumentAdminsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdditionalDocumentAdminsWhereInput
    orderBy?: AdditionalDocumentAdminsOrderByWithAggregationInput | AdditionalDocumentAdminsOrderByWithAggregationInput[]
    by: AdditionalDocumentAdminsScalarFieldEnum[] | AdditionalDocumentAdminsScalarFieldEnum
    having?: AdditionalDocumentAdminsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdditionalDocumentAdminsCountAggregateInputType | true
    _min?: AdditionalDocumentAdminsMinAggregateInputType
    _max?: AdditionalDocumentAdminsMaxAggregateInputType
  }

  export type AdditionalDocumentAdminsGroupByOutputType = {
    id: string
    type: string
    firstname: string
    lastname: string
    email: string
    userId: string
    documentId: string | null
    createdAt: Date
    updatedAt: Date
    _count: AdditionalDocumentAdminsCountAggregateOutputType | null
    _min: AdditionalDocumentAdminsMinAggregateOutputType | null
    _max: AdditionalDocumentAdminsMaxAggregateOutputType | null
  }

  type GetAdditionalDocumentAdminsGroupByPayload<T extends AdditionalDocumentAdminsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdditionalDocumentAdminsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdditionalDocumentAdminsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdditionalDocumentAdminsGroupByOutputType[P]>
            : GetScalarType<T[P], AdditionalDocumentAdminsGroupByOutputType[P]>
        }
      >
    >


  export type AdditionalDocumentAdminsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    firstname?: boolean
    lastname?: boolean
    email?: boolean
    userId?: boolean
    documentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    document?: boolean | AdditionalDocumentAdmins$documentArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["additionalDocumentAdmins"]>


  export type AdditionalDocumentAdminsSelectScalar = {
    id?: boolean
    type?: boolean
    firstname?: boolean
    lastname?: boolean
    email?: boolean
    userId?: boolean
    documentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AdditionalDocumentAdminsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    document?: boolean | AdditionalDocumentAdmins$documentArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AdditionalDocumentAdminsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdditionalDocumentAdmins"
    objects: {
      document: Prisma.$DocumentsPayload<ExtArgs> | null
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: string
      firstname: string
      lastname: string
      email: string
      userId: string
      documentId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["additionalDocumentAdmins"]>
    composites: {}
  }

  type AdditionalDocumentAdminsGetPayload<S extends boolean | null | undefined | AdditionalDocumentAdminsDefaultArgs> = $Result.GetResult<Prisma.$AdditionalDocumentAdminsPayload, S>

  type AdditionalDocumentAdminsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AdditionalDocumentAdminsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AdditionalDocumentAdminsCountAggregateInputType | true
    }

  export interface AdditionalDocumentAdminsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdditionalDocumentAdmins'], meta: { name: 'AdditionalDocumentAdmins' } }
    /**
     * Find zero or one AdditionalDocumentAdmins that matches the filter.
     * @param {AdditionalDocumentAdminsFindUniqueArgs} args - Arguments to find a AdditionalDocumentAdmins
     * @example
     * // Get one AdditionalDocumentAdmins
     * const additionalDocumentAdmins = await prisma.additionalDocumentAdmins.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdditionalDocumentAdminsFindUniqueArgs>(args: SelectSubset<T, AdditionalDocumentAdminsFindUniqueArgs<ExtArgs>>): Prisma__AdditionalDocumentAdminsClient<$Result.GetResult<Prisma.$AdditionalDocumentAdminsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AdditionalDocumentAdmins that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AdditionalDocumentAdminsFindUniqueOrThrowArgs} args - Arguments to find a AdditionalDocumentAdmins
     * @example
     * // Get one AdditionalDocumentAdmins
     * const additionalDocumentAdmins = await prisma.additionalDocumentAdmins.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdditionalDocumentAdminsFindUniqueOrThrowArgs>(args: SelectSubset<T, AdditionalDocumentAdminsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdditionalDocumentAdminsClient<$Result.GetResult<Prisma.$AdditionalDocumentAdminsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AdditionalDocumentAdmins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdditionalDocumentAdminsFindFirstArgs} args - Arguments to find a AdditionalDocumentAdmins
     * @example
     * // Get one AdditionalDocumentAdmins
     * const additionalDocumentAdmins = await prisma.additionalDocumentAdmins.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdditionalDocumentAdminsFindFirstArgs>(args?: SelectSubset<T, AdditionalDocumentAdminsFindFirstArgs<ExtArgs>>): Prisma__AdditionalDocumentAdminsClient<$Result.GetResult<Prisma.$AdditionalDocumentAdminsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AdditionalDocumentAdmins that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdditionalDocumentAdminsFindFirstOrThrowArgs} args - Arguments to find a AdditionalDocumentAdmins
     * @example
     * // Get one AdditionalDocumentAdmins
     * const additionalDocumentAdmins = await prisma.additionalDocumentAdmins.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdditionalDocumentAdminsFindFirstOrThrowArgs>(args?: SelectSubset<T, AdditionalDocumentAdminsFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdditionalDocumentAdminsClient<$Result.GetResult<Prisma.$AdditionalDocumentAdminsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AdditionalDocumentAdmins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdditionalDocumentAdminsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdditionalDocumentAdmins
     * const additionalDocumentAdmins = await prisma.additionalDocumentAdmins.findMany()
     * 
     * // Get first 10 AdditionalDocumentAdmins
     * const additionalDocumentAdmins = await prisma.additionalDocumentAdmins.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const additionalDocumentAdminsWithIdOnly = await prisma.additionalDocumentAdmins.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdditionalDocumentAdminsFindManyArgs>(args?: SelectSubset<T, AdditionalDocumentAdminsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdditionalDocumentAdminsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AdditionalDocumentAdmins.
     * @param {AdditionalDocumentAdminsCreateArgs} args - Arguments to create a AdditionalDocumentAdmins.
     * @example
     * // Create one AdditionalDocumentAdmins
     * const AdditionalDocumentAdmins = await prisma.additionalDocumentAdmins.create({
     *   data: {
     *     // ... data to create a AdditionalDocumentAdmins
     *   }
     * })
     * 
     */
    create<T extends AdditionalDocumentAdminsCreateArgs>(args: SelectSubset<T, AdditionalDocumentAdminsCreateArgs<ExtArgs>>): Prisma__AdditionalDocumentAdminsClient<$Result.GetResult<Prisma.$AdditionalDocumentAdminsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AdditionalDocumentAdmins.
     * @param {AdditionalDocumentAdminsCreateManyArgs} args - Arguments to create many AdditionalDocumentAdmins.
     * @example
     * // Create many AdditionalDocumentAdmins
     * const additionalDocumentAdmins = await prisma.additionalDocumentAdmins.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdditionalDocumentAdminsCreateManyArgs>(args?: SelectSubset<T, AdditionalDocumentAdminsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AdditionalDocumentAdmins.
     * @param {AdditionalDocumentAdminsDeleteArgs} args - Arguments to delete one AdditionalDocumentAdmins.
     * @example
     * // Delete one AdditionalDocumentAdmins
     * const AdditionalDocumentAdmins = await prisma.additionalDocumentAdmins.delete({
     *   where: {
     *     // ... filter to delete one AdditionalDocumentAdmins
     *   }
     * })
     * 
     */
    delete<T extends AdditionalDocumentAdminsDeleteArgs>(args: SelectSubset<T, AdditionalDocumentAdminsDeleteArgs<ExtArgs>>): Prisma__AdditionalDocumentAdminsClient<$Result.GetResult<Prisma.$AdditionalDocumentAdminsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AdditionalDocumentAdmins.
     * @param {AdditionalDocumentAdminsUpdateArgs} args - Arguments to update one AdditionalDocumentAdmins.
     * @example
     * // Update one AdditionalDocumentAdmins
     * const additionalDocumentAdmins = await prisma.additionalDocumentAdmins.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdditionalDocumentAdminsUpdateArgs>(args: SelectSubset<T, AdditionalDocumentAdminsUpdateArgs<ExtArgs>>): Prisma__AdditionalDocumentAdminsClient<$Result.GetResult<Prisma.$AdditionalDocumentAdminsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AdditionalDocumentAdmins.
     * @param {AdditionalDocumentAdminsDeleteManyArgs} args - Arguments to filter AdditionalDocumentAdmins to delete.
     * @example
     * // Delete a few AdditionalDocumentAdmins
     * const { count } = await prisma.additionalDocumentAdmins.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdditionalDocumentAdminsDeleteManyArgs>(args?: SelectSubset<T, AdditionalDocumentAdminsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdditionalDocumentAdmins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdditionalDocumentAdminsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdditionalDocumentAdmins
     * const additionalDocumentAdmins = await prisma.additionalDocumentAdmins.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdditionalDocumentAdminsUpdateManyArgs>(args: SelectSubset<T, AdditionalDocumentAdminsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AdditionalDocumentAdmins.
     * @param {AdditionalDocumentAdminsUpsertArgs} args - Arguments to update or create a AdditionalDocumentAdmins.
     * @example
     * // Update or create a AdditionalDocumentAdmins
     * const additionalDocumentAdmins = await prisma.additionalDocumentAdmins.upsert({
     *   create: {
     *     // ... data to create a AdditionalDocumentAdmins
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdditionalDocumentAdmins we want to update
     *   }
     * })
     */
    upsert<T extends AdditionalDocumentAdminsUpsertArgs>(args: SelectSubset<T, AdditionalDocumentAdminsUpsertArgs<ExtArgs>>): Prisma__AdditionalDocumentAdminsClient<$Result.GetResult<Prisma.$AdditionalDocumentAdminsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more AdditionalDocumentAdmins that matches the filter.
     * @param {AdditionalDocumentAdminsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const additionalDocumentAdmins = await prisma.additionalDocumentAdmins.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: AdditionalDocumentAdminsFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a AdditionalDocumentAdmins.
     * @param {AdditionalDocumentAdminsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const additionalDocumentAdmins = await prisma.additionalDocumentAdmins.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: AdditionalDocumentAdminsAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of AdditionalDocumentAdmins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdditionalDocumentAdminsCountArgs} args - Arguments to filter AdditionalDocumentAdmins to count.
     * @example
     * // Count the number of AdditionalDocumentAdmins
     * const count = await prisma.additionalDocumentAdmins.count({
     *   where: {
     *     // ... the filter for the AdditionalDocumentAdmins we want to count
     *   }
     * })
    **/
    count<T extends AdditionalDocumentAdminsCountArgs>(
      args?: Subset<T, AdditionalDocumentAdminsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdditionalDocumentAdminsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdditionalDocumentAdmins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdditionalDocumentAdminsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdditionalDocumentAdminsAggregateArgs>(args: Subset<T, AdditionalDocumentAdminsAggregateArgs>): Prisma.PrismaPromise<GetAdditionalDocumentAdminsAggregateType<T>>

    /**
     * Group by AdditionalDocumentAdmins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdditionalDocumentAdminsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdditionalDocumentAdminsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdditionalDocumentAdminsGroupByArgs['orderBy'] }
        : { orderBy?: AdditionalDocumentAdminsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdditionalDocumentAdminsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdditionalDocumentAdminsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdditionalDocumentAdmins model
   */
  readonly fields: AdditionalDocumentAdminsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdditionalDocumentAdmins.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdditionalDocumentAdminsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    document<T extends AdditionalDocumentAdmins$documentArgs<ExtArgs> = {}>(args?: Subset<T, AdditionalDocumentAdmins$documentArgs<ExtArgs>>): Prisma__DocumentsClient<$Result.GetResult<Prisma.$DocumentsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdditionalDocumentAdmins model
   */ 
  interface AdditionalDocumentAdminsFieldRefs {
    readonly id: FieldRef<"AdditionalDocumentAdmins", 'String'>
    readonly type: FieldRef<"AdditionalDocumentAdmins", 'String'>
    readonly firstname: FieldRef<"AdditionalDocumentAdmins", 'String'>
    readonly lastname: FieldRef<"AdditionalDocumentAdmins", 'String'>
    readonly email: FieldRef<"AdditionalDocumentAdmins", 'String'>
    readonly userId: FieldRef<"AdditionalDocumentAdmins", 'String'>
    readonly documentId: FieldRef<"AdditionalDocumentAdmins", 'String'>
    readonly createdAt: FieldRef<"AdditionalDocumentAdmins", 'DateTime'>
    readonly updatedAt: FieldRef<"AdditionalDocumentAdmins", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AdditionalDocumentAdmins findUnique
   */
  export type AdditionalDocumentAdminsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdditionalDocumentAdmins
     */
    select?: AdditionalDocumentAdminsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdditionalDocumentAdminsInclude<ExtArgs> | null
    /**
     * Filter, which AdditionalDocumentAdmins to fetch.
     */
    where: AdditionalDocumentAdminsWhereUniqueInput
  }

  /**
   * AdditionalDocumentAdmins findUniqueOrThrow
   */
  export type AdditionalDocumentAdminsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdditionalDocumentAdmins
     */
    select?: AdditionalDocumentAdminsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdditionalDocumentAdminsInclude<ExtArgs> | null
    /**
     * Filter, which AdditionalDocumentAdmins to fetch.
     */
    where: AdditionalDocumentAdminsWhereUniqueInput
  }

  /**
   * AdditionalDocumentAdmins findFirst
   */
  export type AdditionalDocumentAdminsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdditionalDocumentAdmins
     */
    select?: AdditionalDocumentAdminsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdditionalDocumentAdminsInclude<ExtArgs> | null
    /**
     * Filter, which AdditionalDocumentAdmins to fetch.
     */
    where?: AdditionalDocumentAdminsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdditionalDocumentAdmins to fetch.
     */
    orderBy?: AdditionalDocumentAdminsOrderByWithRelationInput | AdditionalDocumentAdminsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdditionalDocumentAdmins.
     */
    cursor?: AdditionalDocumentAdminsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdditionalDocumentAdmins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdditionalDocumentAdmins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdditionalDocumentAdmins.
     */
    distinct?: AdditionalDocumentAdminsScalarFieldEnum | AdditionalDocumentAdminsScalarFieldEnum[]
  }

  /**
   * AdditionalDocumentAdmins findFirstOrThrow
   */
  export type AdditionalDocumentAdminsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdditionalDocumentAdmins
     */
    select?: AdditionalDocumentAdminsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdditionalDocumentAdminsInclude<ExtArgs> | null
    /**
     * Filter, which AdditionalDocumentAdmins to fetch.
     */
    where?: AdditionalDocumentAdminsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdditionalDocumentAdmins to fetch.
     */
    orderBy?: AdditionalDocumentAdminsOrderByWithRelationInput | AdditionalDocumentAdminsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdditionalDocumentAdmins.
     */
    cursor?: AdditionalDocumentAdminsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdditionalDocumentAdmins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdditionalDocumentAdmins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdditionalDocumentAdmins.
     */
    distinct?: AdditionalDocumentAdminsScalarFieldEnum | AdditionalDocumentAdminsScalarFieldEnum[]
  }

  /**
   * AdditionalDocumentAdmins findMany
   */
  export type AdditionalDocumentAdminsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdditionalDocumentAdmins
     */
    select?: AdditionalDocumentAdminsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdditionalDocumentAdminsInclude<ExtArgs> | null
    /**
     * Filter, which AdditionalDocumentAdmins to fetch.
     */
    where?: AdditionalDocumentAdminsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdditionalDocumentAdmins to fetch.
     */
    orderBy?: AdditionalDocumentAdminsOrderByWithRelationInput | AdditionalDocumentAdminsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdditionalDocumentAdmins.
     */
    cursor?: AdditionalDocumentAdminsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdditionalDocumentAdmins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdditionalDocumentAdmins.
     */
    skip?: number
    distinct?: AdditionalDocumentAdminsScalarFieldEnum | AdditionalDocumentAdminsScalarFieldEnum[]
  }

  /**
   * AdditionalDocumentAdmins create
   */
  export type AdditionalDocumentAdminsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdditionalDocumentAdmins
     */
    select?: AdditionalDocumentAdminsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdditionalDocumentAdminsInclude<ExtArgs> | null
    /**
     * The data needed to create a AdditionalDocumentAdmins.
     */
    data: XOR<AdditionalDocumentAdminsCreateInput, AdditionalDocumentAdminsUncheckedCreateInput>
  }

  /**
   * AdditionalDocumentAdmins createMany
   */
  export type AdditionalDocumentAdminsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdditionalDocumentAdmins.
     */
    data: AdditionalDocumentAdminsCreateManyInput | AdditionalDocumentAdminsCreateManyInput[]
  }

  /**
   * AdditionalDocumentAdmins update
   */
  export type AdditionalDocumentAdminsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdditionalDocumentAdmins
     */
    select?: AdditionalDocumentAdminsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdditionalDocumentAdminsInclude<ExtArgs> | null
    /**
     * The data needed to update a AdditionalDocumentAdmins.
     */
    data: XOR<AdditionalDocumentAdminsUpdateInput, AdditionalDocumentAdminsUncheckedUpdateInput>
    /**
     * Choose, which AdditionalDocumentAdmins to update.
     */
    where: AdditionalDocumentAdminsWhereUniqueInput
  }

  /**
   * AdditionalDocumentAdmins updateMany
   */
  export type AdditionalDocumentAdminsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdditionalDocumentAdmins.
     */
    data: XOR<AdditionalDocumentAdminsUpdateManyMutationInput, AdditionalDocumentAdminsUncheckedUpdateManyInput>
    /**
     * Filter which AdditionalDocumentAdmins to update
     */
    where?: AdditionalDocumentAdminsWhereInput
  }

  /**
   * AdditionalDocumentAdmins upsert
   */
  export type AdditionalDocumentAdminsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdditionalDocumentAdmins
     */
    select?: AdditionalDocumentAdminsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdditionalDocumentAdminsInclude<ExtArgs> | null
    /**
     * The filter to search for the AdditionalDocumentAdmins to update in case it exists.
     */
    where: AdditionalDocumentAdminsWhereUniqueInput
    /**
     * In case the AdditionalDocumentAdmins found by the `where` argument doesn't exist, create a new AdditionalDocumentAdmins with this data.
     */
    create: XOR<AdditionalDocumentAdminsCreateInput, AdditionalDocumentAdminsUncheckedCreateInput>
    /**
     * In case the AdditionalDocumentAdmins was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdditionalDocumentAdminsUpdateInput, AdditionalDocumentAdminsUncheckedUpdateInput>
  }

  /**
   * AdditionalDocumentAdmins delete
   */
  export type AdditionalDocumentAdminsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdditionalDocumentAdmins
     */
    select?: AdditionalDocumentAdminsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdditionalDocumentAdminsInclude<ExtArgs> | null
    /**
     * Filter which AdditionalDocumentAdmins to delete.
     */
    where: AdditionalDocumentAdminsWhereUniqueInput
  }

  /**
   * AdditionalDocumentAdmins deleteMany
   */
  export type AdditionalDocumentAdminsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdditionalDocumentAdmins to delete
     */
    where?: AdditionalDocumentAdminsWhereInput
  }

  /**
   * AdditionalDocumentAdmins findRaw
   */
  export type AdditionalDocumentAdminsFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * AdditionalDocumentAdmins aggregateRaw
   */
  export type AdditionalDocumentAdminsAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * AdditionalDocumentAdmins.document
   */
  export type AdditionalDocumentAdmins$documentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Documents
     */
    select?: DocumentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentsInclude<ExtArgs> | null
    where?: DocumentsWhereInput
  }

  /**
   * AdditionalDocumentAdmins without action
   */
  export type AdditionalDocumentAdminsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdditionalDocumentAdmins
     */
    select?: AdditionalDocumentAdminsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdditionalDocumentAdminsInclude<ExtArgs> | null
  }


  /**
   * Model Logs
   */

  export type AggregateLogs = {
    _count: LogsCountAggregateOutputType | null
    _min: LogsMinAggregateOutputType | null
    _max: LogsMaxAggregateOutputType | null
  }

  export type LogsMinAggregateOutputType = {
    id: string | null
    userId: string | null
    action: string | null
    resource: string | null
    type: string | null
  }

  export type LogsMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    action: string | null
    resource: string | null
    type: string | null
  }

  export type LogsCountAggregateOutputType = {
    id: number
    userId: number
    action: number
    resource: number
    type: number
    additionalDetails: number
    _all: number
  }


  export type LogsMinAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    resource?: true
    type?: true
  }

  export type LogsMaxAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    resource?: true
    type?: true
  }

  export type LogsCountAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    resource?: true
    type?: true
    additionalDetails?: true
    _all?: true
  }

  export type LogsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Logs to aggregate.
     */
    where?: LogsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logs to fetch.
     */
    orderBy?: LogsOrderByWithRelationInput | LogsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LogsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Logs
    **/
    _count?: true | LogsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LogsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LogsMaxAggregateInputType
  }

  export type GetLogsAggregateType<T extends LogsAggregateArgs> = {
        [P in keyof T & keyof AggregateLogs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLogs[P]>
      : GetScalarType<T[P], AggregateLogs[P]>
  }




  export type LogsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LogsWhereInput
    orderBy?: LogsOrderByWithAggregationInput | LogsOrderByWithAggregationInput[]
    by: LogsScalarFieldEnum[] | LogsScalarFieldEnum
    having?: LogsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LogsCountAggregateInputType | true
    _min?: LogsMinAggregateInputType
    _max?: LogsMaxAggregateInputType
  }

  export type LogsGroupByOutputType = {
    id: string
    userId: string
    action: string
    resource: string
    type: string
    additionalDetails: JsonValue
    _count: LogsCountAggregateOutputType | null
    _min: LogsMinAggregateOutputType | null
    _max: LogsMaxAggregateOutputType | null
  }

  type GetLogsGroupByPayload<T extends LogsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LogsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LogsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LogsGroupByOutputType[P]>
            : GetScalarType<T[P], LogsGroupByOutputType[P]>
        }
      >
    >


  export type LogsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    resource?: boolean
    type?: boolean
    additionalDetails?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["logs"]>


  export type LogsSelectScalar = {
    id?: boolean
    userId?: boolean
    action?: boolean
    resource?: boolean
    type?: boolean
    additionalDetails?: boolean
  }

  export type LogsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $LogsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Logs"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      action: string
      resource: string
      type: string
      additionalDetails: Prisma.JsonValue
    }, ExtArgs["result"]["logs"]>
    composites: {}
  }

  type LogsGetPayload<S extends boolean | null | undefined | LogsDefaultArgs> = $Result.GetResult<Prisma.$LogsPayload, S>

  type LogsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LogsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LogsCountAggregateInputType | true
    }

  export interface LogsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Logs'], meta: { name: 'Logs' } }
    /**
     * Find zero or one Logs that matches the filter.
     * @param {LogsFindUniqueArgs} args - Arguments to find a Logs
     * @example
     * // Get one Logs
     * const logs = await prisma.logs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LogsFindUniqueArgs>(args: SelectSubset<T, LogsFindUniqueArgs<ExtArgs>>): Prisma__LogsClient<$Result.GetResult<Prisma.$LogsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Logs that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LogsFindUniqueOrThrowArgs} args - Arguments to find a Logs
     * @example
     * // Get one Logs
     * const logs = await prisma.logs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LogsFindUniqueOrThrowArgs>(args: SelectSubset<T, LogsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LogsClient<$Result.GetResult<Prisma.$LogsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogsFindFirstArgs} args - Arguments to find a Logs
     * @example
     * // Get one Logs
     * const logs = await prisma.logs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LogsFindFirstArgs>(args?: SelectSubset<T, LogsFindFirstArgs<ExtArgs>>): Prisma__LogsClient<$Result.GetResult<Prisma.$LogsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Logs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogsFindFirstOrThrowArgs} args - Arguments to find a Logs
     * @example
     * // Get one Logs
     * const logs = await prisma.logs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LogsFindFirstOrThrowArgs>(args?: SelectSubset<T, LogsFindFirstOrThrowArgs<ExtArgs>>): Prisma__LogsClient<$Result.GetResult<Prisma.$LogsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Logs
     * const logs = await prisma.logs.findMany()
     * 
     * // Get first 10 Logs
     * const logs = await prisma.logs.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const logsWithIdOnly = await prisma.logs.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LogsFindManyArgs>(args?: SelectSubset<T, LogsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Logs.
     * @param {LogsCreateArgs} args - Arguments to create a Logs.
     * @example
     * // Create one Logs
     * const Logs = await prisma.logs.create({
     *   data: {
     *     // ... data to create a Logs
     *   }
     * })
     * 
     */
    create<T extends LogsCreateArgs>(args: SelectSubset<T, LogsCreateArgs<ExtArgs>>): Prisma__LogsClient<$Result.GetResult<Prisma.$LogsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Logs.
     * @param {LogsCreateManyArgs} args - Arguments to create many Logs.
     * @example
     * // Create many Logs
     * const logs = await prisma.logs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LogsCreateManyArgs>(args?: SelectSubset<T, LogsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Logs.
     * @param {LogsDeleteArgs} args - Arguments to delete one Logs.
     * @example
     * // Delete one Logs
     * const Logs = await prisma.logs.delete({
     *   where: {
     *     // ... filter to delete one Logs
     *   }
     * })
     * 
     */
    delete<T extends LogsDeleteArgs>(args: SelectSubset<T, LogsDeleteArgs<ExtArgs>>): Prisma__LogsClient<$Result.GetResult<Prisma.$LogsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Logs.
     * @param {LogsUpdateArgs} args - Arguments to update one Logs.
     * @example
     * // Update one Logs
     * const logs = await prisma.logs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LogsUpdateArgs>(args: SelectSubset<T, LogsUpdateArgs<ExtArgs>>): Prisma__LogsClient<$Result.GetResult<Prisma.$LogsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Logs.
     * @param {LogsDeleteManyArgs} args - Arguments to filter Logs to delete.
     * @example
     * // Delete a few Logs
     * const { count } = await prisma.logs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LogsDeleteManyArgs>(args?: SelectSubset<T, LogsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Logs
     * const logs = await prisma.logs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LogsUpdateManyArgs>(args: SelectSubset<T, LogsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Logs.
     * @param {LogsUpsertArgs} args - Arguments to update or create a Logs.
     * @example
     * // Update or create a Logs
     * const logs = await prisma.logs.upsert({
     *   create: {
     *     // ... data to create a Logs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Logs we want to update
     *   }
     * })
     */
    upsert<T extends LogsUpsertArgs>(args: SelectSubset<T, LogsUpsertArgs<ExtArgs>>): Prisma__LogsClient<$Result.GetResult<Prisma.$LogsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Logs that matches the filter.
     * @param {LogsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const logs = await prisma.logs.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: LogsFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Logs.
     * @param {LogsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const logs = await prisma.logs.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: LogsAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogsCountArgs} args - Arguments to filter Logs to count.
     * @example
     * // Count the number of Logs
     * const count = await prisma.logs.count({
     *   where: {
     *     // ... the filter for the Logs we want to count
     *   }
     * })
    **/
    count<T extends LogsCountArgs>(
      args?: Subset<T, LogsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LogsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LogsAggregateArgs>(args: Subset<T, LogsAggregateArgs>): Prisma.PrismaPromise<GetLogsAggregateType<T>>

    /**
     * Group by Logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LogsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LogsGroupByArgs['orderBy'] }
        : { orderBy?: LogsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LogsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLogsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Logs model
   */
  readonly fields: LogsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Logs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LogsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Logs model
   */ 
  interface LogsFieldRefs {
    readonly id: FieldRef<"Logs", 'String'>
    readonly userId: FieldRef<"Logs", 'String'>
    readonly action: FieldRef<"Logs", 'String'>
    readonly resource: FieldRef<"Logs", 'String'>
    readonly type: FieldRef<"Logs", 'String'>
    readonly additionalDetails: FieldRef<"Logs", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * Logs findUnique
   */
  export type LogsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Logs
     */
    select?: LogsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogsInclude<ExtArgs> | null
    /**
     * Filter, which Logs to fetch.
     */
    where: LogsWhereUniqueInput
  }

  /**
   * Logs findUniqueOrThrow
   */
  export type LogsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Logs
     */
    select?: LogsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogsInclude<ExtArgs> | null
    /**
     * Filter, which Logs to fetch.
     */
    where: LogsWhereUniqueInput
  }

  /**
   * Logs findFirst
   */
  export type LogsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Logs
     */
    select?: LogsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogsInclude<ExtArgs> | null
    /**
     * Filter, which Logs to fetch.
     */
    where?: LogsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logs to fetch.
     */
    orderBy?: LogsOrderByWithRelationInput | LogsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Logs.
     */
    cursor?: LogsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Logs.
     */
    distinct?: LogsScalarFieldEnum | LogsScalarFieldEnum[]
  }

  /**
   * Logs findFirstOrThrow
   */
  export type LogsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Logs
     */
    select?: LogsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogsInclude<ExtArgs> | null
    /**
     * Filter, which Logs to fetch.
     */
    where?: LogsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logs to fetch.
     */
    orderBy?: LogsOrderByWithRelationInput | LogsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Logs.
     */
    cursor?: LogsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Logs.
     */
    distinct?: LogsScalarFieldEnum | LogsScalarFieldEnum[]
  }

  /**
   * Logs findMany
   */
  export type LogsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Logs
     */
    select?: LogsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogsInclude<ExtArgs> | null
    /**
     * Filter, which Logs to fetch.
     */
    where?: LogsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logs to fetch.
     */
    orderBy?: LogsOrderByWithRelationInput | LogsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Logs.
     */
    cursor?: LogsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logs.
     */
    skip?: number
    distinct?: LogsScalarFieldEnum | LogsScalarFieldEnum[]
  }

  /**
   * Logs create
   */
  export type LogsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Logs
     */
    select?: LogsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogsInclude<ExtArgs> | null
    /**
     * The data needed to create a Logs.
     */
    data: XOR<LogsCreateInput, LogsUncheckedCreateInput>
  }

  /**
   * Logs createMany
   */
  export type LogsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Logs.
     */
    data: LogsCreateManyInput | LogsCreateManyInput[]
  }

  /**
   * Logs update
   */
  export type LogsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Logs
     */
    select?: LogsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogsInclude<ExtArgs> | null
    /**
     * The data needed to update a Logs.
     */
    data: XOR<LogsUpdateInput, LogsUncheckedUpdateInput>
    /**
     * Choose, which Logs to update.
     */
    where: LogsWhereUniqueInput
  }

  /**
   * Logs updateMany
   */
  export type LogsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Logs.
     */
    data: XOR<LogsUpdateManyMutationInput, LogsUncheckedUpdateManyInput>
    /**
     * Filter which Logs to update
     */
    where?: LogsWhereInput
  }

  /**
   * Logs upsert
   */
  export type LogsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Logs
     */
    select?: LogsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogsInclude<ExtArgs> | null
    /**
     * The filter to search for the Logs to update in case it exists.
     */
    where: LogsWhereUniqueInput
    /**
     * In case the Logs found by the `where` argument doesn't exist, create a new Logs with this data.
     */
    create: XOR<LogsCreateInput, LogsUncheckedCreateInput>
    /**
     * In case the Logs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LogsUpdateInput, LogsUncheckedUpdateInput>
  }

  /**
   * Logs delete
   */
  export type LogsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Logs
     */
    select?: LogsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogsInclude<ExtArgs> | null
    /**
     * Filter which Logs to delete.
     */
    where: LogsWhereUniqueInput
  }

  /**
   * Logs deleteMany
   */
  export type LogsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Logs to delete
     */
    where?: LogsWhereInput
  }

  /**
   * Logs findRaw
   */
  export type LogsFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Logs aggregateRaw
   */
  export type LogsAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Logs without action
   */
  export type LogsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Logs
     */
    select?: LogsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogsInclude<ExtArgs> | null
  }


  /**
   * Model userPersonalisation
   */

  export type AggregateUserPersonalisation = {
    _count: UserPersonalisationCountAggregateOutputType | null
    _min: UserPersonalisationMinAggregateOutputType | null
    _max: UserPersonalisationMaxAggregateOutputType | null
  }

  export type UserPersonalisationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    organizationId: string | null
    targetObject: string | null
  }

  export type UserPersonalisationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    organizationId: string | null
    targetObject: string | null
  }

  export type UserPersonalisationCountAggregateOutputType = {
    id: number
    userId: number
    organizationId: number
    targetObject: number
    targetObjectId: number
    _all: number
  }


  export type UserPersonalisationMinAggregateInputType = {
    id?: true
    userId?: true
    organizationId?: true
    targetObject?: true
  }

  export type UserPersonalisationMaxAggregateInputType = {
    id?: true
    userId?: true
    organizationId?: true
    targetObject?: true
  }

  export type UserPersonalisationCountAggregateInputType = {
    id?: true
    userId?: true
    organizationId?: true
    targetObject?: true
    targetObjectId?: true
    _all?: true
  }

  export type UserPersonalisationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which userPersonalisation to aggregate.
     */
    where?: userPersonalisationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userPersonalisations to fetch.
     */
    orderBy?: userPersonalisationOrderByWithRelationInput | userPersonalisationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: userPersonalisationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userPersonalisations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userPersonalisations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned userPersonalisations
    **/
    _count?: true | UserPersonalisationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserPersonalisationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserPersonalisationMaxAggregateInputType
  }

  export type GetUserPersonalisationAggregateType<T extends UserPersonalisationAggregateArgs> = {
        [P in keyof T & keyof AggregateUserPersonalisation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserPersonalisation[P]>
      : GetScalarType<T[P], AggregateUserPersonalisation[P]>
  }




  export type userPersonalisationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userPersonalisationWhereInput
    orderBy?: userPersonalisationOrderByWithAggregationInput | userPersonalisationOrderByWithAggregationInput[]
    by: UserPersonalisationScalarFieldEnum[] | UserPersonalisationScalarFieldEnum
    having?: userPersonalisationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserPersonalisationCountAggregateInputType | true
    _min?: UserPersonalisationMinAggregateInputType
    _max?: UserPersonalisationMaxAggregateInputType
  }

  export type UserPersonalisationGroupByOutputType = {
    id: string
    userId: string
    organizationId: string | null
    targetObject: string
    targetObjectId: string[]
    _count: UserPersonalisationCountAggregateOutputType | null
    _min: UserPersonalisationMinAggregateOutputType | null
    _max: UserPersonalisationMaxAggregateOutputType | null
  }

  type GetUserPersonalisationGroupByPayload<T extends userPersonalisationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserPersonalisationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserPersonalisationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserPersonalisationGroupByOutputType[P]>
            : GetScalarType<T[P], UserPersonalisationGroupByOutputType[P]>
        }
      >
    >


  export type userPersonalisationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    organizationId?: boolean
    targetObject?: boolean
    targetObjectId?: boolean
    Organization?: boolean | userPersonalisation$OrganizationArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userPersonalisation"]>


  export type userPersonalisationSelectScalar = {
    id?: boolean
    userId?: boolean
    organizationId?: boolean
    targetObject?: boolean
    targetObjectId?: boolean
  }

  export type userPersonalisationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Organization?: boolean | userPersonalisation$OrganizationArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $userPersonalisationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "userPersonalisation"
    objects: {
      Organization: Prisma.$OrganizationPayload<ExtArgs> | null
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      organizationId: string | null
      targetObject: string
      targetObjectId: string[]
    }, ExtArgs["result"]["userPersonalisation"]>
    composites: {}
  }

  type userPersonalisationGetPayload<S extends boolean | null | undefined | userPersonalisationDefaultArgs> = $Result.GetResult<Prisma.$userPersonalisationPayload, S>

  type userPersonalisationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<userPersonalisationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserPersonalisationCountAggregateInputType | true
    }

  export interface userPersonalisationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['userPersonalisation'], meta: { name: 'userPersonalisation' } }
    /**
     * Find zero or one UserPersonalisation that matches the filter.
     * @param {userPersonalisationFindUniqueArgs} args - Arguments to find a UserPersonalisation
     * @example
     * // Get one UserPersonalisation
     * const userPersonalisation = await prisma.userPersonalisation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends userPersonalisationFindUniqueArgs>(args: SelectSubset<T, userPersonalisationFindUniqueArgs<ExtArgs>>): Prisma__userPersonalisationClient<$Result.GetResult<Prisma.$userPersonalisationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserPersonalisation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {userPersonalisationFindUniqueOrThrowArgs} args - Arguments to find a UserPersonalisation
     * @example
     * // Get one UserPersonalisation
     * const userPersonalisation = await prisma.userPersonalisation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends userPersonalisationFindUniqueOrThrowArgs>(args: SelectSubset<T, userPersonalisationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__userPersonalisationClient<$Result.GetResult<Prisma.$userPersonalisationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserPersonalisation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userPersonalisationFindFirstArgs} args - Arguments to find a UserPersonalisation
     * @example
     * // Get one UserPersonalisation
     * const userPersonalisation = await prisma.userPersonalisation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends userPersonalisationFindFirstArgs>(args?: SelectSubset<T, userPersonalisationFindFirstArgs<ExtArgs>>): Prisma__userPersonalisationClient<$Result.GetResult<Prisma.$userPersonalisationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserPersonalisation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userPersonalisationFindFirstOrThrowArgs} args - Arguments to find a UserPersonalisation
     * @example
     * // Get one UserPersonalisation
     * const userPersonalisation = await prisma.userPersonalisation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends userPersonalisationFindFirstOrThrowArgs>(args?: SelectSubset<T, userPersonalisationFindFirstOrThrowArgs<ExtArgs>>): Prisma__userPersonalisationClient<$Result.GetResult<Prisma.$userPersonalisationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserPersonalisations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userPersonalisationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserPersonalisations
     * const userPersonalisations = await prisma.userPersonalisation.findMany()
     * 
     * // Get first 10 UserPersonalisations
     * const userPersonalisations = await prisma.userPersonalisation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userPersonalisationWithIdOnly = await prisma.userPersonalisation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends userPersonalisationFindManyArgs>(args?: SelectSubset<T, userPersonalisationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userPersonalisationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserPersonalisation.
     * @param {userPersonalisationCreateArgs} args - Arguments to create a UserPersonalisation.
     * @example
     * // Create one UserPersonalisation
     * const UserPersonalisation = await prisma.userPersonalisation.create({
     *   data: {
     *     // ... data to create a UserPersonalisation
     *   }
     * })
     * 
     */
    create<T extends userPersonalisationCreateArgs>(args: SelectSubset<T, userPersonalisationCreateArgs<ExtArgs>>): Prisma__userPersonalisationClient<$Result.GetResult<Prisma.$userPersonalisationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserPersonalisations.
     * @param {userPersonalisationCreateManyArgs} args - Arguments to create many UserPersonalisations.
     * @example
     * // Create many UserPersonalisations
     * const userPersonalisation = await prisma.userPersonalisation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends userPersonalisationCreateManyArgs>(args?: SelectSubset<T, userPersonalisationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserPersonalisation.
     * @param {userPersonalisationDeleteArgs} args - Arguments to delete one UserPersonalisation.
     * @example
     * // Delete one UserPersonalisation
     * const UserPersonalisation = await prisma.userPersonalisation.delete({
     *   where: {
     *     // ... filter to delete one UserPersonalisation
     *   }
     * })
     * 
     */
    delete<T extends userPersonalisationDeleteArgs>(args: SelectSubset<T, userPersonalisationDeleteArgs<ExtArgs>>): Prisma__userPersonalisationClient<$Result.GetResult<Prisma.$userPersonalisationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserPersonalisation.
     * @param {userPersonalisationUpdateArgs} args - Arguments to update one UserPersonalisation.
     * @example
     * // Update one UserPersonalisation
     * const userPersonalisation = await prisma.userPersonalisation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends userPersonalisationUpdateArgs>(args: SelectSubset<T, userPersonalisationUpdateArgs<ExtArgs>>): Prisma__userPersonalisationClient<$Result.GetResult<Prisma.$userPersonalisationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserPersonalisations.
     * @param {userPersonalisationDeleteManyArgs} args - Arguments to filter UserPersonalisations to delete.
     * @example
     * // Delete a few UserPersonalisations
     * const { count } = await prisma.userPersonalisation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends userPersonalisationDeleteManyArgs>(args?: SelectSubset<T, userPersonalisationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserPersonalisations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userPersonalisationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserPersonalisations
     * const userPersonalisation = await prisma.userPersonalisation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends userPersonalisationUpdateManyArgs>(args: SelectSubset<T, userPersonalisationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserPersonalisation.
     * @param {userPersonalisationUpsertArgs} args - Arguments to update or create a UserPersonalisation.
     * @example
     * // Update or create a UserPersonalisation
     * const userPersonalisation = await prisma.userPersonalisation.upsert({
     *   create: {
     *     // ... data to create a UserPersonalisation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserPersonalisation we want to update
     *   }
     * })
     */
    upsert<T extends userPersonalisationUpsertArgs>(args: SelectSubset<T, userPersonalisationUpsertArgs<ExtArgs>>): Prisma__userPersonalisationClient<$Result.GetResult<Prisma.$userPersonalisationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more UserPersonalisations that matches the filter.
     * @param {userPersonalisationFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const userPersonalisation = await prisma.userPersonalisation.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: userPersonalisationFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a UserPersonalisation.
     * @param {userPersonalisationAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const userPersonalisation = await prisma.userPersonalisation.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: userPersonalisationAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of UserPersonalisations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userPersonalisationCountArgs} args - Arguments to filter UserPersonalisations to count.
     * @example
     * // Count the number of UserPersonalisations
     * const count = await prisma.userPersonalisation.count({
     *   where: {
     *     // ... the filter for the UserPersonalisations we want to count
     *   }
     * })
    **/
    count<T extends userPersonalisationCountArgs>(
      args?: Subset<T, userPersonalisationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserPersonalisationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserPersonalisation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPersonalisationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserPersonalisationAggregateArgs>(args: Subset<T, UserPersonalisationAggregateArgs>): Prisma.PrismaPromise<GetUserPersonalisationAggregateType<T>>

    /**
     * Group by UserPersonalisation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userPersonalisationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends userPersonalisationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: userPersonalisationGroupByArgs['orderBy'] }
        : { orderBy?: userPersonalisationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, userPersonalisationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserPersonalisationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the userPersonalisation model
   */
  readonly fields: userPersonalisationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for userPersonalisation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__userPersonalisationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Organization<T extends userPersonalisation$OrganizationArgs<ExtArgs> = {}>(args?: Subset<T, userPersonalisation$OrganizationArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the userPersonalisation model
   */ 
  interface userPersonalisationFieldRefs {
    readonly id: FieldRef<"userPersonalisation", 'String'>
    readonly userId: FieldRef<"userPersonalisation", 'String'>
    readonly organizationId: FieldRef<"userPersonalisation", 'String'>
    readonly targetObject: FieldRef<"userPersonalisation", 'String'>
    readonly targetObjectId: FieldRef<"userPersonalisation", 'String[]'>
  }
    

  // Custom InputTypes
  /**
   * userPersonalisation findUnique
   */
  export type userPersonalisationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userPersonalisation
     */
    select?: userPersonalisationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userPersonalisationInclude<ExtArgs> | null
    /**
     * Filter, which userPersonalisation to fetch.
     */
    where: userPersonalisationWhereUniqueInput
  }

  /**
   * userPersonalisation findUniqueOrThrow
   */
  export type userPersonalisationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userPersonalisation
     */
    select?: userPersonalisationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userPersonalisationInclude<ExtArgs> | null
    /**
     * Filter, which userPersonalisation to fetch.
     */
    where: userPersonalisationWhereUniqueInput
  }

  /**
   * userPersonalisation findFirst
   */
  export type userPersonalisationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userPersonalisation
     */
    select?: userPersonalisationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userPersonalisationInclude<ExtArgs> | null
    /**
     * Filter, which userPersonalisation to fetch.
     */
    where?: userPersonalisationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userPersonalisations to fetch.
     */
    orderBy?: userPersonalisationOrderByWithRelationInput | userPersonalisationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for userPersonalisations.
     */
    cursor?: userPersonalisationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userPersonalisations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userPersonalisations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of userPersonalisations.
     */
    distinct?: UserPersonalisationScalarFieldEnum | UserPersonalisationScalarFieldEnum[]
  }

  /**
   * userPersonalisation findFirstOrThrow
   */
  export type userPersonalisationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userPersonalisation
     */
    select?: userPersonalisationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userPersonalisationInclude<ExtArgs> | null
    /**
     * Filter, which userPersonalisation to fetch.
     */
    where?: userPersonalisationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userPersonalisations to fetch.
     */
    orderBy?: userPersonalisationOrderByWithRelationInput | userPersonalisationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for userPersonalisations.
     */
    cursor?: userPersonalisationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userPersonalisations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userPersonalisations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of userPersonalisations.
     */
    distinct?: UserPersonalisationScalarFieldEnum | UserPersonalisationScalarFieldEnum[]
  }

  /**
   * userPersonalisation findMany
   */
  export type userPersonalisationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userPersonalisation
     */
    select?: userPersonalisationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userPersonalisationInclude<ExtArgs> | null
    /**
     * Filter, which userPersonalisations to fetch.
     */
    where?: userPersonalisationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userPersonalisations to fetch.
     */
    orderBy?: userPersonalisationOrderByWithRelationInput | userPersonalisationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing userPersonalisations.
     */
    cursor?: userPersonalisationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userPersonalisations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userPersonalisations.
     */
    skip?: number
    distinct?: UserPersonalisationScalarFieldEnum | UserPersonalisationScalarFieldEnum[]
  }

  /**
   * userPersonalisation create
   */
  export type userPersonalisationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userPersonalisation
     */
    select?: userPersonalisationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userPersonalisationInclude<ExtArgs> | null
    /**
     * The data needed to create a userPersonalisation.
     */
    data: XOR<userPersonalisationCreateInput, userPersonalisationUncheckedCreateInput>
  }

  /**
   * userPersonalisation createMany
   */
  export type userPersonalisationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many userPersonalisations.
     */
    data: userPersonalisationCreateManyInput | userPersonalisationCreateManyInput[]
  }

  /**
   * userPersonalisation update
   */
  export type userPersonalisationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userPersonalisation
     */
    select?: userPersonalisationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userPersonalisationInclude<ExtArgs> | null
    /**
     * The data needed to update a userPersonalisation.
     */
    data: XOR<userPersonalisationUpdateInput, userPersonalisationUncheckedUpdateInput>
    /**
     * Choose, which userPersonalisation to update.
     */
    where: userPersonalisationWhereUniqueInput
  }

  /**
   * userPersonalisation updateMany
   */
  export type userPersonalisationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update userPersonalisations.
     */
    data: XOR<userPersonalisationUpdateManyMutationInput, userPersonalisationUncheckedUpdateManyInput>
    /**
     * Filter which userPersonalisations to update
     */
    where?: userPersonalisationWhereInput
  }

  /**
   * userPersonalisation upsert
   */
  export type userPersonalisationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userPersonalisation
     */
    select?: userPersonalisationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userPersonalisationInclude<ExtArgs> | null
    /**
     * The filter to search for the userPersonalisation to update in case it exists.
     */
    where: userPersonalisationWhereUniqueInput
    /**
     * In case the userPersonalisation found by the `where` argument doesn't exist, create a new userPersonalisation with this data.
     */
    create: XOR<userPersonalisationCreateInput, userPersonalisationUncheckedCreateInput>
    /**
     * In case the userPersonalisation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<userPersonalisationUpdateInput, userPersonalisationUncheckedUpdateInput>
  }

  /**
   * userPersonalisation delete
   */
  export type userPersonalisationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userPersonalisation
     */
    select?: userPersonalisationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userPersonalisationInclude<ExtArgs> | null
    /**
     * Filter which userPersonalisation to delete.
     */
    where: userPersonalisationWhereUniqueInput
  }

  /**
   * userPersonalisation deleteMany
   */
  export type userPersonalisationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which userPersonalisations to delete
     */
    where?: userPersonalisationWhereInput
  }

  /**
   * userPersonalisation findRaw
   */
  export type userPersonalisationFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * userPersonalisation aggregateRaw
   */
  export type userPersonalisationAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * userPersonalisation.Organization
   */
  export type userPersonalisation$OrganizationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    where?: OrganizationWhereInput
  }

  /**
   * userPersonalisation without action
   */
  export type userPersonalisationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userPersonalisation
     */
    select?: userPersonalisationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userPersonalisationInclude<ExtArgs> | null
  }


  /**
   * Model ConnectedApps
   */

  export type AggregateConnectedApps = {
    _count: ConnectedAppsCountAggregateOutputType | null
    _min: ConnectedAppsMinAggregateOutputType | null
    _max: ConnectedAppsMaxAggregateOutputType | null
  }

  export type ConnectedAppsMinAggregateOutputType = {
    id: string | null
    sourceName: string | null
    clientId: string | null
    clientSecret: string | null
    baseURL: string | null
    user: string | null
    password: string | null
    redirectURL: string | null
    grantType: string | null
    description: string | null
    deleted: boolean | null
    organizationId: string | null
    createdModifiedBy: string | null
    createdModifiedAt: Date | null
    Status: boolean | null
  }

  export type ConnectedAppsMaxAggregateOutputType = {
    id: string | null
    sourceName: string | null
    clientId: string | null
    clientSecret: string | null
    baseURL: string | null
    user: string | null
    password: string | null
    redirectURL: string | null
    grantType: string | null
    description: string | null
    deleted: boolean | null
    organizationId: string | null
    createdModifiedBy: string | null
    createdModifiedAt: Date | null
    Status: boolean | null
  }

  export type ConnectedAppsCountAggregateOutputType = {
    id: number
    sourceName: number
    clientId: number
    clientSecret: number
    baseURL: number
    user: number
    password: number
    redirectURL: number
    grantType: number
    description: number
    deleted: number
    organizationId: number
    createdModifiedBy: number
    createdModifiedAt: number
    locationId: number
    Status: number
    _all: number
  }


  export type ConnectedAppsMinAggregateInputType = {
    id?: true
    sourceName?: true
    clientId?: true
    clientSecret?: true
    baseURL?: true
    user?: true
    password?: true
    redirectURL?: true
    grantType?: true
    description?: true
    deleted?: true
    organizationId?: true
    createdModifiedBy?: true
    createdModifiedAt?: true
    Status?: true
  }

  export type ConnectedAppsMaxAggregateInputType = {
    id?: true
    sourceName?: true
    clientId?: true
    clientSecret?: true
    baseURL?: true
    user?: true
    password?: true
    redirectURL?: true
    grantType?: true
    description?: true
    deleted?: true
    organizationId?: true
    createdModifiedBy?: true
    createdModifiedAt?: true
    Status?: true
  }

  export type ConnectedAppsCountAggregateInputType = {
    id?: true
    sourceName?: true
    clientId?: true
    clientSecret?: true
    baseURL?: true
    user?: true
    password?: true
    redirectURL?: true
    grantType?: true
    description?: true
    deleted?: true
    organizationId?: true
    createdModifiedBy?: true
    createdModifiedAt?: true
    locationId?: true
    Status?: true
    _all?: true
  }

  export type ConnectedAppsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConnectedApps to aggregate.
     */
    where?: ConnectedAppsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConnectedApps to fetch.
     */
    orderBy?: ConnectedAppsOrderByWithRelationInput | ConnectedAppsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConnectedAppsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConnectedApps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConnectedApps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ConnectedApps
    **/
    _count?: true | ConnectedAppsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConnectedAppsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConnectedAppsMaxAggregateInputType
  }

  export type GetConnectedAppsAggregateType<T extends ConnectedAppsAggregateArgs> = {
        [P in keyof T & keyof AggregateConnectedApps]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConnectedApps[P]>
      : GetScalarType<T[P], AggregateConnectedApps[P]>
  }




  export type ConnectedAppsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConnectedAppsWhereInput
    orderBy?: ConnectedAppsOrderByWithAggregationInput | ConnectedAppsOrderByWithAggregationInput[]
    by: ConnectedAppsScalarFieldEnum[] | ConnectedAppsScalarFieldEnum
    having?: ConnectedAppsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConnectedAppsCountAggregateInputType | true
    _min?: ConnectedAppsMinAggregateInputType
    _max?: ConnectedAppsMaxAggregateInputType
  }

  export type ConnectedAppsGroupByOutputType = {
    id: string
    sourceName: string
    clientId: string
    clientSecret: string
    baseURL: string
    user: string | null
    password: string | null
    redirectURL: string | null
    grantType: string | null
    description: string
    deleted: boolean | null
    organizationId: string | null
    createdModifiedBy: string
    createdModifiedAt: Date
    locationId: string[]
    Status: boolean
    _count: ConnectedAppsCountAggregateOutputType | null
    _min: ConnectedAppsMinAggregateOutputType | null
    _max: ConnectedAppsMaxAggregateOutputType | null
  }

  type GetConnectedAppsGroupByPayload<T extends ConnectedAppsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConnectedAppsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConnectedAppsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConnectedAppsGroupByOutputType[P]>
            : GetScalarType<T[P], ConnectedAppsGroupByOutputType[P]>
        }
      >
    >


  export type ConnectedAppsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sourceName?: boolean
    clientId?: boolean
    clientSecret?: boolean
    baseURL?: boolean
    user?: boolean
    password?: boolean
    redirectURL?: boolean
    grantType?: boolean
    description?: boolean
    deleted?: boolean
    organizationId?: boolean
    createdModifiedBy?: boolean
    createdModifiedAt?: boolean
    locationId?: boolean
    Status?: boolean
    organization?: boolean | ConnectedApps$organizationArgs<ExtArgs>
    uom?: boolean | ConnectedApps$uomArgs<ExtArgs>
    kpi?: boolean | ConnectedApps$kpiArgs<ExtArgs>
    _count?: boolean | ConnectedAppsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["connectedApps"]>


  export type ConnectedAppsSelectScalar = {
    id?: boolean
    sourceName?: boolean
    clientId?: boolean
    clientSecret?: boolean
    baseURL?: boolean
    user?: boolean
    password?: boolean
    redirectURL?: boolean
    grantType?: boolean
    description?: boolean
    deleted?: boolean
    organizationId?: boolean
    createdModifiedBy?: boolean
    createdModifiedAt?: boolean
    locationId?: boolean
    Status?: boolean
  }

  export type ConnectedAppsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | ConnectedApps$organizationArgs<ExtArgs>
    uom?: boolean | ConnectedApps$uomArgs<ExtArgs>
    kpi?: boolean | ConnectedApps$kpiArgs<ExtArgs>
    _count?: boolean | ConnectedAppsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ConnectedAppsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ConnectedApps"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs> | null
      uom: Prisma.$unitTypePayload<ExtArgs>[]
      kpi: Prisma.$kpiPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sourceName: string
      clientId: string
      clientSecret: string
      baseURL: string
      user: string | null
      password: string | null
      redirectURL: string | null
      grantType: string | null
      description: string
      deleted: boolean | null
      organizationId: string | null
      createdModifiedBy: string
      createdModifiedAt: Date
      locationId: string[]
      Status: boolean
    }, ExtArgs["result"]["connectedApps"]>
    composites: {}
  }

  type ConnectedAppsGetPayload<S extends boolean | null | undefined | ConnectedAppsDefaultArgs> = $Result.GetResult<Prisma.$ConnectedAppsPayload, S>

  type ConnectedAppsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ConnectedAppsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ConnectedAppsCountAggregateInputType | true
    }

  export interface ConnectedAppsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ConnectedApps'], meta: { name: 'ConnectedApps' } }
    /**
     * Find zero or one ConnectedApps that matches the filter.
     * @param {ConnectedAppsFindUniqueArgs} args - Arguments to find a ConnectedApps
     * @example
     * // Get one ConnectedApps
     * const connectedApps = await prisma.connectedApps.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConnectedAppsFindUniqueArgs>(args: SelectSubset<T, ConnectedAppsFindUniqueArgs<ExtArgs>>): Prisma__ConnectedAppsClient<$Result.GetResult<Prisma.$ConnectedAppsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ConnectedApps that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ConnectedAppsFindUniqueOrThrowArgs} args - Arguments to find a ConnectedApps
     * @example
     * // Get one ConnectedApps
     * const connectedApps = await prisma.connectedApps.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConnectedAppsFindUniqueOrThrowArgs>(args: SelectSubset<T, ConnectedAppsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConnectedAppsClient<$Result.GetResult<Prisma.$ConnectedAppsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ConnectedApps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConnectedAppsFindFirstArgs} args - Arguments to find a ConnectedApps
     * @example
     * // Get one ConnectedApps
     * const connectedApps = await prisma.connectedApps.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConnectedAppsFindFirstArgs>(args?: SelectSubset<T, ConnectedAppsFindFirstArgs<ExtArgs>>): Prisma__ConnectedAppsClient<$Result.GetResult<Prisma.$ConnectedAppsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ConnectedApps that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConnectedAppsFindFirstOrThrowArgs} args - Arguments to find a ConnectedApps
     * @example
     * // Get one ConnectedApps
     * const connectedApps = await prisma.connectedApps.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConnectedAppsFindFirstOrThrowArgs>(args?: SelectSubset<T, ConnectedAppsFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConnectedAppsClient<$Result.GetResult<Prisma.$ConnectedAppsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ConnectedApps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConnectedAppsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ConnectedApps
     * const connectedApps = await prisma.connectedApps.findMany()
     * 
     * // Get first 10 ConnectedApps
     * const connectedApps = await prisma.connectedApps.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const connectedAppsWithIdOnly = await prisma.connectedApps.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConnectedAppsFindManyArgs>(args?: SelectSubset<T, ConnectedAppsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConnectedAppsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ConnectedApps.
     * @param {ConnectedAppsCreateArgs} args - Arguments to create a ConnectedApps.
     * @example
     * // Create one ConnectedApps
     * const ConnectedApps = await prisma.connectedApps.create({
     *   data: {
     *     // ... data to create a ConnectedApps
     *   }
     * })
     * 
     */
    create<T extends ConnectedAppsCreateArgs>(args: SelectSubset<T, ConnectedAppsCreateArgs<ExtArgs>>): Prisma__ConnectedAppsClient<$Result.GetResult<Prisma.$ConnectedAppsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ConnectedApps.
     * @param {ConnectedAppsCreateManyArgs} args - Arguments to create many ConnectedApps.
     * @example
     * // Create many ConnectedApps
     * const connectedApps = await prisma.connectedApps.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConnectedAppsCreateManyArgs>(args?: SelectSubset<T, ConnectedAppsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ConnectedApps.
     * @param {ConnectedAppsDeleteArgs} args - Arguments to delete one ConnectedApps.
     * @example
     * // Delete one ConnectedApps
     * const ConnectedApps = await prisma.connectedApps.delete({
     *   where: {
     *     // ... filter to delete one ConnectedApps
     *   }
     * })
     * 
     */
    delete<T extends ConnectedAppsDeleteArgs>(args: SelectSubset<T, ConnectedAppsDeleteArgs<ExtArgs>>): Prisma__ConnectedAppsClient<$Result.GetResult<Prisma.$ConnectedAppsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ConnectedApps.
     * @param {ConnectedAppsUpdateArgs} args - Arguments to update one ConnectedApps.
     * @example
     * // Update one ConnectedApps
     * const connectedApps = await prisma.connectedApps.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConnectedAppsUpdateArgs>(args: SelectSubset<T, ConnectedAppsUpdateArgs<ExtArgs>>): Prisma__ConnectedAppsClient<$Result.GetResult<Prisma.$ConnectedAppsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ConnectedApps.
     * @param {ConnectedAppsDeleteManyArgs} args - Arguments to filter ConnectedApps to delete.
     * @example
     * // Delete a few ConnectedApps
     * const { count } = await prisma.connectedApps.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConnectedAppsDeleteManyArgs>(args?: SelectSubset<T, ConnectedAppsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConnectedApps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConnectedAppsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ConnectedApps
     * const connectedApps = await prisma.connectedApps.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConnectedAppsUpdateManyArgs>(args: SelectSubset<T, ConnectedAppsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ConnectedApps.
     * @param {ConnectedAppsUpsertArgs} args - Arguments to update or create a ConnectedApps.
     * @example
     * // Update or create a ConnectedApps
     * const connectedApps = await prisma.connectedApps.upsert({
     *   create: {
     *     // ... data to create a ConnectedApps
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ConnectedApps we want to update
     *   }
     * })
     */
    upsert<T extends ConnectedAppsUpsertArgs>(args: SelectSubset<T, ConnectedAppsUpsertArgs<ExtArgs>>): Prisma__ConnectedAppsClient<$Result.GetResult<Prisma.$ConnectedAppsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more ConnectedApps that matches the filter.
     * @param {ConnectedAppsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const connectedApps = await prisma.connectedApps.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: ConnectedAppsFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a ConnectedApps.
     * @param {ConnectedAppsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const connectedApps = await prisma.connectedApps.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: ConnectedAppsAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of ConnectedApps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConnectedAppsCountArgs} args - Arguments to filter ConnectedApps to count.
     * @example
     * // Count the number of ConnectedApps
     * const count = await prisma.connectedApps.count({
     *   where: {
     *     // ... the filter for the ConnectedApps we want to count
     *   }
     * })
    **/
    count<T extends ConnectedAppsCountArgs>(
      args?: Subset<T, ConnectedAppsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConnectedAppsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ConnectedApps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConnectedAppsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConnectedAppsAggregateArgs>(args: Subset<T, ConnectedAppsAggregateArgs>): Prisma.PrismaPromise<GetConnectedAppsAggregateType<T>>

    /**
     * Group by ConnectedApps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConnectedAppsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConnectedAppsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConnectedAppsGroupByArgs['orderBy'] }
        : { orderBy?: ConnectedAppsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConnectedAppsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConnectedAppsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ConnectedApps model
   */
  readonly fields: ConnectedAppsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ConnectedApps.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConnectedAppsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organization<T extends ConnectedApps$organizationArgs<ExtArgs> = {}>(args?: Subset<T, ConnectedApps$organizationArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    uom<T extends ConnectedApps$uomArgs<ExtArgs> = {}>(args?: Subset<T, ConnectedApps$uomArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$unitTypePayload<ExtArgs>, T, "findMany"> | Null>
    kpi<T extends ConnectedApps$kpiArgs<ExtArgs> = {}>(args?: Subset<T, ConnectedApps$kpiArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$kpiPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ConnectedApps model
   */ 
  interface ConnectedAppsFieldRefs {
    readonly id: FieldRef<"ConnectedApps", 'String'>
    readonly sourceName: FieldRef<"ConnectedApps", 'String'>
    readonly clientId: FieldRef<"ConnectedApps", 'String'>
    readonly clientSecret: FieldRef<"ConnectedApps", 'String'>
    readonly baseURL: FieldRef<"ConnectedApps", 'String'>
    readonly user: FieldRef<"ConnectedApps", 'String'>
    readonly password: FieldRef<"ConnectedApps", 'String'>
    readonly redirectURL: FieldRef<"ConnectedApps", 'String'>
    readonly grantType: FieldRef<"ConnectedApps", 'String'>
    readonly description: FieldRef<"ConnectedApps", 'String'>
    readonly deleted: FieldRef<"ConnectedApps", 'Boolean'>
    readonly organizationId: FieldRef<"ConnectedApps", 'String'>
    readonly createdModifiedBy: FieldRef<"ConnectedApps", 'String'>
    readonly createdModifiedAt: FieldRef<"ConnectedApps", 'DateTime'>
    readonly locationId: FieldRef<"ConnectedApps", 'String[]'>
    readonly Status: FieldRef<"ConnectedApps", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * ConnectedApps findUnique
   */
  export type ConnectedAppsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConnectedApps
     */
    select?: ConnectedAppsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectedAppsInclude<ExtArgs> | null
    /**
     * Filter, which ConnectedApps to fetch.
     */
    where: ConnectedAppsWhereUniqueInput
  }

  /**
   * ConnectedApps findUniqueOrThrow
   */
  export type ConnectedAppsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConnectedApps
     */
    select?: ConnectedAppsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectedAppsInclude<ExtArgs> | null
    /**
     * Filter, which ConnectedApps to fetch.
     */
    where: ConnectedAppsWhereUniqueInput
  }

  /**
   * ConnectedApps findFirst
   */
  export type ConnectedAppsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConnectedApps
     */
    select?: ConnectedAppsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectedAppsInclude<ExtArgs> | null
    /**
     * Filter, which ConnectedApps to fetch.
     */
    where?: ConnectedAppsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConnectedApps to fetch.
     */
    orderBy?: ConnectedAppsOrderByWithRelationInput | ConnectedAppsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConnectedApps.
     */
    cursor?: ConnectedAppsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConnectedApps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConnectedApps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConnectedApps.
     */
    distinct?: ConnectedAppsScalarFieldEnum | ConnectedAppsScalarFieldEnum[]
  }

  /**
   * ConnectedApps findFirstOrThrow
   */
  export type ConnectedAppsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConnectedApps
     */
    select?: ConnectedAppsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectedAppsInclude<ExtArgs> | null
    /**
     * Filter, which ConnectedApps to fetch.
     */
    where?: ConnectedAppsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConnectedApps to fetch.
     */
    orderBy?: ConnectedAppsOrderByWithRelationInput | ConnectedAppsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConnectedApps.
     */
    cursor?: ConnectedAppsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConnectedApps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConnectedApps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConnectedApps.
     */
    distinct?: ConnectedAppsScalarFieldEnum | ConnectedAppsScalarFieldEnum[]
  }

  /**
   * ConnectedApps findMany
   */
  export type ConnectedAppsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConnectedApps
     */
    select?: ConnectedAppsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectedAppsInclude<ExtArgs> | null
    /**
     * Filter, which ConnectedApps to fetch.
     */
    where?: ConnectedAppsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConnectedApps to fetch.
     */
    orderBy?: ConnectedAppsOrderByWithRelationInput | ConnectedAppsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ConnectedApps.
     */
    cursor?: ConnectedAppsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConnectedApps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConnectedApps.
     */
    skip?: number
    distinct?: ConnectedAppsScalarFieldEnum | ConnectedAppsScalarFieldEnum[]
  }

  /**
   * ConnectedApps create
   */
  export type ConnectedAppsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConnectedApps
     */
    select?: ConnectedAppsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectedAppsInclude<ExtArgs> | null
    /**
     * The data needed to create a ConnectedApps.
     */
    data: XOR<ConnectedAppsCreateInput, ConnectedAppsUncheckedCreateInput>
  }

  /**
   * ConnectedApps createMany
   */
  export type ConnectedAppsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ConnectedApps.
     */
    data: ConnectedAppsCreateManyInput | ConnectedAppsCreateManyInput[]
  }

  /**
   * ConnectedApps update
   */
  export type ConnectedAppsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConnectedApps
     */
    select?: ConnectedAppsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectedAppsInclude<ExtArgs> | null
    /**
     * The data needed to update a ConnectedApps.
     */
    data: XOR<ConnectedAppsUpdateInput, ConnectedAppsUncheckedUpdateInput>
    /**
     * Choose, which ConnectedApps to update.
     */
    where: ConnectedAppsWhereUniqueInput
  }

  /**
   * ConnectedApps updateMany
   */
  export type ConnectedAppsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ConnectedApps.
     */
    data: XOR<ConnectedAppsUpdateManyMutationInput, ConnectedAppsUncheckedUpdateManyInput>
    /**
     * Filter which ConnectedApps to update
     */
    where?: ConnectedAppsWhereInput
  }

  /**
   * ConnectedApps upsert
   */
  export type ConnectedAppsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConnectedApps
     */
    select?: ConnectedAppsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectedAppsInclude<ExtArgs> | null
    /**
     * The filter to search for the ConnectedApps to update in case it exists.
     */
    where: ConnectedAppsWhereUniqueInput
    /**
     * In case the ConnectedApps found by the `where` argument doesn't exist, create a new ConnectedApps with this data.
     */
    create: XOR<ConnectedAppsCreateInput, ConnectedAppsUncheckedCreateInput>
    /**
     * In case the ConnectedApps was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConnectedAppsUpdateInput, ConnectedAppsUncheckedUpdateInput>
  }

  /**
   * ConnectedApps delete
   */
  export type ConnectedAppsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConnectedApps
     */
    select?: ConnectedAppsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectedAppsInclude<ExtArgs> | null
    /**
     * Filter which ConnectedApps to delete.
     */
    where: ConnectedAppsWhereUniqueInput
  }

  /**
   * ConnectedApps deleteMany
   */
  export type ConnectedAppsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConnectedApps to delete
     */
    where?: ConnectedAppsWhereInput
  }

  /**
   * ConnectedApps findRaw
   */
  export type ConnectedAppsFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * ConnectedApps aggregateRaw
   */
  export type ConnectedAppsAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * ConnectedApps.organization
   */
  export type ConnectedApps$organizationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    where?: OrganizationWhereInput
  }

  /**
   * ConnectedApps.uom
   */
  export type ConnectedApps$uomArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the unitType
     */
    select?: unitTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: unitTypeInclude<ExtArgs> | null
    where?: unitTypeWhereInput
    orderBy?: unitTypeOrderByWithRelationInput | unitTypeOrderByWithRelationInput[]
    cursor?: unitTypeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UnitTypeScalarFieldEnum | UnitTypeScalarFieldEnum[]
  }

  /**
   * ConnectedApps.kpi
   */
  export type ConnectedApps$kpiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kpi
     */
    select?: kpiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kpiInclude<ExtArgs> | null
    where?: kpiWhereInput
    orderBy?: kpiOrderByWithRelationInput | kpiOrderByWithRelationInput[]
    cursor?: kpiWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KpiScalarFieldEnum | KpiScalarFieldEnum[]
  }

  /**
   * ConnectedApps without action
   */
  export type ConnectedAppsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConnectedApps
     */
    select?: ConnectedAppsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectedAppsInclude<ExtArgs> | null
  }


  /**
   * Model unitType
   */

  export type AggregateUnitType = {
    _count: UnitTypeCountAggregateOutputType | null
    _min: UnitTypeMinAggregateOutputType | null
    _max: UnitTypeMaxAggregateOutputType | null
  }

  export type UnitTypeMinAggregateOutputType = {
    id: string | null
    unitType: string | null
    organizationId: string | null
    locationId: string | null
    deleted: boolean | null
    createdModifiedBy: string | null
    createdModifiedAt: Date | null
    connectedAppsId: string | null
  }

  export type UnitTypeMaxAggregateOutputType = {
    id: string | null
    unitType: string | null
    organizationId: string | null
    locationId: string | null
    deleted: boolean | null
    createdModifiedBy: string | null
    createdModifiedAt: Date | null
    connectedAppsId: string | null
  }

  export type UnitTypeCountAggregateOutputType = {
    id: number
    unitType: number
    unitOfMeasurement: number
    organizationId: number
    locationId: number
    deleted: number
    createdModifiedBy: number
    createdModifiedAt: number
    connectedAppsId: number
    _all: number
  }


  export type UnitTypeMinAggregateInputType = {
    id?: true
    unitType?: true
    organizationId?: true
    locationId?: true
    deleted?: true
    createdModifiedBy?: true
    createdModifiedAt?: true
    connectedAppsId?: true
  }

  export type UnitTypeMaxAggregateInputType = {
    id?: true
    unitType?: true
    organizationId?: true
    locationId?: true
    deleted?: true
    createdModifiedBy?: true
    createdModifiedAt?: true
    connectedAppsId?: true
  }

  export type UnitTypeCountAggregateInputType = {
    id?: true
    unitType?: true
    unitOfMeasurement?: true
    organizationId?: true
    locationId?: true
    deleted?: true
    createdModifiedBy?: true
    createdModifiedAt?: true
    connectedAppsId?: true
    _all?: true
  }

  export type UnitTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which unitType to aggregate.
     */
    where?: unitTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of unitTypes to fetch.
     */
    orderBy?: unitTypeOrderByWithRelationInput | unitTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: unitTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` unitTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` unitTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned unitTypes
    **/
    _count?: true | UnitTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UnitTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UnitTypeMaxAggregateInputType
  }

  export type GetUnitTypeAggregateType<T extends UnitTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateUnitType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUnitType[P]>
      : GetScalarType<T[P], AggregateUnitType[P]>
  }




  export type unitTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: unitTypeWhereInput
    orderBy?: unitTypeOrderByWithAggregationInput | unitTypeOrderByWithAggregationInput[]
    by: UnitTypeScalarFieldEnum[] | UnitTypeScalarFieldEnum
    having?: unitTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UnitTypeCountAggregateInputType | true
    _min?: UnitTypeMinAggregateInputType
    _max?: UnitTypeMaxAggregateInputType
  }

  export type UnitTypeGroupByOutputType = {
    id: string
    unitType: string
    unitOfMeasurement: string[]
    organizationId: string | null
    locationId: string | null
    deleted: boolean | null
    createdModifiedBy: string
    createdModifiedAt: Date
    connectedAppsId: string | null
    _count: UnitTypeCountAggregateOutputType | null
    _min: UnitTypeMinAggregateOutputType | null
    _max: UnitTypeMaxAggregateOutputType | null
  }

  type GetUnitTypeGroupByPayload<T extends unitTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UnitTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UnitTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UnitTypeGroupByOutputType[P]>
            : GetScalarType<T[P], UnitTypeGroupByOutputType[P]>
        }
      >
    >


  export type unitTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    unitType?: boolean
    unitOfMeasurement?: boolean
    organizationId?: boolean
    locationId?: boolean
    deleted?: boolean
    createdModifiedBy?: boolean
    createdModifiedAt?: boolean
    connectedAppsId?: boolean
    kpi?: boolean | unitType$kpiArgs<ExtArgs>
    organization?: boolean | unitType$organizationArgs<ExtArgs>
    location?: boolean | unitType$locationArgs<ExtArgs>
    ConnectedApps?: boolean | unitType$ConnectedAppsArgs<ExtArgs>
    _count?: boolean | UnitTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["unitType"]>


  export type unitTypeSelectScalar = {
    id?: boolean
    unitType?: boolean
    unitOfMeasurement?: boolean
    organizationId?: boolean
    locationId?: boolean
    deleted?: boolean
    createdModifiedBy?: boolean
    createdModifiedAt?: boolean
    connectedAppsId?: boolean
  }

  export type unitTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    kpi?: boolean | unitType$kpiArgs<ExtArgs>
    organization?: boolean | unitType$organizationArgs<ExtArgs>
    location?: boolean | unitType$locationArgs<ExtArgs>
    ConnectedApps?: boolean | unitType$ConnectedAppsArgs<ExtArgs>
    _count?: boolean | UnitTypeCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $unitTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "unitType"
    objects: {
      kpi: Prisma.$kpiPayload<ExtArgs>[]
      organization: Prisma.$OrganizationPayload<ExtArgs> | null
      location: Prisma.$LocationPayload<ExtArgs> | null
      ConnectedApps: Prisma.$ConnectedAppsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      unitType: string
      unitOfMeasurement: string[]
      organizationId: string | null
      locationId: string | null
      deleted: boolean | null
      createdModifiedBy: string
      createdModifiedAt: Date
      connectedAppsId: string | null
    }, ExtArgs["result"]["unitType"]>
    composites: {}
  }

  type unitTypeGetPayload<S extends boolean | null | undefined | unitTypeDefaultArgs> = $Result.GetResult<Prisma.$unitTypePayload, S>

  type unitTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<unitTypeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UnitTypeCountAggregateInputType | true
    }

  export interface unitTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['unitType'], meta: { name: 'unitType' } }
    /**
     * Find zero or one UnitType that matches the filter.
     * @param {unitTypeFindUniqueArgs} args - Arguments to find a UnitType
     * @example
     * // Get one UnitType
     * const unitType = await prisma.unitType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends unitTypeFindUniqueArgs>(args: SelectSubset<T, unitTypeFindUniqueArgs<ExtArgs>>): Prisma__unitTypeClient<$Result.GetResult<Prisma.$unitTypePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UnitType that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {unitTypeFindUniqueOrThrowArgs} args - Arguments to find a UnitType
     * @example
     * // Get one UnitType
     * const unitType = await prisma.unitType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends unitTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, unitTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__unitTypeClient<$Result.GetResult<Prisma.$unitTypePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UnitType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {unitTypeFindFirstArgs} args - Arguments to find a UnitType
     * @example
     * // Get one UnitType
     * const unitType = await prisma.unitType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends unitTypeFindFirstArgs>(args?: SelectSubset<T, unitTypeFindFirstArgs<ExtArgs>>): Prisma__unitTypeClient<$Result.GetResult<Prisma.$unitTypePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UnitType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {unitTypeFindFirstOrThrowArgs} args - Arguments to find a UnitType
     * @example
     * // Get one UnitType
     * const unitType = await prisma.unitType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends unitTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, unitTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__unitTypeClient<$Result.GetResult<Prisma.$unitTypePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UnitTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {unitTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UnitTypes
     * const unitTypes = await prisma.unitType.findMany()
     * 
     * // Get first 10 UnitTypes
     * const unitTypes = await prisma.unitType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const unitTypeWithIdOnly = await prisma.unitType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends unitTypeFindManyArgs>(args?: SelectSubset<T, unitTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$unitTypePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UnitType.
     * @param {unitTypeCreateArgs} args - Arguments to create a UnitType.
     * @example
     * // Create one UnitType
     * const UnitType = await prisma.unitType.create({
     *   data: {
     *     // ... data to create a UnitType
     *   }
     * })
     * 
     */
    create<T extends unitTypeCreateArgs>(args: SelectSubset<T, unitTypeCreateArgs<ExtArgs>>): Prisma__unitTypeClient<$Result.GetResult<Prisma.$unitTypePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UnitTypes.
     * @param {unitTypeCreateManyArgs} args - Arguments to create many UnitTypes.
     * @example
     * // Create many UnitTypes
     * const unitType = await prisma.unitType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends unitTypeCreateManyArgs>(args?: SelectSubset<T, unitTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UnitType.
     * @param {unitTypeDeleteArgs} args - Arguments to delete one UnitType.
     * @example
     * // Delete one UnitType
     * const UnitType = await prisma.unitType.delete({
     *   where: {
     *     // ... filter to delete one UnitType
     *   }
     * })
     * 
     */
    delete<T extends unitTypeDeleteArgs>(args: SelectSubset<T, unitTypeDeleteArgs<ExtArgs>>): Prisma__unitTypeClient<$Result.GetResult<Prisma.$unitTypePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UnitType.
     * @param {unitTypeUpdateArgs} args - Arguments to update one UnitType.
     * @example
     * // Update one UnitType
     * const unitType = await prisma.unitType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends unitTypeUpdateArgs>(args: SelectSubset<T, unitTypeUpdateArgs<ExtArgs>>): Prisma__unitTypeClient<$Result.GetResult<Prisma.$unitTypePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UnitTypes.
     * @param {unitTypeDeleteManyArgs} args - Arguments to filter UnitTypes to delete.
     * @example
     * // Delete a few UnitTypes
     * const { count } = await prisma.unitType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends unitTypeDeleteManyArgs>(args?: SelectSubset<T, unitTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UnitTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {unitTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UnitTypes
     * const unitType = await prisma.unitType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends unitTypeUpdateManyArgs>(args: SelectSubset<T, unitTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UnitType.
     * @param {unitTypeUpsertArgs} args - Arguments to update or create a UnitType.
     * @example
     * // Update or create a UnitType
     * const unitType = await prisma.unitType.upsert({
     *   create: {
     *     // ... data to create a UnitType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UnitType we want to update
     *   }
     * })
     */
    upsert<T extends unitTypeUpsertArgs>(args: SelectSubset<T, unitTypeUpsertArgs<ExtArgs>>): Prisma__unitTypeClient<$Result.GetResult<Prisma.$unitTypePayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more UnitTypes that matches the filter.
     * @param {unitTypeFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const unitType = await prisma.unitType.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: unitTypeFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a UnitType.
     * @param {unitTypeAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const unitType = await prisma.unitType.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: unitTypeAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of UnitTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {unitTypeCountArgs} args - Arguments to filter UnitTypes to count.
     * @example
     * // Count the number of UnitTypes
     * const count = await prisma.unitType.count({
     *   where: {
     *     // ... the filter for the UnitTypes we want to count
     *   }
     * })
    **/
    count<T extends unitTypeCountArgs>(
      args?: Subset<T, unitTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UnitTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UnitType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UnitTypeAggregateArgs>(args: Subset<T, UnitTypeAggregateArgs>): Prisma.PrismaPromise<GetUnitTypeAggregateType<T>>

    /**
     * Group by UnitType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {unitTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends unitTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: unitTypeGroupByArgs['orderBy'] }
        : { orderBy?: unitTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, unitTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUnitTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the unitType model
   */
  readonly fields: unitTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for unitType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__unitTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    kpi<T extends unitType$kpiArgs<ExtArgs> = {}>(args?: Subset<T, unitType$kpiArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$kpiPayload<ExtArgs>, T, "findMany"> | Null>
    organization<T extends unitType$organizationArgs<ExtArgs> = {}>(args?: Subset<T, unitType$organizationArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    location<T extends unitType$locationArgs<ExtArgs> = {}>(args?: Subset<T, unitType$locationArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    ConnectedApps<T extends unitType$ConnectedAppsArgs<ExtArgs> = {}>(args?: Subset<T, unitType$ConnectedAppsArgs<ExtArgs>>): Prisma__ConnectedAppsClient<$Result.GetResult<Prisma.$ConnectedAppsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the unitType model
   */ 
  interface unitTypeFieldRefs {
    readonly id: FieldRef<"unitType", 'String'>
    readonly unitType: FieldRef<"unitType", 'String'>
    readonly unitOfMeasurement: FieldRef<"unitType", 'String[]'>
    readonly organizationId: FieldRef<"unitType", 'String'>
    readonly locationId: FieldRef<"unitType", 'String'>
    readonly deleted: FieldRef<"unitType", 'Boolean'>
    readonly createdModifiedBy: FieldRef<"unitType", 'String'>
    readonly createdModifiedAt: FieldRef<"unitType", 'DateTime'>
    readonly connectedAppsId: FieldRef<"unitType", 'String'>
  }
    

  // Custom InputTypes
  /**
   * unitType findUnique
   */
  export type unitTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the unitType
     */
    select?: unitTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: unitTypeInclude<ExtArgs> | null
    /**
     * Filter, which unitType to fetch.
     */
    where: unitTypeWhereUniqueInput
  }

  /**
   * unitType findUniqueOrThrow
   */
  export type unitTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the unitType
     */
    select?: unitTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: unitTypeInclude<ExtArgs> | null
    /**
     * Filter, which unitType to fetch.
     */
    where: unitTypeWhereUniqueInput
  }

  /**
   * unitType findFirst
   */
  export type unitTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the unitType
     */
    select?: unitTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: unitTypeInclude<ExtArgs> | null
    /**
     * Filter, which unitType to fetch.
     */
    where?: unitTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of unitTypes to fetch.
     */
    orderBy?: unitTypeOrderByWithRelationInput | unitTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for unitTypes.
     */
    cursor?: unitTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` unitTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` unitTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of unitTypes.
     */
    distinct?: UnitTypeScalarFieldEnum | UnitTypeScalarFieldEnum[]
  }

  /**
   * unitType findFirstOrThrow
   */
  export type unitTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the unitType
     */
    select?: unitTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: unitTypeInclude<ExtArgs> | null
    /**
     * Filter, which unitType to fetch.
     */
    where?: unitTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of unitTypes to fetch.
     */
    orderBy?: unitTypeOrderByWithRelationInput | unitTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for unitTypes.
     */
    cursor?: unitTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` unitTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` unitTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of unitTypes.
     */
    distinct?: UnitTypeScalarFieldEnum | UnitTypeScalarFieldEnum[]
  }

  /**
   * unitType findMany
   */
  export type unitTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the unitType
     */
    select?: unitTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: unitTypeInclude<ExtArgs> | null
    /**
     * Filter, which unitTypes to fetch.
     */
    where?: unitTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of unitTypes to fetch.
     */
    orderBy?: unitTypeOrderByWithRelationInput | unitTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing unitTypes.
     */
    cursor?: unitTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` unitTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` unitTypes.
     */
    skip?: number
    distinct?: UnitTypeScalarFieldEnum | UnitTypeScalarFieldEnum[]
  }

  /**
   * unitType create
   */
  export type unitTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the unitType
     */
    select?: unitTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: unitTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a unitType.
     */
    data: XOR<unitTypeCreateInput, unitTypeUncheckedCreateInput>
  }

  /**
   * unitType createMany
   */
  export type unitTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many unitTypes.
     */
    data: unitTypeCreateManyInput | unitTypeCreateManyInput[]
  }

  /**
   * unitType update
   */
  export type unitTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the unitType
     */
    select?: unitTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: unitTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a unitType.
     */
    data: XOR<unitTypeUpdateInput, unitTypeUncheckedUpdateInput>
    /**
     * Choose, which unitType to update.
     */
    where: unitTypeWhereUniqueInput
  }

  /**
   * unitType updateMany
   */
  export type unitTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update unitTypes.
     */
    data: XOR<unitTypeUpdateManyMutationInput, unitTypeUncheckedUpdateManyInput>
    /**
     * Filter which unitTypes to update
     */
    where?: unitTypeWhereInput
  }

  /**
   * unitType upsert
   */
  export type unitTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the unitType
     */
    select?: unitTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: unitTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the unitType to update in case it exists.
     */
    where: unitTypeWhereUniqueInput
    /**
     * In case the unitType found by the `where` argument doesn't exist, create a new unitType with this data.
     */
    create: XOR<unitTypeCreateInput, unitTypeUncheckedCreateInput>
    /**
     * In case the unitType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<unitTypeUpdateInput, unitTypeUncheckedUpdateInput>
  }

  /**
   * unitType delete
   */
  export type unitTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the unitType
     */
    select?: unitTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: unitTypeInclude<ExtArgs> | null
    /**
     * Filter which unitType to delete.
     */
    where: unitTypeWhereUniqueInput
  }

  /**
   * unitType deleteMany
   */
  export type unitTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which unitTypes to delete
     */
    where?: unitTypeWhereInput
  }

  /**
   * unitType findRaw
   */
  export type unitTypeFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * unitType aggregateRaw
   */
  export type unitTypeAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * unitType.kpi
   */
  export type unitType$kpiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kpi
     */
    select?: kpiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kpiInclude<ExtArgs> | null
    where?: kpiWhereInput
    orderBy?: kpiOrderByWithRelationInput | kpiOrderByWithRelationInput[]
    cursor?: kpiWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KpiScalarFieldEnum | KpiScalarFieldEnum[]
  }

  /**
   * unitType.organization
   */
  export type unitType$organizationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    where?: OrganizationWhereInput
  }

  /**
   * unitType.location
   */
  export type unitType$locationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    where?: LocationWhereInput
  }

  /**
   * unitType.ConnectedApps
   */
  export type unitType$ConnectedAppsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConnectedApps
     */
    select?: ConnectedAppsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectedAppsInclude<ExtArgs> | null
    where?: ConnectedAppsWhereInput
  }

  /**
   * unitType without action
   */
  export type unitTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the unitType
     */
    select?: unitTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: unitTypeInclude<ExtArgs> | null
  }


  /**
   * Model kpi
   */

  export type AggregateKpi = {
    _count: KpiCountAggregateOutputType | null
    _min: KpiMinAggregateOutputType | null
    _max: KpiMaxAggregateOutputType | null
  }

  export type KpiMinAggregateOutputType = {
    id: string | null
    kpiName: string | null
    kpiType: string | null
    unitTypeId: string | null
    uom: string | null
    sourceId: string | null
    status: boolean | null
    apiEndPoint: string | null
    kpiDescription: string | null
    kpiTargetType: boolean | null
    organizationId: string | null
    createdModifiedBy: string | null
    createdModifiedAt: Date | null
  }

  export type KpiMaxAggregateOutputType = {
    id: string | null
    kpiName: string | null
    kpiType: string | null
    unitTypeId: string | null
    uom: string | null
    sourceId: string | null
    status: boolean | null
    apiEndPoint: string | null
    kpiDescription: string | null
    kpiTargetType: boolean | null
    organizationId: string | null
    createdModifiedBy: string | null
    createdModifiedAt: Date | null
  }

  export type KpiCountAggregateOutputType = {
    id: number
    kpiName: number
    kpiType: number
    keyFields: number
    unitTypeId: number
    uom: number
    sourceId: number
    status: number
    apiEndPoint: number
    kpiDescription: number
    kpiTargetType: number
    organizationId: number
    locationId: number
    createdModifiedBy: number
    createdModifiedAt: number
    _all: number
  }


  export type KpiMinAggregateInputType = {
    id?: true
    kpiName?: true
    kpiType?: true
    unitTypeId?: true
    uom?: true
    sourceId?: true
    status?: true
    apiEndPoint?: true
    kpiDescription?: true
    kpiTargetType?: true
    organizationId?: true
    createdModifiedBy?: true
    createdModifiedAt?: true
  }

  export type KpiMaxAggregateInputType = {
    id?: true
    kpiName?: true
    kpiType?: true
    unitTypeId?: true
    uom?: true
    sourceId?: true
    status?: true
    apiEndPoint?: true
    kpiDescription?: true
    kpiTargetType?: true
    organizationId?: true
    createdModifiedBy?: true
    createdModifiedAt?: true
  }

  export type KpiCountAggregateInputType = {
    id?: true
    kpiName?: true
    kpiType?: true
    keyFields?: true
    unitTypeId?: true
    uom?: true
    sourceId?: true
    status?: true
    apiEndPoint?: true
    kpiDescription?: true
    kpiTargetType?: true
    organizationId?: true
    locationId?: true
    createdModifiedBy?: true
    createdModifiedAt?: true
    _all?: true
  }

  export type KpiAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which kpi to aggregate.
     */
    where?: kpiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of kpis to fetch.
     */
    orderBy?: kpiOrderByWithRelationInput | kpiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: kpiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` kpis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` kpis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned kpis
    **/
    _count?: true | KpiCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KpiMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KpiMaxAggregateInputType
  }

  export type GetKpiAggregateType<T extends KpiAggregateArgs> = {
        [P in keyof T & keyof AggregateKpi]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKpi[P]>
      : GetScalarType<T[P], AggregateKpi[P]>
  }




  export type kpiGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: kpiWhereInput
    orderBy?: kpiOrderByWithAggregationInput | kpiOrderByWithAggregationInput[]
    by: KpiScalarFieldEnum[] | KpiScalarFieldEnum
    having?: kpiScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KpiCountAggregateInputType | true
    _min?: KpiMinAggregateInputType
    _max?: KpiMaxAggregateInputType
  }

  export type KpiGroupByOutputType = {
    id: string
    kpiName: string
    kpiType: string | null
    keyFields: string[]
    unitTypeId: string | null
    uom: string
    sourceId: string | null
    status: boolean
    apiEndPoint: string | null
    kpiDescription: string | null
    kpiTargetType: boolean | null
    organizationId: string | null
    locationId: string[]
    createdModifiedBy: string
    createdModifiedAt: Date
    _count: KpiCountAggregateOutputType | null
    _min: KpiMinAggregateOutputType | null
    _max: KpiMaxAggregateOutputType | null
  }

  type GetKpiGroupByPayload<T extends kpiGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<KpiGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KpiGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KpiGroupByOutputType[P]>
            : GetScalarType<T[P], KpiGroupByOutputType[P]>
        }
      >
    >


  export type kpiSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    kpiName?: boolean
    kpiType?: boolean
    keyFields?: boolean
    unitTypeId?: boolean
    uom?: boolean
    sourceId?: boolean
    status?: boolean
    apiEndPoint?: boolean
    kpiDescription?: boolean
    kpiTargetType?: boolean
    organizationId?: boolean
    locationId?: boolean
    createdModifiedBy?: boolean
    createdModifiedAt?: boolean
    unitType?: boolean | kpi$unitTypeArgs<ExtArgs>
    ConnectedApps?: boolean | kpi$ConnectedAppsArgs<ExtArgs>
    organization?: boolean | kpi$organizationArgs<ExtArgs>
  }, ExtArgs["result"]["kpi"]>


  export type kpiSelectScalar = {
    id?: boolean
    kpiName?: boolean
    kpiType?: boolean
    keyFields?: boolean
    unitTypeId?: boolean
    uom?: boolean
    sourceId?: boolean
    status?: boolean
    apiEndPoint?: boolean
    kpiDescription?: boolean
    kpiTargetType?: boolean
    organizationId?: boolean
    locationId?: boolean
    createdModifiedBy?: boolean
    createdModifiedAt?: boolean
  }

  export type kpiInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unitType?: boolean | kpi$unitTypeArgs<ExtArgs>
    ConnectedApps?: boolean | kpi$ConnectedAppsArgs<ExtArgs>
    organization?: boolean | kpi$organizationArgs<ExtArgs>
  }

  export type $kpiPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "kpi"
    objects: {
      unitType: Prisma.$unitTypePayload<ExtArgs> | null
      ConnectedApps: Prisma.$ConnectedAppsPayload<ExtArgs> | null
      organization: Prisma.$OrganizationPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      kpiName: string
      kpiType: string | null
      keyFields: string[]
      unitTypeId: string | null
      uom: string
      sourceId: string | null
      status: boolean
      apiEndPoint: string | null
      kpiDescription: string | null
      kpiTargetType: boolean | null
      organizationId: string | null
      locationId: string[]
      createdModifiedBy: string
      createdModifiedAt: Date
    }, ExtArgs["result"]["kpi"]>
    composites: {}
  }

  type kpiGetPayload<S extends boolean | null | undefined | kpiDefaultArgs> = $Result.GetResult<Prisma.$kpiPayload, S>

  type kpiCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<kpiFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: KpiCountAggregateInputType | true
    }

  export interface kpiDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['kpi'], meta: { name: 'kpi' } }
    /**
     * Find zero or one Kpi that matches the filter.
     * @param {kpiFindUniqueArgs} args - Arguments to find a Kpi
     * @example
     * // Get one Kpi
     * const kpi = await prisma.kpi.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends kpiFindUniqueArgs>(args: SelectSubset<T, kpiFindUniqueArgs<ExtArgs>>): Prisma__kpiClient<$Result.GetResult<Prisma.$kpiPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Kpi that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {kpiFindUniqueOrThrowArgs} args - Arguments to find a Kpi
     * @example
     * // Get one Kpi
     * const kpi = await prisma.kpi.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends kpiFindUniqueOrThrowArgs>(args: SelectSubset<T, kpiFindUniqueOrThrowArgs<ExtArgs>>): Prisma__kpiClient<$Result.GetResult<Prisma.$kpiPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Kpi that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kpiFindFirstArgs} args - Arguments to find a Kpi
     * @example
     * // Get one Kpi
     * const kpi = await prisma.kpi.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends kpiFindFirstArgs>(args?: SelectSubset<T, kpiFindFirstArgs<ExtArgs>>): Prisma__kpiClient<$Result.GetResult<Prisma.$kpiPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Kpi that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kpiFindFirstOrThrowArgs} args - Arguments to find a Kpi
     * @example
     * // Get one Kpi
     * const kpi = await prisma.kpi.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends kpiFindFirstOrThrowArgs>(args?: SelectSubset<T, kpiFindFirstOrThrowArgs<ExtArgs>>): Prisma__kpiClient<$Result.GetResult<Prisma.$kpiPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Kpis that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kpiFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Kpis
     * const kpis = await prisma.kpi.findMany()
     * 
     * // Get first 10 Kpis
     * const kpis = await prisma.kpi.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const kpiWithIdOnly = await prisma.kpi.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends kpiFindManyArgs>(args?: SelectSubset<T, kpiFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$kpiPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Kpi.
     * @param {kpiCreateArgs} args - Arguments to create a Kpi.
     * @example
     * // Create one Kpi
     * const Kpi = await prisma.kpi.create({
     *   data: {
     *     // ... data to create a Kpi
     *   }
     * })
     * 
     */
    create<T extends kpiCreateArgs>(args: SelectSubset<T, kpiCreateArgs<ExtArgs>>): Prisma__kpiClient<$Result.GetResult<Prisma.$kpiPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Kpis.
     * @param {kpiCreateManyArgs} args - Arguments to create many Kpis.
     * @example
     * // Create many Kpis
     * const kpi = await prisma.kpi.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends kpiCreateManyArgs>(args?: SelectSubset<T, kpiCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Kpi.
     * @param {kpiDeleteArgs} args - Arguments to delete one Kpi.
     * @example
     * // Delete one Kpi
     * const Kpi = await prisma.kpi.delete({
     *   where: {
     *     // ... filter to delete one Kpi
     *   }
     * })
     * 
     */
    delete<T extends kpiDeleteArgs>(args: SelectSubset<T, kpiDeleteArgs<ExtArgs>>): Prisma__kpiClient<$Result.GetResult<Prisma.$kpiPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Kpi.
     * @param {kpiUpdateArgs} args - Arguments to update one Kpi.
     * @example
     * // Update one Kpi
     * const kpi = await prisma.kpi.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends kpiUpdateArgs>(args: SelectSubset<T, kpiUpdateArgs<ExtArgs>>): Prisma__kpiClient<$Result.GetResult<Prisma.$kpiPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Kpis.
     * @param {kpiDeleteManyArgs} args - Arguments to filter Kpis to delete.
     * @example
     * // Delete a few Kpis
     * const { count } = await prisma.kpi.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends kpiDeleteManyArgs>(args?: SelectSubset<T, kpiDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Kpis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kpiUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Kpis
     * const kpi = await prisma.kpi.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends kpiUpdateManyArgs>(args: SelectSubset<T, kpiUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Kpi.
     * @param {kpiUpsertArgs} args - Arguments to update or create a Kpi.
     * @example
     * // Update or create a Kpi
     * const kpi = await prisma.kpi.upsert({
     *   create: {
     *     // ... data to create a Kpi
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Kpi we want to update
     *   }
     * })
     */
    upsert<T extends kpiUpsertArgs>(args: SelectSubset<T, kpiUpsertArgs<ExtArgs>>): Prisma__kpiClient<$Result.GetResult<Prisma.$kpiPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Kpis that matches the filter.
     * @param {kpiFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const kpi = await prisma.kpi.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: kpiFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Kpi.
     * @param {kpiAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const kpi = await prisma.kpi.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: kpiAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Kpis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kpiCountArgs} args - Arguments to filter Kpis to count.
     * @example
     * // Count the number of Kpis
     * const count = await prisma.kpi.count({
     *   where: {
     *     // ... the filter for the Kpis we want to count
     *   }
     * })
    **/
    count<T extends kpiCountArgs>(
      args?: Subset<T, kpiCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KpiCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Kpi.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KpiAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KpiAggregateArgs>(args: Subset<T, KpiAggregateArgs>): Prisma.PrismaPromise<GetKpiAggregateType<T>>

    /**
     * Group by Kpi.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kpiGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends kpiGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: kpiGroupByArgs['orderBy'] }
        : { orderBy?: kpiGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, kpiGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKpiGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the kpi model
   */
  readonly fields: kpiFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for kpi.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__kpiClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    unitType<T extends kpi$unitTypeArgs<ExtArgs> = {}>(args?: Subset<T, kpi$unitTypeArgs<ExtArgs>>): Prisma__unitTypeClient<$Result.GetResult<Prisma.$unitTypePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    ConnectedApps<T extends kpi$ConnectedAppsArgs<ExtArgs> = {}>(args?: Subset<T, kpi$ConnectedAppsArgs<ExtArgs>>): Prisma__ConnectedAppsClient<$Result.GetResult<Prisma.$ConnectedAppsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    organization<T extends kpi$organizationArgs<ExtArgs> = {}>(args?: Subset<T, kpi$organizationArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the kpi model
   */ 
  interface kpiFieldRefs {
    readonly id: FieldRef<"kpi", 'String'>
    readonly kpiName: FieldRef<"kpi", 'String'>
    readonly kpiType: FieldRef<"kpi", 'String'>
    readonly keyFields: FieldRef<"kpi", 'String[]'>
    readonly unitTypeId: FieldRef<"kpi", 'String'>
    readonly uom: FieldRef<"kpi", 'String'>
    readonly sourceId: FieldRef<"kpi", 'String'>
    readonly status: FieldRef<"kpi", 'Boolean'>
    readonly apiEndPoint: FieldRef<"kpi", 'String'>
    readonly kpiDescription: FieldRef<"kpi", 'String'>
    readonly kpiTargetType: FieldRef<"kpi", 'Boolean'>
    readonly organizationId: FieldRef<"kpi", 'String'>
    readonly locationId: FieldRef<"kpi", 'String[]'>
    readonly createdModifiedBy: FieldRef<"kpi", 'String'>
    readonly createdModifiedAt: FieldRef<"kpi", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * kpi findUnique
   */
  export type kpiFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kpi
     */
    select?: kpiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kpiInclude<ExtArgs> | null
    /**
     * Filter, which kpi to fetch.
     */
    where: kpiWhereUniqueInput
  }

  /**
   * kpi findUniqueOrThrow
   */
  export type kpiFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kpi
     */
    select?: kpiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kpiInclude<ExtArgs> | null
    /**
     * Filter, which kpi to fetch.
     */
    where: kpiWhereUniqueInput
  }

  /**
   * kpi findFirst
   */
  export type kpiFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kpi
     */
    select?: kpiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kpiInclude<ExtArgs> | null
    /**
     * Filter, which kpi to fetch.
     */
    where?: kpiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of kpis to fetch.
     */
    orderBy?: kpiOrderByWithRelationInput | kpiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for kpis.
     */
    cursor?: kpiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` kpis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` kpis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of kpis.
     */
    distinct?: KpiScalarFieldEnum | KpiScalarFieldEnum[]
  }

  /**
   * kpi findFirstOrThrow
   */
  export type kpiFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kpi
     */
    select?: kpiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kpiInclude<ExtArgs> | null
    /**
     * Filter, which kpi to fetch.
     */
    where?: kpiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of kpis to fetch.
     */
    orderBy?: kpiOrderByWithRelationInput | kpiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for kpis.
     */
    cursor?: kpiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` kpis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` kpis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of kpis.
     */
    distinct?: KpiScalarFieldEnum | KpiScalarFieldEnum[]
  }

  /**
   * kpi findMany
   */
  export type kpiFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kpi
     */
    select?: kpiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kpiInclude<ExtArgs> | null
    /**
     * Filter, which kpis to fetch.
     */
    where?: kpiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of kpis to fetch.
     */
    orderBy?: kpiOrderByWithRelationInput | kpiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing kpis.
     */
    cursor?: kpiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` kpis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` kpis.
     */
    skip?: number
    distinct?: KpiScalarFieldEnum | KpiScalarFieldEnum[]
  }

  /**
   * kpi create
   */
  export type kpiCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kpi
     */
    select?: kpiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kpiInclude<ExtArgs> | null
    /**
     * The data needed to create a kpi.
     */
    data: XOR<kpiCreateInput, kpiUncheckedCreateInput>
  }

  /**
   * kpi createMany
   */
  export type kpiCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many kpis.
     */
    data: kpiCreateManyInput | kpiCreateManyInput[]
  }

  /**
   * kpi update
   */
  export type kpiUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kpi
     */
    select?: kpiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kpiInclude<ExtArgs> | null
    /**
     * The data needed to update a kpi.
     */
    data: XOR<kpiUpdateInput, kpiUncheckedUpdateInput>
    /**
     * Choose, which kpi to update.
     */
    where: kpiWhereUniqueInput
  }

  /**
   * kpi updateMany
   */
  export type kpiUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update kpis.
     */
    data: XOR<kpiUpdateManyMutationInput, kpiUncheckedUpdateManyInput>
    /**
     * Filter which kpis to update
     */
    where?: kpiWhereInput
  }

  /**
   * kpi upsert
   */
  export type kpiUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kpi
     */
    select?: kpiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kpiInclude<ExtArgs> | null
    /**
     * The filter to search for the kpi to update in case it exists.
     */
    where: kpiWhereUniqueInput
    /**
     * In case the kpi found by the `where` argument doesn't exist, create a new kpi with this data.
     */
    create: XOR<kpiCreateInput, kpiUncheckedCreateInput>
    /**
     * In case the kpi was found with the provided `where` argument, update it with this data.
     */
    update: XOR<kpiUpdateInput, kpiUncheckedUpdateInput>
  }

  /**
   * kpi delete
   */
  export type kpiDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kpi
     */
    select?: kpiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kpiInclude<ExtArgs> | null
    /**
     * Filter which kpi to delete.
     */
    where: kpiWhereUniqueInput
  }

  /**
   * kpi deleteMany
   */
  export type kpiDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which kpis to delete
     */
    where?: kpiWhereInput
  }

  /**
   * kpi findRaw
   */
  export type kpiFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * kpi aggregateRaw
   */
  export type kpiAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * kpi.unitType
   */
  export type kpi$unitTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the unitType
     */
    select?: unitTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: unitTypeInclude<ExtArgs> | null
    where?: unitTypeWhereInput
  }

  /**
   * kpi.ConnectedApps
   */
  export type kpi$ConnectedAppsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConnectedApps
     */
    select?: ConnectedAppsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectedAppsInclude<ExtArgs> | null
    where?: ConnectedAppsWhereInput
  }

  /**
   * kpi.organization
   */
  export type kpi$organizationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    where?: OrganizationWhereInput
  }

  /**
   * kpi without action
   */
  export type kpiDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kpi
     */
    select?: kpiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kpiInclude<ExtArgs> | null
  }


  /**
   * Model auditTrial
   */

  export type AggregateAuditTrial = {
    _count: AuditTrialCountAggregateOutputType | null
    _min: AuditTrialMinAggregateOutputType | null
    _max: AuditTrialMaxAggregateOutputType | null
  }

  export type AuditTrialMinAggregateOutputType = {
    id: string | null
    moduleType: string | null
    actionType: string | null
    transactionId: string | null
    actionBy: string | null
    actionDate: Date | null
  }

  export type AuditTrialMaxAggregateOutputType = {
    id: string | null
    moduleType: string | null
    actionType: string | null
    transactionId: string | null
    actionBy: string | null
    actionDate: Date | null
  }

  export type AuditTrialCountAggregateOutputType = {
    id: number
    moduleType: number
    actionType: number
    transactionId: number
    actionBy: number
    actionDate: number
    _all: number
  }


  export type AuditTrialMinAggregateInputType = {
    id?: true
    moduleType?: true
    actionType?: true
    transactionId?: true
    actionBy?: true
    actionDate?: true
  }

  export type AuditTrialMaxAggregateInputType = {
    id?: true
    moduleType?: true
    actionType?: true
    transactionId?: true
    actionBy?: true
    actionDate?: true
  }

  export type AuditTrialCountAggregateInputType = {
    id?: true
    moduleType?: true
    actionType?: true
    transactionId?: true
    actionBy?: true
    actionDate?: true
    _all?: true
  }

  export type AuditTrialAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which auditTrial to aggregate.
     */
    where?: auditTrialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of auditTrials to fetch.
     */
    orderBy?: auditTrialOrderByWithRelationInput | auditTrialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: auditTrialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` auditTrials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` auditTrials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned auditTrials
    **/
    _count?: true | AuditTrialCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditTrialMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditTrialMaxAggregateInputType
  }

  export type GetAuditTrialAggregateType<T extends AuditTrialAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditTrial]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditTrial[P]>
      : GetScalarType<T[P], AggregateAuditTrial[P]>
  }




  export type auditTrialGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: auditTrialWhereInput
    orderBy?: auditTrialOrderByWithAggregationInput | auditTrialOrderByWithAggregationInput[]
    by: AuditTrialScalarFieldEnum[] | AuditTrialScalarFieldEnum
    having?: auditTrialScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditTrialCountAggregateInputType | true
    _min?: AuditTrialMinAggregateInputType
    _max?: AuditTrialMaxAggregateInputType
  }

  export type AuditTrialGroupByOutputType = {
    id: string
    moduleType: string | null
    actionType: string | null
    transactionId: string | null
    actionBy: string | null
    actionDate: Date | null
    _count: AuditTrialCountAggregateOutputType | null
    _min: AuditTrialMinAggregateOutputType | null
    _max: AuditTrialMaxAggregateOutputType | null
  }

  type GetAuditTrialGroupByPayload<T extends auditTrialGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditTrialGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditTrialGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditTrialGroupByOutputType[P]>
            : GetScalarType<T[P], AuditTrialGroupByOutputType[P]>
        }
      >
    >


  export type auditTrialSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    moduleType?: boolean
    actionType?: boolean
    transactionId?: boolean
    actionBy?: boolean
    actionDate?: boolean
    user?: boolean | auditTrial$userArgs<ExtArgs>
  }, ExtArgs["result"]["auditTrial"]>


  export type auditTrialSelectScalar = {
    id?: boolean
    moduleType?: boolean
    actionType?: boolean
    transactionId?: boolean
    actionBy?: boolean
    actionDate?: boolean
  }

  export type auditTrialInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | auditTrial$userArgs<ExtArgs>
  }

  export type $auditTrialPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "auditTrial"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      moduleType: string | null
      actionType: string | null
      transactionId: string | null
      actionBy: string | null
      actionDate: Date | null
    }, ExtArgs["result"]["auditTrial"]>
    composites: {}
  }

  type auditTrialGetPayload<S extends boolean | null | undefined | auditTrialDefaultArgs> = $Result.GetResult<Prisma.$auditTrialPayload, S>

  type auditTrialCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<auditTrialFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AuditTrialCountAggregateInputType | true
    }

  export interface auditTrialDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['auditTrial'], meta: { name: 'auditTrial' } }
    /**
     * Find zero or one AuditTrial that matches the filter.
     * @param {auditTrialFindUniqueArgs} args - Arguments to find a AuditTrial
     * @example
     * // Get one AuditTrial
     * const auditTrial = await prisma.auditTrial.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends auditTrialFindUniqueArgs>(args: SelectSubset<T, auditTrialFindUniqueArgs<ExtArgs>>): Prisma__auditTrialClient<$Result.GetResult<Prisma.$auditTrialPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AuditTrial that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {auditTrialFindUniqueOrThrowArgs} args - Arguments to find a AuditTrial
     * @example
     * // Get one AuditTrial
     * const auditTrial = await prisma.auditTrial.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends auditTrialFindUniqueOrThrowArgs>(args: SelectSubset<T, auditTrialFindUniqueOrThrowArgs<ExtArgs>>): Prisma__auditTrialClient<$Result.GetResult<Prisma.$auditTrialPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AuditTrial that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auditTrialFindFirstArgs} args - Arguments to find a AuditTrial
     * @example
     * // Get one AuditTrial
     * const auditTrial = await prisma.auditTrial.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends auditTrialFindFirstArgs>(args?: SelectSubset<T, auditTrialFindFirstArgs<ExtArgs>>): Prisma__auditTrialClient<$Result.GetResult<Prisma.$auditTrialPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AuditTrial that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auditTrialFindFirstOrThrowArgs} args - Arguments to find a AuditTrial
     * @example
     * // Get one AuditTrial
     * const auditTrial = await prisma.auditTrial.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends auditTrialFindFirstOrThrowArgs>(args?: SelectSubset<T, auditTrialFindFirstOrThrowArgs<ExtArgs>>): Prisma__auditTrialClient<$Result.GetResult<Prisma.$auditTrialPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AuditTrials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auditTrialFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditTrials
     * const auditTrials = await prisma.auditTrial.findMany()
     * 
     * // Get first 10 AuditTrials
     * const auditTrials = await prisma.auditTrial.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditTrialWithIdOnly = await prisma.auditTrial.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends auditTrialFindManyArgs>(args?: SelectSubset<T, auditTrialFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$auditTrialPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AuditTrial.
     * @param {auditTrialCreateArgs} args - Arguments to create a AuditTrial.
     * @example
     * // Create one AuditTrial
     * const AuditTrial = await prisma.auditTrial.create({
     *   data: {
     *     // ... data to create a AuditTrial
     *   }
     * })
     * 
     */
    create<T extends auditTrialCreateArgs>(args: SelectSubset<T, auditTrialCreateArgs<ExtArgs>>): Prisma__auditTrialClient<$Result.GetResult<Prisma.$auditTrialPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AuditTrials.
     * @param {auditTrialCreateManyArgs} args - Arguments to create many AuditTrials.
     * @example
     * // Create many AuditTrials
     * const auditTrial = await prisma.auditTrial.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends auditTrialCreateManyArgs>(args?: SelectSubset<T, auditTrialCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AuditTrial.
     * @param {auditTrialDeleteArgs} args - Arguments to delete one AuditTrial.
     * @example
     * // Delete one AuditTrial
     * const AuditTrial = await prisma.auditTrial.delete({
     *   where: {
     *     // ... filter to delete one AuditTrial
     *   }
     * })
     * 
     */
    delete<T extends auditTrialDeleteArgs>(args: SelectSubset<T, auditTrialDeleteArgs<ExtArgs>>): Prisma__auditTrialClient<$Result.GetResult<Prisma.$auditTrialPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AuditTrial.
     * @param {auditTrialUpdateArgs} args - Arguments to update one AuditTrial.
     * @example
     * // Update one AuditTrial
     * const auditTrial = await prisma.auditTrial.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends auditTrialUpdateArgs>(args: SelectSubset<T, auditTrialUpdateArgs<ExtArgs>>): Prisma__auditTrialClient<$Result.GetResult<Prisma.$auditTrialPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AuditTrials.
     * @param {auditTrialDeleteManyArgs} args - Arguments to filter AuditTrials to delete.
     * @example
     * // Delete a few AuditTrials
     * const { count } = await prisma.auditTrial.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends auditTrialDeleteManyArgs>(args?: SelectSubset<T, auditTrialDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditTrials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auditTrialUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditTrials
     * const auditTrial = await prisma.auditTrial.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends auditTrialUpdateManyArgs>(args: SelectSubset<T, auditTrialUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AuditTrial.
     * @param {auditTrialUpsertArgs} args - Arguments to update or create a AuditTrial.
     * @example
     * // Update or create a AuditTrial
     * const auditTrial = await prisma.auditTrial.upsert({
     *   create: {
     *     // ... data to create a AuditTrial
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditTrial we want to update
     *   }
     * })
     */
    upsert<T extends auditTrialUpsertArgs>(args: SelectSubset<T, auditTrialUpsertArgs<ExtArgs>>): Prisma__auditTrialClient<$Result.GetResult<Prisma.$auditTrialPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more AuditTrials that matches the filter.
     * @param {auditTrialFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const auditTrial = await prisma.auditTrial.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: auditTrialFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a AuditTrial.
     * @param {auditTrialAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const auditTrial = await prisma.auditTrial.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: auditTrialAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of AuditTrials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auditTrialCountArgs} args - Arguments to filter AuditTrials to count.
     * @example
     * // Count the number of AuditTrials
     * const count = await prisma.auditTrial.count({
     *   where: {
     *     // ... the filter for the AuditTrials we want to count
     *   }
     * })
    **/
    count<T extends auditTrialCountArgs>(
      args?: Subset<T, auditTrialCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditTrialCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditTrial.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditTrialAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditTrialAggregateArgs>(args: Subset<T, AuditTrialAggregateArgs>): Prisma.PrismaPromise<GetAuditTrialAggregateType<T>>

    /**
     * Group by AuditTrial.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auditTrialGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends auditTrialGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: auditTrialGroupByArgs['orderBy'] }
        : { orderBy?: auditTrialGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, auditTrialGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditTrialGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the auditTrial model
   */
  readonly fields: auditTrialFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for auditTrial.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__auditTrialClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends auditTrial$userArgs<ExtArgs> = {}>(args?: Subset<T, auditTrial$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the auditTrial model
   */ 
  interface auditTrialFieldRefs {
    readonly id: FieldRef<"auditTrial", 'String'>
    readonly moduleType: FieldRef<"auditTrial", 'String'>
    readonly actionType: FieldRef<"auditTrial", 'String'>
    readonly transactionId: FieldRef<"auditTrial", 'String'>
    readonly actionBy: FieldRef<"auditTrial", 'String'>
    readonly actionDate: FieldRef<"auditTrial", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * auditTrial findUnique
   */
  export type auditTrialFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auditTrial
     */
    select?: auditTrialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditTrialInclude<ExtArgs> | null
    /**
     * Filter, which auditTrial to fetch.
     */
    where: auditTrialWhereUniqueInput
  }

  /**
   * auditTrial findUniqueOrThrow
   */
  export type auditTrialFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auditTrial
     */
    select?: auditTrialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditTrialInclude<ExtArgs> | null
    /**
     * Filter, which auditTrial to fetch.
     */
    where: auditTrialWhereUniqueInput
  }

  /**
   * auditTrial findFirst
   */
  export type auditTrialFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auditTrial
     */
    select?: auditTrialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditTrialInclude<ExtArgs> | null
    /**
     * Filter, which auditTrial to fetch.
     */
    where?: auditTrialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of auditTrials to fetch.
     */
    orderBy?: auditTrialOrderByWithRelationInput | auditTrialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for auditTrials.
     */
    cursor?: auditTrialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` auditTrials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` auditTrials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of auditTrials.
     */
    distinct?: AuditTrialScalarFieldEnum | AuditTrialScalarFieldEnum[]
  }

  /**
   * auditTrial findFirstOrThrow
   */
  export type auditTrialFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auditTrial
     */
    select?: auditTrialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditTrialInclude<ExtArgs> | null
    /**
     * Filter, which auditTrial to fetch.
     */
    where?: auditTrialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of auditTrials to fetch.
     */
    orderBy?: auditTrialOrderByWithRelationInput | auditTrialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for auditTrials.
     */
    cursor?: auditTrialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` auditTrials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` auditTrials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of auditTrials.
     */
    distinct?: AuditTrialScalarFieldEnum | AuditTrialScalarFieldEnum[]
  }

  /**
   * auditTrial findMany
   */
  export type auditTrialFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auditTrial
     */
    select?: auditTrialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditTrialInclude<ExtArgs> | null
    /**
     * Filter, which auditTrials to fetch.
     */
    where?: auditTrialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of auditTrials to fetch.
     */
    orderBy?: auditTrialOrderByWithRelationInput | auditTrialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing auditTrials.
     */
    cursor?: auditTrialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` auditTrials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` auditTrials.
     */
    skip?: number
    distinct?: AuditTrialScalarFieldEnum | AuditTrialScalarFieldEnum[]
  }

  /**
   * auditTrial create
   */
  export type auditTrialCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auditTrial
     */
    select?: auditTrialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditTrialInclude<ExtArgs> | null
    /**
     * The data needed to create a auditTrial.
     */
    data?: XOR<auditTrialCreateInput, auditTrialUncheckedCreateInput>
  }

  /**
   * auditTrial createMany
   */
  export type auditTrialCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many auditTrials.
     */
    data: auditTrialCreateManyInput | auditTrialCreateManyInput[]
  }

  /**
   * auditTrial update
   */
  export type auditTrialUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auditTrial
     */
    select?: auditTrialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditTrialInclude<ExtArgs> | null
    /**
     * The data needed to update a auditTrial.
     */
    data: XOR<auditTrialUpdateInput, auditTrialUncheckedUpdateInput>
    /**
     * Choose, which auditTrial to update.
     */
    where: auditTrialWhereUniqueInput
  }

  /**
   * auditTrial updateMany
   */
  export type auditTrialUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update auditTrials.
     */
    data: XOR<auditTrialUpdateManyMutationInput, auditTrialUncheckedUpdateManyInput>
    /**
     * Filter which auditTrials to update
     */
    where?: auditTrialWhereInput
  }

  /**
   * auditTrial upsert
   */
  export type auditTrialUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auditTrial
     */
    select?: auditTrialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditTrialInclude<ExtArgs> | null
    /**
     * The filter to search for the auditTrial to update in case it exists.
     */
    where: auditTrialWhereUniqueInput
    /**
     * In case the auditTrial found by the `where` argument doesn't exist, create a new auditTrial with this data.
     */
    create: XOR<auditTrialCreateInput, auditTrialUncheckedCreateInput>
    /**
     * In case the auditTrial was found with the provided `where` argument, update it with this data.
     */
    update: XOR<auditTrialUpdateInput, auditTrialUncheckedUpdateInput>
  }

  /**
   * auditTrial delete
   */
  export type auditTrialDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auditTrial
     */
    select?: auditTrialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditTrialInclude<ExtArgs> | null
    /**
     * Filter which auditTrial to delete.
     */
    where: auditTrialWhereUniqueInput
  }

  /**
   * auditTrial deleteMany
   */
  export type auditTrialDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which auditTrials to delete
     */
    where?: auditTrialWhereInput
  }

  /**
   * auditTrial findRaw
   */
  export type auditTrialFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * auditTrial aggregateRaw
   */
  export type auditTrialAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * auditTrial.user
   */
  export type auditTrial$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * auditTrial without action
   */
  export type auditTrialDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auditTrial
     */
    select?: auditTrialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditTrialInclude<ExtArgs> | null
  }


  /**
   * Model prefixSuffix
   */

  export type AggregatePrefixSuffix = {
    _count: PrefixSuffixCountAggregateOutputType | null
    _min: PrefixSuffixMinAggregateOutputType | null
    _max: PrefixSuffixMaxAggregateOutputType | null
  }

  export type PrefixSuffixMinAggregateOutputType = {
    id: string | null
    prefix: string | null
    suffix: string | null
    moduleType: string | null
    location: string | null
    organizationId: string | null
    createdBy: string | null
    createdAt: Date | null
  }

  export type PrefixSuffixMaxAggregateOutputType = {
    id: string | null
    prefix: string | null
    suffix: string | null
    moduleType: string | null
    location: string | null
    organizationId: string | null
    createdBy: string | null
    createdAt: Date | null
  }

  export type PrefixSuffixCountAggregateOutputType = {
    id: number
    prefix: number
    suffix: number
    moduleType: number
    location: number
    organizationId: number
    createdBy: number
    createdAt: number
    _all: number
  }


  export type PrefixSuffixMinAggregateInputType = {
    id?: true
    prefix?: true
    suffix?: true
    moduleType?: true
    location?: true
    organizationId?: true
    createdBy?: true
    createdAt?: true
  }

  export type PrefixSuffixMaxAggregateInputType = {
    id?: true
    prefix?: true
    suffix?: true
    moduleType?: true
    location?: true
    organizationId?: true
    createdBy?: true
    createdAt?: true
  }

  export type PrefixSuffixCountAggregateInputType = {
    id?: true
    prefix?: true
    suffix?: true
    moduleType?: true
    location?: true
    organizationId?: true
    createdBy?: true
    createdAt?: true
    _all?: true
  }

  export type PrefixSuffixAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which prefixSuffix to aggregate.
     */
    where?: prefixSuffixWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of prefixSuffixes to fetch.
     */
    orderBy?: prefixSuffixOrderByWithRelationInput | prefixSuffixOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: prefixSuffixWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` prefixSuffixes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` prefixSuffixes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned prefixSuffixes
    **/
    _count?: true | PrefixSuffixCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PrefixSuffixMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PrefixSuffixMaxAggregateInputType
  }

  export type GetPrefixSuffixAggregateType<T extends PrefixSuffixAggregateArgs> = {
        [P in keyof T & keyof AggregatePrefixSuffix]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePrefixSuffix[P]>
      : GetScalarType<T[P], AggregatePrefixSuffix[P]>
  }




  export type prefixSuffixGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: prefixSuffixWhereInput
    orderBy?: prefixSuffixOrderByWithAggregationInput | prefixSuffixOrderByWithAggregationInput[]
    by: PrefixSuffixScalarFieldEnum[] | PrefixSuffixScalarFieldEnum
    having?: prefixSuffixScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PrefixSuffixCountAggregateInputType | true
    _min?: PrefixSuffixMinAggregateInputType
    _max?: PrefixSuffixMaxAggregateInputType
  }

  export type PrefixSuffixGroupByOutputType = {
    id: string
    prefix: string | null
    suffix: string | null
    moduleType: string | null
    location: string | null
    organizationId: string | null
    createdBy: string | null
    createdAt: Date
    _count: PrefixSuffixCountAggregateOutputType | null
    _min: PrefixSuffixMinAggregateOutputType | null
    _max: PrefixSuffixMaxAggregateOutputType | null
  }

  type GetPrefixSuffixGroupByPayload<T extends prefixSuffixGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PrefixSuffixGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PrefixSuffixGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PrefixSuffixGroupByOutputType[P]>
            : GetScalarType<T[P], PrefixSuffixGroupByOutputType[P]>
        }
      >
    >


  export type prefixSuffixSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    prefix?: boolean
    suffix?: boolean
    moduleType?: boolean
    location?: boolean
    organizationId?: boolean
    createdBy?: boolean
    createdAt?: boolean
    organization?: boolean | prefixSuffix$organizationArgs<ExtArgs>
  }, ExtArgs["result"]["prefixSuffix"]>


  export type prefixSuffixSelectScalar = {
    id?: boolean
    prefix?: boolean
    suffix?: boolean
    moduleType?: boolean
    location?: boolean
    organizationId?: boolean
    createdBy?: boolean
    createdAt?: boolean
  }

  export type prefixSuffixInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | prefixSuffix$organizationArgs<ExtArgs>
  }

  export type $prefixSuffixPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "prefixSuffix"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      prefix: string | null
      suffix: string | null
      moduleType: string | null
      location: string | null
      organizationId: string | null
      createdBy: string | null
      createdAt: Date
    }, ExtArgs["result"]["prefixSuffix"]>
    composites: {}
  }

  type prefixSuffixGetPayload<S extends boolean | null | undefined | prefixSuffixDefaultArgs> = $Result.GetResult<Prisma.$prefixSuffixPayload, S>

  type prefixSuffixCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<prefixSuffixFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PrefixSuffixCountAggregateInputType | true
    }

  export interface prefixSuffixDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['prefixSuffix'], meta: { name: 'prefixSuffix' } }
    /**
     * Find zero or one PrefixSuffix that matches the filter.
     * @param {prefixSuffixFindUniqueArgs} args - Arguments to find a PrefixSuffix
     * @example
     * // Get one PrefixSuffix
     * const prefixSuffix = await prisma.prefixSuffix.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends prefixSuffixFindUniqueArgs>(args: SelectSubset<T, prefixSuffixFindUniqueArgs<ExtArgs>>): Prisma__prefixSuffixClient<$Result.GetResult<Prisma.$prefixSuffixPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PrefixSuffix that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {prefixSuffixFindUniqueOrThrowArgs} args - Arguments to find a PrefixSuffix
     * @example
     * // Get one PrefixSuffix
     * const prefixSuffix = await prisma.prefixSuffix.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends prefixSuffixFindUniqueOrThrowArgs>(args: SelectSubset<T, prefixSuffixFindUniqueOrThrowArgs<ExtArgs>>): Prisma__prefixSuffixClient<$Result.GetResult<Prisma.$prefixSuffixPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PrefixSuffix that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {prefixSuffixFindFirstArgs} args - Arguments to find a PrefixSuffix
     * @example
     * // Get one PrefixSuffix
     * const prefixSuffix = await prisma.prefixSuffix.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends prefixSuffixFindFirstArgs>(args?: SelectSubset<T, prefixSuffixFindFirstArgs<ExtArgs>>): Prisma__prefixSuffixClient<$Result.GetResult<Prisma.$prefixSuffixPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PrefixSuffix that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {prefixSuffixFindFirstOrThrowArgs} args - Arguments to find a PrefixSuffix
     * @example
     * // Get one PrefixSuffix
     * const prefixSuffix = await prisma.prefixSuffix.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends prefixSuffixFindFirstOrThrowArgs>(args?: SelectSubset<T, prefixSuffixFindFirstOrThrowArgs<ExtArgs>>): Prisma__prefixSuffixClient<$Result.GetResult<Prisma.$prefixSuffixPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PrefixSuffixes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {prefixSuffixFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PrefixSuffixes
     * const prefixSuffixes = await prisma.prefixSuffix.findMany()
     * 
     * // Get first 10 PrefixSuffixes
     * const prefixSuffixes = await prisma.prefixSuffix.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const prefixSuffixWithIdOnly = await prisma.prefixSuffix.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends prefixSuffixFindManyArgs>(args?: SelectSubset<T, prefixSuffixFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$prefixSuffixPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PrefixSuffix.
     * @param {prefixSuffixCreateArgs} args - Arguments to create a PrefixSuffix.
     * @example
     * // Create one PrefixSuffix
     * const PrefixSuffix = await prisma.prefixSuffix.create({
     *   data: {
     *     // ... data to create a PrefixSuffix
     *   }
     * })
     * 
     */
    create<T extends prefixSuffixCreateArgs>(args: SelectSubset<T, prefixSuffixCreateArgs<ExtArgs>>): Prisma__prefixSuffixClient<$Result.GetResult<Prisma.$prefixSuffixPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PrefixSuffixes.
     * @param {prefixSuffixCreateManyArgs} args - Arguments to create many PrefixSuffixes.
     * @example
     * // Create many PrefixSuffixes
     * const prefixSuffix = await prisma.prefixSuffix.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends prefixSuffixCreateManyArgs>(args?: SelectSubset<T, prefixSuffixCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PrefixSuffix.
     * @param {prefixSuffixDeleteArgs} args - Arguments to delete one PrefixSuffix.
     * @example
     * // Delete one PrefixSuffix
     * const PrefixSuffix = await prisma.prefixSuffix.delete({
     *   where: {
     *     // ... filter to delete one PrefixSuffix
     *   }
     * })
     * 
     */
    delete<T extends prefixSuffixDeleteArgs>(args: SelectSubset<T, prefixSuffixDeleteArgs<ExtArgs>>): Prisma__prefixSuffixClient<$Result.GetResult<Prisma.$prefixSuffixPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PrefixSuffix.
     * @param {prefixSuffixUpdateArgs} args - Arguments to update one PrefixSuffix.
     * @example
     * // Update one PrefixSuffix
     * const prefixSuffix = await prisma.prefixSuffix.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends prefixSuffixUpdateArgs>(args: SelectSubset<T, prefixSuffixUpdateArgs<ExtArgs>>): Prisma__prefixSuffixClient<$Result.GetResult<Prisma.$prefixSuffixPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PrefixSuffixes.
     * @param {prefixSuffixDeleteManyArgs} args - Arguments to filter PrefixSuffixes to delete.
     * @example
     * // Delete a few PrefixSuffixes
     * const { count } = await prisma.prefixSuffix.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends prefixSuffixDeleteManyArgs>(args?: SelectSubset<T, prefixSuffixDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PrefixSuffixes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {prefixSuffixUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PrefixSuffixes
     * const prefixSuffix = await prisma.prefixSuffix.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends prefixSuffixUpdateManyArgs>(args: SelectSubset<T, prefixSuffixUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PrefixSuffix.
     * @param {prefixSuffixUpsertArgs} args - Arguments to update or create a PrefixSuffix.
     * @example
     * // Update or create a PrefixSuffix
     * const prefixSuffix = await prisma.prefixSuffix.upsert({
     *   create: {
     *     // ... data to create a PrefixSuffix
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PrefixSuffix we want to update
     *   }
     * })
     */
    upsert<T extends prefixSuffixUpsertArgs>(args: SelectSubset<T, prefixSuffixUpsertArgs<ExtArgs>>): Prisma__prefixSuffixClient<$Result.GetResult<Prisma.$prefixSuffixPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more PrefixSuffixes that matches the filter.
     * @param {prefixSuffixFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const prefixSuffix = await prisma.prefixSuffix.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: prefixSuffixFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a PrefixSuffix.
     * @param {prefixSuffixAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const prefixSuffix = await prisma.prefixSuffix.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: prefixSuffixAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of PrefixSuffixes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {prefixSuffixCountArgs} args - Arguments to filter PrefixSuffixes to count.
     * @example
     * // Count the number of PrefixSuffixes
     * const count = await prisma.prefixSuffix.count({
     *   where: {
     *     // ... the filter for the PrefixSuffixes we want to count
     *   }
     * })
    **/
    count<T extends prefixSuffixCountArgs>(
      args?: Subset<T, prefixSuffixCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PrefixSuffixCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PrefixSuffix.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrefixSuffixAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PrefixSuffixAggregateArgs>(args: Subset<T, PrefixSuffixAggregateArgs>): Prisma.PrismaPromise<GetPrefixSuffixAggregateType<T>>

    /**
     * Group by PrefixSuffix.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {prefixSuffixGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends prefixSuffixGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: prefixSuffixGroupByArgs['orderBy'] }
        : { orderBy?: prefixSuffixGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, prefixSuffixGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPrefixSuffixGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the prefixSuffix model
   */
  readonly fields: prefixSuffixFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for prefixSuffix.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__prefixSuffixClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organization<T extends prefixSuffix$organizationArgs<ExtArgs> = {}>(args?: Subset<T, prefixSuffix$organizationArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the prefixSuffix model
   */ 
  interface prefixSuffixFieldRefs {
    readonly id: FieldRef<"prefixSuffix", 'String'>
    readonly prefix: FieldRef<"prefixSuffix", 'String'>
    readonly suffix: FieldRef<"prefixSuffix", 'String'>
    readonly moduleType: FieldRef<"prefixSuffix", 'String'>
    readonly location: FieldRef<"prefixSuffix", 'String'>
    readonly organizationId: FieldRef<"prefixSuffix", 'String'>
    readonly createdBy: FieldRef<"prefixSuffix", 'String'>
    readonly createdAt: FieldRef<"prefixSuffix", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * prefixSuffix findUnique
   */
  export type prefixSuffixFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prefixSuffix
     */
    select?: prefixSuffixSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: prefixSuffixInclude<ExtArgs> | null
    /**
     * Filter, which prefixSuffix to fetch.
     */
    where: prefixSuffixWhereUniqueInput
  }

  /**
   * prefixSuffix findUniqueOrThrow
   */
  export type prefixSuffixFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prefixSuffix
     */
    select?: prefixSuffixSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: prefixSuffixInclude<ExtArgs> | null
    /**
     * Filter, which prefixSuffix to fetch.
     */
    where: prefixSuffixWhereUniqueInput
  }

  /**
   * prefixSuffix findFirst
   */
  export type prefixSuffixFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prefixSuffix
     */
    select?: prefixSuffixSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: prefixSuffixInclude<ExtArgs> | null
    /**
     * Filter, which prefixSuffix to fetch.
     */
    where?: prefixSuffixWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of prefixSuffixes to fetch.
     */
    orderBy?: prefixSuffixOrderByWithRelationInput | prefixSuffixOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for prefixSuffixes.
     */
    cursor?: prefixSuffixWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` prefixSuffixes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` prefixSuffixes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of prefixSuffixes.
     */
    distinct?: PrefixSuffixScalarFieldEnum | PrefixSuffixScalarFieldEnum[]
  }

  /**
   * prefixSuffix findFirstOrThrow
   */
  export type prefixSuffixFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prefixSuffix
     */
    select?: prefixSuffixSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: prefixSuffixInclude<ExtArgs> | null
    /**
     * Filter, which prefixSuffix to fetch.
     */
    where?: prefixSuffixWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of prefixSuffixes to fetch.
     */
    orderBy?: prefixSuffixOrderByWithRelationInput | prefixSuffixOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for prefixSuffixes.
     */
    cursor?: prefixSuffixWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` prefixSuffixes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` prefixSuffixes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of prefixSuffixes.
     */
    distinct?: PrefixSuffixScalarFieldEnum | PrefixSuffixScalarFieldEnum[]
  }

  /**
   * prefixSuffix findMany
   */
  export type prefixSuffixFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prefixSuffix
     */
    select?: prefixSuffixSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: prefixSuffixInclude<ExtArgs> | null
    /**
     * Filter, which prefixSuffixes to fetch.
     */
    where?: prefixSuffixWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of prefixSuffixes to fetch.
     */
    orderBy?: prefixSuffixOrderByWithRelationInput | prefixSuffixOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing prefixSuffixes.
     */
    cursor?: prefixSuffixWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` prefixSuffixes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` prefixSuffixes.
     */
    skip?: number
    distinct?: PrefixSuffixScalarFieldEnum | PrefixSuffixScalarFieldEnum[]
  }

  /**
   * prefixSuffix create
   */
  export type prefixSuffixCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prefixSuffix
     */
    select?: prefixSuffixSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: prefixSuffixInclude<ExtArgs> | null
    /**
     * The data needed to create a prefixSuffix.
     */
    data?: XOR<prefixSuffixCreateInput, prefixSuffixUncheckedCreateInput>
  }

  /**
   * prefixSuffix createMany
   */
  export type prefixSuffixCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many prefixSuffixes.
     */
    data: prefixSuffixCreateManyInput | prefixSuffixCreateManyInput[]
  }

  /**
   * prefixSuffix update
   */
  export type prefixSuffixUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prefixSuffix
     */
    select?: prefixSuffixSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: prefixSuffixInclude<ExtArgs> | null
    /**
     * The data needed to update a prefixSuffix.
     */
    data: XOR<prefixSuffixUpdateInput, prefixSuffixUncheckedUpdateInput>
    /**
     * Choose, which prefixSuffix to update.
     */
    where: prefixSuffixWhereUniqueInput
  }

  /**
   * prefixSuffix updateMany
   */
  export type prefixSuffixUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update prefixSuffixes.
     */
    data: XOR<prefixSuffixUpdateManyMutationInput, prefixSuffixUncheckedUpdateManyInput>
    /**
     * Filter which prefixSuffixes to update
     */
    where?: prefixSuffixWhereInput
  }

  /**
   * prefixSuffix upsert
   */
  export type prefixSuffixUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prefixSuffix
     */
    select?: prefixSuffixSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: prefixSuffixInclude<ExtArgs> | null
    /**
     * The filter to search for the prefixSuffix to update in case it exists.
     */
    where: prefixSuffixWhereUniqueInput
    /**
     * In case the prefixSuffix found by the `where` argument doesn't exist, create a new prefixSuffix with this data.
     */
    create: XOR<prefixSuffixCreateInput, prefixSuffixUncheckedCreateInput>
    /**
     * In case the prefixSuffix was found with the provided `where` argument, update it with this data.
     */
    update: XOR<prefixSuffixUpdateInput, prefixSuffixUncheckedUpdateInput>
  }

  /**
   * prefixSuffix delete
   */
  export type prefixSuffixDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prefixSuffix
     */
    select?: prefixSuffixSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: prefixSuffixInclude<ExtArgs> | null
    /**
     * Filter which prefixSuffix to delete.
     */
    where: prefixSuffixWhereUniqueInput
  }

  /**
   * prefixSuffix deleteMany
   */
  export type prefixSuffixDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which prefixSuffixes to delete
     */
    where?: prefixSuffixWhereInput
  }

  /**
   * prefixSuffix findRaw
   */
  export type prefixSuffixFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * prefixSuffix aggregateRaw
   */
  export type prefixSuffixAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * prefixSuffix.organization
   */
  export type prefixSuffix$organizationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    where?: OrganizationWhereInput
  }

  /**
   * prefixSuffix without action
   */
  export type prefixSuffixDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prefixSuffix
     */
    select?: prefixSuffixSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: prefixSuffixInclude<ExtArgs> | null
  }


  /**
   * Model serialNumber
   */

  export type AggregateSerialNumber = {
    _count: SerialNumberCountAggregateOutputType | null
    _avg: SerialNumberAvgAggregateOutputType | null
    _sum: SerialNumberSumAggregateOutputType | null
    _min: SerialNumberMinAggregateOutputType | null
    _max: SerialNumberMaxAggregateOutputType | null
  }

  export type SerialNumberAvgAggregateOutputType = {
    serialNumber: number | null
  }

  export type SerialNumberSumAggregateOutputType = {
    serialNumber: number | null
  }

  export type SerialNumberMinAggregateOutputType = {
    id: string | null
    moduleType: string | null
    location: string | null
    entity: string | null
    year: string | null
    tid: string | null
    serialNumber: number | null
    createdBy: string | null
    createdAt: Date | null
    organizationId: string | null
  }

  export type SerialNumberMaxAggregateOutputType = {
    id: string | null
    moduleType: string | null
    location: string | null
    entity: string | null
    year: string | null
    tid: string | null
    serialNumber: number | null
    createdBy: string | null
    createdAt: Date | null
    organizationId: string | null
  }

  export type SerialNumberCountAggregateOutputType = {
    id: number
    moduleType: number
    location: number
    entity: number
    year: number
    tid: number
    serialNumber: number
    createdBy: number
    createdAt: number
    organizationId: number
    _all: number
  }


  export type SerialNumberAvgAggregateInputType = {
    serialNumber?: true
  }

  export type SerialNumberSumAggregateInputType = {
    serialNumber?: true
  }

  export type SerialNumberMinAggregateInputType = {
    id?: true
    moduleType?: true
    location?: true
    entity?: true
    year?: true
    tid?: true
    serialNumber?: true
    createdBy?: true
    createdAt?: true
    organizationId?: true
  }

  export type SerialNumberMaxAggregateInputType = {
    id?: true
    moduleType?: true
    location?: true
    entity?: true
    year?: true
    tid?: true
    serialNumber?: true
    createdBy?: true
    createdAt?: true
    organizationId?: true
  }

  export type SerialNumberCountAggregateInputType = {
    id?: true
    moduleType?: true
    location?: true
    entity?: true
    year?: true
    tid?: true
    serialNumber?: true
    createdBy?: true
    createdAt?: true
    organizationId?: true
    _all?: true
  }

  export type SerialNumberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which serialNumber to aggregate.
     */
    where?: serialNumberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of serialNumbers to fetch.
     */
    orderBy?: serialNumberOrderByWithRelationInput | serialNumberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: serialNumberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` serialNumbers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` serialNumbers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned serialNumbers
    **/
    _count?: true | SerialNumberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SerialNumberAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SerialNumberSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SerialNumberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SerialNumberMaxAggregateInputType
  }

  export type GetSerialNumberAggregateType<T extends SerialNumberAggregateArgs> = {
        [P in keyof T & keyof AggregateSerialNumber]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSerialNumber[P]>
      : GetScalarType<T[P], AggregateSerialNumber[P]>
  }




  export type serialNumberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: serialNumberWhereInput
    orderBy?: serialNumberOrderByWithAggregationInput | serialNumberOrderByWithAggregationInput[]
    by: SerialNumberScalarFieldEnum[] | SerialNumberScalarFieldEnum
    having?: serialNumberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SerialNumberCountAggregateInputType | true
    _avg?: SerialNumberAvgAggregateInputType
    _sum?: SerialNumberSumAggregateInputType
    _min?: SerialNumberMinAggregateInputType
    _max?: SerialNumberMaxAggregateInputType
  }

  export type SerialNumberGroupByOutputType = {
    id: string
    moduleType: string | null
    location: string | null
    entity: string | null
    year: string | null
    tid: string | null
    serialNumber: number
    createdBy: string | null
    createdAt: Date
    organizationId: string | null
    _count: SerialNumberCountAggregateOutputType | null
    _avg: SerialNumberAvgAggregateOutputType | null
    _sum: SerialNumberSumAggregateOutputType | null
    _min: SerialNumberMinAggregateOutputType | null
    _max: SerialNumberMaxAggregateOutputType | null
  }

  type GetSerialNumberGroupByPayload<T extends serialNumberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SerialNumberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SerialNumberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SerialNumberGroupByOutputType[P]>
            : GetScalarType<T[P], SerialNumberGroupByOutputType[P]>
        }
      >
    >


  export type serialNumberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    moduleType?: boolean
    location?: boolean
    entity?: boolean
    year?: boolean
    tid?: boolean
    serialNumber?: boolean
    createdBy?: boolean
    createdAt?: boolean
    organizationId?: boolean
    organization?: boolean | serialNumber$organizationArgs<ExtArgs>
  }, ExtArgs["result"]["serialNumber"]>


  export type serialNumberSelectScalar = {
    id?: boolean
    moduleType?: boolean
    location?: boolean
    entity?: boolean
    year?: boolean
    tid?: boolean
    serialNumber?: boolean
    createdBy?: boolean
    createdAt?: boolean
    organizationId?: boolean
  }

  export type serialNumberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | serialNumber$organizationArgs<ExtArgs>
  }

  export type $serialNumberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "serialNumber"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      moduleType: string | null
      location: string | null
      entity: string | null
      year: string | null
      tid: string | null
      serialNumber: number
      createdBy: string | null
      createdAt: Date
      organizationId: string | null
    }, ExtArgs["result"]["serialNumber"]>
    composites: {}
  }

  type serialNumberGetPayload<S extends boolean | null | undefined | serialNumberDefaultArgs> = $Result.GetResult<Prisma.$serialNumberPayload, S>

  type serialNumberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<serialNumberFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SerialNumberCountAggregateInputType | true
    }

  export interface serialNumberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['serialNumber'], meta: { name: 'serialNumber' } }
    /**
     * Find zero or one SerialNumber that matches the filter.
     * @param {serialNumberFindUniqueArgs} args - Arguments to find a SerialNumber
     * @example
     * // Get one SerialNumber
     * const serialNumber = await prisma.serialNumber.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends serialNumberFindUniqueArgs>(args: SelectSubset<T, serialNumberFindUniqueArgs<ExtArgs>>): Prisma__serialNumberClient<$Result.GetResult<Prisma.$serialNumberPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SerialNumber that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {serialNumberFindUniqueOrThrowArgs} args - Arguments to find a SerialNumber
     * @example
     * // Get one SerialNumber
     * const serialNumber = await prisma.serialNumber.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends serialNumberFindUniqueOrThrowArgs>(args: SelectSubset<T, serialNumberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__serialNumberClient<$Result.GetResult<Prisma.$serialNumberPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SerialNumber that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serialNumberFindFirstArgs} args - Arguments to find a SerialNumber
     * @example
     * // Get one SerialNumber
     * const serialNumber = await prisma.serialNumber.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends serialNumberFindFirstArgs>(args?: SelectSubset<T, serialNumberFindFirstArgs<ExtArgs>>): Prisma__serialNumberClient<$Result.GetResult<Prisma.$serialNumberPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SerialNumber that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serialNumberFindFirstOrThrowArgs} args - Arguments to find a SerialNumber
     * @example
     * // Get one SerialNumber
     * const serialNumber = await prisma.serialNumber.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends serialNumberFindFirstOrThrowArgs>(args?: SelectSubset<T, serialNumberFindFirstOrThrowArgs<ExtArgs>>): Prisma__serialNumberClient<$Result.GetResult<Prisma.$serialNumberPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SerialNumbers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serialNumberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SerialNumbers
     * const serialNumbers = await prisma.serialNumber.findMany()
     * 
     * // Get first 10 SerialNumbers
     * const serialNumbers = await prisma.serialNumber.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serialNumberWithIdOnly = await prisma.serialNumber.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends serialNumberFindManyArgs>(args?: SelectSubset<T, serialNumberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$serialNumberPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SerialNumber.
     * @param {serialNumberCreateArgs} args - Arguments to create a SerialNumber.
     * @example
     * // Create one SerialNumber
     * const SerialNumber = await prisma.serialNumber.create({
     *   data: {
     *     // ... data to create a SerialNumber
     *   }
     * })
     * 
     */
    create<T extends serialNumberCreateArgs>(args: SelectSubset<T, serialNumberCreateArgs<ExtArgs>>): Prisma__serialNumberClient<$Result.GetResult<Prisma.$serialNumberPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SerialNumbers.
     * @param {serialNumberCreateManyArgs} args - Arguments to create many SerialNumbers.
     * @example
     * // Create many SerialNumbers
     * const serialNumber = await prisma.serialNumber.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends serialNumberCreateManyArgs>(args?: SelectSubset<T, serialNumberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SerialNumber.
     * @param {serialNumberDeleteArgs} args - Arguments to delete one SerialNumber.
     * @example
     * // Delete one SerialNumber
     * const SerialNumber = await prisma.serialNumber.delete({
     *   where: {
     *     // ... filter to delete one SerialNumber
     *   }
     * })
     * 
     */
    delete<T extends serialNumberDeleteArgs>(args: SelectSubset<T, serialNumberDeleteArgs<ExtArgs>>): Prisma__serialNumberClient<$Result.GetResult<Prisma.$serialNumberPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SerialNumber.
     * @param {serialNumberUpdateArgs} args - Arguments to update one SerialNumber.
     * @example
     * // Update one SerialNumber
     * const serialNumber = await prisma.serialNumber.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends serialNumberUpdateArgs>(args: SelectSubset<T, serialNumberUpdateArgs<ExtArgs>>): Prisma__serialNumberClient<$Result.GetResult<Prisma.$serialNumberPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SerialNumbers.
     * @param {serialNumberDeleteManyArgs} args - Arguments to filter SerialNumbers to delete.
     * @example
     * // Delete a few SerialNumbers
     * const { count } = await prisma.serialNumber.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends serialNumberDeleteManyArgs>(args?: SelectSubset<T, serialNumberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SerialNumbers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serialNumberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SerialNumbers
     * const serialNumber = await prisma.serialNumber.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends serialNumberUpdateManyArgs>(args: SelectSubset<T, serialNumberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SerialNumber.
     * @param {serialNumberUpsertArgs} args - Arguments to update or create a SerialNumber.
     * @example
     * // Update or create a SerialNumber
     * const serialNumber = await prisma.serialNumber.upsert({
     *   create: {
     *     // ... data to create a SerialNumber
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SerialNumber we want to update
     *   }
     * })
     */
    upsert<T extends serialNumberUpsertArgs>(args: SelectSubset<T, serialNumberUpsertArgs<ExtArgs>>): Prisma__serialNumberClient<$Result.GetResult<Prisma.$serialNumberPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more SerialNumbers that matches the filter.
     * @param {serialNumberFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const serialNumber = await prisma.serialNumber.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: serialNumberFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a SerialNumber.
     * @param {serialNumberAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const serialNumber = await prisma.serialNumber.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: serialNumberAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of SerialNumbers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serialNumberCountArgs} args - Arguments to filter SerialNumbers to count.
     * @example
     * // Count the number of SerialNumbers
     * const count = await prisma.serialNumber.count({
     *   where: {
     *     // ... the filter for the SerialNumbers we want to count
     *   }
     * })
    **/
    count<T extends serialNumberCountArgs>(
      args?: Subset<T, serialNumberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SerialNumberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SerialNumber.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SerialNumberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SerialNumberAggregateArgs>(args: Subset<T, SerialNumberAggregateArgs>): Prisma.PrismaPromise<GetSerialNumberAggregateType<T>>

    /**
     * Group by SerialNumber.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serialNumberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends serialNumberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: serialNumberGroupByArgs['orderBy'] }
        : { orderBy?: serialNumberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, serialNumberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSerialNumberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the serialNumber model
   */
  readonly fields: serialNumberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for serialNumber.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__serialNumberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organization<T extends serialNumber$organizationArgs<ExtArgs> = {}>(args?: Subset<T, serialNumber$organizationArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the serialNumber model
   */ 
  interface serialNumberFieldRefs {
    readonly id: FieldRef<"serialNumber", 'String'>
    readonly moduleType: FieldRef<"serialNumber", 'String'>
    readonly location: FieldRef<"serialNumber", 'String'>
    readonly entity: FieldRef<"serialNumber", 'String'>
    readonly year: FieldRef<"serialNumber", 'String'>
    readonly tid: FieldRef<"serialNumber", 'String'>
    readonly serialNumber: FieldRef<"serialNumber", 'Int'>
    readonly createdBy: FieldRef<"serialNumber", 'String'>
    readonly createdAt: FieldRef<"serialNumber", 'DateTime'>
    readonly organizationId: FieldRef<"serialNumber", 'String'>
  }
    

  // Custom InputTypes
  /**
   * serialNumber findUnique
   */
  export type serialNumberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serialNumber
     */
    select?: serialNumberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serialNumberInclude<ExtArgs> | null
    /**
     * Filter, which serialNumber to fetch.
     */
    where: serialNumberWhereUniqueInput
  }

  /**
   * serialNumber findUniqueOrThrow
   */
  export type serialNumberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serialNumber
     */
    select?: serialNumberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serialNumberInclude<ExtArgs> | null
    /**
     * Filter, which serialNumber to fetch.
     */
    where: serialNumberWhereUniqueInput
  }

  /**
   * serialNumber findFirst
   */
  export type serialNumberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serialNumber
     */
    select?: serialNumberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serialNumberInclude<ExtArgs> | null
    /**
     * Filter, which serialNumber to fetch.
     */
    where?: serialNumberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of serialNumbers to fetch.
     */
    orderBy?: serialNumberOrderByWithRelationInput | serialNumberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for serialNumbers.
     */
    cursor?: serialNumberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` serialNumbers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` serialNumbers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of serialNumbers.
     */
    distinct?: SerialNumberScalarFieldEnum | SerialNumberScalarFieldEnum[]
  }

  /**
   * serialNumber findFirstOrThrow
   */
  export type serialNumberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serialNumber
     */
    select?: serialNumberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serialNumberInclude<ExtArgs> | null
    /**
     * Filter, which serialNumber to fetch.
     */
    where?: serialNumberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of serialNumbers to fetch.
     */
    orderBy?: serialNumberOrderByWithRelationInput | serialNumberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for serialNumbers.
     */
    cursor?: serialNumberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` serialNumbers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` serialNumbers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of serialNumbers.
     */
    distinct?: SerialNumberScalarFieldEnum | SerialNumberScalarFieldEnum[]
  }

  /**
   * serialNumber findMany
   */
  export type serialNumberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serialNumber
     */
    select?: serialNumberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serialNumberInclude<ExtArgs> | null
    /**
     * Filter, which serialNumbers to fetch.
     */
    where?: serialNumberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of serialNumbers to fetch.
     */
    orderBy?: serialNumberOrderByWithRelationInput | serialNumberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing serialNumbers.
     */
    cursor?: serialNumberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` serialNumbers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` serialNumbers.
     */
    skip?: number
    distinct?: SerialNumberScalarFieldEnum | SerialNumberScalarFieldEnum[]
  }

  /**
   * serialNumber create
   */
  export type serialNumberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serialNumber
     */
    select?: serialNumberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serialNumberInclude<ExtArgs> | null
    /**
     * The data needed to create a serialNumber.
     */
    data?: XOR<serialNumberCreateInput, serialNumberUncheckedCreateInput>
  }

  /**
   * serialNumber createMany
   */
  export type serialNumberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many serialNumbers.
     */
    data: serialNumberCreateManyInput | serialNumberCreateManyInput[]
  }

  /**
   * serialNumber update
   */
  export type serialNumberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serialNumber
     */
    select?: serialNumberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serialNumberInclude<ExtArgs> | null
    /**
     * The data needed to update a serialNumber.
     */
    data: XOR<serialNumberUpdateInput, serialNumberUncheckedUpdateInput>
    /**
     * Choose, which serialNumber to update.
     */
    where: serialNumberWhereUniqueInput
  }

  /**
   * serialNumber updateMany
   */
  export type serialNumberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update serialNumbers.
     */
    data: XOR<serialNumberUpdateManyMutationInput, serialNumberUncheckedUpdateManyInput>
    /**
     * Filter which serialNumbers to update
     */
    where?: serialNumberWhereInput
  }

  /**
   * serialNumber upsert
   */
  export type serialNumberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serialNumber
     */
    select?: serialNumberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serialNumberInclude<ExtArgs> | null
    /**
     * The filter to search for the serialNumber to update in case it exists.
     */
    where: serialNumberWhereUniqueInput
    /**
     * In case the serialNumber found by the `where` argument doesn't exist, create a new serialNumber with this data.
     */
    create: XOR<serialNumberCreateInput, serialNumberUncheckedCreateInput>
    /**
     * In case the serialNumber was found with the provided `where` argument, update it with this data.
     */
    update: XOR<serialNumberUpdateInput, serialNumberUncheckedUpdateInput>
  }

  /**
   * serialNumber delete
   */
  export type serialNumberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serialNumber
     */
    select?: serialNumberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serialNumberInclude<ExtArgs> | null
    /**
     * Filter which serialNumber to delete.
     */
    where: serialNumberWhereUniqueInput
  }

  /**
   * serialNumber deleteMany
   */
  export type serialNumberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which serialNumbers to delete
     */
    where?: serialNumberWhereInput
  }

  /**
   * serialNumber findRaw
   */
  export type serialNumberFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * serialNumber aggregateRaw
   */
  export type serialNumberAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * serialNumber.organization
   */
  export type serialNumber$organizationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    where?: OrganizationWhereInput
  }

  /**
   * serialNumber without action
   */
  export type serialNumberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serialNumber
     */
    select?: serialNumberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serialNumberInclude<ExtArgs> | null
  }


  /**
   * Model rolesTable
   */

  export type AggregateRolesTable = {
    _count: RolesTableCountAggregateOutputType | null
    _min: RolesTableMinAggregateOutputType | null
    _max: RolesTableMaxAggregateOutputType | null
  }

  export type RolesTableMinAggregateOutputType = {
    id: string | null
    orgId: string | null
    unitId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RolesTableMaxAggregateOutputType = {
    id: string | null
    orgId: string | null
    unitId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RolesTableCountAggregateOutputType = {
    id: number
    orgId: number
    unitId: number
    users: number
    roleId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RolesTableMinAggregateInputType = {
    id?: true
    orgId?: true
    unitId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RolesTableMaxAggregateInputType = {
    id?: true
    orgId?: true
    unitId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RolesTableCountAggregateInputType = {
    id?: true
    orgId?: true
    unitId?: true
    users?: true
    roleId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RolesTableAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which rolesTable to aggregate.
     */
    where?: rolesTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rolesTables to fetch.
     */
    orderBy?: rolesTableOrderByWithRelationInput | rolesTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: rolesTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rolesTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rolesTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned rolesTables
    **/
    _count?: true | RolesTableCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RolesTableMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RolesTableMaxAggregateInputType
  }

  export type GetRolesTableAggregateType<T extends RolesTableAggregateArgs> = {
        [P in keyof T & keyof AggregateRolesTable]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRolesTable[P]>
      : GetScalarType<T[P], AggregateRolesTable[P]>
  }




  export type rolesTableGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: rolesTableWhereInput
    orderBy?: rolesTableOrderByWithAggregationInput | rolesTableOrderByWithAggregationInput[]
    by: RolesTableScalarFieldEnum[] | RolesTableScalarFieldEnum
    having?: rolesTableScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RolesTableCountAggregateInputType | true
    _min?: RolesTableMinAggregateInputType
    _max?: RolesTableMaxAggregateInputType
  }

  export type RolesTableGroupByOutputType = {
    id: string
    orgId: string
    unitId: string
    users: string[]
    roleId: string[]
    createdAt: Date
    updatedAt: Date
    _count: RolesTableCountAggregateOutputType | null
    _min: RolesTableMinAggregateOutputType | null
    _max: RolesTableMaxAggregateOutputType | null
  }

  type GetRolesTableGroupByPayload<T extends rolesTableGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RolesTableGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RolesTableGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RolesTableGroupByOutputType[P]>
            : GetScalarType<T[P], RolesTableGroupByOutputType[P]>
        }
      >
    >


  export type rolesTableSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    unitId?: boolean
    users?: boolean
    roleId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rolesTable"]>


  export type rolesTableSelectScalar = {
    id?: boolean
    orgId?: boolean
    unitId?: boolean
    users?: boolean
    roleId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type rolesTableInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }

  export type $rolesTablePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "rolesTable"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs>
      location: Prisma.$LocationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orgId: string
      unitId: string
      users: string[]
      roleId: string[]
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["rolesTable"]>
    composites: {}
  }

  type rolesTableGetPayload<S extends boolean | null | undefined | rolesTableDefaultArgs> = $Result.GetResult<Prisma.$rolesTablePayload, S>

  type rolesTableCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<rolesTableFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RolesTableCountAggregateInputType | true
    }

  export interface rolesTableDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['rolesTable'], meta: { name: 'rolesTable' } }
    /**
     * Find zero or one RolesTable that matches the filter.
     * @param {rolesTableFindUniqueArgs} args - Arguments to find a RolesTable
     * @example
     * // Get one RolesTable
     * const rolesTable = await prisma.rolesTable.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends rolesTableFindUniqueArgs>(args: SelectSubset<T, rolesTableFindUniqueArgs<ExtArgs>>): Prisma__rolesTableClient<$Result.GetResult<Prisma.$rolesTablePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RolesTable that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {rolesTableFindUniqueOrThrowArgs} args - Arguments to find a RolesTable
     * @example
     * // Get one RolesTable
     * const rolesTable = await prisma.rolesTable.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends rolesTableFindUniqueOrThrowArgs>(args: SelectSubset<T, rolesTableFindUniqueOrThrowArgs<ExtArgs>>): Prisma__rolesTableClient<$Result.GetResult<Prisma.$rolesTablePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RolesTable that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesTableFindFirstArgs} args - Arguments to find a RolesTable
     * @example
     * // Get one RolesTable
     * const rolesTable = await prisma.rolesTable.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends rolesTableFindFirstArgs>(args?: SelectSubset<T, rolesTableFindFirstArgs<ExtArgs>>): Prisma__rolesTableClient<$Result.GetResult<Prisma.$rolesTablePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RolesTable that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesTableFindFirstOrThrowArgs} args - Arguments to find a RolesTable
     * @example
     * // Get one RolesTable
     * const rolesTable = await prisma.rolesTable.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends rolesTableFindFirstOrThrowArgs>(args?: SelectSubset<T, rolesTableFindFirstOrThrowArgs<ExtArgs>>): Prisma__rolesTableClient<$Result.GetResult<Prisma.$rolesTablePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RolesTables that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesTableFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RolesTables
     * const rolesTables = await prisma.rolesTable.findMany()
     * 
     * // Get first 10 RolesTables
     * const rolesTables = await prisma.rolesTable.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rolesTableWithIdOnly = await prisma.rolesTable.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends rolesTableFindManyArgs>(args?: SelectSubset<T, rolesTableFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rolesTablePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RolesTable.
     * @param {rolesTableCreateArgs} args - Arguments to create a RolesTable.
     * @example
     * // Create one RolesTable
     * const RolesTable = await prisma.rolesTable.create({
     *   data: {
     *     // ... data to create a RolesTable
     *   }
     * })
     * 
     */
    create<T extends rolesTableCreateArgs>(args: SelectSubset<T, rolesTableCreateArgs<ExtArgs>>): Prisma__rolesTableClient<$Result.GetResult<Prisma.$rolesTablePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RolesTables.
     * @param {rolesTableCreateManyArgs} args - Arguments to create many RolesTables.
     * @example
     * // Create many RolesTables
     * const rolesTable = await prisma.rolesTable.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends rolesTableCreateManyArgs>(args?: SelectSubset<T, rolesTableCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RolesTable.
     * @param {rolesTableDeleteArgs} args - Arguments to delete one RolesTable.
     * @example
     * // Delete one RolesTable
     * const RolesTable = await prisma.rolesTable.delete({
     *   where: {
     *     // ... filter to delete one RolesTable
     *   }
     * })
     * 
     */
    delete<T extends rolesTableDeleteArgs>(args: SelectSubset<T, rolesTableDeleteArgs<ExtArgs>>): Prisma__rolesTableClient<$Result.GetResult<Prisma.$rolesTablePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RolesTable.
     * @param {rolesTableUpdateArgs} args - Arguments to update one RolesTable.
     * @example
     * // Update one RolesTable
     * const rolesTable = await prisma.rolesTable.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends rolesTableUpdateArgs>(args: SelectSubset<T, rolesTableUpdateArgs<ExtArgs>>): Prisma__rolesTableClient<$Result.GetResult<Prisma.$rolesTablePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RolesTables.
     * @param {rolesTableDeleteManyArgs} args - Arguments to filter RolesTables to delete.
     * @example
     * // Delete a few RolesTables
     * const { count } = await prisma.rolesTable.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends rolesTableDeleteManyArgs>(args?: SelectSubset<T, rolesTableDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RolesTables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesTableUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RolesTables
     * const rolesTable = await prisma.rolesTable.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends rolesTableUpdateManyArgs>(args: SelectSubset<T, rolesTableUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RolesTable.
     * @param {rolesTableUpsertArgs} args - Arguments to update or create a RolesTable.
     * @example
     * // Update or create a RolesTable
     * const rolesTable = await prisma.rolesTable.upsert({
     *   create: {
     *     // ... data to create a RolesTable
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RolesTable we want to update
     *   }
     * })
     */
    upsert<T extends rolesTableUpsertArgs>(args: SelectSubset<T, rolesTableUpsertArgs<ExtArgs>>): Prisma__rolesTableClient<$Result.GetResult<Prisma.$rolesTablePayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more RolesTables that matches the filter.
     * @param {rolesTableFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const rolesTable = await prisma.rolesTable.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: rolesTableFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a RolesTable.
     * @param {rolesTableAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const rolesTable = await prisma.rolesTable.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: rolesTableAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of RolesTables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesTableCountArgs} args - Arguments to filter RolesTables to count.
     * @example
     * // Count the number of RolesTables
     * const count = await prisma.rolesTable.count({
     *   where: {
     *     // ... the filter for the RolesTables we want to count
     *   }
     * })
    **/
    count<T extends rolesTableCountArgs>(
      args?: Subset<T, rolesTableCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RolesTableCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RolesTable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesTableAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RolesTableAggregateArgs>(args: Subset<T, RolesTableAggregateArgs>): Prisma.PrismaPromise<GetRolesTableAggregateType<T>>

    /**
     * Group by RolesTable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesTableGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends rolesTableGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: rolesTableGroupByArgs['orderBy'] }
        : { orderBy?: rolesTableGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, rolesTableGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRolesTableGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the rolesTable model
   */
  readonly fields: rolesTableFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for rolesTable.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__rolesTableClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    location<T extends LocationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LocationDefaultArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the rolesTable model
   */ 
  interface rolesTableFieldRefs {
    readonly id: FieldRef<"rolesTable", 'String'>
    readonly orgId: FieldRef<"rolesTable", 'String'>
    readonly unitId: FieldRef<"rolesTable", 'String'>
    readonly users: FieldRef<"rolesTable", 'String[]'>
    readonly roleId: FieldRef<"rolesTable", 'String[]'>
    readonly createdAt: FieldRef<"rolesTable", 'DateTime'>
    readonly updatedAt: FieldRef<"rolesTable", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * rolesTable findUnique
   */
  export type rolesTableFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rolesTable
     */
    select?: rolesTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesTableInclude<ExtArgs> | null
    /**
     * Filter, which rolesTable to fetch.
     */
    where: rolesTableWhereUniqueInput
  }

  /**
   * rolesTable findUniqueOrThrow
   */
  export type rolesTableFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rolesTable
     */
    select?: rolesTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesTableInclude<ExtArgs> | null
    /**
     * Filter, which rolesTable to fetch.
     */
    where: rolesTableWhereUniqueInput
  }

  /**
   * rolesTable findFirst
   */
  export type rolesTableFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rolesTable
     */
    select?: rolesTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesTableInclude<ExtArgs> | null
    /**
     * Filter, which rolesTable to fetch.
     */
    where?: rolesTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rolesTables to fetch.
     */
    orderBy?: rolesTableOrderByWithRelationInput | rolesTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for rolesTables.
     */
    cursor?: rolesTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rolesTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rolesTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of rolesTables.
     */
    distinct?: RolesTableScalarFieldEnum | RolesTableScalarFieldEnum[]
  }

  /**
   * rolesTable findFirstOrThrow
   */
  export type rolesTableFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rolesTable
     */
    select?: rolesTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesTableInclude<ExtArgs> | null
    /**
     * Filter, which rolesTable to fetch.
     */
    where?: rolesTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rolesTables to fetch.
     */
    orderBy?: rolesTableOrderByWithRelationInput | rolesTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for rolesTables.
     */
    cursor?: rolesTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rolesTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rolesTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of rolesTables.
     */
    distinct?: RolesTableScalarFieldEnum | RolesTableScalarFieldEnum[]
  }

  /**
   * rolesTable findMany
   */
  export type rolesTableFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rolesTable
     */
    select?: rolesTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesTableInclude<ExtArgs> | null
    /**
     * Filter, which rolesTables to fetch.
     */
    where?: rolesTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rolesTables to fetch.
     */
    orderBy?: rolesTableOrderByWithRelationInput | rolesTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing rolesTables.
     */
    cursor?: rolesTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rolesTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rolesTables.
     */
    skip?: number
    distinct?: RolesTableScalarFieldEnum | RolesTableScalarFieldEnum[]
  }

  /**
   * rolesTable create
   */
  export type rolesTableCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rolesTable
     */
    select?: rolesTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesTableInclude<ExtArgs> | null
    /**
     * The data needed to create a rolesTable.
     */
    data: XOR<rolesTableCreateInput, rolesTableUncheckedCreateInput>
  }

  /**
   * rolesTable createMany
   */
  export type rolesTableCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many rolesTables.
     */
    data: rolesTableCreateManyInput | rolesTableCreateManyInput[]
  }

  /**
   * rolesTable update
   */
  export type rolesTableUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rolesTable
     */
    select?: rolesTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesTableInclude<ExtArgs> | null
    /**
     * The data needed to update a rolesTable.
     */
    data: XOR<rolesTableUpdateInput, rolesTableUncheckedUpdateInput>
    /**
     * Choose, which rolesTable to update.
     */
    where: rolesTableWhereUniqueInput
  }

  /**
   * rolesTable updateMany
   */
  export type rolesTableUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update rolesTables.
     */
    data: XOR<rolesTableUpdateManyMutationInput, rolesTableUncheckedUpdateManyInput>
    /**
     * Filter which rolesTables to update
     */
    where?: rolesTableWhereInput
  }

  /**
   * rolesTable upsert
   */
  export type rolesTableUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rolesTable
     */
    select?: rolesTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesTableInclude<ExtArgs> | null
    /**
     * The filter to search for the rolesTable to update in case it exists.
     */
    where: rolesTableWhereUniqueInput
    /**
     * In case the rolesTable found by the `where` argument doesn't exist, create a new rolesTable with this data.
     */
    create: XOR<rolesTableCreateInput, rolesTableUncheckedCreateInput>
    /**
     * In case the rolesTable was found with the provided `where` argument, update it with this data.
     */
    update: XOR<rolesTableUpdateInput, rolesTableUncheckedUpdateInput>
  }

  /**
   * rolesTable delete
   */
  export type rolesTableDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rolesTable
     */
    select?: rolesTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesTableInclude<ExtArgs> | null
    /**
     * Filter which rolesTable to delete.
     */
    where: rolesTableWhereUniqueInput
  }

  /**
   * rolesTable deleteMany
   */
  export type rolesTableDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which rolesTables to delete
     */
    where?: rolesTableWhereInput
  }

  /**
   * rolesTable findRaw
   */
  export type rolesTableFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * rolesTable aggregateRaw
   */
  export type rolesTableAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * rolesTable without action
   */
  export type rolesTableDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rolesTable
     */
    select?: rolesTableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesTableInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const UserScalarFieldEnum: {
    id: 'id',
    kcId: 'kcId',
    email: 'email',
    username: 'username',
    firstname: 'firstname',
    lastname: 'lastname',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy',
    enabled: 'enabled',
    organizationId: 'organizationId',
    locationId: 'locationId',
    entityId: 'entityId',
    userType: 'userType',
    status: 'status',
    avatar: 'avatar',
    deleted: 'deleted',
    roleId: 'roleId',
    functionId: 'functionId',
    additionalUnits: 'additionalUnits'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const ModelsScalarFieldEnum: {
    id: 'id',
    modelNo: 'modelNo',
    modelName: 'modelName',
    description: 'description',
    organizationId: 'organizationId',
    partsId: 'partsId',
    claimId: 'claimId'
  };

  export type ModelsScalarFieldEnum = (typeof ModelsScalarFieldEnum)[keyof typeof ModelsScalarFieldEnum]


  export const PartsScalarFieldEnum: {
    id: 'id',
    partNo: 'partNo',
    partName: 'partName',
    description: 'description',
    organizationId: 'organizationId',
    entityId: 'entityId',
    claimId: 'claimId',
    modelsId: 'modelsId'
  };

  export type PartsScalarFieldEnum = (typeof PartsScalarFieldEnum)[keyof typeof PartsScalarFieldEnum]


  export const ClaimScalarFieldEnum: {
    id: 'id',
    partId: 'partId',
    modelId: 'modelId',
    partRecieptDate: 'partRecieptDate',
    vehicleType: 'vehicleType',
    FrameNo: 'FrameNo',
    prNo: 'prNo',
    lineOffDate: 'lineOffDate',
    saleDate: 'saleDate',
    repairDate: 'repairDate',
    shipmentId: 'shipmentId',
    investigationId: 'investigationId',
    settleMonth: 'settleMonth',
    kms: 'kms',
    problemId: 'problemId',
    mis: 'mis',
    claimNo: 'claimNo'
  };

  export type ClaimScalarFieldEnum = (typeof ClaimScalarFieldEnum)[keyof typeof ClaimScalarFieldEnum]


  export const ProblemScalarFieldEnum: {
    id: 'id',
    problem: 'problem',
    createdAt: 'createdAt',
    organizationId: 'organizationId'
  };

  export type ProblemScalarFieldEnum = (typeof ProblemScalarFieldEnum)[keyof typeof ProblemScalarFieldEnum]


  export const ClaimToEntityScalarFieldEnum: {
    id: 'id',
    claimId: 'claimId',
    entityId: 'entityId'
  };

  export type ClaimToEntityScalarFieldEnum = (typeof ClaimToEntityScalarFieldEnum)[keyof typeof ClaimToEntityScalarFieldEnum]


  export const InvestigationScalarFieldEnum: {
    id: 'id',
    rootCause: 'rootCause',
    counterMeasure: 'counterMeasure',
    leadTime: 'leadTime',
    claimType: 'claimType',
    implementDate: 'implementDate',
    attachment: 'attachment',
    claimNo: 'claimNo',
    problemId: 'problemId'
  };

  export type InvestigationScalarFieldEnum = (typeof InvestigationScalarFieldEnum)[keyof typeof InvestigationScalarFieldEnum]


  export const ShipmentScalarFieldEnum: {
    id: 'id',
    shipmentDate: 'shipmentDate',
    quantity: 'quantity',
    location: 'location',
    InvoiceNumber: 'InvoiceNumber',
    dueDate: 'dueDate',
    shipmentCost: 'shipmentCost',
    createdBy: 'createdBy',
    awb: 'awb',
    supplierName: 'supplierName',
    supplierReport: 'supplierReport'
  };

  export type ShipmentScalarFieldEnum = (typeof ShipmentScalarFieldEnum)[keyof typeof ShipmentScalarFieldEnum]


  export const OrganizationScalarFieldEnum: {
    id: 'id',
    kcId: 'kcId',
    organizationName: 'organizationName',
    realmName: 'realmName',
    instanceUrl: 'instanceUrl',
    principalGeography: 'principalGeography',
    loginUrl: 'loginUrl',
    logoutUrl: 'logoutUrl',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy',
    activeModules: 'activeModules',
    clientID: 'clientID',
    clientSecret: 'clientSecret',
    fiscalYearQuarters: 'fiscalYearQuarters',
    fiscalYearFormat: 'fiscalYearFormat',
    auditYear: 'auditYear',
    logoUrl: 'logoUrl',
    deleted: 'deleted'
  };

  export type OrganizationScalarFieldEnum = (typeof OrganizationScalarFieldEnum)[keyof typeof OrganizationScalarFieldEnum]


  export const RoleScalarFieldEnum: {
    id: 'id',
    kcId: 'kcId',
    roleName: 'roleName',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy',
    deleted: 'deleted',
    organizationId: 'organizationId',
    locationId: 'locationId'
  };

  export type RoleScalarFieldEnum = (typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum]


  export const SystemTypeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    color: 'color',
    updatedBy: 'updatedBy',
    deleted: 'deleted',
    organizationId: 'organizationId'
  };

  export type SystemTypeScalarFieldEnum = (typeof SystemTypeScalarFieldEnum)[keyof typeof SystemTypeScalarFieldEnum]


  export const EntityTypeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy',
    organizationId: 'organizationId',
    deleted: 'deleted'
  };

  export type EntityTypeScalarFieldEnum = (typeof EntityTypeScalarFieldEnum)[keyof typeof EntityTypeScalarFieldEnum]


  export const BusinessTypeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    deleted: 'deleted',
    organizationId: 'organizationId'
  };

  export type BusinessTypeScalarFieldEnum = (typeof BusinessTypeScalarFieldEnum)[keyof typeof BusinessTypeScalarFieldEnum]


  export const BusinessScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy',
    organizationId: 'organizationId',
    deleted: 'deleted'
  };

  export type BusinessScalarFieldEnum = (typeof BusinessScalarFieldEnum)[keyof typeof BusinessScalarFieldEnum]


  export const FunctionsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    functionId: 'functionId',
    description: 'description',
    functionHead: 'functionHead',
    functionSpoc: 'functionSpoc',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy',
    deleted: 'deleted',
    organizationId: 'organizationId',
    type: 'type',
    locationId: 'locationId',
    businessId: 'businessId',
    unitId: 'unitId'
  };

  export type FunctionsScalarFieldEnum = (typeof FunctionsScalarFieldEnum)[keyof typeof FunctionsScalarFieldEnum]


  export const SectionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy',
    organizationId: 'organizationId',
    deleted: 'deleted'
  };

  export type SectionScalarFieldEnum = (typeof SectionScalarFieldEnum)[keyof typeof SectionScalarFieldEnum]


  export const LocationScalarFieldEnum: {
    id: 'id',
    locationName: 'locationName',
    locationType: 'locationType',
    locationId: 'locationId',
    description: 'description',
    status: 'status',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy',
    functionId: 'functionId',
    deleted: 'deleted',
    organizationId: 'organizationId',
    users: 'users',
    businessTypeId: 'businessTypeId',
    type: 'type'
  };

  export type LocationScalarFieldEnum = (typeof LocationScalarFieldEnum)[keyof typeof LocationScalarFieldEnum]


  export const EntityScalarFieldEnum: {
    id: 'id',
    entityName: 'entityName',
    description: 'description',
    entityTypeId: 'entityTypeId',
    organizationId: 'organizationId',
    locationId: 'locationId',
    createdBy: 'createdBy',
    entityId: 'entityId',
    deleted: 'deleted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy',
    users: 'users',
    sections: 'sections',
    functionId: 'functionId'
  };

  export type EntityScalarFieldEnum = (typeof EntityScalarFieldEnum)[keyof typeof EntityScalarFieldEnum]


  export const LocationBusinessScalarFieldEnum: {
    id: 'id',
    locationId: 'locationId',
    businessId: 'businessId'
  };

  export type LocationBusinessScalarFieldEnum = (typeof LocationBusinessScalarFieldEnum)[keyof typeof LocationBusinessScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    type: 'type',
    text: 'text',
    content: 'content',
    receiver: 'receiver',
    creator: 'creator',
    date: 'date',
    style: 'style',
    read: 'read'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const DoctypeScalarFieldEnum: {
    id: 'id',
    locationId: 'locationId',
    documentTypeName: 'documentTypeName',
    documentNumbering: 'documentNumbering',
    reviewFrequency: 'reviewFrequency',
    revisionRemind: 'revisionRemind',
    prefix: 'prefix',
    suffix: 'suffix',
    organizationId: 'organizationId',
    readAccess: 'readAccess',
    readAccessUsers: 'readAccessUsers',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy',
    createdBy: 'createdBy',
    applicable_systems: 'applicable_systems',
    users: 'users',
    document_classification: 'document_classification',
    entityId: 'entityId',
    distributionUsers: 'distributionUsers',
    currentVersion: 'currentVersion',
    distributionList: 'distributionList'
  };

  export type DoctypeScalarFieldEnum = (typeof DoctypeScalarFieldEnum)[keyof typeof DoctypeScalarFieldEnum]


  export const DocumentsScalarFieldEnum: {
    id: 'id',
    doctypeId: 'doctypeId',
    organizationId: 'organizationId',
    documentName: 'documentName',
    documentNumbering: 'documentNumbering',
    reasonOfCreation: 'reasonOfCreation',
    effectiveDate: 'effectiveDate',
    nextRevisionDate: 'nextRevisionDate',
    currentVersion: 'currentVersion',
    documentLink: 'documentLink',
    description: 'description',
    tags: 'tags',
    documentState: 'documentState',
    locationId: 'locationId',
    entityId: 'entityId',
    system: 'system',
    section: 'section',
    revertComment: 'revertComment',
    docType: 'docType',
    documentClassification: 'documentClassification',
    issueNumber: 'issueNumber',
    retireComment: 'retireComment',
    revisionReminderFlag: 'revisionReminderFlag',
    isVersion: 'isVersion',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    approvedDate: 'approvedDate',
    countNumber: 'countNumber',
    createdBy: 'createdBy',
    distributionList: 'distributionList',
    documentId: 'documentId',
    reviewers: 'reviewers',
    approvers: 'approvers',
    creators: 'creators',
    distributionUsers: 'distributionUsers',
    readAccess: 'readAccess',
    readAccessUsers: 'readAccessUsers',
    versionInfo: 'versionInfo'
  };

  export type DocumentsScalarFieldEnum = (typeof DocumentsScalarFieldEnum)[keyof typeof DocumentsScalarFieldEnum]


  export const DocumentAttachmentHistoryScalarFieldEnum: {
    id: 'id',
    documentId: 'documentId',
    updatedLink: 'updatedLink',
    updatedBy: 'updatedBy',
    updatedAt: 'updatedAt'
  };

  export type DocumentAttachmentHistoryScalarFieldEnum = (typeof DocumentAttachmentHistoryScalarFieldEnum)[keyof typeof DocumentAttachmentHistoryScalarFieldEnum]


  export const ReferenceDocumentsScalarFieldEnum: {
    id: 'id',
    documentLink: 'documentLink',
    type: 'type',
    documentName: 'documentName',
    version: 'version',
    documentId: 'documentId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    referenceDocId: 'referenceDocId',
    versionId: 'versionId'
  };

  export type ReferenceDocumentsScalarFieldEnum = (typeof ReferenceDocumentsScalarFieldEnum)[keyof typeof ReferenceDocumentsScalarFieldEnum]


  export const VersionReferenceDocumentsScalarFieldEnum: {
    id: 'id',
    documentLink: 'documentLink',
    type: 'type',
    documentName: 'documentName',
    version: 'version',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    referenceDocId: 'referenceDocId',
    versionId: 'versionId',
    documentsId: 'documentsId'
  };

  export type VersionReferenceDocumentsScalarFieldEnum = (typeof VersionReferenceDocumentsScalarFieldEnum)[keyof typeof VersionReferenceDocumentsScalarFieldEnum]


  export const DocumentVersionsScalarFieldEnum: {
    id: 'id',
    versionName: 'versionName',
    userId: 'userId',
    by: 'by',
    approvedDate: 'approvedDate',
    versionLink: 'versionLink',
    documentId: 'documentId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    documentName: 'documentName',
    documentNumbering: 'documentNumbering',
    reasonOfCreation: 'reasonOfCreation',
    effectiveDate: 'effectiveDate',
    description: 'description',
    issueNumber: 'issueNumber'
  };

  export type DocumentVersionsScalarFieldEnum = (typeof DocumentVersionsScalarFieldEnum)[keyof typeof DocumentVersionsScalarFieldEnum]


  export const DocumentCommentsScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    commentBy: 'commentBy',
    commentText: 'commentText',
    documentId: 'documentId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DocumentCommentsScalarFieldEnum = (typeof DocumentCommentsScalarFieldEnum)[keyof typeof DocumentCommentsScalarFieldEnum]


  export const DocumentWorkFlowHistoryScalarFieldEnum: {
    id: 'id',
    actionName: 'actionName',
    userId: 'userId',
    actionBy: 'actionBy',
    documentId: 'documentId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DocumentWorkFlowHistoryScalarFieldEnum = (typeof DocumentWorkFlowHistoryScalarFieldEnum)[keyof typeof DocumentWorkFlowHistoryScalarFieldEnum]


  export const DocumentAdminsScalarFieldEnum: {
    id: 'id',
    type: 'type',
    firstname: 'firstname',
    lastname: 'lastname',
    email: 'email',
    userId: 'userId',
    doctypeId: 'doctypeId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DocumentAdminsScalarFieldEnum = (typeof DocumentAdminsScalarFieldEnum)[keyof typeof DocumentAdminsScalarFieldEnum]


  export const AdditionalDocumentAdminsScalarFieldEnum: {
    id: 'id',
    type: 'type',
    firstname: 'firstname',
    lastname: 'lastname',
    email: 'email',
    userId: 'userId',
    documentId: 'documentId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AdditionalDocumentAdminsScalarFieldEnum = (typeof AdditionalDocumentAdminsScalarFieldEnum)[keyof typeof AdditionalDocumentAdminsScalarFieldEnum]


  export const LogsScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    action: 'action',
    resource: 'resource',
    type: 'type',
    additionalDetails: 'additionalDetails'
  };

  export type LogsScalarFieldEnum = (typeof LogsScalarFieldEnum)[keyof typeof LogsScalarFieldEnum]


  export const UserPersonalisationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    organizationId: 'organizationId',
    targetObject: 'targetObject',
    targetObjectId: 'targetObjectId'
  };

  export type UserPersonalisationScalarFieldEnum = (typeof UserPersonalisationScalarFieldEnum)[keyof typeof UserPersonalisationScalarFieldEnum]


  export const ConnectedAppsScalarFieldEnum: {
    id: 'id',
    sourceName: 'sourceName',
    clientId: 'clientId',
    clientSecret: 'clientSecret',
    baseURL: 'baseURL',
    user: 'user',
    password: 'password',
    redirectURL: 'redirectURL',
    grantType: 'grantType',
    description: 'description',
    deleted: 'deleted',
    organizationId: 'organizationId',
    createdModifiedBy: 'createdModifiedBy',
    createdModifiedAt: 'createdModifiedAt',
    locationId: 'locationId',
    Status: 'Status'
  };

  export type ConnectedAppsScalarFieldEnum = (typeof ConnectedAppsScalarFieldEnum)[keyof typeof ConnectedAppsScalarFieldEnum]


  export const UnitTypeScalarFieldEnum: {
    id: 'id',
    unitType: 'unitType',
    unitOfMeasurement: 'unitOfMeasurement',
    organizationId: 'organizationId',
    locationId: 'locationId',
    deleted: 'deleted',
    createdModifiedBy: 'createdModifiedBy',
    createdModifiedAt: 'createdModifiedAt',
    connectedAppsId: 'connectedAppsId'
  };

  export type UnitTypeScalarFieldEnum = (typeof UnitTypeScalarFieldEnum)[keyof typeof UnitTypeScalarFieldEnum]


  export const KpiScalarFieldEnum: {
    id: 'id',
    kpiName: 'kpiName',
    kpiType: 'kpiType',
    keyFields: 'keyFields',
    unitTypeId: 'unitTypeId',
    uom: 'uom',
    sourceId: 'sourceId',
    status: 'status',
    apiEndPoint: 'apiEndPoint',
    kpiDescription: 'kpiDescription',
    kpiTargetType: 'kpiTargetType',
    organizationId: 'organizationId',
    locationId: 'locationId',
    createdModifiedBy: 'createdModifiedBy',
    createdModifiedAt: 'createdModifiedAt'
  };

  export type KpiScalarFieldEnum = (typeof KpiScalarFieldEnum)[keyof typeof KpiScalarFieldEnum]


  export const AuditTrialScalarFieldEnum: {
    id: 'id',
    moduleType: 'moduleType',
    actionType: 'actionType',
    transactionId: 'transactionId',
    actionBy: 'actionBy',
    actionDate: 'actionDate'
  };

  export type AuditTrialScalarFieldEnum = (typeof AuditTrialScalarFieldEnum)[keyof typeof AuditTrialScalarFieldEnum]


  export const PrefixSuffixScalarFieldEnum: {
    id: 'id',
    prefix: 'prefix',
    suffix: 'suffix',
    moduleType: 'moduleType',
    location: 'location',
    organizationId: 'organizationId',
    createdBy: 'createdBy',
    createdAt: 'createdAt'
  };

  export type PrefixSuffixScalarFieldEnum = (typeof PrefixSuffixScalarFieldEnum)[keyof typeof PrefixSuffixScalarFieldEnum]


  export const SerialNumberScalarFieldEnum: {
    id: 'id',
    moduleType: 'moduleType',
    location: 'location',
    entity: 'entity',
    year: 'year',
    tid: 'tid',
    serialNumber: 'serialNumber',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    organizationId: 'organizationId'
  };

  export type SerialNumberScalarFieldEnum = (typeof SerialNumberScalarFieldEnum)[keyof typeof SerialNumberScalarFieldEnum]


  export const RolesTableScalarFieldEnum: {
    id: 'id',
    orgId: 'orgId',
    unitId: 'unitId',
    users: 'users',
    roleId: 'roleId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RolesTableScalarFieldEnum = (typeof RolesTableScalarFieldEnum)[keyof typeof RolesTableScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Json[]'
   */
  export type ListJsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    kcId?: StringNullableFilter<"User"> | string | null
    email?: StringNullableFilter<"User"> | string | null
    username?: StringNullableFilter<"User"> | string | null
    firstname?: StringNullableFilter<"User"> | string | null
    lastname?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    createdBy?: StringNullableFilter<"User"> | string | null
    updatedAt?: DateTimeFilter<"User"> | Date | string
    updatedBy?: StringNullableFilter<"User"> | string | null
    enabled?: BoolNullableFilter<"User"> | boolean | null
    organizationId?: StringNullableFilter<"User"> | string | null
    locationId?: StringNullableFilter<"User"> | string | null
    entityId?: StringNullableFilter<"User"> | string | null
    userType?: StringNullableFilter<"User"> | string | null
    status?: BoolNullableFilter<"User"> | boolean | null
    avatar?: StringNullableFilter<"User"> | string | null
    deleted?: BoolNullableFilter<"User"> | boolean | null
    roleId?: StringNullableListFilter<"User">
    functionId?: JsonNullableFilter<"User">
    additionalUnits?: StringNullableListFilter<"User">
    entity?: XOR<EntityNullableRelationFilter, EntityWhereInput> | null
    location?: XOR<LocationNullableRelationFilter, LocationWhereInput> | null
    organization?: XOR<OrganizationNullableRelationFilter, OrganizationWhereInput> | null
    AdditionalDocumentAdmins?: AdditionalDocumentAdminsListRelationFilter
    DocumentComments?: DocumentCommentsListRelationFilter
    DocumentVersions?: DocumentVersionsListRelationFilter
    DocumentWorkFlowHistory?: DocumentWorkFlowHistoryListRelationFilter
    Logs?: LogsListRelationFilter
    Notification?: NotificationListRelationFilter
    documentAdmins?: DocumentAdminsListRelationFilter
    userPersonalisation?: UserPersonalisationListRelationFilter
    auditTrial?: AuditTrialListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    kcId?: SortOrder
    email?: SortOrder
    username?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    enabled?: SortOrder
    organizationId?: SortOrder
    locationId?: SortOrder
    entityId?: SortOrder
    userType?: SortOrder
    status?: SortOrder
    avatar?: SortOrder
    deleted?: SortOrder
    roleId?: SortOrder
    functionId?: SortOrder
    additionalUnits?: SortOrder
    entity?: EntityOrderByWithRelationInput
    location?: LocationOrderByWithRelationInput
    organization?: OrganizationOrderByWithRelationInput
    AdditionalDocumentAdmins?: AdditionalDocumentAdminsOrderByRelationAggregateInput
    DocumentComments?: DocumentCommentsOrderByRelationAggregateInput
    DocumentVersions?: DocumentVersionsOrderByRelationAggregateInput
    DocumentWorkFlowHistory?: DocumentWorkFlowHistoryOrderByRelationAggregateInput
    Logs?: LogsOrderByRelationAggregateInput
    Notification?: NotificationOrderByRelationAggregateInput
    documentAdmins?: documentAdminsOrderByRelationAggregateInput
    userPersonalisation?: userPersonalisationOrderByRelationAggregateInput
    auditTrial?: auditTrialOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    kcId?: StringNullableFilter<"User"> | string | null
    email?: StringNullableFilter<"User"> | string | null
    username?: StringNullableFilter<"User"> | string | null
    firstname?: StringNullableFilter<"User"> | string | null
    lastname?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    createdBy?: StringNullableFilter<"User"> | string | null
    updatedAt?: DateTimeFilter<"User"> | Date | string
    updatedBy?: StringNullableFilter<"User"> | string | null
    enabled?: BoolNullableFilter<"User"> | boolean | null
    organizationId?: StringNullableFilter<"User"> | string | null
    locationId?: StringNullableFilter<"User"> | string | null
    entityId?: StringNullableFilter<"User"> | string | null
    userType?: StringNullableFilter<"User"> | string | null
    status?: BoolNullableFilter<"User"> | boolean | null
    avatar?: StringNullableFilter<"User"> | string | null
    deleted?: BoolNullableFilter<"User"> | boolean | null
    roleId?: StringNullableListFilter<"User">
    functionId?: JsonNullableFilter<"User">
    additionalUnits?: StringNullableListFilter<"User">
    entity?: XOR<EntityNullableRelationFilter, EntityWhereInput> | null
    location?: XOR<LocationNullableRelationFilter, LocationWhereInput> | null
    organization?: XOR<OrganizationNullableRelationFilter, OrganizationWhereInput> | null
    AdditionalDocumentAdmins?: AdditionalDocumentAdminsListRelationFilter
    DocumentComments?: DocumentCommentsListRelationFilter
    DocumentVersions?: DocumentVersionsListRelationFilter
    DocumentWorkFlowHistory?: DocumentWorkFlowHistoryListRelationFilter
    Logs?: LogsListRelationFilter
    Notification?: NotificationListRelationFilter
    documentAdmins?: DocumentAdminsListRelationFilter
    userPersonalisation?: UserPersonalisationListRelationFilter
    auditTrial?: AuditTrialListRelationFilter
  }, "id">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    kcId?: SortOrder
    email?: SortOrder
    username?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    enabled?: SortOrder
    organizationId?: SortOrder
    locationId?: SortOrder
    entityId?: SortOrder
    userType?: SortOrder
    status?: SortOrder
    avatar?: SortOrder
    deleted?: SortOrder
    roleId?: SortOrder
    functionId?: SortOrder
    additionalUnits?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    kcId?: StringNullableWithAggregatesFilter<"User"> | string | null
    email?: StringNullableWithAggregatesFilter<"User"> | string | null
    username?: StringNullableWithAggregatesFilter<"User"> | string | null
    firstname?: StringNullableWithAggregatesFilter<"User"> | string | null
    lastname?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    createdBy?: StringNullableWithAggregatesFilter<"User"> | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedBy?: StringNullableWithAggregatesFilter<"User"> | string | null
    enabled?: BoolNullableWithAggregatesFilter<"User"> | boolean | null
    organizationId?: StringNullableWithAggregatesFilter<"User"> | string | null
    locationId?: StringNullableWithAggregatesFilter<"User"> | string | null
    entityId?: StringNullableWithAggregatesFilter<"User"> | string | null
    userType?: StringNullableWithAggregatesFilter<"User"> | string | null
    status?: BoolNullableWithAggregatesFilter<"User"> | boolean | null
    avatar?: StringNullableWithAggregatesFilter<"User"> | string | null
    deleted?: BoolNullableWithAggregatesFilter<"User"> | boolean | null
    roleId?: StringNullableListFilter<"User">
    functionId?: JsonNullableWithAggregatesFilter<"User">
    additionalUnits?: StringNullableListFilter<"User">
  }

  export type ModelsWhereInput = {
    AND?: ModelsWhereInput | ModelsWhereInput[]
    OR?: ModelsWhereInput[]
    NOT?: ModelsWhereInput | ModelsWhereInput[]
    id?: StringFilter<"Models"> | string
    modelNo?: StringFilter<"Models"> | string
    modelName?: StringFilter<"Models"> | string
    description?: StringNullableFilter<"Models"> | string | null
    organizationId?: StringFilter<"Models"> | string
    partsId?: StringNullableListFilter<"Models">
    claimId?: StringNullableListFilter<"Models">
    claims?: ClaimListRelationFilter
    organization?: XOR<OrganizationRelationFilter, OrganizationWhereInput>
    Parts?: PartsListRelationFilter
  }

  export type ModelsOrderByWithRelationInput = {
    id?: SortOrder
    modelNo?: SortOrder
    modelName?: SortOrder
    description?: SortOrder
    organizationId?: SortOrder
    partsId?: SortOrder
    claimId?: SortOrder
    claims?: ClaimOrderByRelationAggregateInput
    organization?: OrganizationOrderByWithRelationInput
    Parts?: PartsOrderByRelationAggregateInput
  }

  export type ModelsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    modelNo?: string
    AND?: ModelsWhereInput | ModelsWhereInput[]
    OR?: ModelsWhereInput[]
    NOT?: ModelsWhereInput | ModelsWhereInput[]
    modelName?: StringFilter<"Models"> | string
    description?: StringNullableFilter<"Models"> | string | null
    organizationId?: StringFilter<"Models"> | string
    partsId?: StringNullableListFilter<"Models">
    claimId?: StringNullableListFilter<"Models">
    claims?: ClaimListRelationFilter
    organization?: XOR<OrganizationRelationFilter, OrganizationWhereInput>
    Parts?: PartsListRelationFilter
  }, "id" | "modelNo">

  export type ModelsOrderByWithAggregationInput = {
    id?: SortOrder
    modelNo?: SortOrder
    modelName?: SortOrder
    description?: SortOrder
    organizationId?: SortOrder
    partsId?: SortOrder
    claimId?: SortOrder
    _count?: ModelsCountOrderByAggregateInput
    _max?: ModelsMaxOrderByAggregateInput
    _min?: ModelsMinOrderByAggregateInput
  }

  export type ModelsScalarWhereWithAggregatesInput = {
    AND?: ModelsScalarWhereWithAggregatesInput | ModelsScalarWhereWithAggregatesInput[]
    OR?: ModelsScalarWhereWithAggregatesInput[]
    NOT?: ModelsScalarWhereWithAggregatesInput | ModelsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Models"> | string
    modelNo?: StringWithAggregatesFilter<"Models"> | string
    modelName?: StringWithAggregatesFilter<"Models"> | string
    description?: StringNullableWithAggregatesFilter<"Models"> | string | null
    organizationId?: StringWithAggregatesFilter<"Models"> | string
    partsId?: StringNullableListFilter<"Models">
    claimId?: StringNullableListFilter<"Models">
  }

  export type PartsWhereInput = {
    AND?: PartsWhereInput | PartsWhereInput[]
    OR?: PartsWhereInput[]
    NOT?: PartsWhereInput | PartsWhereInput[]
    id?: StringFilter<"Parts"> | string
    partNo?: StringFilter<"Parts"> | string
    partName?: StringFilter<"Parts"> | string
    description?: StringNullableFilter<"Parts"> | string | null
    organizationId?: StringNullableFilter<"Parts"> | string | null
    entityId?: StringNullableFilter<"Parts"> | string | null
    claimId?: StringNullableListFilter<"Parts">
    modelsId?: StringNullableListFilter<"Parts">
    claims?: ClaimListRelationFilter
    entity?: XOR<EntityNullableRelationFilter, EntityWhereInput> | null
    organization?: XOR<OrganizationNullableRelationFilter, OrganizationWhereInput> | null
    models?: ModelsListRelationFilter
  }

  export type PartsOrderByWithRelationInput = {
    id?: SortOrder
    partNo?: SortOrder
    partName?: SortOrder
    description?: SortOrder
    organizationId?: SortOrder
    entityId?: SortOrder
    claimId?: SortOrder
    modelsId?: SortOrder
    claims?: ClaimOrderByRelationAggregateInput
    entity?: EntityOrderByWithRelationInput
    organization?: OrganizationOrderByWithRelationInput
    models?: ModelsOrderByRelationAggregateInput
  }

  export type PartsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    partNo?: string
    AND?: PartsWhereInput | PartsWhereInput[]
    OR?: PartsWhereInput[]
    NOT?: PartsWhereInput | PartsWhereInput[]
    partName?: StringFilter<"Parts"> | string
    description?: StringNullableFilter<"Parts"> | string | null
    organizationId?: StringNullableFilter<"Parts"> | string | null
    entityId?: StringNullableFilter<"Parts"> | string | null
    claimId?: StringNullableListFilter<"Parts">
    modelsId?: StringNullableListFilter<"Parts">
    claims?: ClaimListRelationFilter
    entity?: XOR<EntityNullableRelationFilter, EntityWhereInput> | null
    organization?: XOR<OrganizationNullableRelationFilter, OrganizationWhereInput> | null
    models?: ModelsListRelationFilter
  }, "id" | "partNo">

  export type PartsOrderByWithAggregationInput = {
    id?: SortOrder
    partNo?: SortOrder
    partName?: SortOrder
    description?: SortOrder
    organizationId?: SortOrder
    entityId?: SortOrder
    claimId?: SortOrder
    modelsId?: SortOrder
    _count?: PartsCountOrderByAggregateInput
    _max?: PartsMaxOrderByAggregateInput
    _min?: PartsMinOrderByAggregateInput
  }

  export type PartsScalarWhereWithAggregatesInput = {
    AND?: PartsScalarWhereWithAggregatesInput | PartsScalarWhereWithAggregatesInput[]
    OR?: PartsScalarWhereWithAggregatesInput[]
    NOT?: PartsScalarWhereWithAggregatesInput | PartsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Parts"> | string
    partNo?: StringWithAggregatesFilter<"Parts"> | string
    partName?: StringWithAggregatesFilter<"Parts"> | string
    description?: StringNullableWithAggregatesFilter<"Parts"> | string | null
    organizationId?: StringNullableWithAggregatesFilter<"Parts"> | string | null
    entityId?: StringNullableWithAggregatesFilter<"Parts"> | string | null
    claimId?: StringNullableListFilter<"Parts">
    modelsId?: StringNullableListFilter<"Parts">
  }

  export type ClaimWhereInput = {
    AND?: ClaimWhereInput | ClaimWhereInput[]
    OR?: ClaimWhereInput[]
    NOT?: ClaimWhereInput | ClaimWhereInput[]
    id?: StringFilter<"Claim"> | string
    partId?: StringNullableFilter<"Claim"> | string | null
    modelId?: StringNullableFilter<"Claim"> | string | null
    partRecieptDate?: StringFilter<"Claim"> | string
    vehicleType?: StringFilter<"Claim"> | string
    FrameNo?: StringFilter<"Claim"> | string
    prNo?: StringFilter<"Claim"> | string
    lineOffDate?: StringFilter<"Claim"> | string
    saleDate?: StringFilter<"Claim"> | string
    repairDate?: StringFilter<"Claim"> | string
    shipmentId?: StringNullableFilter<"Claim"> | string | null
    investigationId?: StringNullableFilter<"Claim"> | string | null
    settleMonth?: StringNullableFilter<"Claim"> | string | null
    kms?: IntFilter<"Claim"> | number
    problemId?: StringNullableFilter<"Claim"> | string | null
    mis?: IntFilter<"Claim"> | number
    claimNo?: IntFilter<"Claim"> | number
    problem?: XOR<ProblemNullableRelationFilter, ProblemWhereInput> | null
    investigations?: XOR<InvestigationNullableRelationFilter, InvestigationWhereInput> | null
    models?: XOR<ModelsNullableRelationFilter, ModelsWhereInput> | null
    parts?: XOR<PartsNullableRelationFilter, PartsWhereInput> | null
    shipments?: XOR<ShipmentNullableRelationFilter, ShipmentWhereInput> | null
    claimToEntity?: ClaimToEntityListRelationFilter
  }

  export type ClaimOrderByWithRelationInput = {
    id?: SortOrder
    partId?: SortOrder
    modelId?: SortOrder
    partRecieptDate?: SortOrder
    vehicleType?: SortOrder
    FrameNo?: SortOrder
    prNo?: SortOrder
    lineOffDate?: SortOrder
    saleDate?: SortOrder
    repairDate?: SortOrder
    shipmentId?: SortOrder
    investigationId?: SortOrder
    settleMonth?: SortOrder
    kms?: SortOrder
    problemId?: SortOrder
    mis?: SortOrder
    claimNo?: SortOrder
    problem?: ProblemOrderByWithRelationInput
    investigations?: InvestigationOrderByWithRelationInput
    models?: ModelsOrderByWithRelationInput
    parts?: PartsOrderByWithRelationInput
    shipments?: ShipmentOrderByWithRelationInput
    claimToEntity?: ClaimToEntityOrderByRelationAggregateInput
  }

  export type ClaimWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    claimNo?: number
    AND?: ClaimWhereInput | ClaimWhereInput[]
    OR?: ClaimWhereInput[]
    NOT?: ClaimWhereInput | ClaimWhereInput[]
    partId?: StringNullableFilter<"Claim"> | string | null
    modelId?: StringNullableFilter<"Claim"> | string | null
    partRecieptDate?: StringFilter<"Claim"> | string
    vehicleType?: StringFilter<"Claim"> | string
    FrameNo?: StringFilter<"Claim"> | string
    prNo?: StringFilter<"Claim"> | string
    lineOffDate?: StringFilter<"Claim"> | string
    saleDate?: StringFilter<"Claim"> | string
    repairDate?: StringFilter<"Claim"> | string
    shipmentId?: StringNullableFilter<"Claim"> | string | null
    investigationId?: StringNullableFilter<"Claim"> | string | null
    settleMonth?: StringNullableFilter<"Claim"> | string | null
    kms?: IntFilter<"Claim"> | number
    problemId?: StringNullableFilter<"Claim"> | string | null
    mis?: IntFilter<"Claim"> | number
    problem?: XOR<ProblemNullableRelationFilter, ProblemWhereInput> | null
    investigations?: XOR<InvestigationNullableRelationFilter, InvestigationWhereInput> | null
    models?: XOR<ModelsNullableRelationFilter, ModelsWhereInput> | null
    parts?: XOR<PartsNullableRelationFilter, PartsWhereInput> | null
    shipments?: XOR<ShipmentNullableRelationFilter, ShipmentWhereInput> | null
    claimToEntity?: ClaimToEntityListRelationFilter
  }, "id" | "claimNo">

  export type ClaimOrderByWithAggregationInput = {
    id?: SortOrder
    partId?: SortOrder
    modelId?: SortOrder
    partRecieptDate?: SortOrder
    vehicleType?: SortOrder
    FrameNo?: SortOrder
    prNo?: SortOrder
    lineOffDate?: SortOrder
    saleDate?: SortOrder
    repairDate?: SortOrder
    shipmentId?: SortOrder
    investigationId?: SortOrder
    settleMonth?: SortOrder
    kms?: SortOrder
    problemId?: SortOrder
    mis?: SortOrder
    claimNo?: SortOrder
    _count?: ClaimCountOrderByAggregateInput
    _avg?: ClaimAvgOrderByAggregateInput
    _max?: ClaimMaxOrderByAggregateInput
    _min?: ClaimMinOrderByAggregateInput
    _sum?: ClaimSumOrderByAggregateInput
  }

  export type ClaimScalarWhereWithAggregatesInput = {
    AND?: ClaimScalarWhereWithAggregatesInput | ClaimScalarWhereWithAggregatesInput[]
    OR?: ClaimScalarWhereWithAggregatesInput[]
    NOT?: ClaimScalarWhereWithAggregatesInput | ClaimScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Claim"> | string
    partId?: StringNullableWithAggregatesFilter<"Claim"> | string | null
    modelId?: StringNullableWithAggregatesFilter<"Claim"> | string | null
    partRecieptDate?: StringWithAggregatesFilter<"Claim"> | string
    vehicleType?: StringWithAggregatesFilter<"Claim"> | string
    FrameNo?: StringWithAggregatesFilter<"Claim"> | string
    prNo?: StringWithAggregatesFilter<"Claim"> | string
    lineOffDate?: StringWithAggregatesFilter<"Claim"> | string
    saleDate?: StringWithAggregatesFilter<"Claim"> | string
    repairDate?: StringWithAggregatesFilter<"Claim"> | string
    shipmentId?: StringNullableWithAggregatesFilter<"Claim"> | string | null
    investigationId?: StringNullableWithAggregatesFilter<"Claim"> | string | null
    settleMonth?: StringNullableWithAggregatesFilter<"Claim"> | string | null
    kms?: IntWithAggregatesFilter<"Claim"> | number
    problemId?: StringNullableWithAggregatesFilter<"Claim"> | string | null
    mis?: IntWithAggregatesFilter<"Claim"> | number
    claimNo?: IntWithAggregatesFilter<"Claim"> | number
  }

  export type ProblemWhereInput = {
    AND?: ProblemWhereInput | ProblemWhereInput[]
    OR?: ProblemWhereInput[]
    NOT?: ProblemWhereInput | ProblemWhereInput[]
    id?: StringFilter<"Problem"> | string
    problem?: StringFilter<"Problem"> | string
    createdAt?: StringFilter<"Problem"> | string
    organizationId?: StringFilter<"Problem"> | string
    investigations?: InvestigationListRelationFilter
    claim?: ClaimListRelationFilter
    organization?: XOR<OrganizationRelationFilter, OrganizationWhereInput>
  }

  export type ProblemOrderByWithRelationInput = {
    id?: SortOrder
    problem?: SortOrder
    createdAt?: SortOrder
    organizationId?: SortOrder
    investigations?: InvestigationOrderByRelationAggregateInput
    claim?: ClaimOrderByRelationAggregateInput
    organization?: OrganizationOrderByWithRelationInput
  }

  export type ProblemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProblemWhereInput | ProblemWhereInput[]
    OR?: ProblemWhereInput[]
    NOT?: ProblemWhereInput | ProblemWhereInput[]
    problem?: StringFilter<"Problem"> | string
    createdAt?: StringFilter<"Problem"> | string
    organizationId?: StringFilter<"Problem"> | string
    investigations?: InvestigationListRelationFilter
    claim?: ClaimListRelationFilter
    organization?: XOR<OrganizationRelationFilter, OrganizationWhereInput>
  }, "id">

  export type ProblemOrderByWithAggregationInput = {
    id?: SortOrder
    problem?: SortOrder
    createdAt?: SortOrder
    organizationId?: SortOrder
    _count?: ProblemCountOrderByAggregateInput
    _max?: ProblemMaxOrderByAggregateInput
    _min?: ProblemMinOrderByAggregateInput
  }

  export type ProblemScalarWhereWithAggregatesInput = {
    AND?: ProblemScalarWhereWithAggregatesInput | ProblemScalarWhereWithAggregatesInput[]
    OR?: ProblemScalarWhereWithAggregatesInput[]
    NOT?: ProblemScalarWhereWithAggregatesInput | ProblemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Problem"> | string
    problem?: StringWithAggregatesFilter<"Problem"> | string
    createdAt?: StringWithAggregatesFilter<"Problem"> | string
    organizationId?: StringWithAggregatesFilter<"Problem"> | string
  }

  export type ClaimToEntityWhereInput = {
    AND?: ClaimToEntityWhereInput | ClaimToEntityWhereInput[]
    OR?: ClaimToEntityWhereInput[]
    NOT?: ClaimToEntityWhereInput | ClaimToEntityWhereInput[]
    id?: StringFilter<"ClaimToEntity"> | string
    claimId?: StringFilter<"ClaimToEntity"> | string
    entityId?: StringFilter<"ClaimToEntity"> | string
    claim?: XOR<ClaimRelationFilter, ClaimWhereInput>
    entity?: XOR<EntityRelationFilter, EntityWhereInput>
  }

  export type ClaimToEntityOrderByWithRelationInput = {
    id?: SortOrder
    claimId?: SortOrder
    entityId?: SortOrder
    claim?: ClaimOrderByWithRelationInput
    entity?: EntityOrderByWithRelationInput
  }

  export type ClaimToEntityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ClaimToEntityWhereInput | ClaimToEntityWhereInput[]
    OR?: ClaimToEntityWhereInput[]
    NOT?: ClaimToEntityWhereInput | ClaimToEntityWhereInput[]
    claimId?: StringFilter<"ClaimToEntity"> | string
    entityId?: StringFilter<"ClaimToEntity"> | string
    claim?: XOR<ClaimRelationFilter, ClaimWhereInput>
    entity?: XOR<EntityRelationFilter, EntityWhereInput>
  }, "id">

  export type ClaimToEntityOrderByWithAggregationInput = {
    id?: SortOrder
    claimId?: SortOrder
    entityId?: SortOrder
    _count?: ClaimToEntityCountOrderByAggregateInput
    _max?: ClaimToEntityMaxOrderByAggregateInput
    _min?: ClaimToEntityMinOrderByAggregateInput
  }

  export type ClaimToEntityScalarWhereWithAggregatesInput = {
    AND?: ClaimToEntityScalarWhereWithAggregatesInput | ClaimToEntityScalarWhereWithAggregatesInput[]
    OR?: ClaimToEntityScalarWhereWithAggregatesInput[]
    NOT?: ClaimToEntityScalarWhereWithAggregatesInput | ClaimToEntityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ClaimToEntity"> | string
    claimId?: StringWithAggregatesFilter<"ClaimToEntity"> | string
    entityId?: StringWithAggregatesFilter<"ClaimToEntity"> | string
  }

  export type InvestigationWhereInput = {
    AND?: InvestigationWhereInput | InvestigationWhereInput[]
    OR?: InvestigationWhereInput[]
    NOT?: InvestigationWhereInput | InvestigationWhereInput[]
    id?: StringFilter<"Investigation"> | string
    rootCause?: StringFilter<"Investigation"> | string
    counterMeasure?: StringFilter<"Investigation"> | string
    leadTime?: StringFilter<"Investigation"> | string
    claimType?: StringFilter<"Investigation"> | string
    implementDate?: StringFilter<"Investigation"> | string
    attachment?: JsonNullableListFilter<"Investigation">
    claimNo?: IntFilter<"Investigation"> | number
    problemId?: StringNullableFilter<"Investigation"> | string | null
    claims?: ClaimListRelationFilter
    Problem?: XOR<ProblemNullableRelationFilter, ProblemWhereInput> | null
  }

  export type InvestigationOrderByWithRelationInput = {
    id?: SortOrder
    rootCause?: SortOrder
    counterMeasure?: SortOrder
    leadTime?: SortOrder
    claimType?: SortOrder
    implementDate?: SortOrder
    attachment?: SortOrder
    claimNo?: SortOrder
    problemId?: SortOrder
    claims?: ClaimOrderByRelationAggregateInput
    Problem?: ProblemOrderByWithRelationInput
  }

  export type InvestigationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InvestigationWhereInput | InvestigationWhereInput[]
    OR?: InvestigationWhereInput[]
    NOT?: InvestigationWhereInput | InvestigationWhereInput[]
    rootCause?: StringFilter<"Investigation"> | string
    counterMeasure?: StringFilter<"Investigation"> | string
    leadTime?: StringFilter<"Investigation"> | string
    claimType?: StringFilter<"Investigation"> | string
    implementDate?: StringFilter<"Investigation"> | string
    attachment?: JsonNullableListFilter<"Investigation">
    claimNo?: IntFilter<"Investigation"> | number
    problemId?: StringNullableFilter<"Investigation"> | string | null
    claims?: ClaimListRelationFilter
    Problem?: XOR<ProblemNullableRelationFilter, ProblemWhereInput> | null
  }, "id">

  export type InvestigationOrderByWithAggregationInput = {
    id?: SortOrder
    rootCause?: SortOrder
    counterMeasure?: SortOrder
    leadTime?: SortOrder
    claimType?: SortOrder
    implementDate?: SortOrder
    attachment?: SortOrder
    claimNo?: SortOrder
    problemId?: SortOrder
    _count?: InvestigationCountOrderByAggregateInput
    _avg?: InvestigationAvgOrderByAggregateInput
    _max?: InvestigationMaxOrderByAggregateInput
    _min?: InvestigationMinOrderByAggregateInput
    _sum?: InvestigationSumOrderByAggregateInput
  }

  export type InvestigationScalarWhereWithAggregatesInput = {
    AND?: InvestigationScalarWhereWithAggregatesInput | InvestigationScalarWhereWithAggregatesInput[]
    OR?: InvestigationScalarWhereWithAggregatesInput[]
    NOT?: InvestigationScalarWhereWithAggregatesInput | InvestigationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Investigation"> | string
    rootCause?: StringWithAggregatesFilter<"Investigation"> | string
    counterMeasure?: StringWithAggregatesFilter<"Investigation"> | string
    leadTime?: StringWithAggregatesFilter<"Investigation"> | string
    claimType?: StringWithAggregatesFilter<"Investigation"> | string
    implementDate?: StringWithAggregatesFilter<"Investigation"> | string
    attachment?: JsonNullableListFilter<"Investigation">
    claimNo?: IntWithAggregatesFilter<"Investigation"> | number
    problemId?: StringNullableWithAggregatesFilter<"Investigation"> | string | null
  }

  export type ShipmentWhereInput = {
    AND?: ShipmentWhereInput | ShipmentWhereInput[]
    OR?: ShipmentWhereInput[]
    NOT?: ShipmentWhereInput | ShipmentWhereInput[]
    id?: StringFilter<"Shipment"> | string
    shipmentDate?: StringNullableFilter<"Shipment"> | string | null
    quantity?: IntNullableFilter<"Shipment"> | number | null
    location?: StringNullableFilter<"Shipment"> | string | null
    InvoiceNumber?: StringNullableFilter<"Shipment"> | string | null
    dueDate?: StringNullableFilter<"Shipment"> | string | null
    shipmentCost?: IntNullableFilter<"Shipment"> | number | null
    createdBy?: StringNullableFilter<"Shipment"> | string | null
    awb?: StringNullableFilter<"Shipment"> | string | null
    supplierName?: StringNullableFilter<"Shipment"> | string | null
    supplierReport?: JsonNullableListFilter<"Shipment">
    claims?: ClaimListRelationFilter
  }

  export type ShipmentOrderByWithRelationInput = {
    id?: SortOrder
    shipmentDate?: SortOrder
    quantity?: SortOrder
    location?: SortOrder
    InvoiceNumber?: SortOrder
    dueDate?: SortOrder
    shipmentCost?: SortOrder
    createdBy?: SortOrder
    awb?: SortOrder
    supplierName?: SortOrder
    supplierReport?: SortOrder
    claims?: ClaimOrderByRelationAggregateInput
  }

  export type ShipmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ShipmentWhereInput | ShipmentWhereInput[]
    OR?: ShipmentWhereInput[]
    NOT?: ShipmentWhereInput | ShipmentWhereInput[]
    shipmentDate?: StringNullableFilter<"Shipment"> | string | null
    quantity?: IntNullableFilter<"Shipment"> | number | null
    location?: StringNullableFilter<"Shipment"> | string | null
    InvoiceNumber?: StringNullableFilter<"Shipment"> | string | null
    dueDate?: StringNullableFilter<"Shipment"> | string | null
    shipmentCost?: IntNullableFilter<"Shipment"> | number | null
    createdBy?: StringNullableFilter<"Shipment"> | string | null
    awb?: StringNullableFilter<"Shipment"> | string | null
    supplierName?: StringNullableFilter<"Shipment"> | string | null
    supplierReport?: JsonNullableListFilter<"Shipment">
    claims?: ClaimListRelationFilter
  }, "id">

  export type ShipmentOrderByWithAggregationInput = {
    id?: SortOrder
    shipmentDate?: SortOrder
    quantity?: SortOrder
    location?: SortOrder
    InvoiceNumber?: SortOrder
    dueDate?: SortOrder
    shipmentCost?: SortOrder
    createdBy?: SortOrder
    awb?: SortOrder
    supplierName?: SortOrder
    supplierReport?: SortOrder
    _count?: ShipmentCountOrderByAggregateInput
    _avg?: ShipmentAvgOrderByAggregateInput
    _max?: ShipmentMaxOrderByAggregateInput
    _min?: ShipmentMinOrderByAggregateInput
    _sum?: ShipmentSumOrderByAggregateInput
  }

  export type ShipmentScalarWhereWithAggregatesInput = {
    AND?: ShipmentScalarWhereWithAggregatesInput | ShipmentScalarWhereWithAggregatesInput[]
    OR?: ShipmentScalarWhereWithAggregatesInput[]
    NOT?: ShipmentScalarWhereWithAggregatesInput | ShipmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Shipment"> | string
    shipmentDate?: StringNullableWithAggregatesFilter<"Shipment"> | string | null
    quantity?: IntNullableWithAggregatesFilter<"Shipment"> | number | null
    location?: StringNullableWithAggregatesFilter<"Shipment"> | string | null
    InvoiceNumber?: StringNullableWithAggregatesFilter<"Shipment"> | string | null
    dueDate?: StringNullableWithAggregatesFilter<"Shipment"> | string | null
    shipmentCost?: IntNullableWithAggregatesFilter<"Shipment"> | number | null
    createdBy?: StringNullableWithAggregatesFilter<"Shipment"> | string | null
    awb?: StringNullableWithAggregatesFilter<"Shipment"> | string | null
    supplierName?: StringNullableWithAggregatesFilter<"Shipment"> | string | null
    supplierReport?: JsonNullableListFilter<"Shipment">
  }

  export type OrganizationWhereInput = {
    AND?: OrganizationWhereInput | OrganizationWhereInput[]
    OR?: OrganizationWhereInput[]
    NOT?: OrganizationWhereInput | OrganizationWhereInput[]
    id?: StringFilter<"Organization"> | string
    kcId?: StringNullableFilter<"Organization"> | string | null
    organizationName?: StringNullableFilter<"Organization"> | string | null
    realmName?: StringNullableFilter<"Organization"> | string | null
    instanceUrl?: StringNullableFilter<"Organization"> | string | null
    principalGeography?: StringNullableFilter<"Organization"> | string | null
    loginUrl?: StringNullableFilter<"Organization"> | string | null
    logoutUrl?: StringNullableFilter<"Organization"> | string | null
    createdAt?: DateTimeFilter<"Organization"> | Date | string
    createdBy?: StringNullableFilter<"Organization"> | string | null
    updatedAt?: DateTimeFilter<"Organization"> | Date | string
    updatedBy?: StringNullableFilter<"Organization"> | string | null
    activeModules?: StringNullableListFilter<"Organization">
    clientID?: StringNullableFilter<"Organization"> | string | null
    clientSecret?: StringNullableFilter<"Organization"> | string | null
    fiscalYearQuarters?: StringNullableFilter<"Organization"> | string | null
    fiscalYearFormat?: StringNullableFilter<"Organization"> | string | null
    auditYear?: StringNullableFilter<"Organization"> | string | null
    logoUrl?: StringNullableFilter<"Organization"> | string | null
    deleted?: BoolNullableFilter<"Organization"> | boolean | null
    business?: BusinessListRelationFilter
    Doctype?: DoctypeListRelationFilter
    Documents?: DocumentsListRelationFilter
    entity?: EntityListRelationFilter
    entityType?: EntityTypeListRelationFilter
    location?: LocationListRelationFilter
    role?: RoleListRelationFilter
    section?: SectionListRelationFilter
    systemType?: SystemTypeListRelationFilter
    user?: UserListRelationFilter
    userPersonalisation?: UserPersonalisationListRelationFilter
    ConnectedApps?: ConnectedAppsListRelationFilter
    unitOfMeasurement?: UnitTypeListRelationFilter
    kpi?: KpiListRelationFilter
    businessType?: BusinessTypeListRelationFilter
    prefixSuffix?: PrefixSuffixListRelationFilter
    serialNumber?: SerialNumberListRelationFilter
    function?: FunctionsListRelationFilter
    rolesTable?: RolesTableListRelationFilter
    problem?: ProblemListRelationFilter
    parts?: PartsListRelationFilter
    Models?: ModelsListRelationFilter
  }

  export type OrganizationOrderByWithRelationInput = {
    id?: SortOrder
    kcId?: SortOrder
    organizationName?: SortOrder
    realmName?: SortOrder
    instanceUrl?: SortOrder
    principalGeography?: SortOrder
    loginUrl?: SortOrder
    logoutUrl?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    activeModules?: SortOrder
    clientID?: SortOrder
    clientSecret?: SortOrder
    fiscalYearQuarters?: SortOrder
    fiscalYearFormat?: SortOrder
    auditYear?: SortOrder
    logoUrl?: SortOrder
    deleted?: SortOrder
    business?: BusinessOrderByRelationAggregateInput
    Doctype?: DoctypeOrderByRelationAggregateInput
    Documents?: DocumentsOrderByRelationAggregateInput
    entity?: EntityOrderByRelationAggregateInput
    entityType?: EntityTypeOrderByRelationAggregateInput
    location?: LocationOrderByRelationAggregateInput
    role?: RoleOrderByRelationAggregateInput
    section?: SectionOrderByRelationAggregateInput
    systemType?: SystemTypeOrderByRelationAggregateInput
    user?: UserOrderByRelationAggregateInput
    userPersonalisation?: userPersonalisationOrderByRelationAggregateInput
    ConnectedApps?: ConnectedAppsOrderByRelationAggregateInput
    unitOfMeasurement?: unitTypeOrderByRelationAggregateInput
    kpi?: kpiOrderByRelationAggregateInput
    businessType?: businessTypeOrderByRelationAggregateInput
    prefixSuffix?: prefixSuffixOrderByRelationAggregateInput
    serialNumber?: serialNumberOrderByRelationAggregateInput
    function?: FunctionsOrderByRelationAggregateInput
    rolesTable?: rolesTableOrderByRelationAggregateInput
    problem?: ProblemOrderByRelationAggregateInput
    parts?: PartsOrderByRelationAggregateInput
    Models?: ModelsOrderByRelationAggregateInput
  }

  export type OrganizationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OrganizationWhereInput | OrganizationWhereInput[]
    OR?: OrganizationWhereInput[]
    NOT?: OrganizationWhereInput | OrganizationWhereInput[]
    kcId?: StringNullableFilter<"Organization"> | string | null
    organizationName?: StringNullableFilter<"Organization"> | string | null
    realmName?: StringNullableFilter<"Organization"> | string | null
    instanceUrl?: StringNullableFilter<"Organization"> | string | null
    principalGeography?: StringNullableFilter<"Organization"> | string | null
    loginUrl?: StringNullableFilter<"Organization"> | string | null
    logoutUrl?: StringNullableFilter<"Organization"> | string | null
    createdAt?: DateTimeFilter<"Organization"> | Date | string
    createdBy?: StringNullableFilter<"Organization"> | string | null
    updatedAt?: DateTimeFilter<"Organization"> | Date | string
    updatedBy?: StringNullableFilter<"Organization"> | string | null
    activeModules?: StringNullableListFilter<"Organization">
    clientID?: StringNullableFilter<"Organization"> | string | null
    clientSecret?: StringNullableFilter<"Organization"> | string | null
    fiscalYearQuarters?: StringNullableFilter<"Organization"> | string | null
    fiscalYearFormat?: StringNullableFilter<"Organization"> | string | null
    auditYear?: StringNullableFilter<"Organization"> | string | null
    logoUrl?: StringNullableFilter<"Organization"> | string | null
    deleted?: BoolNullableFilter<"Organization"> | boolean | null
    business?: BusinessListRelationFilter
    Doctype?: DoctypeListRelationFilter
    Documents?: DocumentsListRelationFilter
    entity?: EntityListRelationFilter
    entityType?: EntityTypeListRelationFilter
    location?: LocationListRelationFilter
    role?: RoleListRelationFilter
    section?: SectionListRelationFilter
    systemType?: SystemTypeListRelationFilter
    user?: UserListRelationFilter
    userPersonalisation?: UserPersonalisationListRelationFilter
    ConnectedApps?: ConnectedAppsListRelationFilter
    unitOfMeasurement?: UnitTypeListRelationFilter
    kpi?: KpiListRelationFilter
    businessType?: BusinessTypeListRelationFilter
    prefixSuffix?: PrefixSuffixListRelationFilter
    serialNumber?: SerialNumberListRelationFilter
    function?: FunctionsListRelationFilter
    rolesTable?: RolesTableListRelationFilter
    problem?: ProblemListRelationFilter
    parts?: PartsListRelationFilter
    Models?: ModelsListRelationFilter
  }, "id">

  export type OrganizationOrderByWithAggregationInput = {
    id?: SortOrder
    kcId?: SortOrder
    organizationName?: SortOrder
    realmName?: SortOrder
    instanceUrl?: SortOrder
    principalGeography?: SortOrder
    loginUrl?: SortOrder
    logoutUrl?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    activeModules?: SortOrder
    clientID?: SortOrder
    clientSecret?: SortOrder
    fiscalYearQuarters?: SortOrder
    fiscalYearFormat?: SortOrder
    auditYear?: SortOrder
    logoUrl?: SortOrder
    deleted?: SortOrder
    _count?: OrganizationCountOrderByAggregateInput
    _max?: OrganizationMaxOrderByAggregateInput
    _min?: OrganizationMinOrderByAggregateInput
  }

  export type OrganizationScalarWhereWithAggregatesInput = {
    AND?: OrganizationScalarWhereWithAggregatesInput | OrganizationScalarWhereWithAggregatesInput[]
    OR?: OrganizationScalarWhereWithAggregatesInput[]
    NOT?: OrganizationScalarWhereWithAggregatesInput | OrganizationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Organization"> | string
    kcId?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    organizationName?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    realmName?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    instanceUrl?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    principalGeography?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    loginUrl?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    logoutUrl?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Organization"> | Date | string
    createdBy?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"Organization"> | Date | string
    updatedBy?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    activeModules?: StringNullableListFilter<"Organization">
    clientID?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    clientSecret?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    fiscalYearQuarters?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    fiscalYearFormat?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    auditYear?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    logoUrl?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    deleted?: BoolNullableWithAggregatesFilter<"Organization"> | boolean | null
  }

  export type RoleWhereInput = {
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    id?: StringFilter<"Role"> | string
    kcId?: StringNullableFilter<"Role"> | string | null
    roleName?: StringNullableFilter<"Role"> | string | null
    createdAt?: DateTimeFilter<"Role"> | Date | string
    createdBy?: StringNullableFilter<"Role"> | string | null
    updatedAt?: DateTimeFilter<"Role"> | Date | string
    updatedBy?: StringNullableFilter<"Role"> | string | null
    deleted?: BoolNullableFilter<"Role"> | boolean | null
    organizationId?: StringNullableFilter<"Role"> | string | null
    locationId?: StringNullableFilter<"Role"> | string | null
    organization?: XOR<OrganizationNullableRelationFilter, OrganizationWhereInput> | null
    Location?: XOR<LocationNullableRelationFilter, LocationWhereInput> | null
  }

  export type RoleOrderByWithRelationInput = {
    id?: SortOrder
    kcId?: SortOrder
    roleName?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    deleted?: SortOrder
    organizationId?: SortOrder
    locationId?: SortOrder
    organization?: OrganizationOrderByWithRelationInput
    Location?: LocationOrderByWithRelationInput
  }

  export type RoleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    kcId?: string
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    roleName?: StringNullableFilter<"Role"> | string | null
    createdAt?: DateTimeFilter<"Role"> | Date | string
    createdBy?: StringNullableFilter<"Role"> | string | null
    updatedAt?: DateTimeFilter<"Role"> | Date | string
    updatedBy?: StringNullableFilter<"Role"> | string | null
    deleted?: BoolNullableFilter<"Role"> | boolean | null
    organizationId?: StringNullableFilter<"Role"> | string | null
    locationId?: StringNullableFilter<"Role"> | string | null
    organization?: XOR<OrganizationNullableRelationFilter, OrganizationWhereInput> | null
    Location?: XOR<LocationNullableRelationFilter, LocationWhereInput> | null
  }, "id" | "kcId">

  export type RoleOrderByWithAggregationInput = {
    id?: SortOrder
    kcId?: SortOrder
    roleName?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    deleted?: SortOrder
    organizationId?: SortOrder
    locationId?: SortOrder
    _count?: RoleCountOrderByAggregateInput
    _max?: RoleMaxOrderByAggregateInput
    _min?: RoleMinOrderByAggregateInput
  }

  export type RoleScalarWhereWithAggregatesInput = {
    AND?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    OR?: RoleScalarWhereWithAggregatesInput[]
    NOT?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Role"> | string
    kcId?: StringNullableWithAggregatesFilter<"Role"> | string | null
    roleName?: StringNullableWithAggregatesFilter<"Role"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Role"> | Date | string
    createdBy?: StringNullableWithAggregatesFilter<"Role"> | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"Role"> | Date | string
    updatedBy?: StringNullableWithAggregatesFilter<"Role"> | string | null
    deleted?: BoolNullableWithAggregatesFilter<"Role"> | boolean | null
    organizationId?: StringNullableWithAggregatesFilter<"Role"> | string | null
    locationId?: StringNullableWithAggregatesFilter<"Role"> | string | null
  }

  export type SystemTypeWhereInput = {
    AND?: SystemTypeWhereInput | SystemTypeWhereInput[]
    OR?: SystemTypeWhereInput[]
    NOT?: SystemTypeWhereInput | SystemTypeWhereInput[]
    id?: StringFilter<"SystemType"> | string
    name?: StringNullableFilter<"SystemType"> | string | null
    createdAt?: DateTimeFilter<"SystemType"> | Date | string
    createdBy?: StringNullableFilter<"SystemType"> | string | null
    updatedAt?: DateTimeFilter<"SystemType"> | Date | string
    color?: StringNullableFilter<"SystemType"> | string | null
    updatedBy?: StringNullableFilter<"SystemType"> | string | null
    deleted?: BoolNullableFilter<"SystemType"> | boolean | null
    organizationId?: StringNullableFilter<"SystemType"> | string | null
    organization?: XOR<OrganizationNullableRelationFilter, OrganizationWhereInput> | null
  }

  export type SystemTypeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    color?: SortOrder
    updatedBy?: SortOrder
    deleted?: SortOrder
    organizationId?: SortOrder
    organization?: OrganizationOrderByWithRelationInput
  }

  export type SystemTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SystemTypeWhereInput | SystemTypeWhereInput[]
    OR?: SystemTypeWhereInput[]
    NOT?: SystemTypeWhereInput | SystemTypeWhereInput[]
    name?: StringNullableFilter<"SystemType"> | string | null
    createdAt?: DateTimeFilter<"SystemType"> | Date | string
    createdBy?: StringNullableFilter<"SystemType"> | string | null
    updatedAt?: DateTimeFilter<"SystemType"> | Date | string
    color?: StringNullableFilter<"SystemType"> | string | null
    updatedBy?: StringNullableFilter<"SystemType"> | string | null
    deleted?: BoolNullableFilter<"SystemType"> | boolean | null
    organizationId?: StringNullableFilter<"SystemType"> | string | null
    organization?: XOR<OrganizationNullableRelationFilter, OrganizationWhereInput> | null
  }, "id">

  export type SystemTypeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    color?: SortOrder
    updatedBy?: SortOrder
    deleted?: SortOrder
    organizationId?: SortOrder
    _count?: SystemTypeCountOrderByAggregateInput
    _max?: SystemTypeMaxOrderByAggregateInput
    _min?: SystemTypeMinOrderByAggregateInput
  }

  export type SystemTypeScalarWhereWithAggregatesInput = {
    AND?: SystemTypeScalarWhereWithAggregatesInput | SystemTypeScalarWhereWithAggregatesInput[]
    OR?: SystemTypeScalarWhereWithAggregatesInput[]
    NOT?: SystemTypeScalarWhereWithAggregatesInput | SystemTypeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SystemType"> | string
    name?: StringNullableWithAggregatesFilter<"SystemType"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SystemType"> | Date | string
    createdBy?: StringNullableWithAggregatesFilter<"SystemType"> | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"SystemType"> | Date | string
    color?: StringNullableWithAggregatesFilter<"SystemType"> | string | null
    updatedBy?: StringNullableWithAggregatesFilter<"SystemType"> | string | null
    deleted?: BoolNullableWithAggregatesFilter<"SystemType"> | boolean | null
    organizationId?: StringNullableWithAggregatesFilter<"SystemType"> | string | null
  }

  export type EntityTypeWhereInput = {
    AND?: EntityTypeWhereInput | EntityTypeWhereInput[]
    OR?: EntityTypeWhereInput[]
    NOT?: EntityTypeWhereInput | EntityTypeWhereInput[]
    id?: StringFilter<"EntityType"> | string
    name?: StringNullableFilter<"EntityType"> | string | null
    createdAt?: DateTimeFilter<"EntityType"> | Date | string
    createdBy?: StringNullableFilter<"EntityType"> | string | null
    updatedAt?: DateTimeFilter<"EntityType"> | Date | string
    updatedBy?: StringNullableFilter<"EntityType"> | string | null
    organizationId?: StringNullableFilter<"EntityType"> | string | null
    deleted?: BoolNullableFilter<"EntityType"> | boolean | null
    organization?: XOR<OrganizationNullableRelationFilter, OrganizationWhereInput> | null
    entity?: EntityListRelationFilter
  }

  export type EntityTypeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    organizationId?: SortOrder
    deleted?: SortOrder
    organization?: OrganizationOrderByWithRelationInput
    entity?: EntityOrderByRelationAggregateInput
  }

  export type EntityTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EntityTypeWhereInput | EntityTypeWhereInput[]
    OR?: EntityTypeWhereInput[]
    NOT?: EntityTypeWhereInput | EntityTypeWhereInput[]
    name?: StringNullableFilter<"EntityType"> | string | null
    createdAt?: DateTimeFilter<"EntityType"> | Date | string
    createdBy?: StringNullableFilter<"EntityType"> | string | null
    updatedAt?: DateTimeFilter<"EntityType"> | Date | string
    updatedBy?: StringNullableFilter<"EntityType"> | string | null
    organizationId?: StringNullableFilter<"EntityType"> | string | null
    deleted?: BoolNullableFilter<"EntityType"> | boolean | null
    organization?: XOR<OrganizationNullableRelationFilter, OrganizationWhereInput> | null
    entity?: EntityListRelationFilter
  }, "id">

  export type EntityTypeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    organizationId?: SortOrder
    deleted?: SortOrder
    _count?: EntityTypeCountOrderByAggregateInput
    _max?: EntityTypeMaxOrderByAggregateInput
    _min?: EntityTypeMinOrderByAggregateInput
  }

  export type EntityTypeScalarWhereWithAggregatesInput = {
    AND?: EntityTypeScalarWhereWithAggregatesInput | EntityTypeScalarWhereWithAggregatesInput[]
    OR?: EntityTypeScalarWhereWithAggregatesInput[]
    NOT?: EntityTypeScalarWhereWithAggregatesInput | EntityTypeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EntityType"> | string
    name?: StringNullableWithAggregatesFilter<"EntityType"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"EntityType"> | Date | string
    createdBy?: StringNullableWithAggregatesFilter<"EntityType"> | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"EntityType"> | Date | string
    updatedBy?: StringNullableWithAggregatesFilter<"EntityType"> | string | null
    organizationId?: StringNullableWithAggregatesFilter<"EntityType"> | string | null
    deleted?: BoolNullableWithAggregatesFilter<"EntityType"> | boolean | null
  }

  export type businessTypeWhereInput = {
    AND?: businessTypeWhereInput | businessTypeWhereInput[]
    OR?: businessTypeWhereInput[]
    NOT?: businessTypeWhereInput | businessTypeWhereInput[]
    id?: StringFilter<"businessType"> | string
    name?: StringNullableFilter<"businessType"> | string | null
    createdAt?: DateTimeFilter<"businessType"> | Date | string
    createdBy?: StringNullableFilter<"businessType"> | string | null
    deleted?: BoolNullableFilter<"businessType"> | boolean | null
    organizationId?: StringNullableFilter<"businessType"> | string | null
    organization?: XOR<OrganizationNullableRelationFilter, OrganizationWhereInput> | null
  }

  export type businessTypeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    deleted?: SortOrder
    organizationId?: SortOrder
    organization?: OrganizationOrderByWithRelationInput
  }

  export type businessTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: businessTypeWhereInput | businessTypeWhereInput[]
    OR?: businessTypeWhereInput[]
    NOT?: businessTypeWhereInput | businessTypeWhereInput[]
    name?: StringNullableFilter<"businessType"> | string | null
    createdAt?: DateTimeFilter<"businessType"> | Date | string
    createdBy?: StringNullableFilter<"businessType"> | string | null
    deleted?: BoolNullableFilter<"businessType"> | boolean | null
    organizationId?: StringNullableFilter<"businessType"> | string | null
    organization?: XOR<OrganizationNullableRelationFilter, OrganizationWhereInput> | null
  }, "id">

  export type businessTypeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    deleted?: SortOrder
    organizationId?: SortOrder
    _count?: businessTypeCountOrderByAggregateInput
    _max?: businessTypeMaxOrderByAggregateInput
    _min?: businessTypeMinOrderByAggregateInput
  }

  export type businessTypeScalarWhereWithAggregatesInput = {
    AND?: businessTypeScalarWhereWithAggregatesInput | businessTypeScalarWhereWithAggregatesInput[]
    OR?: businessTypeScalarWhereWithAggregatesInput[]
    NOT?: businessTypeScalarWhereWithAggregatesInput | businessTypeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"businessType"> | string
    name?: StringNullableWithAggregatesFilter<"businessType"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"businessType"> | Date | string
    createdBy?: StringNullableWithAggregatesFilter<"businessType"> | string | null
    deleted?: BoolNullableWithAggregatesFilter<"businessType"> | boolean | null
    organizationId?: StringNullableWithAggregatesFilter<"businessType"> | string | null
  }

  export type BusinessWhereInput = {
    AND?: BusinessWhereInput | BusinessWhereInput[]
    OR?: BusinessWhereInput[]
    NOT?: BusinessWhereInput | BusinessWhereInput[]
    id?: StringFilter<"Business"> | string
    name?: StringNullableFilter<"Business"> | string | null
    createdAt?: DateTimeFilter<"Business"> | Date | string
    createdBy?: StringNullableFilter<"Business"> | string | null
    updatedAt?: DateTimeFilter<"Business"> | Date | string
    updatedBy?: StringNullableFilter<"Business"> | string | null
    organizationId?: StringNullableFilter<"Business"> | string | null
    deleted?: BoolNullableFilter<"Business"> | boolean | null
    organization?: XOR<OrganizationNullableRelationFilter, OrganizationWhereInput> | null
    location?: LocationBusinessListRelationFilter
  }

  export type BusinessOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    organizationId?: SortOrder
    deleted?: SortOrder
    organization?: OrganizationOrderByWithRelationInput
    location?: LocationBusinessOrderByRelationAggregateInput
  }

  export type BusinessWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BusinessWhereInput | BusinessWhereInput[]
    OR?: BusinessWhereInput[]
    NOT?: BusinessWhereInput | BusinessWhereInput[]
    name?: StringNullableFilter<"Business"> | string | null
    createdAt?: DateTimeFilter<"Business"> | Date | string
    createdBy?: StringNullableFilter<"Business"> | string | null
    updatedAt?: DateTimeFilter<"Business"> | Date | string
    updatedBy?: StringNullableFilter<"Business"> | string | null
    organizationId?: StringNullableFilter<"Business"> | string | null
    deleted?: BoolNullableFilter<"Business"> | boolean | null
    organization?: XOR<OrganizationNullableRelationFilter, OrganizationWhereInput> | null
    location?: LocationBusinessListRelationFilter
  }, "id">

  export type BusinessOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    organizationId?: SortOrder
    deleted?: SortOrder
    _count?: BusinessCountOrderByAggregateInput
    _max?: BusinessMaxOrderByAggregateInput
    _min?: BusinessMinOrderByAggregateInput
  }

  export type BusinessScalarWhereWithAggregatesInput = {
    AND?: BusinessScalarWhereWithAggregatesInput | BusinessScalarWhereWithAggregatesInput[]
    OR?: BusinessScalarWhereWithAggregatesInput[]
    NOT?: BusinessScalarWhereWithAggregatesInput | BusinessScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Business"> | string
    name?: StringNullableWithAggregatesFilter<"Business"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Business"> | Date | string
    createdBy?: StringNullableWithAggregatesFilter<"Business"> | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"Business"> | Date | string
    updatedBy?: StringNullableWithAggregatesFilter<"Business"> | string | null
    organizationId?: StringNullableWithAggregatesFilter<"Business"> | string | null
    deleted?: BoolNullableWithAggregatesFilter<"Business"> | boolean | null
  }

  export type FunctionsWhereInput = {
    AND?: FunctionsWhereInput | FunctionsWhereInput[]
    OR?: FunctionsWhereInput[]
    NOT?: FunctionsWhereInput | FunctionsWhereInput[]
    id?: StringFilter<"Functions"> | string
    name?: StringNullableFilter<"Functions"> | string | null
    functionId?: StringNullableFilter<"Functions"> | string | null
    description?: StringNullableFilter<"Functions"> | string | null
    functionHead?: StringNullableListFilter<"Functions">
    functionSpoc?: StringNullableListFilter<"Functions">
    createdAt?: DateTimeFilter<"Functions"> | Date | string
    createdBy?: StringNullableFilter<"Functions"> | string | null
    updatedAt?: DateTimeFilter<"Functions"> | Date | string
    updatedBy?: StringNullableFilter<"Functions"> | string | null
    deleted?: BoolNullableFilter<"Functions"> | boolean | null
    organizationId?: StringNullableFilter<"Functions"> | string | null
    type?: BoolFilter<"Functions"> | boolean
    locationId?: StringNullableListFilter<"Functions">
    businessId?: StringNullableListFilter<"Functions">
    unitId?: StringNullableFilter<"Functions"> | string | null
    organization?: XOR<OrganizationNullableRelationFilter, OrganizationWhereInput> | null
    entity?: EntityListRelationFilter
  }

  export type FunctionsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    functionId?: SortOrder
    description?: SortOrder
    functionHead?: SortOrder
    functionSpoc?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    deleted?: SortOrder
    organizationId?: SortOrder
    type?: SortOrder
    locationId?: SortOrder
    businessId?: SortOrder
    unitId?: SortOrder
    organization?: OrganizationOrderByWithRelationInput
    entity?: EntityOrderByRelationAggregateInput
  }

  export type FunctionsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FunctionsWhereInput | FunctionsWhereInput[]
    OR?: FunctionsWhereInput[]
    NOT?: FunctionsWhereInput | FunctionsWhereInput[]
    name?: StringNullableFilter<"Functions"> | string | null
    functionId?: StringNullableFilter<"Functions"> | string | null
    description?: StringNullableFilter<"Functions"> | string | null
    functionHead?: StringNullableListFilter<"Functions">
    functionSpoc?: StringNullableListFilter<"Functions">
    createdAt?: DateTimeFilter<"Functions"> | Date | string
    createdBy?: StringNullableFilter<"Functions"> | string | null
    updatedAt?: DateTimeFilter<"Functions"> | Date | string
    updatedBy?: StringNullableFilter<"Functions"> | string | null
    deleted?: BoolNullableFilter<"Functions"> | boolean | null
    organizationId?: StringNullableFilter<"Functions"> | string | null
    type?: BoolFilter<"Functions"> | boolean
    locationId?: StringNullableListFilter<"Functions">
    businessId?: StringNullableListFilter<"Functions">
    unitId?: StringNullableFilter<"Functions"> | string | null
    organization?: XOR<OrganizationNullableRelationFilter, OrganizationWhereInput> | null
    entity?: EntityListRelationFilter
  }, "id">

  export type FunctionsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    functionId?: SortOrder
    description?: SortOrder
    functionHead?: SortOrder
    functionSpoc?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    deleted?: SortOrder
    organizationId?: SortOrder
    type?: SortOrder
    locationId?: SortOrder
    businessId?: SortOrder
    unitId?: SortOrder
    _count?: FunctionsCountOrderByAggregateInput
    _max?: FunctionsMaxOrderByAggregateInput
    _min?: FunctionsMinOrderByAggregateInput
  }

  export type FunctionsScalarWhereWithAggregatesInput = {
    AND?: FunctionsScalarWhereWithAggregatesInput | FunctionsScalarWhereWithAggregatesInput[]
    OR?: FunctionsScalarWhereWithAggregatesInput[]
    NOT?: FunctionsScalarWhereWithAggregatesInput | FunctionsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Functions"> | string
    name?: StringNullableWithAggregatesFilter<"Functions"> | string | null
    functionId?: StringNullableWithAggregatesFilter<"Functions"> | string | null
    description?: StringNullableWithAggregatesFilter<"Functions"> | string | null
    functionHead?: StringNullableListFilter<"Functions">
    functionSpoc?: StringNullableListFilter<"Functions">
    createdAt?: DateTimeWithAggregatesFilter<"Functions"> | Date | string
    createdBy?: StringNullableWithAggregatesFilter<"Functions"> | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"Functions"> | Date | string
    updatedBy?: StringNullableWithAggregatesFilter<"Functions"> | string | null
    deleted?: BoolNullableWithAggregatesFilter<"Functions"> | boolean | null
    organizationId?: StringNullableWithAggregatesFilter<"Functions"> | string | null
    type?: BoolWithAggregatesFilter<"Functions"> | boolean
    locationId?: StringNullableListFilter<"Functions">
    businessId?: StringNullableListFilter<"Functions">
    unitId?: StringNullableWithAggregatesFilter<"Functions"> | string | null
  }

  export type SectionWhereInput = {
    AND?: SectionWhereInput | SectionWhereInput[]
    OR?: SectionWhereInput[]
    NOT?: SectionWhereInput | SectionWhereInput[]
    id?: StringFilter<"Section"> | string
    name?: StringNullableFilter<"Section"> | string | null
    createdAt?: DateTimeFilter<"Section"> | Date | string
    createdBy?: StringNullableFilter<"Section"> | string | null
    updatedAt?: DateTimeFilter<"Section"> | Date | string
    updatedBy?: StringNullableFilter<"Section"> | string | null
    organizationId?: StringNullableFilter<"Section"> | string | null
    deleted?: BoolNullableFilter<"Section"> | boolean | null
    organization?: XOR<OrganizationNullableRelationFilter, OrganizationWhereInput> | null
  }

  export type SectionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    organizationId?: SortOrder
    deleted?: SortOrder
    organization?: OrganizationOrderByWithRelationInput
  }

  export type SectionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SectionWhereInput | SectionWhereInput[]
    OR?: SectionWhereInput[]
    NOT?: SectionWhereInput | SectionWhereInput[]
    name?: StringNullableFilter<"Section"> | string | null
    createdAt?: DateTimeFilter<"Section"> | Date | string
    createdBy?: StringNullableFilter<"Section"> | string | null
    updatedAt?: DateTimeFilter<"Section"> | Date | string
    updatedBy?: StringNullableFilter<"Section"> | string | null
    organizationId?: StringNullableFilter<"Section"> | string | null
    deleted?: BoolNullableFilter<"Section"> | boolean | null
    organization?: XOR<OrganizationNullableRelationFilter, OrganizationWhereInput> | null
  }, "id">

  export type SectionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    organizationId?: SortOrder
    deleted?: SortOrder
    _count?: SectionCountOrderByAggregateInput
    _max?: SectionMaxOrderByAggregateInput
    _min?: SectionMinOrderByAggregateInput
  }

  export type SectionScalarWhereWithAggregatesInput = {
    AND?: SectionScalarWhereWithAggregatesInput | SectionScalarWhereWithAggregatesInput[]
    OR?: SectionScalarWhereWithAggregatesInput[]
    NOT?: SectionScalarWhereWithAggregatesInput | SectionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Section"> | string
    name?: StringNullableWithAggregatesFilter<"Section"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Section"> | Date | string
    createdBy?: StringNullableWithAggregatesFilter<"Section"> | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"Section"> | Date | string
    updatedBy?: StringNullableWithAggregatesFilter<"Section"> | string | null
    organizationId?: StringNullableWithAggregatesFilter<"Section"> | string | null
    deleted?: BoolNullableWithAggregatesFilter<"Section"> | boolean | null
  }

  export type LocationWhereInput = {
    AND?: LocationWhereInput | LocationWhereInput[]
    OR?: LocationWhereInput[]
    NOT?: LocationWhereInput | LocationWhereInput[]
    id?: StringFilter<"Location"> | string
    locationName?: StringNullableFilter<"Location"> | string | null
    locationType?: StringNullableFilter<"Location"> | string | null
    locationId?: StringNullableFilter<"Location"> | string | null
    description?: StringNullableFilter<"Location"> | string | null
    status?: StringNullableFilter<"Location"> | string | null
    createdBy?: StringNullableFilter<"Location"> | string | null
    createdAt?: DateTimeFilter<"Location"> | Date | string
    updatedAt?: DateTimeFilter<"Location"> | Date | string
    updatedBy?: StringNullableFilter<"Location"> | string | null
    functionId?: StringNullableListFilter<"Location">
    deleted?: BoolNullableFilter<"Location"> | boolean | null
    organizationId?: StringNullableFilter<"Location"> | string | null
    users?: JsonNullableListFilter<"Location">
    businessTypeId?: StringNullableFilter<"Location"> | string | null
    type?: StringNullableFilter<"Location"> | string | null
    organization?: XOR<OrganizationNullableRelationFilter, OrganizationWhereInput> | null
    Documents?: DocumentsListRelationFilter
    entity?: EntityListRelationFilter
    business?: LocationBusinessListRelationFilter
    user?: UserListRelationFilter
    uom?: UnitTypeListRelationFilter
    rolesTable?: RolesTableListRelationFilter
    Role?: RoleListRelationFilter
  }

  export type LocationOrderByWithRelationInput = {
    id?: SortOrder
    locationName?: SortOrder
    locationType?: SortOrder
    locationId?: SortOrder
    description?: SortOrder
    status?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    functionId?: SortOrder
    deleted?: SortOrder
    organizationId?: SortOrder
    users?: SortOrder
    businessTypeId?: SortOrder
    type?: SortOrder
    organization?: OrganizationOrderByWithRelationInput
    Documents?: DocumentsOrderByRelationAggregateInput
    entity?: EntityOrderByRelationAggregateInput
    business?: LocationBusinessOrderByRelationAggregateInput
    user?: UserOrderByRelationAggregateInput
    uom?: unitTypeOrderByRelationAggregateInput
    rolesTable?: rolesTableOrderByRelationAggregateInput
    Role?: RoleOrderByRelationAggregateInput
  }

  export type LocationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LocationWhereInput | LocationWhereInput[]
    OR?: LocationWhereInput[]
    NOT?: LocationWhereInput | LocationWhereInput[]
    locationName?: StringNullableFilter<"Location"> | string | null
    locationType?: StringNullableFilter<"Location"> | string | null
    locationId?: StringNullableFilter<"Location"> | string | null
    description?: StringNullableFilter<"Location"> | string | null
    status?: StringNullableFilter<"Location"> | string | null
    createdBy?: StringNullableFilter<"Location"> | string | null
    createdAt?: DateTimeFilter<"Location"> | Date | string
    updatedAt?: DateTimeFilter<"Location"> | Date | string
    updatedBy?: StringNullableFilter<"Location"> | string | null
    functionId?: StringNullableListFilter<"Location">
    deleted?: BoolNullableFilter<"Location"> | boolean | null
    organizationId?: StringNullableFilter<"Location"> | string | null
    users?: JsonNullableListFilter<"Location">
    businessTypeId?: StringNullableFilter<"Location"> | string | null
    type?: StringNullableFilter<"Location"> | string | null
    organization?: XOR<OrganizationNullableRelationFilter, OrganizationWhereInput> | null
    Documents?: DocumentsListRelationFilter
    entity?: EntityListRelationFilter
    business?: LocationBusinessListRelationFilter
    user?: UserListRelationFilter
    uom?: UnitTypeListRelationFilter
    rolesTable?: RolesTableListRelationFilter
    Role?: RoleListRelationFilter
  }, "id">

  export type LocationOrderByWithAggregationInput = {
    id?: SortOrder
    locationName?: SortOrder
    locationType?: SortOrder
    locationId?: SortOrder
    description?: SortOrder
    status?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    functionId?: SortOrder
    deleted?: SortOrder
    organizationId?: SortOrder
    users?: SortOrder
    businessTypeId?: SortOrder
    type?: SortOrder
    _count?: LocationCountOrderByAggregateInput
    _max?: LocationMaxOrderByAggregateInput
    _min?: LocationMinOrderByAggregateInput
  }

  export type LocationScalarWhereWithAggregatesInput = {
    AND?: LocationScalarWhereWithAggregatesInput | LocationScalarWhereWithAggregatesInput[]
    OR?: LocationScalarWhereWithAggregatesInput[]
    NOT?: LocationScalarWhereWithAggregatesInput | LocationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Location"> | string
    locationName?: StringNullableWithAggregatesFilter<"Location"> | string | null
    locationType?: StringNullableWithAggregatesFilter<"Location"> | string | null
    locationId?: StringNullableWithAggregatesFilter<"Location"> | string | null
    description?: StringNullableWithAggregatesFilter<"Location"> | string | null
    status?: StringNullableWithAggregatesFilter<"Location"> | string | null
    createdBy?: StringNullableWithAggregatesFilter<"Location"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Location"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Location"> | Date | string
    updatedBy?: StringNullableWithAggregatesFilter<"Location"> | string | null
    functionId?: StringNullableListFilter<"Location">
    deleted?: BoolNullableWithAggregatesFilter<"Location"> | boolean | null
    organizationId?: StringNullableWithAggregatesFilter<"Location"> | string | null
    users?: JsonNullableListFilter<"Location">
    businessTypeId?: StringNullableWithAggregatesFilter<"Location"> | string | null
    type?: StringNullableWithAggregatesFilter<"Location"> | string | null
  }

  export type EntityWhereInput = {
    AND?: EntityWhereInput | EntityWhereInput[]
    OR?: EntityWhereInput[]
    NOT?: EntityWhereInput | EntityWhereInput[]
    id?: StringFilter<"Entity"> | string
    entityName?: StringNullableFilter<"Entity"> | string | null
    description?: StringNullableFilter<"Entity"> | string | null
    entityTypeId?: StringNullableFilter<"Entity"> | string | null
    organizationId?: StringNullableFilter<"Entity"> | string | null
    locationId?: StringNullableFilter<"Entity"> | string | null
    createdBy?: StringNullableFilter<"Entity"> | string | null
    entityId?: StringNullableFilter<"Entity"> | string | null
    deleted?: BoolNullableFilter<"Entity"> | boolean | null
    createdAt?: DateTimeFilter<"Entity"> | Date | string
    updatedAt?: DateTimeFilter<"Entity"> | Date | string
    updatedBy?: StringNullableFilter<"Entity"> | string | null
    users?: StringNullableListFilter<"Entity">
    sections?: StringNullableListFilter<"Entity">
    functionId?: StringNullableFilter<"Entity"> | string | null
    entityType?: XOR<EntityTypeNullableRelationFilter, EntityTypeWhereInput> | null
    location?: XOR<LocationNullableRelationFilter, LocationWhereInput> | null
    organization?: XOR<OrganizationNullableRelationFilter, OrganizationWhereInput> | null
    Doctype?: DoctypeListRelationFilter
    Documents?: DocumentsListRelationFilter
    user?: UserListRelationFilter
    parts?: PartsListRelationFilter
    claimToEntity?: ClaimToEntityListRelationFilter
    function?: XOR<FunctionsNullableRelationFilter, FunctionsWhereInput> | null
  }

  export type EntityOrderByWithRelationInput = {
    id?: SortOrder
    entityName?: SortOrder
    description?: SortOrder
    entityTypeId?: SortOrder
    organizationId?: SortOrder
    locationId?: SortOrder
    createdBy?: SortOrder
    entityId?: SortOrder
    deleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    users?: SortOrder
    sections?: SortOrder
    functionId?: SortOrder
    entityType?: EntityTypeOrderByWithRelationInput
    location?: LocationOrderByWithRelationInput
    organization?: OrganizationOrderByWithRelationInput
    Doctype?: DoctypeOrderByRelationAggregateInput
    Documents?: DocumentsOrderByRelationAggregateInput
    user?: UserOrderByRelationAggregateInput
    parts?: PartsOrderByRelationAggregateInput
    claimToEntity?: ClaimToEntityOrderByRelationAggregateInput
    function?: FunctionsOrderByWithRelationInput
  }

  export type EntityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EntityWhereInput | EntityWhereInput[]
    OR?: EntityWhereInput[]
    NOT?: EntityWhereInput | EntityWhereInput[]
    entityName?: StringNullableFilter<"Entity"> | string | null
    description?: StringNullableFilter<"Entity"> | string | null
    entityTypeId?: StringNullableFilter<"Entity"> | string | null
    organizationId?: StringNullableFilter<"Entity"> | string | null
    locationId?: StringNullableFilter<"Entity"> | string | null
    createdBy?: StringNullableFilter<"Entity"> | string | null
    entityId?: StringNullableFilter<"Entity"> | string | null
    deleted?: BoolNullableFilter<"Entity"> | boolean | null
    createdAt?: DateTimeFilter<"Entity"> | Date | string
    updatedAt?: DateTimeFilter<"Entity"> | Date | string
    updatedBy?: StringNullableFilter<"Entity"> | string | null
    users?: StringNullableListFilter<"Entity">
    sections?: StringNullableListFilter<"Entity">
    functionId?: StringNullableFilter<"Entity"> | string | null
    entityType?: XOR<EntityTypeNullableRelationFilter, EntityTypeWhereInput> | null
    location?: XOR<LocationNullableRelationFilter, LocationWhereInput> | null
    organization?: XOR<OrganizationNullableRelationFilter, OrganizationWhereInput> | null
    Doctype?: DoctypeListRelationFilter
    Documents?: DocumentsListRelationFilter
    user?: UserListRelationFilter
    parts?: PartsListRelationFilter
    claimToEntity?: ClaimToEntityListRelationFilter
    function?: XOR<FunctionsNullableRelationFilter, FunctionsWhereInput> | null
  }, "id">

  export type EntityOrderByWithAggregationInput = {
    id?: SortOrder
    entityName?: SortOrder
    description?: SortOrder
    entityTypeId?: SortOrder
    organizationId?: SortOrder
    locationId?: SortOrder
    createdBy?: SortOrder
    entityId?: SortOrder
    deleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    users?: SortOrder
    sections?: SortOrder
    functionId?: SortOrder
    _count?: EntityCountOrderByAggregateInput
    _max?: EntityMaxOrderByAggregateInput
    _min?: EntityMinOrderByAggregateInput
  }

  export type EntityScalarWhereWithAggregatesInput = {
    AND?: EntityScalarWhereWithAggregatesInput | EntityScalarWhereWithAggregatesInput[]
    OR?: EntityScalarWhereWithAggregatesInput[]
    NOT?: EntityScalarWhereWithAggregatesInput | EntityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Entity"> | string
    entityName?: StringNullableWithAggregatesFilter<"Entity"> | string | null
    description?: StringNullableWithAggregatesFilter<"Entity"> | string | null
    entityTypeId?: StringNullableWithAggregatesFilter<"Entity"> | string | null
    organizationId?: StringNullableWithAggregatesFilter<"Entity"> | string | null
    locationId?: StringNullableWithAggregatesFilter<"Entity"> | string | null
    createdBy?: StringNullableWithAggregatesFilter<"Entity"> | string | null
    entityId?: StringNullableWithAggregatesFilter<"Entity"> | string | null
    deleted?: BoolNullableWithAggregatesFilter<"Entity"> | boolean | null
    createdAt?: DateTimeWithAggregatesFilter<"Entity"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Entity"> | Date | string
    updatedBy?: StringNullableWithAggregatesFilter<"Entity"> | string | null
    users?: StringNullableListFilter<"Entity">
    sections?: StringNullableListFilter<"Entity">
    functionId?: StringNullableWithAggregatesFilter<"Entity"> | string | null
  }

  export type LocationBusinessWhereInput = {
    AND?: LocationBusinessWhereInput | LocationBusinessWhereInput[]
    OR?: LocationBusinessWhereInput[]
    NOT?: LocationBusinessWhereInput | LocationBusinessWhereInput[]
    id?: StringFilter<"LocationBusiness"> | string
    locationId?: StringNullableFilter<"LocationBusiness"> | string | null
    businessId?: StringNullableFilter<"LocationBusiness"> | string | null
    business?: XOR<BusinessNullableRelationFilter, BusinessWhereInput> | null
    location?: XOR<LocationNullableRelationFilter, LocationWhereInput> | null
  }

  export type LocationBusinessOrderByWithRelationInput = {
    id?: SortOrder
    locationId?: SortOrder
    businessId?: SortOrder
    business?: BusinessOrderByWithRelationInput
    location?: LocationOrderByWithRelationInput
  }

  export type LocationBusinessWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LocationBusinessWhereInput | LocationBusinessWhereInput[]
    OR?: LocationBusinessWhereInput[]
    NOT?: LocationBusinessWhereInput | LocationBusinessWhereInput[]
    locationId?: StringNullableFilter<"LocationBusiness"> | string | null
    businessId?: StringNullableFilter<"LocationBusiness"> | string | null
    business?: XOR<BusinessNullableRelationFilter, BusinessWhereInput> | null
    location?: XOR<LocationNullableRelationFilter, LocationWhereInput> | null
  }, "id">

  export type LocationBusinessOrderByWithAggregationInput = {
    id?: SortOrder
    locationId?: SortOrder
    businessId?: SortOrder
    _count?: LocationBusinessCountOrderByAggregateInput
    _max?: LocationBusinessMaxOrderByAggregateInput
    _min?: LocationBusinessMinOrderByAggregateInput
  }

  export type LocationBusinessScalarWhereWithAggregatesInput = {
    AND?: LocationBusinessScalarWhereWithAggregatesInput | LocationBusinessScalarWhereWithAggregatesInput[]
    OR?: LocationBusinessScalarWhereWithAggregatesInput[]
    NOT?: LocationBusinessScalarWhereWithAggregatesInput | LocationBusinessScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LocationBusiness"> | string
    locationId?: StringNullableWithAggregatesFilter<"LocationBusiness"> | string | null
    businessId?: StringNullableWithAggregatesFilter<"LocationBusiness"> | string | null
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    type?: StringNullableFilter<"Notification"> | string | null
    text?: StringFilter<"Notification"> | string
    content?: StringFilter<"Notification"> | string
    receiver?: StringNullableFilter<"Notification"> | string | null
    creator?: StringNullableFilter<"Notification"> | string | null
    date?: DateTimeFilter<"Notification"> | Date | string
    style?: StringNullableFilter<"Notification"> | string | null
    read?: BoolFilter<"Notification"> | boolean
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    text?: SortOrder
    content?: SortOrder
    receiver?: SortOrder
    creator?: SortOrder
    date?: SortOrder
    style?: SortOrder
    read?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    type?: StringNullableFilter<"Notification"> | string | null
    text?: StringFilter<"Notification"> | string
    content?: StringFilter<"Notification"> | string
    receiver?: StringNullableFilter<"Notification"> | string | null
    creator?: StringNullableFilter<"Notification"> | string | null
    date?: DateTimeFilter<"Notification"> | Date | string
    style?: StringNullableFilter<"Notification"> | string | null
    read?: BoolFilter<"Notification"> | boolean
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    text?: SortOrder
    content?: SortOrder
    receiver?: SortOrder
    creator?: SortOrder
    date?: SortOrder
    style?: SortOrder
    read?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    type?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    text?: StringWithAggregatesFilter<"Notification"> | string
    content?: StringWithAggregatesFilter<"Notification"> | string
    receiver?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    creator?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    date?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
    style?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    read?: BoolWithAggregatesFilter<"Notification"> | boolean
  }

  export type DoctypeWhereInput = {
    AND?: DoctypeWhereInput | DoctypeWhereInput[]
    OR?: DoctypeWhereInput[]
    NOT?: DoctypeWhereInput | DoctypeWhereInput[]
    id?: StringFilter<"Doctype"> | string
    locationId?: StringNullableListFilter<"Doctype">
    documentTypeName?: StringNullableFilter<"Doctype"> | string | null
    documentNumbering?: StringNullableFilter<"Doctype"> | string | null
    reviewFrequency?: IntNullableFilter<"Doctype"> | number | null
    revisionRemind?: IntNullableFilter<"Doctype"> | number | null
    prefix?: StringNullableFilter<"Doctype"> | string | null
    suffix?: StringNullableFilter<"Doctype"> | string | null
    organizationId?: StringNullableFilter<"Doctype"> | string | null
    readAccess?: StringNullableFilter<"Doctype"> | string | null
    readAccessUsers?: JsonNullableListFilter<"Doctype">
    createdAt?: DateTimeFilter<"Doctype"> | Date | string
    updatedAt?: DateTimeFilter<"Doctype"> | Date | string
    updatedBy?: StringNullableFilter<"Doctype"> | string | null
    createdBy?: StringNullableFilter<"Doctype"> | string | null
    applicable_systems?: JsonNullableListFilter<"Doctype">
    users?: JsonNullableListFilter<"Doctype">
    document_classification?: StringNullableFilter<"Doctype"> | string | null
    entityId?: StringNullableFilter<"Doctype"> | string | null
    distributionUsers?: JsonNullableListFilter<"Doctype">
    currentVersion?: StringFilter<"Doctype"> | string
    distributionList?: StringNullableFilter<"Doctype"> | string | null
    organization?: XOR<OrganizationNullableRelationFilter, OrganizationWhereInput> | null
    Entity?: XOR<EntityNullableRelationFilter, EntityWhereInput> | null
    Documents?: DocumentsListRelationFilter
    documentAdmins?: DocumentAdminsListRelationFilter
  }

  export type DoctypeOrderByWithRelationInput = {
    id?: SortOrder
    locationId?: SortOrder
    documentTypeName?: SortOrder
    documentNumbering?: SortOrder
    reviewFrequency?: SortOrder
    revisionRemind?: SortOrder
    prefix?: SortOrder
    suffix?: SortOrder
    organizationId?: SortOrder
    readAccess?: SortOrder
    readAccessUsers?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    createdBy?: SortOrder
    applicable_systems?: SortOrder
    users?: SortOrder
    document_classification?: SortOrder
    entityId?: SortOrder
    distributionUsers?: SortOrder
    currentVersion?: SortOrder
    distributionList?: SortOrder
    organization?: OrganizationOrderByWithRelationInput
    Entity?: EntityOrderByWithRelationInput
    Documents?: DocumentsOrderByRelationAggregateInput
    documentAdmins?: documentAdminsOrderByRelationAggregateInput
  }

  export type DoctypeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    docUnique?: DoctypeDocUniqueCompoundUniqueInput
    AND?: DoctypeWhereInput | DoctypeWhereInput[]
    OR?: DoctypeWhereInput[]
    NOT?: DoctypeWhereInput | DoctypeWhereInput[]
    locationId?: StringNullableListFilter<"Doctype">
    documentTypeName?: StringNullableFilter<"Doctype"> | string | null
    documentNumbering?: StringNullableFilter<"Doctype"> | string | null
    reviewFrequency?: IntNullableFilter<"Doctype"> | number | null
    revisionRemind?: IntNullableFilter<"Doctype"> | number | null
    prefix?: StringNullableFilter<"Doctype"> | string | null
    suffix?: StringNullableFilter<"Doctype"> | string | null
    organizationId?: StringNullableFilter<"Doctype"> | string | null
    readAccess?: StringNullableFilter<"Doctype"> | string | null
    readAccessUsers?: JsonNullableListFilter<"Doctype">
    createdAt?: DateTimeFilter<"Doctype"> | Date | string
    updatedAt?: DateTimeFilter<"Doctype"> | Date | string
    updatedBy?: StringNullableFilter<"Doctype"> | string | null
    createdBy?: StringNullableFilter<"Doctype"> | string | null
    applicable_systems?: JsonNullableListFilter<"Doctype">
    users?: JsonNullableListFilter<"Doctype">
    document_classification?: StringNullableFilter<"Doctype"> | string | null
    entityId?: StringNullableFilter<"Doctype"> | string | null
    distributionUsers?: JsonNullableListFilter<"Doctype">
    currentVersion?: StringFilter<"Doctype"> | string
    distributionList?: StringNullableFilter<"Doctype"> | string | null
    organization?: XOR<OrganizationNullableRelationFilter, OrganizationWhereInput> | null
    Entity?: XOR<EntityNullableRelationFilter, EntityWhereInput> | null
    Documents?: DocumentsListRelationFilter
    documentAdmins?: DocumentAdminsListRelationFilter
  }, "id" | "docUnique">

  export type DoctypeOrderByWithAggregationInput = {
    id?: SortOrder
    locationId?: SortOrder
    documentTypeName?: SortOrder
    documentNumbering?: SortOrder
    reviewFrequency?: SortOrder
    revisionRemind?: SortOrder
    prefix?: SortOrder
    suffix?: SortOrder
    organizationId?: SortOrder
    readAccess?: SortOrder
    readAccessUsers?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    createdBy?: SortOrder
    applicable_systems?: SortOrder
    users?: SortOrder
    document_classification?: SortOrder
    entityId?: SortOrder
    distributionUsers?: SortOrder
    currentVersion?: SortOrder
    distributionList?: SortOrder
    _count?: DoctypeCountOrderByAggregateInput
    _avg?: DoctypeAvgOrderByAggregateInput
    _max?: DoctypeMaxOrderByAggregateInput
    _min?: DoctypeMinOrderByAggregateInput
    _sum?: DoctypeSumOrderByAggregateInput
  }

  export type DoctypeScalarWhereWithAggregatesInput = {
    AND?: DoctypeScalarWhereWithAggregatesInput | DoctypeScalarWhereWithAggregatesInput[]
    OR?: DoctypeScalarWhereWithAggregatesInput[]
    NOT?: DoctypeScalarWhereWithAggregatesInput | DoctypeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Doctype"> | string
    locationId?: StringNullableListFilter<"Doctype">
    documentTypeName?: StringNullableWithAggregatesFilter<"Doctype"> | string | null
    documentNumbering?: StringNullableWithAggregatesFilter<"Doctype"> | string | null
    reviewFrequency?: IntNullableWithAggregatesFilter<"Doctype"> | number | null
    revisionRemind?: IntNullableWithAggregatesFilter<"Doctype"> | number | null
    prefix?: StringNullableWithAggregatesFilter<"Doctype"> | string | null
    suffix?: StringNullableWithAggregatesFilter<"Doctype"> | string | null
    organizationId?: StringNullableWithAggregatesFilter<"Doctype"> | string | null
    readAccess?: StringNullableWithAggregatesFilter<"Doctype"> | string | null
    readAccessUsers?: JsonNullableListFilter<"Doctype">
    createdAt?: DateTimeWithAggregatesFilter<"Doctype"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Doctype"> | Date | string
    updatedBy?: StringNullableWithAggregatesFilter<"Doctype"> | string | null
    createdBy?: StringNullableWithAggregatesFilter<"Doctype"> | string | null
    applicable_systems?: JsonNullableListFilter<"Doctype">
    users?: JsonNullableListFilter<"Doctype">
    document_classification?: StringNullableWithAggregatesFilter<"Doctype"> | string | null
    entityId?: StringNullableWithAggregatesFilter<"Doctype"> | string | null
    distributionUsers?: JsonNullableListFilter<"Doctype">
    currentVersion?: StringWithAggregatesFilter<"Doctype"> | string
    distributionList?: StringNullableWithAggregatesFilter<"Doctype"> | string | null
  }

  export type DocumentsWhereInput = {
    AND?: DocumentsWhereInput | DocumentsWhereInput[]
    OR?: DocumentsWhereInput[]
    NOT?: DocumentsWhereInput | DocumentsWhereInput[]
    id?: StringFilter<"Documents"> | string
    doctypeId?: StringNullableFilter<"Documents"> | string | null
    organizationId?: StringNullableFilter<"Documents"> | string | null
    documentName?: StringNullableFilter<"Documents"> | string | null
    documentNumbering?: StringNullableFilter<"Documents"> | string | null
    reasonOfCreation?: StringNullableFilter<"Documents"> | string | null
    effectiveDate?: DateTimeNullableFilter<"Documents"> | Date | string | null
    nextRevisionDate?: DateTimeNullableFilter<"Documents"> | Date | string | null
    currentVersion?: StringNullableFilter<"Documents"> | string | null
    documentLink?: StringNullableFilter<"Documents"> | string | null
    description?: StringNullableFilter<"Documents"> | string | null
    tags?: StringNullableListFilter<"Documents">
    documentState?: StringNullableFilter<"Documents"> | string | null
    locationId?: StringFilter<"Documents"> | string
    entityId?: StringNullableFilter<"Documents"> | string | null
    system?: StringNullableListFilter<"Documents">
    section?: StringNullableFilter<"Documents"> | string | null
    revertComment?: StringNullableFilter<"Documents"> | string | null
    docType?: StringNullableFilter<"Documents"> | string | null
    documentClassification?: StringNullableFilter<"Documents"> | string | null
    issueNumber?: StringNullableFilter<"Documents"> | string | null
    retireComment?: StringNullableFilter<"Documents"> | string | null
    revisionReminderFlag?: BoolNullableFilter<"Documents"> | boolean | null
    isVersion?: BoolNullableFilter<"Documents"> | boolean | null
    createdAt?: DateTimeFilter<"Documents"> | Date | string
    updatedAt?: DateTimeFilter<"Documents"> | Date | string
    approvedDate?: DateTimeNullableFilter<"Documents"> | Date | string | null
    countNumber?: IntNullableFilter<"Documents"> | number | null
    createdBy?: StringNullableFilter<"Documents"> | string | null
    distributionList?: StringNullableFilter<"Documents"> | string | null
    documentId?: StringNullableFilter<"Documents"> | string | null
    reviewers?: StringNullableListFilter<"Documents">
    approvers?: StringNullableListFilter<"Documents">
    creators?: StringNullableListFilter<"Documents">
    distributionUsers?: JsonNullableListFilter<"Documents">
    readAccess?: StringNullableFilter<"Documents"> | string | null
    readAccessUsers?: JsonNullableListFilter<"Documents">
    versionInfo?: JsonNullableListFilter<"Documents">
    doctype?: XOR<DoctypeNullableRelationFilter, DoctypeWhereInput> | null
    organization?: XOR<OrganizationNullableRelationFilter, OrganizationWhereInput> | null
    creatorLocation?: XOR<LocationNullableRelationFilter, LocationWhereInput> | null
    creatorEntity?: XOR<EntityNullableRelationFilter, EntityWhereInput> | null
    ReferenceDocuments?: ReferenceDocumentsListRelationFilter
    DocumentVersions?: DocumentVersionsListRelationFilter
    DocumentComments?: DocumentCommentsListRelationFilter
    DocumentWorkFlowHistory?: DocumentWorkFlowHistoryListRelationFilter
    AdditionalDocumentAdmins?: AdditionalDocumentAdminsListRelationFilter
    VersionReferenceDocuments?: VersionReferenceDocumentsListRelationFilter
  }

  export type DocumentsOrderByWithRelationInput = {
    id?: SortOrder
    doctypeId?: SortOrder
    organizationId?: SortOrder
    documentName?: SortOrder
    documentNumbering?: SortOrder
    reasonOfCreation?: SortOrder
    effectiveDate?: SortOrder
    nextRevisionDate?: SortOrder
    currentVersion?: SortOrder
    documentLink?: SortOrder
    description?: SortOrder
    tags?: SortOrder
    documentState?: SortOrder
    locationId?: SortOrder
    entityId?: SortOrder
    system?: SortOrder
    section?: SortOrder
    revertComment?: SortOrder
    docType?: SortOrder
    documentClassification?: SortOrder
    issueNumber?: SortOrder
    retireComment?: SortOrder
    revisionReminderFlag?: SortOrder
    isVersion?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    approvedDate?: SortOrder
    countNumber?: SortOrder
    createdBy?: SortOrder
    distributionList?: SortOrder
    documentId?: SortOrder
    reviewers?: SortOrder
    approvers?: SortOrder
    creators?: SortOrder
    distributionUsers?: SortOrder
    readAccess?: SortOrder
    readAccessUsers?: SortOrder
    versionInfo?: SortOrder
    doctype?: DoctypeOrderByWithRelationInput
    organization?: OrganizationOrderByWithRelationInput
    creatorLocation?: LocationOrderByWithRelationInput
    creatorEntity?: EntityOrderByWithRelationInput
    ReferenceDocuments?: ReferenceDocumentsOrderByRelationAggregateInput
    DocumentVersions?: DocumentVersionsOrderByRelationAggregateInput
    DocumentComments?: DocumentCommentsOrderByRelationAggregateInput
    DocumentWorkFlowHistory?: DocumentWorkFlowHistoryOrderByRelationAggregateInput
    AdditionalDocumentAdmins?: AdditionalDocumentAdminsOrderByRelationAggregateInput
    VersionReferenceDocuments?: VersionReferenceDocumentsOrderByRelationAggregateInput
  }

  export type DocumentsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DocumentsWhereInput | DocumentsWhereInput[]
    OR?: DocumentsWhereInput[]
    NOT?: DocumentsWhereInput | DocumentsWhereInput[]
    doctypeId?: StringNullableFilter<"Documents"> | string | null
    organizationId?: StringNullableFilter<"Documents"> | string | null
    documentName?: StringNullableFilter<"Documents"> | string | null
    documentNumbering?: StringNullableFilter<"Documents"> | string | null
    reasonOfCreation?: StringNullableFilter<"Documents"> | string | null
    effectiveDate?: DateTimeNullableFilter<"Documents"> | Date | string | null
    nextRevisionDate?: DateTimeNullableFilter<"Documents"> | Date | string | null
    currentVersion?: StringNullableFilter<"Documents"> | string | null
    documentLink?: StringNullableFilter<"Documents"> | string | null
    description?: StringNullableFilter<"Documents"> | string | null
    tags?: StringNullableListFilter<"Documents">
    documentState?: StringNullableFilter<"Documents"> | string | null
    locationId?: StringFilter<"Documents"> | string
    entityId?: StringNullableFilter<"Documents"> | string | null
    system?: StringNullableListFilter<"Documents">
    section?: StringNullableFilter<"Documents"> | string | null
    revertComment?: StringNullableFilter<"Documents"> | string | null
    docType?: StringNullableFilter<"Documents"> | string | null
    documentClassification?: StringNullableFilter<"Documents"> | string | null
    issueNumber?: StringNullableFilter<"Documents"> | string | null
    retireComment?: StringNullableFilter<"Documents"> | string | null
    revisionReminderFlag?: BoolNullableFilter<"Documents"> | boolean | null
    isVersion?: BoolNullableFilter<"Documents"> | boolean | null
    createdAt?: DateTimeFilter<"Documents"> | Date | string
    updatedAt?: DateTimeFilter<"Documents"> | Date | string
    approvedDate?: DateTimeNullableFilter<"Documents"> | Date | string | null
    countNumber?: IntNullableFilter<"Documents"> | number | null
    createdBy?: StringNullableFilter<"Documents"> | string | null
    distributionList?: StringNullableFilter<"Documents"> | string | null
    documentId?: StringNullableFilter<"Documents"> | string | null
    reviewers?: StringNullableListFilter<"Documents">
    approvers?: StringNullableListFilter<"Documents">
    creators?: StringNullableListFilter<"Documents">
    distributionUsers?: JsonNullableListFilter<"Documents">
    readAccess?: StringNullableFilter<"Documents"> | string | null
    readAccessUsers?: JsonNullableListFilter<"Documents">
    versionInfo?: JsonNullableListFilter<"Documents">
    doctype?: XOR<DoctypeNullableRelationFilter, DoctypeWhereInput> | null
    organization?: XOR<OrganizationNullableRelationFilter, OrganizationWhereInput> | null
    creatorLocation?: XOR<LocationNullableRelationFilter, LocationWhereInput> | null
    creatorEntity?: XOR<EntityNullableRelationFilter, EntityWhereInput> | null
    ReferenceDocuments?: ReferenceDocumentsListRelationFilter
    DocumentVersions?: DocumentVersionsListRelationFilter
    DocumentComments?: DocumentCommentsListRelationFilter
    DocumentWorkFlowHistory?: DocumentWorkFlowHistoryListRelationFilter
    AdditionalDocumentAdmins?: AdditionalDocumentAdminsListRelationFilter
    VersionReferenceDocuments?: VersionReferenceDocumentsListRelationFilter
  }, "id">

  export type DocumentsOrderByWithAggregationInput = {
    id?: SortOrder
    doctypeId?: SortOrder
    organizationId?: SortOrder
    documentName?: SortOrder
    documentNumbering?: SortOrder
    reasonOfCreation?: SortOrder
    effectiveDate?: SortOrder
    nextRevisionDate?: SortOrder
    currentVersion?: SortOrder
    documentLink?: SortOrder
    description?: SortOrder
    tags?: SortOrder
    documentState?: SortOrder
    locationId?: SortOrder
    entityId?: SortOrder
    system?: SortOrder
    section?: SortOrder
    revertComment?: SortOrder
    docType?: SortOrder
    documentClassification?: SortOrder
    issueNumber?: SortOrder
    retireComment?: SortOrder
    revisionReminderFlag?: SortOrder
    isVersion?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    approvedDate?: SortOrder
    countNumber?: SortOrder
    createdBy?: SortOrder
    distributionList?: SortOrder
    documentId?: SortOrder
    reviewers?: SortOrder
    approvers?: SortOrder
    creators?: SortOrder
    distributionUsers?: SortOrder
    readAccess?: SortOrder
    readAccessUsers?: SortOrder
    versionInfo?: SortOrder
    _count?: DocumentsCountOrderByAggregateInput
    _avg?: DocumentsAvgOrderByAggregateInput
    _max?: DocumentsMaxOrderByAggregateInput
    _min?: DocumentsMinOrderByAggregateInput
    _sum?: DocumentsSumOrderByAggregateInput
  }

  export type DocumentsScalarWhereWithAggregatesInput = {
    AND?: DocumentsScalarWhereWithAggregatesInput | DocumentsScalarWhereWithAggregatesInput[]
    OR?: DocumentsScalarWhereWithAggregatesInput[]
    NOT?: DocumentsScalarWhereWithAggregatesInput | DocumentsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Documents"> | string
    doctypeId?: StringNullableWithAggregatesFilter<"Documents"> | string | null
    organizationId?: StringNullableWithAggregatesFilter<"Documents"> | string | null
    documentName?: StringNullableWithAggregatesFilter<"Documents"> | string | null
    documentNumbering?: StringNullableWithAggregatesFilter<"Documents"> | string | null
    reasonOfCreation?: StringNullableWithAggregatesFilter<"Documents"> | string | null
    effectiveDate?: DateTimeNullableWithAggregatesFilter<"Documents"> | Date | string | null
    nextRevisionDate?: DateTimeNullableWithAggregatesFilter<"Documents"> | Date | string | null
    currentVersion?: StringNullableWithAggregatesFilter<"Documents"> | string | null
    documentLink?: StringNullableWithAggregatesFilter<"Documents"> | string | null
    description?: StringNullableWithAggregatesFilter<"Documents"> | string | null
    tags?: StringNullableListFilter<"Documents">
    documentState?: StringNullableWithAggregatesFilter<"Documents"> | string | null
    locationId?: StringWithAggregatesFilter<"Documents"> | string
    entityId?: StringNullableWithAggregatesFilter<"Documents"> | string | null
    system?: StringNullableListFilter<"Documents">
    section?: StringNullableWithAggregatesFilter<"Documents"> | string | null
    revertComment?: StringNullableWithAggregatesFilter<"Documents"> | string | null
    docType?: StringNullableWithAggregatesFilter<"Documents"> | string | null
    documentClassification?: StringNullableWithAggregatesFilter<"Documents"> | string | null
    issueNumber?: StringNullableWithAggregatesFilter<"Documents"> | string | null
    retireComment?: StringNullableWithAggregatesFilter<"Documents"> | string | null
    revisionReminderFlag?: BoolNullableWithAggregatesFilter<"Documents"> | boolean | null
    isVersion?: BoolNullableWithAggregatesFilter<"Documents"> | boolean | null
    createdAt?: DateTimeWithAggregatesFilter<"Documents"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Documents"> | Date | string
    approvedDate?: DateTimeNullableWithAggregatesFilter<"Documents"> | Date | string | null
    countNumber?: IntNullableWithAggregatesFilter<"Documents"> | number | null
    createdBy?: StringNullableWithAggregatesFilter<"Documents"> | string | null
    distributionList?: StringNullableWithAggregatesFilter<"Documents"> | string | null
    documentId?: StringNullableWithAggregatesFilter<"Documents"> | string | null
    reviewers?: StringNullableListFilter<"Documents">
    approvers?: StringNullableListFilter<"Documents">
    creators?: StringNullableListFilter<"Documents">
    distributionUsers?: JsonNullableListFilter<"Documents">
    readAccess?: StringNullableWithAggregatesFilter<"Documents"> | string | null
    readAccessUsers?: JsonNullableListFilter<"Documents">
    versionInfo?: JsonNullableListFilter<"Documents">
  }

  export type documentAttachmentHistoryWhereInput = {
    AND?: documentAttachmentHistoryWhereInput | documentAttachmentHistoryWhereInput[]
    OR?: documentAttachmentHistoryWhereInput[]
    NOT?: documentAttachmentHistoryWhereInput | documentAttachmentHistoryWhereInput[]
    id?: StringFilter<"documentAttachmentHistory"> | string
    documentId?: StringNullableFilter<"documentAttachmentHistory"> | string | null
    updatedLink?: StringNullableFilter<"documentAttachmentHistory"> | string | null
    updatedBy?: StringNullableFilter<"documentAttachmentHistory"> | string | null
    updatedAt?: DateTimeFilter<"documentAttachmentHistory"> | Date | string
  }

  export type documentAttachmentHistoryOrderByWithRelationInput = {
    id?: SortOrder
    documentId?: SortOrder
    updatedLink?: SortOrder
    updatedBy?: SortOrder
    updatedAt?: SortOrder
  }

  export type documentAttachmentHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: documentAttachmentHistoryWhereInput | documentAttachmentHistoryWhereInput[]
    OR?: documentAttachmentHistoryWhereInput[]
    NOT?: documentAttachmentHistoryWhereInput | documentAttachmentHistoryWhereInput[]
    documentId?: StringNullableFilter<"documentAttachmentHistory"> | string | null
    updatedLink?: StringNullableFilter<"documentAttachmentHistory"> | string | null
    updatedBy?: StringNullableFilter<"documentAttachmentHistory"> | string | null
    updatedAt?: DateTimeFilter<"documentAttachmentHistory"> | Date | string
  }, "id">

  export type documentAttachmentHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    documentId?: SortOrder
    updatedLink?: SortOrder
    updatedBy?: SortOrder
    updatedAt?: SortOrder
    _count?: documentAttachmentHistoryCountOrderByAggregateInput
    _max?: documentAttachmentHistoryMaxOrderByAggregateInput
    _min?: documentAttachmentHistoryMinOrderByAggregateInput
  }

  export type documentAttachmentHistoryScalarWhereWithAggregatesInput = {
    AND?: documentAttachmentHistoryScalarWhereWithAggregatesInput | documentAttachmentHistoryScalarWhereWithAggregatesInput[]
    OR?: documentAttachmentHistoryScalarWhereWithAggregatesInput[]
    NOT?: documentAttachmentHistoryScalarWhereWithAggregatesInput | documentAttachmentHistoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"documentAttachmentHistory"> | string
    documentId?: StringNullableWithAggregatesFilter<"documentAttachmentHistory"> | string | null
    updatedLink?: StringNullableWithAggregatesFilter<"documentAttachmentHistory"> | string | null
    updatedBy?: StringNullableWithAggregatesFilter<"documentAttachmentHistory"> | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"documentAttachmentHistory"> | Date | string
  }

  export type ReferenceDocumentsWhereInput = {
    AND?: ReferenceDocumentsWhereInput | ReferenceDocumentsWhereInput[]
    OR?: ReferenceDocumentsWhereInput[]
    NOT?: ReferenceDocumentsWhereInput | ReferenceDocumentsWhereInput[]
    id?: StringFilter<"ReferenceDocuments"> | string
    documentLink?: StringNullableFilter<"ReferenceDocuments"> | string | null
    type?: StringNullableFilter<"ReferenceDocuments"> | string | null
    documentName?: StringNullableFilter<"ReferenceDocuments"> | string | null
    version?: StringNullableFilter<"ReferenceDocuments"> | string | null
    documentId?: StringNullableFilter<"ReferenceDocuments"> | string | null
    createdAt?: DateTimeFilter<"ReferenceDocuments"> | Date | string
    updatedAt?: DateTimeFilter<"ReferenceDocuments"> | Date | string
    referenceDocId?: StringNullableFilter<"ReferenceDocuments"> | string | null
    versionId?: StringNullableFilter<"ReferenceDocuments"> | string | null
    document?: XOR<DocumentsNullableRelationFilter, DocumentsWhereInput> | null
    versionsLinkedWith?: XOR<DocumentVersionsNullableRelationFilter, DocumentVersionsWhereInput> | null
  }

  export type ReferenceDocumentsOrderByWithRelationInput = {
    id?: SortOrder
    documentLink?: SortOrder
    type?: SortOrder
    documentName?: SortOrder
    version?: SortOrder
    documentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    referenceDocId?: SortOrder
    versionId?: SortOrder
    document?: DocumentsOrderByWithRelationInput
    versionsLinkedWith?: DocumentVersionsOrderByWithRelationInput
  }

  export type ReferenceDocumentsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ReferenceDocumentsWhereInput | ReferenceDocumentsWhereInput[]
    OR?: ReferenceDocumentsWhereInput[]
    NOT?: ReferenceDocumentsWhereInput | ReferenceDocumentsWhereInput[]
    documentLink?: StringNullableFilter<"ReferenceDocuments"> | string | null
    type?: StringNullableFilter<"ReferenceDocuments"> | string | null
    documentName?: StringNullableFilter<"ReferenceDocuments"> | string | null
    version?: StringNullableFilter<"ReferenceDocuments"> | string | null
    documentId?: StringNullableFilter<"ReferenceDocuments"> | string | null
    createdAt?: DateTimeFilter<"ReferenceDocuments"> | Date | string
    updatedAt?: DateTimeFilter<"ReferenceDocuments"> | Date | string
    referenceDocId?: StringNullableFilter<"ReferenceDocuments"> | string | null
    versionId?: StringNullableFilter<"ReferenceDocuments"> | string | null
    document?: XOR<DocumentsNullableRelationFilter, DocumentsWhereInput> | null
    versionsLinkedWith?: XOR<DocumentVersionsNullableRelationFilter, DocumentVersionsWhereInput> | null
  }, "id">

  export type ReferenceDocumentsOrderByWithAggregationInput = {
    id?: SortOrder
    documentLink?: SortOrder
    type?: SortOrder
    documentName?: SortOrder
    version?: SortOrder
    documentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    referenceDocId?: SortOrder
    versionId?: SortOrder
    _count?: ReferenceDocumentsCountOrderByAggregateInput
    _max?: ReferenceDocumentsMaxOrderByAggregateInput
    _min?: ReferenceDocumentsMinOrderByAggregateInput
  }

  export type ReferenceDocumentsScalarWhereWithAggregatesInput = {
    AND?: ReferenceDocumentsScalarWhereWithAggregatesInput | ReferenceDocumentsScalarWhereWithAggregatesInput[]
    OR?: ReferenceDocumentsScalarWhereWithAggregatesInput[]
    NOT?: ReferenceDocumentsScalarWhereWithAggregatesInput | ReferenceDocumentsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ReferenceDocuments"> | string
    documentLink?: StringNullableWithAggregatesFilter<"ReferenceDocuments"> | string | null
    type?: StringNullableWithAggregatesFilter<"ReferenceDocuments"> | string | null
    documentName?: StringNullableWithAggregatesFilter<"ReferenceDocuments"> | string | null
    version?: StringNullableWithAggregatesFilter<"ReferenceDocuments"> | string | null
    documentId?: StringNullableWithAggregatesFilter<"ReferenceDocuments"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ReferenceDocuments"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ReferenceDocuments"> | Date | string
    referenceDocId?: StringNullableWithAggregatesFilter<"ReferenceDocuments"> | string | null
    versionId?: StringNullableWithAggregatesFilter<"ReferenceDocuments"> | string | null
  }

  export type VersionReferenceDocumentsWhereInput = {
    AND?: VersionReferenceDocumentsWhereInput | VersionReferenceDocumentsWhereInput[]
    OR?: VersionReferenceDocumentsWhereInput[]
    NOT?: VersionReferenceDocumentsWhereInput | VersionReferenceDocumentsWhereInput[]
    id?: StringFilter<"VersionReferenceDocuments"> | string
    documentLink?: StringNullableFilter<"VersionReferenceDocuments"> | string | null
    type?: StringNullableFilter<"VersionReferenceDocuments"> | string | null
    documentName?: StringNullableFilter<"VersionReferenceDocuments"> | string | null
    version?: StringNullableFilter<"VersionReferenceDocuments"> | string | null
    createdAt?: DateTimeFilter<"VersionReferenceDocuments"> | Date | string
    updatedAt?: DateTimeFilter<"VersionReferenceDocuments"> | Date | string
    referenceDocId?: StringNullableFilter<"VersionReferenceDocuments"> | string | null
    versionId?: StringNullableFilter<"VersionReferenceDocuments"> | string | null
    documentsId?: StringNullableFilter<"VersionReferenceDocuments"> | string | null
    Documents?: XOR<DocumentsNullableRelationFilter, DocumentsWhereInput> | null
    versionsLinkedWith?: XOR<DocumentVersionsNullableRelationFilter, DocumentVersionsWhereInput> | null
  }

  export type VersionReferenceDocumentsOrderByWithRelationInput = {
    id?: SortOrder
    documentLink?: SortOrder
    type?: SortOrder
    documentName?: SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    referenceDocId?: SortOrder
    versionId?: SortOrder
    documentsId?: SortOrder
    Documents?: DocumentsOrderByWithRelationInput
    versionsLinkedWith?: DocumentVersionsOrderByWithRelationInput
  }

  export type VersionReferenceDocumentsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VersionReferenceDocumentsWhereInput | VersionReferenceDocumentsWhereInput[]
    OR?: VersionReferenceDocumentsWhereInput[]
    NOT?: VersionReferenceDocumentsWhereInput | VersionReferenceDocumentsWhereInput[]
    documentLink?: StringNullableFilter<"VersionReferenceDocuments"> | string | null
    type?: StringNullableFilter<"VersionReferenceDocuments"> | string | null
    documentName?: StringNullableFilter<"VersionReferenceDocuments"> | string | null
    version?: StringNullableFilter<"VersionReferenceDocuments"> | string | null
    createdAt?: DateTimeFilter<"VersionReferenceDocuments"> | Date | string
    updatedAt?: DateTimeFilter<"VersionReferenceDocuments"> | Date | string
    referenceDocId?: StringNullableFilter<"VersionReferenceDocuments"> | string | null
    versionId?: StringNullableFilter<"VersionReferenceDocuments"> | string | null
    documentsId?: StringNullableFilter<"VersionReferenceDocuments"> | string | null
    Documents?: XOR<DocumentsNullableRelationFilter, DocumentsWhereInput> | null
    versionsLinkedWith?: XOR<DocumentVersionsNullableRelationFilter, DocumentVersionsWhereInput> | null
  }, "id">

  export type VersionReferenceDocumentsOrderByWithAggregationInput = {
    id?: SortOrder
    documentLink?: SortOrder
    type?: SortOrder
    documentName?: SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    referenceDocId?: SortOrder
    versionId?: SortOrder
    documentsId?: SortOrder
    _count?: VersionReferenceDocumentsCountOrderByAggregateInput
    _max?: VersionReferenceDocumentsMaxOrderByAggregateInput
    _min?: VersionReferenceDocumentsMinOrderByAggregateInput
  }

  export type VersionReferenceDocumentsScalarWhereWithAggregatesInput = {
    AND?: VersionReferenceDocumentsScalarWhereWithAggregatesInput | VersionReferenceDocumentsScalarWhereWithAggregatesInput[]
    OR?: VersionReferenceDocumentsScalarWhereWithAggregatesInput[]
    NOT?: VersionReferenceDocumentsScalarWhereWithAggregatesInput | VersionReferenceDocumentsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VersionReferenceDocuments"> | string
    documentLink?: StringNullableWithAggregatesFilter<"VersionReferenceDocuments"> | string | null
    type?: StringNullableWithAggregatesFilter<"VersionReferenceDocuments"> | string | null
    documentName?: StringNullableWithAggregatesFilter<"VersionReferenceDocuments"> | string | null
    version?: StringNullableWithAggregatesFilter<"VersionReferenceDocuments"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"VersionReferenceDocuments"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"VersionReferenceDocuments"> | Date | string
    referenceDocId?: StringNullableWithAggregatesFilter<"VersionReferenceDocuments"> | string | null
    versionId?: StringNullableWithAggregatesFilter<"VersionReferenceDocuments"> | string | null
    documentsId?: StringNullableWithAggregatesFilter<"VersionReferenceDocuments"> | string | null
  }

  export type DocumentVersionsWhereInput = {
    AND?: DocumentVersionsWhereInput | DocumentVersionsWhereInput[]
    OR?: DocumentVersionsWhereInput[]
    NOT?: DocumentVersionsWhereInput | DocumentVersionsWhereInput[]
    id?: StringFilter<"DocumentVersions"> | string
    versionName?: StringFilter<"DocumentVersions"> | string
    userId?: StringNullableFilter<"DocumentVersions"> | string | null
    by?: StringNullableFilter<"DocumentVersions"> | string | null
    approvedDate?: DateTimeNullableFilter<"DocumentVersions"> | Date | string | null
    versionLink?: StringFilter<"DocumentVersions"> | string
    documentId?: StringNullableFilter<"DocumentVersions"> | string | null
    createdAt?: DateTimeFilter<"DocumentVersions"> | Date | string
    updatedAt?: DateTimeFilter<"DocumentVersions"> | Date | string
    documentName?: StringNullableFilter<"DocumentVersions"> | string | null
    documentNumbering?: StringNullableFilter<"DocumentVersions"> | string | null
    reasonOfCreation?: StringNullableFilter<"DocumentVersions"> | string | null
    effectiveDate?: DateTimeNullableFilter<"DocumentVersions"> | Date | string | null
    description?: StringNullableFilter<"DocumentVersions"> | string | null
    issueNumber?: StringNullableFilter<"DocumentVersions"> | string | null
    document?: XOR<DocumentsNullableRelationFilter, DocumentsWhereInput> | null
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    ReferenceDocuments?: ReferenceDocumentsListRelationFilter
    VersionReferenceDocuments?: VersionReferenceDocumentsListRelationFilter
  }

  export type DocumentVersionsOrderByWithRelationInput = {
    id?: SortOrder
    versionName?: SortOrder
    userId?: SortOrder
    by?: SortOrder
    approvedDate?: SortOrder
    versionLink?: SortOrder
    documentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    documentName?: SortOrder
    documentNumbering?: SortOrder
    reasonOfCreation?: SortOrder
    effectiveDate?: SortOrder
    description?: SortOrder
    issueNumber?: SortOrder
    document?: DocumentsOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    ReferenceDocuments?: ReferenceDocumentsOrderByRelationAggregateInput
    VersionReferenceDocuments?: VersionReferenceDocumentsOrderByRelationAggregateInput
  }

  export type DocumentVersionsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DocumentVersionsWhereInput | DocumentVersionsWhereInput[]
    OR?: DocumentVersionsWhereInput[]
    NOT?: DocumentVersionsWhereInput | DocumentVersionsWhereInput[]
    versionName?: StringFilter<"DocumentVersions"> | string
    userId?: StringNullableFilter<"DocumentVersions"> | string | null
    by?: StringNullableFilter<"DocumentVersions"> | string | null
    approvedDate?: DateTimeNullableFilter<"DocumentVersions"> | Date | string | null
    versionLink?: StringFilter<"DocumentVersions"> | string
    documentId?: StringNullableFilter<"DocumentVersions"> | string | null
    createdAt?: DateTimeFilter<"DocumentVersions"> | Date | string
    updatedAt?: DateTimeFilter<"DocumentVersions"> | Date | string
    documentName?: StringNullableFilter<"DocumentVersions"> | string | null
    documentNumbering?: StringNullableFilter<"DocumentVersions"> | string | null
    reasonOfCreation?: StringNullableFilter<"DocumentVersions"> | string | null
    effectiveDate?: DateTimeNullableFilter<"DocumentVersions"> | Date | string | null
    description?: StringNullableFilter<"DocumentVersions"> | string | null
    issueNumber?: StringNullableFilter<"DocumentVersions"> | string | null
    document?: XOR<DocumentsNullableRelationFilter, DocumentsWhereInput> | null
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    ReferenceDocuments?: ReferenceDocumentsListRelationFilter
    VersionReferenceDocuments?: VersionReferenceDocumentsListRelationFilter
  }, "id">

  export type DocumentVersionsOrderByWithAggregationInput = {
    id?: SortOrder
    versionName?: SortOrder
    userId?: SortOrder
    by?: SortOrder
    approvedDate?: SortOrder
    versionLink?: SortOrder
    documentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    documentName?: SortOrder
    documentNumbering?: SortOrder
    reasonOfCreation?: SortOrder
    effectiveDate?: SortOrder
    description?: SortOrder
    issueNumber?: SortOrder
    _count?: DocumentVersionsCountOrderByAggregateInput
    _max?: DocumentVersionsMaxOrderByAggregateInput
    _min?: DocumentVersionsMinOrderByAggregateInput
  }

  export type DocumentVersionsScalarWhereWithAggregatesInput = {
    AND?: DocumentVersionsScalarWhereWithAggregatesInput | DocumentVersionsScalarWhereWithAggregatesInput[]
    OR?: DocumentVersionsScalarWhereWithAggregatesInput[]
    NOT?: DocumentVersionsScalarWhereWithAggregatesInput | DocumentVersionsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DocumentVersions"> | string
    versionName?: StringWithAggregatesFilter<"DocumentVersions"> | string
    userId?: StringNullableWithAggregatesFilter<"DocumentVersions"> | string | null
    by?: StringNullableWithAggregatesFilter<"DocumentVersions"> | string | null
    approvedDate?: DateTimeNullableWithAggregatesFilter<"DocumentVersions"> | Date | string | null
    versionLink?: StringWithAggregatesFilter<"DocumentVersions"> | string
    documentId?: StringNullableWithAggregatesFilter<"DocumentVersions"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"DocumentVersions"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DocumentVersions"> | Date | string
    documentName?: StringNullableWithAggregatesFilter<"DocumentVersions"> | string | null
    documentNumbering?: StringNullableWithAggregatesFilter<"DocumentVersions"> | string | null
    reasonOfCreation?: StringNullableWithAggregatesFilter<"DocumentVersions"> | string | null
    effectiveDate?: DateTimeNullableWithAggregatesFilter<"DocumentVersions"> | Date | string | null
    description?: StringNullableWithAggregatesFilter<"DocumentVersions"> | string | null
    issueNumber?: StringNullableWithAggregatesFilter<"DocumentVersions"> | string | null
  }

  export type DocumentCommentsWhereInput = {
    AND?: DocumentCommentsWhereInput | DocumentCommentsWhereInput[]
    OR?: DocumentCommentsWhereInput[]
    NOT?: DocumentCommentsWhereInput | DocumentCommentsWhereInput[]
    id?: StringFilter<"DocumentComments"> | string
    userId?: StringNullableFilter<"DocumentComments"> | string | null
    commentBy?: StringNullableFilter<"DocumentComments"> | string | null
    commentText?: StringFilter<"DocumentComments"> | string
    documentId?: StringNullableFilter<"DocumentComments"> | string | null
    createdAt?: DateTimeFilter<"DocumentComments"> | Date | string
    updatedAt?: DateTimeFilter<"DocumentComments"> | Date | string
    document?: XOR<DocumentsNullableRelationFilter, DocumentsWhereInput> | null
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type DocumentCommentsOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    commentBy?: SortOrder
    commentText?: SortOrder
    documentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    document?: DocumentsOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type DocumentCommentsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DocumentCommentsWhereInput | DocumentCommentsWhereInput[]
    OR?: DocumentCommentsWhereInput[]
    NOT?: DocumentCommentsWhereInput | DocumentCommentsWhereInput[]
    userId?: StringNullableFilter<"DocumentComments"> | string | null
    commentBy?: StringNullableFilter<"DocumentComments"> | string | null
    commentText?: StringFilter<"DocumentComments"> | string
    documentId?: StringNullableFilter<"DocumentComments"> | string | null
    createdAt?: DateTimeFilter<"DocumentComments"> | Date | string
    updatedAt?: DateTimeFilter<"DocumentComments"> | Date | string
    document?: XOR<DocumentsNullableRelationFilter, DocumentsWhereInput> | null
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type DocumentCommentsOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    commentBy?: SortOrder
    commentText?: SortOrder
    documentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DocumentCommentsCountOrderByAggregateInput
    _max?: DocumentCommentsMaxOrderByAggregateInput
    _min?: DocumentCommentsMinOrderByAggregateInput
  }

  export type DocumentCommentsScalarWhereWithAggregatesInput = {
    AND?: DocumentCommentsScalarWhereWithAggregatesInput | DocumentCommentsScalarWhereWithAggregatesInput[]
    OR?: DocumentCommentsScalarWhereWithAggregatesInput[]
    NOT?: DocumentCommentsScalarWhereWithAggregatesInput | DocumentCommentsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DocumentComments"> | string
    userId?: StringNullableWithAggregatesFilter<"DocumentComments"> | string | null
    commentBy?: StringNullableWithAggregatesFilter<"DocumentComments"> | string | null
    commentText?: StringWithAggregatesFilter<"DocumentComments"> | string
    documentId?: StringNullableWithAggregatesFilter<"DocumentComments"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"DocumentComments"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DocumentComments"> | Date | string
  }

  export type DocumentWorkFlowHistoryWhereInput = {
    AND?: DocumentWorkFlowHistoryWhereInput | DocumentWorkFlowHistoryWhereInput[]
    OR?: DocumentWorkFlowHistoryWhereInput[]
    NOT?: DocumentWorkFlowHistoryWhereInput | DocumentWorkFlowHistoryWhereInput[]
    id?: StringFilter<"DocumentWorkFlowHistory"> | string
    actionName?: StringFilter<"DocumentWorkFlowHistory"> | string
    userId?: StringNullableFilter<"DocumentWorkFlowHistory"> | string | null
    actionBy?: StringNullableFilter<"DocumentWorkFlowHistory"> | string | null
    documentId?: StringNullableFilter<"DocumentWorkFlowHistory"> | string | null
    createdAt?: DateTimeFilter<"DocumentWorkFlowHistory"> | Date | string
    updatedAt?: DateTimeFilter<"DocumentWorkFlowHistory"> | Date | string
    document?: XOR<DocumentsNullableRelationFilter, DocumentsWhereInput> | null
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type DocumentWorkFlowHistoryOrderByWithRelationInput = {
    id?: SortOrder
    actionName?: SortOrder
    userId?: SortOrder
    actionBy?: SortOrder
    documentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    document?: DocumentsOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type DocumentWorkFlowHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DocumentWorkFlowHistoryWhereInput | DocumentWorkFlowHistoryWhereInput[]
    OR?: DocumentWorkFlowHistoryWhereInput[]
    NOT?: DocumentWorkFlowHistoryWhereInput | DocumentWorkFlowHistoryWhereInput[]
    actionName?: StringFilter<"DocumentWorkFlowHistory"> | string
    userId?: StringNullableFilter<"DocumentWorkFlowHistory"> | string | null
    actionBy?: StringNullableFilter<"DocumentWorkFlowHistory"> | string | null
    documentId?: StringNullableFilter<"DocumentWorkFlowHistory"> | string | null
    createdAt?: DateTimeFilter<"DocumentWorkFlowHistory"> | Date | string
    updatedAt?: DateTimeFilter<"DocumentWorkFlowHistory"> | Date | string
    document?: XOR<DocumentsNullableRelationFilter, DocumentsWhereInput> | null
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type DocumentWorkFlowHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    actionName?: SortOrder
    userId?: SortOrder
    actionBy?: SortOrder
    documentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DocumentWorkFlowHistoryCountOrderByAggregateInput
    _max?: DocumentWorkFlowHistoryMaxOrderByAggregateInput
    _min?: DocumentWorkFlowHistoryMinOrderByAggregateInput
  }

  export type DocumentWorkFlowHistoryScalarWhereWithAggregatesInput = {
    AND?: DocumentWorkFlowHistoryScalarWhereWithAggregatesInput | DocumentWorkFlowHistoryScalarWhereWithAggregatesInput[]
    OR?: DocumentWorkFlowHistoryScalarWhereWithAggregatesInput[]
    NOT?: DocumentWorkFlowHistoryScalarWhereWithAggregatesInput | DocumentWorkFlowHistoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DocumentWorkFlowHistory"> | string
    actionName?: StringWithAggregatesFilter<"DocumentWorkFlowHistory"> | string
    userId?: StringNullableWithAggregatesFilter<"DocumentWorkFlowHistory"> | string | null
    actionBy?: StringNullableWithAggregatesFilter<"DocumentWorkFlowHistory"> | string | null
    documentId?: StringNullableWithAggregatesFilter<"DocumentWorkFlowHistory"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"DocumentWorkFlowHistory"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DocumentWorkFlowHistory"> | Date | string
  }

  export type documentAdminsWhereInput = {
    AND?: documentAdminsWhereInput | documentAdminsWhereInput[]
    OR?: documentAdminsWhereInput[]
    NOT?: documentAdminsWhereInput | documentAdminsWhereInput[]
    id?: StringFilter<"documentAdmins"> | string
    type?: StringFilter<"documentAdmins"> | string
    firstname?: StringFilter<"documentAdmins"> | string
    lastname?: StringFilter<"documentAdmins"> | string
    email?: StringFilter<"documentAdmins"> | string
    userId?: StringFilter<"documentAdmins"> | string
    doctypeId?: StringNullableFilter<"documentAdmins"> | string | null
    createdAt?: DateTimeFilter<"documentAdmins"> | Date | string
    updatedAt?: DateTimeFilter<"documentAdmins"> | Date | string
    doctype?: XOR<DoctypeNullableRelationFilter, DoctypeWhereInput> | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type documentAdminsOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    email?: SortOrder
    userId?: SortOrder
    doctypeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    doctype?: DoctypeOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type documentAdminsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: documentAdminsWhereInput | documentAdminsWhereInput[]
    OR?: documentAdminsWhereInput[]
    NOT?: documentAdminsWhereInput | documentAdminsWhereInput[]
    type?: StringFilter<"documentAdmins"> | string
    firstname?: StringFilter<"documentAdmins"> | string
    lastname?: StringFilter<"documentAdmins"> | string
    email?: StringFilter<"documentAdmins"> | string
    userId?: StringFilter<"documentAdmins"> | string
    doctypeId?: StringNullableFilter<"documentAdmins"> | string | null
    createdAt?: DateTimeFilter<"documentAdmins"> | Date | string
    updatedAt?: DateTimeFilter<"documentAdmins"> | Date | string
    doctype?: XOR<DoctypeNullableRelationFilter, DoctypeWhereInput> | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type documentAdminsOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    email?: SortOrder
    userId?: SortOrder
    doctypeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: documentAdminsCountOrderByAggregateInput
    _max?: documentAdminsMaxOrderByAggregateInput
    _min?: documentAdminsMinOrderByAggregateInput
  }

  export type documentAdminsScalarWhereWithAggregatesInput = {
    AND?: documentAdminsScalarWhereWithAggregatesInput | documentAdminsScalarWhereWithAggregatesInput[]
    OR?: documentAdminsScalarWhereWithAggregatesInput[]
    NOT?: documentAdminsScalarWhereWithAggregatesInput | documentAdminsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"documentAdmins"> | string
    type?: StringWithAggregatesFilter<"documentAdmins"> | string
    firstname?: StringWithAggregatesFilter<"documentAdmins"> | string
    lastname?: StringWithAggregatesFilter<"documentAdmins"> | string
    email?: StringWithAggregatesFilter<"documentAdmins"> | string
    userId?: StringWithAggregatesFilter<"documentAdmins"> | string
    doctypeId?: StringNullableWithAggregatesFilter<"documentAdmins"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"documentAdmins"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"documentAdmins"> | Date | string
  }

  export type AdditionalDocumentAdminsWhereInput = {
    AND?: AdditionalDocumentAdminsWhereInput | AdditionalDocumentAdminsWhereInput[]
    OR?: AdditionalDocumentAdminsWhereInput[]
    NOT?: AdditionalDocumentAdminsWhereInput | AdditionalDocumentAdminsWhereInput[]
    id?: StringFilter<"AdditionalDocumentAdmins"> | string
    type?: StringFilter<"AdditionalDocumentAdmins"> | string
    firstname?: StringFilter<"AdditionalDocumentAdmins"> | string
    lastname?: StringFilter<"AdditionalDocumentAdmins"> | string
    email?: StringFilter<"AdditionalDocumentAdmins"> | string
    userId?: StringFilter<"AdditionalDocumentAdmins"> | string
    documentId?: StringNullableFilter<"AdditionalDocumentAdmins"> | string | null
    createdAt?: DateTimeFilter<"AdditionalDocumentAdmins"> | Date | string
    updatedAt?: DateTimeFilter<"AdditionalDocumentAdmins"> | Date | string
    document?: XOR<DocumentsNullableRelationFilter, DocumentsWhereInput> | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type AdditionalDocumentAdminsOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    email?: SortOrder
    userId?: SortOrder
    documentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    document?: DocumentsOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type AdditionalDocumentAdminsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AdditionalDocumentAdminsWhereInput | AdditionalDocumentAdminsWhereInput[]
    OR?: AdditionalDocumentAdminsWhereInput[]
    NOT?: AdditionalDocumentAdminsWhereInput | AdditionalDocumentAdminsWhereInput[]
    type?: StringFilter<"AdditionalDocumentAdmins"> | string
    firstname?: StringFilter<"AdditionalDocumentAdmins"> | string
    lastname?: StringFilter<"AdditionalDocumentAdmins"> | string
    email?: StringFilter<"AdditionalDocumentAdmins"> | string
    userId?: StringFilter<"AdditionalDocumentAdmins"> | string
    documentId?: StringNullableFilter<"AdditionalDocumentAdmins"> | string | null
    createdAt?: DateTimeFilter<"AdditionalDocumentAdmins"> | Date | string
    updatedAt?: DateTimeFilter<"AdditionalDocumentAdmins"> | Date | string
    document?: XOR<DocumentsNullableRelationFilter, DocumentsWhereInput> | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type AdditionalDocumentAdminsOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    email?: SortOrder
    userId?: SortOrder
    documentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AdditionalDocumentAdminsCountOrderByAggregateInput
    _max?: AdditionalDocumentAdminsMaxOrderByAggregateInput
    _min?: AdditionalDocumentAdminsMinOrderByAggregateInput
  }

  export type AdditionalDocumentAdminsScalarWhereWithAggregatesInput = {
    AND?: AdditionalDocumentAdminsScalarWhereWithAggregatesInput | AdditionalDocumentAdminsScalarWhereWithAggregatesInput[]
    OR?: AdditionalDocumentAdminsScalarWhereWithAggregatesInput[]
    NOT?: AdditionalDocumentAdminsScalarWhereWithAggregatesInput | AdditionalDocumentAdminsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AdditionalDocumentAdmins"> | string
    type?: StringWithAggregatesFilter<"AdditionalDocumentAdmins"> | string
    firstname?: StringWithAggregatesFilter<"AdditionalDocumentAdmins"> | string
    lastname?: StringWithAggregatesFilter<"AdditionalDocumentAdmins"> | string
    email?: StringWithAggregatesFilter<"AdditionalDocumentAdmins"> | string
    userId?: StringWithAggregatesFilter<"AdditionalDocumentAdmins"> | string
    documentId?: StringNullableWithAggregatesFilter<"AdditionalDocumentAdmins"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AdditionalDocumentAdmins"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AdditionalDocumentAdmins"> | Date | string
  }

  export type LogsWhereInput = {
    AND?: LogsWhereInput | LogsWhereInput[]
    OR?: LogsWhereInput[]
    NOT?: LogsWhereInput | LogsWhereInput[]
    id?: StringFilter<"Logs"> | string
    userId?: StringFilter<"Logs"> | string
    action?: StringFilter<"Logs"> | string
    resource?: StringFilter<"Logs"> | string
    type?: StringFilter<"Logs"> | string
    additionalDetails?: JsonFilter<"Logs">
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type LogsOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    type?: SortOrder
    additionalDetails?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type LogsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LogsWhereInput | LogsWhereInput[]
    OR?: LogsWhereInput[]
    NOT?: LogsWhereInput | LogsWhereInput[]
    userId?: StringFilter<"Logs"> | string
    action?: StringFilter<"Logs"> | string
    resource?: StringFilter<"Logs"> | string
    type?: StringFilter<"Logs"> | string
    additionalDetails?: JsonFilter<"Logs">
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type LogsOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    type?: SortOrder
    additionalDetails?: SortOrder
    _count?: LogsCountOrderByAggregateInput
    _max?: LogsMaxOrderByAggregateInput
    _min?: LogsMinOrderByAggregateInput
  }

  export type LogsScalarWhereWithAggregatesInput = {
    AND?: LogsScalarWhereWithAggregatesInput | LogsScalarWhereWithAggregatesInput[]
    OR?: LogsScalarWhereWithAggregatesInput[]
    NOT?: LogsScalarWhereWithAggregatesInput | LogsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Logs"> | string
    userId?: StringWithAggregatesFilter<"Logs"> | string
    action?: StringWithAggregatesFilter<"Logs"> | string
    resource?: StringWithAggregatesFilter<"Logs"> | string
    type?: StringWithAggregatesFilter<"Logs"> | string
    additionalDetails?: JsonWithAggregatesFilter<"Logs">
  }

  export type userPersonalisationWhereInput = {
    AND?: userPersonalisationWhereInput | userPersonalisationWhereInput[]
    OR?: userPersonalisationWhereInput[]
    NOT?: userPersonalisationWhereInput | userPersonalisationWhereInput[]
    id?: StringFilter<"userPersonalisation"> | string
    userId?: StringFilter<"userPersonalisation"> | string
    organizationId?: StringNullableFilter<"userPersonalisation"> | string | null
    targetObject?: StringFilter<"userPersonalisation"> | string
    targetObjectId?: StringNullableListFilter<"userPersonalisation">
    Organization?: XOR<OrganizationNullableRelationFilter, OrganizationWhereInput> | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type userPersonalisationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    organizationId?: SortOrder
    targetObject?: SortOrder
    targetObjectId?: SortOrder
    Organization?: OrganizationOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type userPersonalisationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_targetObject?: userPersonalisationUserIdTargetObjectCompoundUniqueInput
    AND?: userPersonalisationWhereInput | userPersonalisationWhereInput[]
    OR?: userPersonalisationWhereInput[]
    NOT?: userPersonalisationWhereInput | userPersonalisationWhereInput[]
    userId?: StringFilter<"userPersonalisation"> | string
    organizationId?: StringNullableFilter<"userPersonalisation"> | string | null
    targetObject?: StringFilter<"userPersonalisation"> | string
    targetObjectId?: StringNullableListFilter<"userPersonalisation">
    Organization?: XOR<OrganizationNullableRelationFilter, OrganizationWhereInput> | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "userId_targetObject">

  export type userPersonalisationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    organizationId?: SortOrder
    targetObject?: SortOrder
    targetObjectId?: SortOrder
    _count?: userPersonalisationCountOrderByAggregateInput
    _max?: userPersonalisationMaxOrderByAggregateInput
    _min?: userPersonalisationMinOrderByAggregateInput
  }

  export type userPersonalisationScalarWhereWithAggregatesInput = {
    AND?: userPersonalisationScalarWhereWithAggregatesInput | userPersonalisationScalarWhereWithAggregatesInput[]
    OR?: userPersonalisationScalarWhereWithAggregatesInput[]
    NOT?: userPersonalisationScalarWhereWithAggregatesInput | userPersonalisationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"userPersonalisation"> | string
    userId?: StringWithAggregatesFilter<"userPersonalisation"> | string
    organizationId?: StringNullableWithAggregatesFilter<"userPersonalisation"> | string | null
    targetObject?: StringWithAggregatesFilter<"userPersonalisation"> | string
    targetObjectId?: StringNullableListFilter<"userPersonalisation">
  }

  export type ConnectedAppsWhereInput = {
    AND?: ConnectedAppsWhereInput | ConnectedAppsWhereInput[]
    OR?: ConnectedAppsWhereInput[]
    NOT?: ConnectedAppsWhereInput | ConnectedAppsWhereInput[]
    id?: StringFilter<"ConnectedApps"> | string
    sourceName?: StringFilter<"ConnectedApps"> | string
    clientId?: StringFilter<"ConnectedApps"> | string
    clientSecret?: StringFilter<"ConnectedApps"> | string
    baseURL?: StringFilter<"ConnectedApps"> | string
    user?: StringNullableFilter<"ConnectedApps"> | string | null
    password?: StringNullableFilter<"ConnectedApps"> | string | null
    redirectURL?: StringNullableFilter<"ConnectedApps"> | string | null
    grantType?: StringNullableFilter<"ConnectedApps"> | string | null
    description?: StringFilter<"ConnectedApps"> | string
    deleted?: BoolNullableFilter<"ConnectedApps"> | boolean | null
    organizationId?: StringNullableFilter<"ConnectedApps"> | string | null
    createdModifiedBy?: StringFilter<"ConnectedApps"> | string
    createdModifiedAt?: DateTimeFilter<"ConnectedApps"> | Date | string
    locationId?: StringNullableListFilter<"ConnectedApps">
    Status?: BoolFilter<"ConnectedApps"> | boolean
    organization?: XOR<OrganizationNullableRelationFilter, OrganizationWhereInput> | null
    uom?: UnitTypeListRelationFilter
    kpi?: KpiListRelationFilter
  }

  export type ConnectedAppsOrderByWithRelationInput = {
    id?: SortOrder
    sourceName?: SortOrder
    clientId?: SortOrder
    clientSecret?: SortOrder
    baseURL?: SortOrder
    user?: SortOrder
    password?: SortOrder
    redirectURL?: SortOrder
    grantType?: SortOrder
    description?: SortOrder
    deleted?: SortOrder
    organizationId?: SortOrder
    createdModifiedBy?: SortOrder
    createdModifiedAt?: SortOrder
    locationId?: SortOrder
    Status?: SortOrder
    organization?: OrganizationOrderByWithRelationInput
    uom?: unitTypeOrderByRelationAggregateInput
    kpi?: kpiOrderByRelationAggregateInput
  }

  export type ConnectedAppsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    clientId?: string
    clientSecret?: string
    organizationId_sourceName?: ConnectedAppsOrganizationIdSourceNameCompoundUniqueInput
    AND?: ConnectedAppsWhereInput | ConnectedAppsWhereInput[]
    OR?: ConnectedAppsWhereInput[]
    NOT?: ConnectedAppsWhereInput | ConnectedAppsWhereInput[]
    sourceName?: StringFilter<"ConnectedApps"> | string
    baseURL?: StringFilter<"ConnectedApps"> | string
    user?: StringNullableFilter<"ConnectedApps"> | string | null
    password?: StringNullableFilter<"ConnectedApps"> | string | null
    redirectURL?: StringNullableFilter<"ConnectedApps"> | string | null
    grantType?: StringNullableFilter<"ConnectedApps"> | string | null
    description?: StringFilter<"ConnectedApps"> | string
    deleted?: BoolNullableFilter<"ConnectedApps"> | boolean | null
    organizationId?: StringNullableFilter<"ConnectedApps"> | string | null
    createdModifiedBy?: StringFilter<"ConnectedApps"> | string
    createdModifiedAt?: DateTimeFilter<"ConnectedApps"> | Date | string
    locationId?: StringNullableListFilter<"ConnectedApps">
    Status?: BoolFilter<"ConnectedApps"> | boolean
    organization?: XOR<OrganizationNullableRelationFilter, OrganizationWhereInput> | null
    uom?: UnitTypeListRelationFilter
    kpi?: KpiListRelationFilter
  }, "id" | "clientId" | "clientSecret" | "organizationId_sourceName">

  export type ConnectedAppsOrderByWithAggregationInput = {
    id?: SortOrder
    sourceName?: SortOrder
    clientId?: SortOrder
    clientSecret?: SortOrder
    baseURL?: SortOrder
    user?: SortOrder
    password?: SortOrder
    redirectURL?: SortOrder
    grantType?: SortOrder
    description?: SortOrder
    deleted?: SortOrder
    organizationId?: SortOrder
    createdModifiedBy?: SortOrder
    createdModifiedAt?: SortOrder
    locationId?: SortOrder
    Status?: SortOrder
    _count?: ConnectedAppsCountOrderByAggregateInput
    _max?: ConnectedAppsMaxOrderByAggregateInput
    _min?: ConnectedAppsMinOrderByAggregateInput
  }

  export type ConnectedAppsScalarWhereWithAggregatesInput = {
    AND?: ConnectedAppsScalarWhereWithAggregatesInput | ConnectedAppsScalarWhereWithAggregatesInput[]
    OR?: ConnectedAppsScalarWhereWithAggregatesInput[]
    NOT?: ConnectedAppsScalarWhereWithAggregatesInput | ConnectedAppsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ConnectedApps"> | string
    sourceName?: StringWithAggregatesFilter<"ConnectedApps"> | string
    clientId?: StringWithAggregatesFilter<"ConnectedApps"> | string
    clientSecret?: StringWithAggregatesFilter<"ConnectedApps"> | string
    baseURL?: StringWithAggregatesFilter<"ConnectedApps"> | string
    user?: StringNullableWithAggregatesFilter<"ConnectedApps"> | string | null
    password?: StringNullableWithAggregatesFilter<"ConnectedApps"> | string | null
    redirectURL?: StringNullableWithAggregatesFilter<"ConnectedApps"> | string | null
    grantType?: StringNullableWithAggregatesFilter<"ConnectedApps"> | string | null
    description?: StringWithAggregatesFilter<"ConnectedApps"> | string
    deleted?: BoolNullableWithAggregatesFilter<"ConnectedApps"> | boolean | null
    organizationId?: StringNullableWithAggregatesFilter<"ConnectedApps"> | string | null
    createdModifiedBy?: StringWithAggregatesFilter<"ConnectedApps"> | string
    createdModifiedAt?: DateTimeWithAggregatesFilter<"ConnectedApps"> | Date | string
    locationId?: StringNullableListFilter<"ConnectedApps">
    Status?: BoolWithAggregatesFilter<"ConnectedApps"> | boolean
  }

  export type unitTypeWhereInput = {
    AND?: unitTypeWhereInput | unitTypeWhereInput[]
    OR?: unitTypeWhereInput[]
    NOT?: unitTypeWhereInput | unitTypeWhereInput[]
    id?: StringFilter<"unitType"> | string
    unitType?: StringFilter<"unitType"> | string
    unitOfMeasurement?: StringNullableListFilter<"unitType">
    organizationId?: StringNullableFilter<"unitType"> | string | null
    locationId?: StringNullableFilter<"unitType"> | string | null
    deleted?: BoolNullableFilter<"unitType"> | boolean | null
    createdModifiedBy?: StringFilter<"unitType"> | string
    createdModifiedAt?: DateTimeFilter<"unitType"> | Date | string
    connectedAppsId?: StringNullableFilter<"unitType"> | string | null
    kpi?: KpiListRelationFilter
    organization?: XOR<OrganizationNullableRelationFilter, OrganizationWhereInput> | null
    location?: XOR<LocationNullableRelationFilter, LocationWhereInput> | null
    ConnectedApps?: XOR<ConnectedAppsNullableRelationFilter, ConnectedAppsWhereInput> | null
  }

  export type unitTypeOrderByWithRelationInput = {
    id?: SortOrder
    unitType?: SortOrder
    unitOfMeasurement?: SortOrder
    organizationId?: SortOrder
    locationId?: SortOrder
    deleted?: SortOrder
    createdModifiedBy?: SortOrder
    createdModifiedAt?: SortOrder
    connectedAppsId?: SortOrder
    kpi?: kpiOrderByRelationAggregateInput
    organization?: OrganizationOrderByWithRelationInput
    location?: LocationOrderByWithRelationInput
    ConnectedApps?: ConnectedAppsOrderByWithRelationInput
  }

  export type unitTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    organizationId_unitType?: unitTypeOrganizationIdUnitTypeCompoundUniqueInput
    AND?: unitTypeWhereInput | unitTypeWhereInput[]
    OR?: unitTypeWhereInput[]
    NOT?: unitTypeWhereInput | unitTypeWhereInput[]
    unitType?: StringFilter<"unitType"> | string
    unitOfMeasurement?: StringNullableListFilter<"unitType">
    organizationId?: StringNullableFilter<"unitType"> | string | null
    locationId?: StringNullableFilter<"unitType"> | string | null
    deleted?: BoolNullableFilter<"unitType"> | boolean | null
    createdModifiedBy?: StringFilter<"unitType"> | string
    createdModifiedAt?: DateTimeFilter<"unitType"> | Date | string
    connectedAppsId?: StringNullableFilter<"unitType"> | string | null
    kpi?: KpiListRelationFilter
    organization?: XOR<OrganizationNullableRelationFilter, OrganizationWhereInput> | null
    location?: XOR<LocationNullableRelationFilter, LocationWhereInput> | null
    ConnectedApps?: XOR<ConnectedAppsNullableRelationFilter, ConnectedAppsWhereInput> | null
  }, "id" | "organizationId_unitType">

  export type unitTypeOrderByWithAggregationInput = {
    id?: SortOrder
    unitType?: SortOrder
    unitOfMeasurement?: SortOrder
    organizationId?: SortOrder
    locationId?: SortOrder
    deleted?: SortOrder
    createdModifiedBy?: SortOrder
    createdModifiedAt?: SortOrder
    connectedAppsId?: SortOrder
    _count?: unitTypeCountOrderByAggregateInput
    _max?: unitTypeMaxOrderByAggregateInput
    _min?: unitTypeMinOrderByAggregateInput
  }

  export type unitTypeScalarWhereWithAggregatesInput = {
    AND?: unitTypeScalarWhereWithAggregatesInput | unitTypeScalarWhereWithAggregatesInput[]
    OR?: unitTypeScalarWhereWithAggregatesInput[]
    NOT?: unitTypeScalarWhereWithAggregatesInput | unitTypeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"unitType"> | string
    unitType?: StringWithAggregatesFilter<"unitType"> | string
    unitOfMeasurement?: StringNullableListFilter<"unitType">
    organizationId?: StringNullableWithAggregatesFilter<"unitType"> | string | null
    locationId?: StringNullableWithAggregatesFilter<"unitType"> | string | null
    deleted?: BoolNullableWithAggregatesFilter<"unitType"> | boolean | null
    createdModifiedBy?: StringWithAggregatesFilter<"unitType"> | string
    createdModifiedAt?: DateTimeWithAggregatesFilter<"unitType"> | Date | string
    connectedAppsId?: StringNullableWithAggregatesFilter<"unitType"> | string | null
  }

  export type kpiWhereInput = {
    AND?: kpiWhereInput | kpiWhereInput[]
    OR?: kpiWhereInput[]
    NOT?: kpiWhereInput | kpiWhereInput[]
    id?: StringFilter<"kpi"> | string
    kpiName?: StringFilter<"kpi"> | string
    kpiType?: StringNullableFilter<"kpi"> | string | null
    keyFields?: StringNullableListFilter<"kpi">
    unitTypeId?: StringNullableFilter<"kpi"> | string | null
    uom?: StringFilter<"kpi"> | string
    sourceId?: StringNullableFilter<"kpi"> | string | null
    status?: BoolFilter<"kpi"> | boolean
    apiEndPoint?: StringNullableFilter<"kpi"> | string | null
    kpiDescription?: StringNullableFilter<"kpi"> | string | null
    kpiTargetType?: BoolNullableFilter<"kpi"> | boolean | null
    organizationId?: StringNullableFilter<"kpi"> | string | null
    locationId?: StringNullableListFilter<"kpi">
    createdModifiedBy?: StringFilter<"kpi"> | string
    createdModifiedAt?: DateTimeFilter<"kpi"> | Date | string
    unitType?: XOR<UnitTypeNullableRelationFilter, unitTypeWhereInput> | null
    ConnectedApps?: XOR<ConnectedAppsNullableRelationFilter, ConnectedAppsWhereInput> | null
    organization?: XOR<OrganizationNullableRelationFilter, OrganizationWhereInput> | null
  }

  export type kpiOrderByWithRelationInput = {
    id?: SortOrder
    kpiName?: SortOrder
    kpiType?: SortOrder
    keyFields?: SortOrder
    unitTypeId?: SortOrder
    uom?: SortOrder
    sourceId?: SortOrder
    status?: SortOrder
    apiEndPoint?: SortOrder
    kpiDescription?: SortOrder
    kpiTargetType?: SortOrder
    organizationId?: SortOrder
    locationId?: SortOrder
    createdModifiedBy?: SortOrder
    createdModifiedAt?: SortOrder
    unitType?: unitTypeOrderByWithRelationInput
    ConnectedApps?: ConnectedAppsOrderByWithRelationInput
    organization?: OrganizationOrderByWithRelationInput
  }

  export type kpiWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    kpiName?: string
    AND?: kpiWhereInput | kpiWhereInput[]
    OR?: kpiWhereInput[]
    NOT?: kpiWhereInput | kpiWhereInput[]
    kpiType?: StringNullableFilter<"kpi"> | string | null
    keyFields?: StringNullableListFilter<"kpi">
    unitTypeId?: StringNullableFilter<"kpi"> | string | null
    uom?: StringFilter<"kpi"> | string
    sourceId?: StringNullableFilter<"kpi"> | string | null
    status?: BoolFilter<"kpi"> | boolean
    apiEndPoint?: StringNullableFilter<"kpi"> | string | null
    kpiDescription?: StringNullableFilter<"kpi"> | string | null
    kpiTargetType?: BoolNullableFilter<"kpi"> | boolean | null
    organizationId?: StringNullableFilter<"kpi"> | string | null
    locationId?: StringNullableListFilter<"kpi">
    createdModifiedBy?: StringFilter<"kpi"> | string
    createdModifiedAt?: DateTimeFilter<"kpi"> | Date | string
    unitType?: XOR<UnitTypeNullableRelationFilter, unitTypeWhereInput> | null
    ConnectedApps?: XOR<ConnectedAppsNullableRelationFilter, ConnectedAppsWhereInput> | null
    organization?: XOR<OrganizationNullableRelationFilter, OrganizationWhereInput> | null
  }, "id" | "kpiName">

  export type kpiOrderByWithAggregationInput = {
    id?: SortOrder
    kpiName?: SortOrder
    kpiType?: SortOrder
    keyFields?: SortOrder
    unitTypeId?: SortOrder
    uom?: SortOrder
    sourceId?: SortOrder
    status?: SortOrder
    apiEndPoint?: SortOrder
    kpiDescription?: SortOrder
    kpiTargetType?: SortOrder
    organizationId?: SortOrder
    locationId?: SortOrder
    createdModifiedBy?: SortOrder
    createdModifiedAt?: SortOrder
    _count?: kpiCountOrderByAggregateInput
    _max?: kpiMaxOrderByAggregateInput
    _min?: kpiMinOrderByAggregateInput
  }

  export type kpiScalarWhereWithAggregatesInput = {
    AND?: kpiScalarWhereWithAggregatesInput | kpiScalarWhereWithAggregatesInput[]
    OR?: kpiScalarWhereWithAggregatesInput[]
    NOT?: kpiScalarWhereWithAggregatesInput | kpiScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"kpi"> | string
    kpiName?: StringWithAggregatesFilter<"kpi"> | string
    kpiType?: StringNullableWithAggregatesFilter<"kpi"> | string | null
    keyFields?: StringNullableListFilter<"kpi">
    unitTypeId?: StringNullableWithAggregatesFilter<"kpi"> | string | null
    uom?: StringWithAggregatesFilter<"kpi"> | string
    sourceId?: StringNullableWithAggregatesFilter<"kpi"> | string | null
    status?: BoolWithAggregatesFilter<"kpi"> | boolean
    apiEndPoint?: StringNullableWithAggregatesFilter<"kpi"> | string | null
    kpiDescription?: StringNullableWithAggregatesFilter<"kpi"> | string | null
    kpiTargetType?: BoolNullableWithAggregatesFilter<"kpi"> | boolean | null
    organizationId?: StringNullableWithAggregatesFilter<"kpi"> | string | null
    locationId?: StringNullableListFilter<"kpi">
    createdModifiedBy?: StringWithAggregatesFilter<"kpi"> | string
    createdModifiedAt?: DateTimeWithAggregatesFilter<"kpi"> | Date | string
  }

  export type auditTrialWhereInput = {
    AND?: auditTrialWhereInput | auditTrialWhereInput[]
    OR?: auditTrialWhereInput[]
    NOT?: auditTrialWhereInput | auditTrialWhereInput[]
    id?: StringFilter<"auditTrial"> | string
    moduleType?: StringNullableFilter<"auditTrial"> | string | null
    actionType?: StringNullableFilter<"auditTrial"> | string | null
    transactionId?: StringNullableFilter<"auditTrial"> | string | null
    actionBy?: StringNullableFilter<"auditTrial"> | string | null
    actionDate?: DateTimeNullableFilter<"auditTrial"> | Date | string | null
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type auditTrialOrderByWithRelationInput = {
    id?: SortOrder
    moduleType?: SortOrder
    actionType?: SortOrder
    transactionId?: SortOrder
    actionBy?: SortOrder
    actionDate?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type auditTrialWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: auditTrialWhereInput | auditTrialWhereInput[]
    OR?: auditTrialWhereInput[]
    NOT?: auditTrialWhereInput | auditTrialWhereInput[]
    moduleType?: StringNullableFilter<"auditTrial"> | string | null
    actionType?: StringNullableFilter<"auditTrial"> | string | null
    transactionId?: StringNullableFilter<"auditTrial"> | string | null
    actionBy?: StringNullableFilter<"auditTrial"> | string | null
    actionDate?: DateTimeNullableFilter<"auditTrial"> | Date | string | null
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type auditTrialOrderByWithAggregationInput = {
    id?: SortOrder
    moduleType?: SortOrder
    actionType?: SortOrder
    transactionId?: SortOrder
    actionBy?: SortOrder
    actionDate?: SortOrder
    _count?: auditTrialCountOrderByAggregateInput
    _max?: auditTrialMaxOrderByAggregateInput
    _min?: auditTrialMinOrderByAggregateInput
  }

  export type auditTrialScalarWhereWithAggregatesInput = {
    AND?: auditTrialScalarWhereWithAggregatesInput | auditTrialScalarWhereWithAggregatesInput[]
    OR?: auditTrialScalarWhereWithAggregatesInput[]
    NOT?: auditTrialScalarWhereWithAggregatesInput | auditTrialScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"auditTrial"> | string
    moduleType?: StringNullableWithAggregatesFilter<"auditTrial"> | string | null
    actionType?: StringNullableWithAggregatesFilter<"auditTrial"> | string | null
    transactionId?: StringNullableWithAggregatesFilter<"auditTrial"> | string | null
    actionBy?: StringNullableWithAggregatesFilter<"auditTrial"> | string | null
    actionDate?: DateTimeNullableWithAggregatesFilter<"auditTrial"> | Date | string | null
  }

  export type prefixSuffixWhereInput = {
    AND?: prefixSuffixWhereInput | prefixSuffixWhereInput[]
    OR?: prefixSuffixWhereInput[]
    NOT?: prefixSuffixWhereInput | prefixSuffixWhereInput[]
    id?: StringFilter<"prefixSuffix"> | string
    prefix?: StringNullableFilter<"prefixSuffix"> | string | null
    suffix?: StringNullableFilter<"prefixSuffix"> | string | null
    moduleType?: StringNullableFilter<"prefixSuffix"> | string | null
    location?: StringNullableFilter<"prefixSuffix"> | string | null
    organizationId?: StringNullableFilter<"prefixSuffix"> | string | null
    createdBy?: StringNullableFilter<"prefixSuffix"> | string | null
    createdAt?: DateTimeFilter<"prefixSuffix"> | Date | string
    organization?: XOR<OrganizationNullableRelationFilter, OrganizationWhereInput> | null
  }

  export type prefixSuffixOrderByWithRelationInput = {
    id?: SortOrder
    prefix?: SortOrder
    suffix?: SortOrder
    moduleType?: SortOrder
    location?: SortOrder
    organizationId?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    organization?: OrganizationOrderByWithRelationInput
  }

  export type prefixSuffixWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: prefixSuffixWhereInput | prefixSuffixWhereInput[]
    OR?: prefixSuffixWhereInput[]
    NOT?: prefixSuffixWhereInput | prefixSuffixWhereInput[]
    prefix?: StringNullableFilter<"prefixSuffix"> | string | null
    suffix?: StringNullableFilter<"prefixSuffix"> | string | null
    moduleType?: StringNullableFilter<"prefixSuffix"> | string | null
    location?: StringNullableFilter<"prefixSuffix"> | string | null
    organizationId?: StringNullableFilter<"prefixSuffix"> | string | null
    createdBy?: StringNullableFilter<"prefixSuffix"> | string | null
    createdAt?: DateTimeFilter<"prefixSuffix"> | Date | string
    organization?: XOR<OrganizationNullableRelationFilter, OrganizationWhereInput> | null
  }, "id">

  export type prefixSuffixOrderByWithAggregationInput = {
    id?: SortOrder
    prefix?: SortOrder
    suffix?: SortOrder
    moduleType?: SortOrder
    location?: SortOrder
    organizationId?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    _count?: prefixSuffixCountOrderByAggregateInput
    _max?: prefixSuffixMaxOrderByAggregateInput
    _min?: prefixSuffixMinOrderByAggregateInput
  }

  export type prefixSuffixScalarWhereWithAggregatesInput = {
    AND?: prefixSuffixScalarWhereWithAggregatesInput | prefixSuffixScalarWhereWithAggregatesInput[]
    OR?: prefixSuffixScalarWhereWithAggregatesInput[]
    NOT?: prefixSuffixScalarWhereWithAggregatesInput | prefixSuffixScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"prefixSuffix"> | string
    prefix?: StringNullableWithAggregatesFilter<"prefixSuffix"> | string | null
    suffix?: StringNullableWithAggregatesFilter<"prefixSuffix"> | string | null
    moduleType?: StringNullableWithAggregatesFilter<"prefixSuffix"> | string | null
    location?: StringNullableWithAggregatesFilter<"prefixSuffix"> | string | null
    organizationId?: StringNullableWithAggregatesFilter<"prefixSuffix"> | string | null
    createdBy?: StringNullableWithAggregatesFilter<"prefixSuffix"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"prefixSuffix"> | Date | string
  }

  export type serialNumberWhereInput = {
    AND?: serialNumberWhereInput | serialNumberWhereInput[]
    OR?: serialNumberWhereInput[]
    NOT?: serialNumberWhereInput | serialNumberWhereInput[]
    id?: StringFilter<"serialNumber"> | string
    moduleType?: StringNullableFilter<"serialNumber"> | string | null
    location?: StringNullableFilter<"serialNumber"> | string | null
    entity?: StringNullableFilter<"serialNumber"> | string | null
    year?: StringNullableFilter<"serialNumber"> | string | null
    tid?: StringNullableFilter<"serialNumber"> | string | null
    serialNumber?: IntFilter<"serialNumber"> | number
    createdBy?: StringNullableFilter<"serialNumber"> | string | null
    createdAt?: DateTimeFilter<"serialNumber"> | Date | string
    organizationId?: StringNullableFilter<"serialNumber"> | string | null
    organization?: XOR<OrganizationNullableRelationFilter, OrganizationWhereInput> | null
  }

  export type serialNumberOrderByWithRelationInput = {
    id?: SortOrder
    moduleType?: SortOrder
    location?: SortOrder
    entity?: SortOrder
    year?: SortOrder
    tid?: SortOrder
    serialNumber?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    organizationId?: SortOrder
    organization?: OrganizationOrderByWithRelationInput
  }

  export type serialNumberWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    moduleType_location_entity_year_tid?: serialNumberModuleTypeLocationEntityYearTidCompoundUniqueInput
    AND?: serialNumberWhereInput | serialNumberWhereInput[]
    OR?: serialNumberWhereInput[]
    NOT?: serialNumberWhereInput | serialNumberWhereInput[]
    moduleType?: StringNullableFilter<"serialNumber"> | string | null
    location?: StringNullableFilter<"serialNumber"> | string | null
    entity?: StringNullableFilter<"serialNumber"> | string | null
    year?: StringNullableFilter<"serialNumber"> | string | null
    tid?: StringNullableFilter<"serialNumber"> | string | null
    serialNumber?: IntFilter<"serialNumber"> | number
    createdBy?: StringNullableFilter<"serialNumber"> | string | null
    createdAt?: DateTimeFilter<"serialNumber"> | Date | string
    organizationId?: StringNullableFilter<"serialNumber"> | string | null
    organization?: XOR<OrganizationNullableRelationFilter, OrganizationWhereInput> | null
  }, "id" | "moduleType_location_entity_year_tid">

  export type serialNumberOrderByWithAggregationInput = {
    id?: SortOrder
    moduleType?: SortOrder
    location?: SortOrder
    entity?: SortOrder
    year?: SortOrder
    tid?: SortOrder
    serialNumber?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    organizationId?: SortOrder
    _count?: serialNumberCountOrderByAggregateInput
    _avg?: serialNumberAvgOrderByAggregateInput
    _max?: serialNumberMaxOrderByAggregateInput
    _min?: serialNumberMinOrderByAggregateInput
    _sum?: serialNumberSumOrderByAggregateInput
  }

  export type serialNumberScalarWhereWithAggregatesInput = {
    AND?: serialNumberScalarWhereWithAggregatesInput | serialNumberScalarWhereWithAggregatesInput[]
    OR?: serialNumberScalarWhereWithAggregatesInput[]
    NOT?: serialNumberScalarWhereWithAggregatesInput | serialNumberScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"serialNumber"> | string
    moduleType?: StringNullableWithAggregatesFilter<"serialNumber"> | string | null
    location?: StringNullableWithAggregatesFilter<"serialNumber"> | string | null
    entity?: StringNullableWithAggregatesFilter<"serialNumber"> | string | null
    year?: StringNullableWithAggregatesFilter<"serialNumber"> | string | null
    tid?: StringNullableWithAggregatesFilter<"serialNumber"> | string | null
    serialNumber?: IntWithAggregatesFilter<"serialNumber"> | number
    createdBy?: StringNullableWithAggregatesFilter<"serialNumber"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"serialNumber"> | Date | string
    organizationId?: StringNullableWithAggregatesFilter<"serialNumber"> | string | null
  }

  export type rolesTableWhereInput = {
    AND?: rolesTableWhereInput | rolesTableWhereInput[]
    OR?: rolesTableWhereInput[]
    NOT?: rolesTableWhereInput | rolesTableWhereInput[]
    id?: StringFilter<"rolesTable"> | string
    orgId?: StringFilter<"rolesTable"> | string
    unitId?: StringFilter<"rolesTable"> | string
    users?: StringNullableListFilter<"rolesTable">
    roleId?: StringNullableListFilter<"rolesTable">
    createdAt?: DateTimeFilter<"rolesTable"> | Date | string
    updatedAt?: DateTimeFilter<"rolesTable"> | Date | string
    organization?: XOR<OrganizationRelationFilter, OrganizationWhereInput>
    location?: XOR<LocationRelationFilter, LocationWhereInput>
  }

  export type rolesTableOrderByWithRelationInput = {
    id?: SortOrder
    orgId?: SortOrder
    unitId?: SortOrder
    users?: SortOrder
    roleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    organization?: OrganizationOrderByWithRelationInput
    location?: LocationOrderByWithRelationInput
  }

  export type rolesTableWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: rolesTableWhereInput | rolesTableWhereInput[]
    OR?: rolesTableWhereInput[]
    NOT?: rolesTableWhereInput | rolesTableWhereInput[]
    orgId?: StringFilter<"rolesTable"> | string
    unitId?: StringFilter<"rolesTable"> | string
    users?: StringNullableListFilter<"rolesTable">
    roleId?: StringNullableListFilter<"rolesTable">
    createdAt?: DateTimeFilter<"rolesTable"> | Date | string
    updatedAt?: DateTimeFilter<"rolesTable"> | Date | string
    organization?: XOR<OrganizationRelationFilter, OrganizationWhereInput>
    location?: XOR<LocationRelationFilter, LocationWhereInput>
  }, "id">

  export type rolesTableOrderByWithAggregationInput = {
    id?: SortOrder
    orgId?: SortOrder
    unitId?: SortOrder
    users?: SortOrder
    roleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: rolesTableCountOrderByAggregateInput
    _max?: rolesTableMaxOrderByAggregateInput
    _min?: rolesTableMinOrderByAggregateInput
  }

  export type rolesTableScalarWhereWithAggregatesInput = {
    AND?: rolesTableScalarWhereWithAggregatesInput | rolesTableScalarWhereWithAggregatesInput[]
    OR?: rolesTableScalarWhereWithAggregatesInput[]
    NOT?: rolesTableScalarWhereWithAggregatesInput | rolesTableScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"rolesTable"> | string
    orgId?: StringWithAggregatesFilter<"rolesTable"> | string
    unitId?: StringWithAggregatesFilter<"rolesTable"> | string
    users?: StringNullableListFilter<"rolesTable">
    roleId?: StringNullableListFilter<"rolesTable">
    createdAt?: DateTimeWithAggregatesFilter<"rolesTable"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"rolesTable"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    kcId?: string | null
    email?: string | null
    username?: string | null
    firstname?: string | null
    lastname?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    enabled?: boolean | null
    userType?: string | null
    status?: boolean | null
    avatar?: string | null
    deleted?: boolean | null
    roleId?: UserCreateroleIdInput | string[]
    functionId?: InputJsonValue | null
    additionalUnits?: UserCreateadditionalUnitsInput | string[]
    entity?: EntityCreateNestedOneWithoutUserInput
    location?: LocationCreateNestedOneWithoutUserInput
    organization?: OrganizationCreateNestedOneWithoutUserInput
    AdditionalDocumentAdmins?: AdditionalDocumentAdminsCreateNestedManyWithoutUserInput
    DocumentComments?: DocumentCommentsCreateNestedManyWithoutUserInput
    DocumentVersions?: DocumentVersionsCreateNestedManyWithoutUserInput
    DocumentWorkFlowHistory?: DocumentWorkFlowHistoryCreateNestedManyWithoutUserInput
    Logs?: LogsCreateNestedManyWithoutUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
    documentAdmins?: documentAdminsCreateNestedManyWithoutUserInput
    userPersonalisation?: userPersonalisationCreateNestedManyWithoutUserInput
    auditTrial?: auditTrialCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    kcId?: string | null
    email?: string | null
    username?: string | null
    firstname?: string | null
    lastname?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    enabled?: boolean | null
    organizationId?: string | null
    locationId?: string | null
    entityId?: string | null
    userType?: string | null
    status?: boolean | null
    avatar?: string | null
    deleted?: boolean | null
    roleId?: UserCreateroleIdInput | string[]
    functionId?: InputJsonValue | null
    additionalUnits?: UserCreateadditionalUnitsInput | string[]
    AdditionalDocumentAdmins?: AdditionalDocumentAdminsUncheckedCreateNestedManyWithoutUserInput
    DocumentComments?: DocumentCommentsUncheckedCreateNestedManyWithoutUserInput
    DocumentVersions?: DocumentVersionsUncheckedCreateNestedManyWithoutUserInput
    DocumentWorkFlowHistory?: DocumentWorkFlowHistoryUncheckedCreateNestedManyWithoutUserInput
    Logs?: LogsUncheckedCreateNestedManyWithoutUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    documentAdmins?: documentAdminsUncheckedCreateNestedManyWithoutUserInput
    userPersonalisation?: userPersonalisationUncheckedCreateNestedManyWithoutUserInput
    auditTrial?: auditTrialUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    kcId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    userType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    roleId?: UserUpdateroleIdInput | string[]
    functionId?: InputJsonValue | InputJsonValue | null
    additionalUnits?: UserUpdateadditionalUnitsInput | string[]
    entity?: EntityUpdateOneWithoutUserNestedInput
    location?: LocationUpdateOneWithoutUserNestedInput
    organization?: OrganizationUpdateOneWithoutUserNestedInput
    AdditionalDocumentAdmins?: AdditionalDocumentAdminsUpdateManyWithoutUserNestedInput
    DocumentComments?: DocumentCommentsUpdateManyWithoutUserNestedInput
    DocumentVersions?: DocumentVersionsUpdateManyWithoutUserNestedInput
    DocumentWorkFlowHistory?: DocumentWorkFlowHistoryUpdateManyWithoutUserNestedInput
    Logs?: LogsUpdateManyWithoutUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
    documentAdmins?: documentAdminsUpdateManyWithoutUserNestedInput
    userPersonalisation?: userPersonalisationUpdateManyWithoutUserNestedInput
    auditTrial?: auditTrialUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    kcId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    roleId?: UserUpdateroleIdInput | string[]
    functionId?: InputJsonValue | InputJsonValue | null
    additionalUnits?: UserUpdateadditionalUnitsInput | string[]
    AdditionalDocumentAdmins?: AdditionalDocumentAdminsUncheckedUpdateManyWithoutUserNestedInput
    DocumentComments?: DocumentCommentsUncheckedUpdateManyWithoutUserNestedInput
    DocumentVersions?: DocumentVersionsUncheckedUpdateManyWithoutUserNestedInput
    DocumentWorkFlowHistory?: DocumentWorkFlowHistoryUncheckedUpdateManyWithoutUserNestedInput
    Logs?: LogsUncheckedUpdateManyWithoutUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    documentAdmins?: documentAdminsUncheckedUpdateManyWithoutUserNestedInput
    userPersonalisation?: userPersonalisationUncheckedUpdateManyWithoutUserNestedInput
    auditTrial?: auditTrialUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    kcId?: string | null
    email?: string | null
    username?: string | null
    firstname?: string | null
    lastname?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    enabled?: boolean | null
    organizationId?: string | null
    locationId?: string | null
    entityId?: string | null
    userType?: string | null
    status?: boolean | null
    avatar?: string | null
    deleted?: boolean | null
    roleId?: UserCreateroleIdInput | string[]
    functionId?: InputJsonValue | null
    additionalUnits?: UserCreateadditionalUnitsInput | string[]
  }

  export type UserUpdateManyMutationInput = {
    kcId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    userType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    roleId?: UserUpdateroleIdInput | string[]
    functionId?: InputJsonValue | InputJsonValue | null
    additionalUnits?: UserUpdateadditionalUnitsInput | string[]
  }

  export type UserUncheckedUpdateManyInput = {
    kcId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    roleId?: UserUpdateroleIdInput | string[]
    functionId?: InputJsonValue | InputJsonValue | null
    additionalUnits?: UserUpdateadditionalUnitsInput | string[]
  }

  export type ModelsCreateInput = {
    id?: string
    modelNo: string
    modelName: string
    description?: string | null
    claimId?: ModelsCreateclaimIdInput | string[]
    claims?: ClaimCreateNestedManyWithoutModelsInput
    organization: OrganizationCreateNestedOneWithoutModelsInput
    Parts?: PartsCreateNestedManyWithoutModelsInput
  }

  export type ModelsUncheckedCreateInput = {
    id?: string
    modelNo: string
    modelName: string
    description?: string | null
    organizationId: string
    partsId?: ModelsCreatepartsIdInput | string[]
    claimId?: ModelsCreateclaimIdInput | string[]
    claims?: ClaimUncheckedCreateNestedManyWithoutModelsInput
    Parts?: PartsUncheckedCreateNestedManyWithoutModelsInput
  }

  export type ModelsUpdateInput = {
    modelNo?: StringFieldUpdateOperationsInput | string
    modelName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    claimId?: ModelsUpdateclaimIdInput | string[]
    claims?: ClaimUpdateManyWithoutModelsNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutModelsNestedInput
    Parts?: PartsUpdateManyWithoutModelsNestedInput
  }

  export type ModelsUncheckedUpdateInput = {
    modelNo?: StringFieldUpdateOperationsInput | string
    modelName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: StringFieldUpdateOperationsInput | string
    partsId?: ModelsUpdatepartsIdInput | string[]
    claimId?: ModelsUpdateclaimIdInput | string[]
    claims?: ClaimUncheckedUpdateManyWithoutModelsNestedInput
    Parts?: PartsUncheckedUpdateManyWithoutModelsNestedInput
  }

  export type ModelsCreateManyInput = {
    id?: string
    modelNo: string
    modelName: string
    description?: string | null
    organizationId: string
    partsId?: ModelsCreatepartsIdInput | string[]
    claimId?: ModelsCreateclaimIdInput | string[]
  }

  export type ModelsUpdateManyMutationInput = {
    modelNo?: StringFieldUpdateOperationsInput | string
    modelName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    claimId?: ModelsUpdateclaimIdInput | string[]
  }

  export type ModelsUncheckedUpdateManyInput = {
    modelNo?: StringFieldUpdateOperationsInput | string
    modelName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: StringFieldUpdateOperationsInput | string
    partsId?: ModelsUpdatepartsIdInput | string[]
    claimId?: ModelsUpdateclaimIdInput | string[]
  }

  export type PartsCreateInput = {
    id?: string
    partNo: string
    partName: string
    description?: string | null
    claimId?: PartsCreateclaimIdInput | string[]
    claims?: ClaimCreateNestedManyWithoutPartsInput
    entity?: EntityCreateNestedOneWithoutPartsInput
    organization?: OrganizationCreateNestedOneWithoutPartsInput
    models?: ModelsCreateNestedManyWithoutPartsInput
  }

  export type PartsUncheckedCreateInput = {
    id?: string
    partNo: string
    partName: string
    description?: string | null
    organizationId?: string | null
    entityId?: string | null
    claimId?: PartsCreateclaimIdInput | string[]
    modelsId?: PartsCreatemodelsIdInput | string[]
    claims?: ClaimUncheckedCreateNestedManyWithoutPartsInput
    models?: ModelsUncheckedCreateNestedManyWithoutPartsInput
  }

  export type PartsUpdateInput = {
    partNo?: StringFieldUpdateOperationsInput | string
    partName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    claimId?: PartsUpdateclaimIdInput | string[]
    claims?: ClaimUpdateManyWithoutPartsNestedInput
    entity?: EntityUpdateOneWithoutPartsNestedInput
    organization?: OrganizationUpdateOneWithoutPartsNestedInput
    models?: ModelsUpdateManyWithoutPartsNestedInput
  }

  export type PartsUncheckedUpdateInput = {
    partNo?: StringFieldUpdateOperationsInput | string
    partName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    claimId?: PartsUpdateclaimIdInput | string[]
    modelsId?: PartsUpdatemodelsIdInput | string[]
    claims?: ClaimUncheckedUpdateManyWithoutPartsNestedInput
    models?: ModelsUncheckedUpdateManyWithoutPartsNestedInput
  }

  export type PartsCreateManyInput = {
    id?: string
    partNo: string
    partName: string
    description?: string | null
    organizationId?: string | null
    entityId?: string | null
    claimId?: PartsCreateclaimIdInput | string[]
    modelsId?: PartsCreatemodelsIdInput | string[]
  }

  export type PartsUpdateManyMutationInput = {
    partNo?: StringFieldUpdateOperationsInput | string
    partName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    claimId?: PartsUpdateclaimIdInput | string[]
  }

  export type PartsUncheckedUpdateManyInput = {
    partNo?: StringFieldUpdateOperationsInput | string
    partName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    claimId?: PartsUpdateclaimIdInput | string[]
    modelsId?: PartsUpdatemodelsIdInput | string[]
  }

  export type ClaimCreateInput = {
    id?: string
    partRecieptDate: string
    vehicleType: string
    FrameNo: string
    prNo: string
    lineOffDate: string
    saleDate: string
    repairDate: string
    settleMonth?: string | null
    kms: number
    mis: number
    claimNo: number
    problem?: ProblemCreateNestedOneWithoutClaimInput
    investigations?: InvestigationCreateNestedOneWithoutClaimsInput
    models?: ModelsCreateNestedOneWithoutClaimsInput
    parts?: PartsCreateNestedOneWithoutClaimsInput
    shipments?: ShipmentCreateNestedOneWithoutClaimsInput
    claimToEntity?: ClaimToEntityCreateNestedManyWithoutClaimInput
  }

  export type ClaimUncheckedCreateInput = {
    id?: string
    partId?: string | null
    modelId?: string | null
    partRecieptDate: string
    vehicleType: string
    FrameNo: string
    prNo: string
    lineOffDate: string
    saleDate: string
    repairDate: string
    shipmentId?: string | null
    investigationId?: string | null
    settleMonth?: string | null
    kms: number
    problemId?: string | null
    mis: number
    claimNo: number
    claimToEntity?: ClaimToEntityUncheckedCreateNestedManyWithoutClaimInput
  }

  export type ClaimUpdateInput = {
    partRecieptDate?: StringFieldUpdateOperationsInput | string
    vehicleType?: StringFieldUpdateOperationsInput | string
    FrameNo?: StringFieldUpdateOperationsInput | string
    prNo?: StringFieldUpdateOperationsInput | string
    lineOffDate?: StringFieldUpdateOperationsInput | string
    saleDate?: StringFieldUpdateOperationsInput | string
    repairDate?: StringFieldUpdateOperationsInput | string
    settleMonth?: NullableStringFieldUpdateOperationsInput | string | null
    kms?: IntFieldUpdateOperationsInput | number
    mis?: IntFieldUpdateOperationsInput | number
    claimNo?: IntFieldUpdateOperationsInput | number
    problem?: ProblemUpdateOneWithoutClaimNestedInput
    investigations?: InvestigationUpdateOneWithoutClaimsNestedInput
    models?: ModelsUpdateOneWithoutClaimsNestedInput
    parts?: PartsUpdateOneWithoutClaimsNestedInput
    shipments?: ShipmentUpdateOneWithoutClaimsNestedInput
    claimToEntity?: ClaimToEntityUpdateManyWithoutClaimNestedInput
  }

  export type ClaimUncheckedUpdateInput = {
    partId?: NullableStringFieldUpdateOperationsInput | string | null
    modelId?: NullableStringFieldUpdateOperationsInput | string | null
    partRecieptDate?: StringFieldUpdateOperationsInput | string
    vehicleType?: StringFieldUpdateOperationsInput | string
    FrameNo?: StringFieldUpdateOperationsInput | string
    prNo?: StringFieldUpdateOperationsInput | string
    lineOffDate?: StringFieldUpdateOperationsInput | string
    saleDate?: StringFieldUpdateOperationsInput | string
    repairDate?: StringFieldUpdateOperationsInput | string
    shipmentId?: NullableStringFieldUpdateOperationsInput | string | null
    investigationId?: NullableStringFieldUpdateOperationsInput | string | null
    settleMonth?: NullableStringFieldUpdateOperationsInput | string | null
    kms?: IntFieldUpdateOperationsInput | number
    problemId?: NullableStringFieldUpdateOperationsInput | string | null
    mis?: IntFieldUpdateOperationsInput | number
    claimNo?: IntFieldUpdateOperationsInput | number
    claimToEntity?: ClaimToEntityUncheckedUpdateManyWithoutClaimNestedInput
  }

  export type ClaimCreateManyInput = {
    id?: string
    partId?: string | null
    modelId?: string | null
    partRecieptDate: string
    vehicleType: string
    FrameNo: string
    prNo: string
    lineOffDate: string
    saleDate: string
    repairDate: string
    shipmentId?: string | null
    investigationId?: string | null
    settleMonth?: string | null
    kms: number
    problemId?: string | null
    mis: number
    claimNo: number
  }

  export type ClaimUpdateManyMutationInput = {
    partRecieptDate?: StringFieldUpdateOperationsInput | string
    vehicleType?: StringFieldUpdateOperationsInput | string
    FrameNo?: StringFieldUpdateOperationsInput | string
    prNo?: StringFieldUpdateOperationsInput | string
    lineOffDate?: StringFieldUpdateOperationsInput | string
    saleDate?: StringFieldUpdateOperationsInput | string
    repairDate?: StringFieldUpdateOperationsInput | string
    settleMonth?: NullableStringFieldUpdateOperationsInput | string | null
    kms?: IntFieldUpdateOperationsInput | number
    mis?: IntFieldUpdateOperationsInput | number
    claimNo?: IntFieldUpdateOperationsInput | number
  }

  export type ClaimUncheckedUpdateManyInput = {
    partId?: NullableStringFieldUpdateOperationsInput | string | null
    modelId?: NullableStringFieldUpdateOperationsInput | string | null
    partRecieptDate?: StringFieldUpdateOperationsInput | string
    vehicleType?: StringFieldUpdateOperationsInput | string
    FrameNo?: StringFieldUpdateOperationsInput | string
    prNo?: StringFieldUpdateOperationsInput | string
    lineOffDate?: StringFieldUpdateOperationsInput | string
    saleDate?: StringFieldUpdateOperationsInput | string
    repairDate?: StringFieldUpdateOperationsInput | string
    shipmentId?: NullableStringFieldUpdateOperationsInput | string | null
    investigationId?: NullableStringFieldUpdateOperationsInput | string | null
    settleMonth?: NullableStringFieldUpdateOperationsInput | string | null
    kms?: IntFieldUpdateOperationsInput | number
    problemId?: NullableStringFieldUpdateOperationsInput | string | null
    mis?: IntFieldUpdateOperationsInput | number
    claimNo?: IntFieldUpdateOperationsInput | number
  }

  export type ProblemCreateInput = {
    id?: string
    problem: string
    createdAt: string
    investigations?: InvestigationCreateNestedManyWithoutProblemInput
    claim?: ClaimCreateNestedManyWithoutProblemInput
    organization: OrganizationCreateNestedOneWithoutProblemInput
  }

  export type ProblemUncheckedCreateInput = {
    id?: string
    problem: string
    createdAt: string
    organizationId: string
    investigations?: InvestigationUncheckedCreateNestedManyWithoutProblemInput
    claim?: ClaimUncheckedCreateNestedManyWithoutProblemInput
  }

  export type ProblemUpdateInput = {
    problem?: StringFieldUpdateOperationsInput | string
    createdAt?: StringFieldUpdateOperationsInput | string
    investigations?: InvestigationUpdateManyWithoutProblemNestedInput
    claim?: ClaimUpdateManyWithoutProblemNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutProblemNestedInput
  }

  export type ProblemUncheckedUpdateInput = {
    problem?: StringFieldUpdateOperationsInput | string
    createdAt?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    investigations?: InvestigationUncheckedUpdateManyWithoutProblemNestedInput
    claim?: ClaimUncheckedUpdateManyWithoutProblemNestedInput
  }

  export type ProblemCreateManyInput = {
    id?: string
    problem: string
    createdAt: string
    organizationId: string
  }

  export type ProblemUpdateManyMutationInput = {
    problem?: StringFieldUpdateOperationsInput | string
    createdAt?: StringFieldUpdateOperationsInput | string
  }

  export type ProblemUncheckedUpdateManyInput = {
    problem?: StringFieldUpdateOperationsInput | string
    createdAt?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
  }

  export type ClaimToEntityCreateInput = {
    id?: string
    claim: ClaimCreateNestedOneWithoutClaimToEntityInput
    entity: EntityCreateNestedOneWithoutClaimToEntityInput
  }

  export type ClaimToEntityUncheckedCreateInput = {
    id?: string
    claimId: string
    entityId: string
  }

  export type ClaimToEntityUpdateInput = {
    claim?: ClaimUpdateOneRequiredWithoutClaimToEntityNestedInput
    entity?: EntityUpdateOneRequiredWithoutClaimToEntityNestedInput
  }

  export type ClaimToEntityUncheckedUpdateInput = {
    claimId?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
  }

  export type ClaimToEntityCreateManyInput = {
    id?: string
    claimId: string
    entityId: string
  }

  export type ClaimToEntityUpdateManyMutationInput = {

  }

  export type ClaimToEntityUncheckedUpdateManyInput = {
    claimId?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
  }

  export type InvestigationCreateInput = {
    id?: string
    rootCause: string
    counterMeasure: string
    leadTime: string
    claimType: string
    implementDate: string
    attachment?: InvestigationCreateattachmentInput | InputJsonValue[]
    claimNo: number
    claims?: ClaimCreateNestedManyWithoutInvestigationsInput
    Problem?: ProblemCreateNestedOneWithoutInvestigationsInput
  }

  export type InvestigationUncheckedCreateInput = {
    id?: string
    rootCause: string
    counterMeasure: string
    leadTime: string
    claimType: string
    implementDate: string
    attachment?: InvestigationCreateattachmentInput | InputJsonValue[]
    claimNo: number
    problemId?: string | null
    claims?: ClaimUncheckedCreateNestedManyWithoutInvestigationsInput
  }

  export type InvestigationUpdateInput = {
    rootCause?: StringFieldUpdateOperationsInput | string
    counterMeasure?: StringFieldUpdateOperationsInput | string
    leadTime?: StringFieldUpdateOperationsInput | string
    claimType?: StringFieldUpdateOperationsInput | string
    implementDate?: StringFieldUpdateOperationsInput | string
    attachment?: InvestigationUpdateattachmentInput | InputJsonValue[]
    claimNo?: IntFieldUpdateOperationsInput | number
    claims?: ClaimUpdateManyWithoutInvestigationsNestedInput
    Problem?: ProblemUpdateOneWithoutInvestigationsNestedInput
  }

  export type InvestigationUncheckedUpdateInput = {
    rootCause?: StringFieldUpdateOperationsInput | string
    counterMeasure?: StringFieldUpdateOperationsInput | string
    leadTime?: StringFieldUpdateOperationsInput | string
    claimType?: StringFieldUpdateOperationsInput | string
    implementDate?: StringFieldUpdateOperationsInput | string
    attachment?: InvestigationUpdateattachmentInput | InputJsonValue[]
    claimNo?: IntFieldUpdateOperationsInput | number
    problemId?: NullableStringFieldUpdateOperationsInput | string | null
    claims?: ClaimUncheckedUpdateManyWithoutInvestigationsNestedInput
  }

  export type InvestigationCreateManyInput = {
    id?: string
    rootCause: string
    counterMeasure: string
    leadTime: string
    claimType: string
    implementDate: string
    attachment?: InvestigationCreateattachmentInput | InputJsonValue[]
    claimNo: number
    problemId?: string | null
  }

  export type InvestigationUpdateManyMutationInput = {
    rootCause?: StringFieldUpdateOperationsInput | string
    counterMeasure?: StringFieldUpdateOperationsInput | string
    leadTime?: StringFieldUpdateOperationsInput | string
    claimType?: StringFieldUpdateOperationsInput | string
    implementDate?: StringFieldUpdateOperationsInput | string
    attachment?: InvestigationUpdateattachmentInput | InputJsonValue[]
    claimNo?: IntFieldUpdateOperationsInput | number
  }

  export type InvestigationUncheckedUpdateManyInput = {
    rootCause?: StringFieldUpdateOperationsInput | string
    counterMeasure?: StringFieldUpdateOperationsInput | string
    leadTime?: StringFieldUpdateOperationsInput | string
    claimType?: StringFieldUpdateOperationsInput | string
    implementDate?: StringFieldUpdateOperationsInput | string
    attachment?: InvestigationUpdateattachmentInput | InputJsonValue[]
    claimNo?: IntFieldUpdateOperationsInput | number
    problemId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ShipmentCreateInput = {
    id?: string
    shipmentDate?: string | null
    quantity?: number | null
    location?: string | null
    InvoiceNumber?: string | null
    dueDate?: string | null
    shipmentCost?: number | null
    createdBy?: string | null
    awb?: string | null
    supplierName?: string | null
    supplierReport?: ShipmentCreatesupplierReportInput | InputJsonValue[]
    claims?: ClaimCreateNestedManyWithoutShipmentsInput
  }

  export type ShipmentUncheckedCreateInput = {
    id?: string
    shipmentDate?: string | null
    quantity?: number | null
    location?: string | null
    InvoiceNumber?: string | null
    dueDate?: string | null
    shipmentCost?: number | null
    createdBy?: string | null
    awb?: string | null
    supplierName?: string | null
    supplierReport?: ShipmentCreatesupplierReportInput | InputJsonValue[]
    claims?: ClaimUncheckedCreateNestedManyWithoutShipmentsInput
  }

  export type ShipmentUpdateInput = {
    shipmentDate?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    InvoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableStringFieldUpdateOperationsInput | string | null
    shipmentCost?: NullableIntFieldUpdateOperationsInput | number | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    awb?: NullableStringFieldUpdateOperationsInput | string | null
    supplierName?: NullableStringFieldUpdateOperationsInput | string | null
    supplierReport?: ShipmentUpdatesupplierReportInput | InputJsonValue[]
    claims?: ClaimUpdateManyWithoutShipmentsNestedInput
  }

  export type ShipmentUncheckedUpdateInput = {
    shipmentDate?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    InvoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableStringFieldUpdateOperationsInput | string | null
    shipmentCost?: NullableIntFieldUpdateOperationsInput | number | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    awb?: NullableStringFieldUpdateOperationsInput | string | null
    supplierName?: NullableStringFieldUpdateOperationsInput | string | null
    supplierReport?: ShipmentUpdatesupplierReportInput | InputJsonValue[]
    claims?: ClaimUncheckedUpdateManyWithoutShipmentsNestedInput
  }

  export type ShipmentCreateManyInput = {
    id?: string
    shipmentDate?: string | null
    quantity?: number | null
    location?: string | null
    InvoiceNumber?: string | null
    dueDate?: string | null
    shipmentCost?: number | null
    createdBy?: string | null
    awb?: string | null
    supplierName?: string | null
    supplierReport?: ShipmentCreatesupplierReportInput | InputJsonValue[]
  }

  export type ShipmentUpdateManyMutationInput = {
    shipmentDate?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    InvoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableStringFieldUpdateOperationsInput | string | null
    shipmentCost?: NullableIntFieldUpdateOperationsInput | number | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    awb?: NullableStringFieldUpdateOperationsInput | string | null
    supplierName?: NullableStringFieldUpdateOperationsInput | string | null
    supplierReport?: ShipmentUpdatesupplierReportInput | InputJsonValue[]
  }

  export type ShipmentUncheckedUpdateManyInput = {
    shipmentDate?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    InvoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableStringFieldUpdateOperationsInput | string | null
    shipmentCost?: NullableIntFieldUpdateOperationsInput | number | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    awb?: NullableStringFieldUpdateOperationsInput | string | null
    supplierName?: NullableStringFieldUpdateOperationsInput | string | null
    supplierReport?: ShipmentUpdatesupplierReportInput | InputJsonValue[]
  }

  export type OrganizationCreateInput = {
    id?: string
    kcId?: string | null
    organizationName?: string | null
    realmName?: string | null
    instanceUrl?: string | null
    principalGeography?: string | null
    loginUrl?: string | null
    logoutUrl?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    activeModules?: OrganizationCreateactiveModulesInput | string[]
    clientID?: string | null
    clientSecret?: string | null
    fiscalYearQuarters?: string | null
    fiscalYearFormat?: string | null
    auditYear?: string | null
    logoUrl?: string | null
    deleted?: boolean | null
    business?: BusinessCreateNestedManyWithoutOrganizationInput
    Doctype?: DoctypeCreateNestedManyWithoutOrganizationInput
    Documents?: DocumentsCreateNestedManyWithoutOrganizationInput
    entity?: EntityCreateNestedManyWithoutOrganizationInput
    entityType?: EntityTypeCreateNestedManyWithoutOrganizationInput
    location?: LocationCreateNestedManyWithoutOrganizationInput
    role?: RoleCreateNestedManyWithoutOrganizationInput
    section?: SectionCreateNestedManyWithoutOrganizationInput
    systemType?: SystemTypeCreateNestedManyWithoutOrganizationInput
    user?: UserCreateNestedManyWithoutOrganizationInput
    userPersonalisation?: userPersonalisationCreateNestedManyWithoutOrganizationInput
    ConnectedApps?: ConnectedAppsCreateNestedManyWithoutOrganizationInput
    unitOfMeasurement?: unitTypeCreateNestedManyWithoutOrganizationInput
    kpi?: kpiCreateNestedManyWithoutOrganizationInput
    businessType?: businessTypeCreateNestedManyWithoutOrganizationInput
    prefixSuffix?: prefixSuffixCreateNestedManyWithoutOrganizationInput
    serialNumber?: serialNumberCreateNestedManyWithoutOrganizationInput
    function?: FunctionsCreateNestedManyWithoutOrganizationInput
    rolesTable?: rolesTableCreateNestedManyWithoutOrganizationInput
    problem?: ProblemCreateNestedManyWithoutOrganizationInput
    parts?: PartsCreateNestedManyWithoutOrganizationInput
    Models?: ModelsCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateInput = {
    id?: string
    kcId?: string | null
    organizationName?: string | null
    realmName?: string | null
    instanceUrl?: string | null
    principalGeography?: string | null
    loginUrl?: string | null
    logoutUrl?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    activeModules?: OrganizationCreateactiveModulesInput | string[]
    clientID?: string | null
    clientSecret?: string | null
    fiscalYearQuarters?: string | null
    fiscalYearFormat?: string | null
    auditYear?: string | null
    logoUrl?: string | null
    deleted?: boolean | null
    business?: BusinessUncheckedCreateNestedManyWithoutOrganizationInput
    Doctype?: DoctypeUncheckedCreateNestedManyWithoutOrganizationInput
    Documents?: DocumentsUncheckedCreateNestedManyWithoutOrganizationInput
    entity?: EntityUncheckedCreateNestedManyWithoutOrganizationInput
    entityType?: EntityTypeUncheckedCreateNestedManyWithoutOrganizationInput
    location?: LocationUncheckedCreateNestedManyWithoutOrganizationInput
    role?: RoleUncheckedCreateNestedManyWithoutOrganizationInput
    section?: SectionUncheckedCreateNestedManyWithoutOrganizationInput
    systemType?: SystemTypeUncheckedCreateNestedManyWithoutOrganizationInput
    user?: UserUncheckedCreateNestedManyWithoutOrganizationInput
    userPersonalisation?: userPersonalisationUncheckedCreateNestedManyWithoutOrganizationInput
    ConnectedApps?: ConnectedAppsUncheckedCreateNestedManyWithoutOrganizationInput
    unitOfMeasurement?: unitTypeUncheckedCreateNestedManyWithoutOrganizationInput
    kpi?: kpiUncheckedCreateNestedManyWithoutOrganizationInput
    businessType?: businessTypeUncheckedCreateNestedManyWithoutOrganizationInput
    prefixSuffix?: prefixSuffixUncheckedCreateNestedManyWithoutOrganizationInput
    serialNumber?: serialNumberUncheckedCreateNestedManyWithoutOrganizationInput
    function?: FunctionsUncheckedCreateNestedManyWithoutOrganizationInput
    rolesTable?: rolesTableUncheckedCreateNestedManyWithoutOrganizationInput
    problem?: ProblemUncheckedCreateNestedManyWithoutOrganizationInput
    parts?: PartsUncheckedCreateNestedManyWithoutOrganizationInput
    Models?: ModelsUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUpdateInput = {
    kcId?: NullableStringFieldUpdateOperationsInput | string | null
    organizationName?: NullableStringFieldUpdateOperationsInput | string | null
    realmName?: NullableStringFieldUpdateOperationsInput | string | null
    instanceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    principalGeography?: NullableStringFieldUpdateOperationsInput | string | null
    loginUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoutUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    activeModules?: OrganizationUpdateactiveModulesInput | string[]
    clientID?: NullableStringFieldUpdateOperationsInput | string | null
    clientSecret?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearQuarters?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearFormat?: NullableStringFieldUpdateOperationsInput | string | null
    auditYear?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    business?: BusinessUpdateManyWithoutOrganizationNestedInput
    Doctype?: DoctypeUpdateManyWithoutOrganizationNestedInput
    Documents?: DocumentsUpdateManyWithoutOrganizationNestedInput
    entity?: EntityUpdateManyWithoutOrganizationNestedInput
    entityType?: EntityTypeUpdateManyWithoutOrganizationNestedInput
    location?: LocationUpdateManyWithoutOrganizationNestedInput
    role?: RoleUpdateManyWithoutOrganizationNestedInput
    section?: SectionUpdateManyWithoutOrganizationNestedInput
    systemType?: SystemTypeUpdateManyWithoutOrganizationNestedInput
    user?: UserUpdateManyWithoutOrganizationNestedInput
    userPersonalisation?: userPersonalisationUpdateManyWithoutOrganizationNestedInput
    ConnectedApps?: ConnectedAppsUpdateManyWithoutOrganizationNestedInput
    unitOfMeasurement?: unitTypeUpdateManyWithoutOrganizationNestedInput
    kpi?: kpiUpdateManyWithoutOrganizationNestedInput
    businessType?: businessTypeUpdateManyWithoutOrganizationNestedInput
    prefixSuffix?: prefixSuffixUpdateManyWithoutOrganizationNestedInput
    serialNumber?: serialNumberUpdateManyWithoutOrganizationNestedInput
    function?: FunctionsUpdateManyWithoutOrganizationNestedInput
    rolesTable?: rolesTableUpdateManyWithoutOrganizationNestedInput
    problem?: ProblemUpdateManyWithoutOrganizationNestedInput
    parts?: PartsUpdateManyWithoutOrganizationNestedInput
    Models?: ModelsUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateInput = {
    kcId?: NullableStringFieldUpdateOperationsInput | string | null
    organizationName?: NullableStringFieldUpdateOperationsInput | string | null
    realmName?: NullableStringFieldUpdateOperationsInput | string | null
    instanceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    principalGeography?: NullableStringFieldUpdateOperationsInput | string | null
    loginUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoutUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    activeModules?: OrganizationUpdateactiveModulesInput | string[]
    clientID?: NullableStringFieldUpdateOperationsInput | string | null
    clientSecret?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearQuarters?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearFormat?: NullableStringFieldUpdateOperationsInput | string | null
    auditYear?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    business?: BusinessUncheckedUpdateManyWithoutOrganizationNestedInput
    Doctype?: DoctypeUncheckedUpdateManyWithoutOrganizationNestedInput
    Documents?: DocumentsUncheckedUpdateManyWithoutOrganizationNestedInput
    entity?: EntityUncheckedUpdateManyWithoutOrganizationNestedInput
    entityType?: EntityTypeUncheckedUpdateManyWithoutOrganizationNestedInput
    location?: LocationUncheckedUpdateManyWithoutOrganizationNestedInput
    role?: RoleUncheckedUpdateManyWithoutOrganizationNestedInput
    section?: SectionUncheckedUpdateManyWithoutOrganizationNestedInput
    systemType?: SystemTypeUncheckedUpdateManyWithoutOrganizationNestedInput
    user?: UserUncheckedUpdateManyWithoutOrganizationNestedInput
    userPersonalisation?: userPersonalisationUncheckedUpdateManyWithoutOrganizationNestedInput
    ConnectedApps?: ConnectedAppsUncheckedUpdateManyWithoutOrganizationNestedInput
    unitOfMeasurement?: unitTypeUncheckedUpdateManyWithoutOrganizationNestedInput
    kpi?: kpiUncheckedUpdateManyWithoutOrganizationNestedInput
    businessType?: businessTypeUncheckedUpdateManyWithoutOrganizationNestedInput
    prefixSuffix?: prefixSuffixUncheckedUpdateManyWithoutOrganizationNestedInput
    serialNumber?: serialNumberUncheckedUpdateManyWithoutOrganizationNestedInput
    function?: FunctionsUncheckedUpdateManyWithoutOrganizationNestedInput
    rolesTable?: rolesTableUncheckedUpdateManyWithoutOrganizationNestedInput
    problem?: ProblemUncheckedUpdateManyWithoutOrganizationNestedInput
    parts?: PartsUncheckedUpdateManyWithoutOrganizationNestedInput
    Models?: ModelsUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationCreateManyInput = {
    id?: string
    kcId?: string | null
    organizationName?: string | null
    realmName?: string | null
    instanceUrl?: string | null
    principalGeography?: string | null
    loginUrl?: string | null
    logoutUrl?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    activeModules?: OrganizationCreateactiveModulesInput | string[]
    clientID?: string | null
    clientSecret?: string | null
    fiscalYearQuarters?: string | null
    fiscalYearFormat?: string | null
    auditYear?: string | null
    logoUrl?: string | null
    deleted?: boolean | null
  }

  export type OrganizationUpdateManyMutationInput = {
    kcId?: NullableStringFieldUpdateOperationsInput | string | null
    organizationName?: NullableStringFieldUpdateOperationsInput | string | null
    realmName?: NullableStringFieldUpdateOperationsInput | string | null
    instanceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    principalGeography?: NullableStringFieldUpdateOperationsInput | string | null
    loginUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoutUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    activeModules?: OrganizationUpdateactiveModulesInput | string[]
    clientID?: NullableStringFieldUpdateOperationsInput | string | null
    clientSecret?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearQuarters?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearFormat?: NullableStringFieldUpdateOperationsInput | string | null
    auditYear?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type OrganizationUncheckedUpdateManyInput = {
    kcId?: NullableStringFieldUpdateOperationsInput | string | null
    organizationName?: NullableStringFieldUpdateOperationsInput | string | null
    realmName?: NullableStringFieldUpdateOperationsInput | string | null
    instanceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    principalGeography?: NullableStringFieldUpdateOperationsInput | string | null
    loginUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoutUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    activeModules?: OrganizationUpdateactiveModulesInput | string[]
    clientID?: NullableStringFieldUpdateOperationsInput | string | null
    clientSecret?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearQuarters?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearFormat?: NullableStringFieldUpdateOperationsInput | string | null
    auditYear?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type RoleCreateInput = {
    id?: string
    kcId?: string | null
    roleName?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    deleted?: boolean | null
    organization?: OrganizationCreateNestedOneWithoutRoleInput
    Location?: LocationCreateNestedOneWithoutRoleInput
  }

  export type RoleUncheckedCreateInput = {
    id?: string
    kcId?: string | null
    roleName?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    deleted?: boolean | null
    organizationId?: string | null
    locationId?: string | null
  }

  export type RoleUpdateInput = {
    kcId?: NullableStringFieldUpdateOperationsInput | string | null
    roleName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    organization?: OrganizationUpdateOneWithoutRoleNestedInput
    Location?: LocationUpdateOneWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateInput = {
    kcId?: NullableStringFieldUpdateOperationsInput | string | null
    roleName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RoleCreateManyInput = {
    id?: string
    kcId?: string | null
    roleName?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    deleted?: boolean | null
    organizationId?: string | null
    locationId?: string | null
  }

  export type RoleUpdateManyMutationInput = {
    kcId?: NullableStringFieldUpdateOperationsInput | string | null
    roleName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type RoleUncheckedUpdateManyInput = {
    kcId?: NullableStringFieldUpdateOperationsInput | string | null
    roleName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SystemTypeCreateInput = {
    id?: string
    name?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    color?: string | null
    updatedBy?: string | null
    deleted?: boolean | null
    organization?: OrganizationCreateNestedOneWithoutSystemTypeInput
  }

  export type SystemTypeUncheckedCreateInput = {
    id?: string
    name?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    color?: string | null
    updatedBy?: string | null
    deleted?: boolean | null
    organizationId?: string | null
  }

  export type SystemTypeUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    organization?: OrganizationUpdateOneWithoutSystemTypeNestedInput
  }

  export type SystemTypeUncheckedUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SystemTypeCreateManyInput = {
    id?: string
    name?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    color?: string | null
    updatedBy?: string | null
    deleted?: boolean | null
    organizationId?: string | null
  }

  export type SystemTypeUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type SystemTypeUncheckedUpdateManyInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EntityTypeCreateInput = {
    id?: string
    name?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    deleted?: boolean | null
    organization?: OrganizationCreateNestedOneWithoutEntityTypeInput
    entity?: EntityCreateNestedManyWithoutEntityTypeInput
  }

  export type EntityTypeUncheckedCreateInput = {
    id?: string
    name?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    organizationId?: string | null
    deleted?: boolean | null
    entity?: EntityUncheckedCreateNestedManyWithoutEntityTypeInput
  }

  export type EntityTypeUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    organization?: OrganizationUpdateOneWithoutEntityTypeNestedInput
    entity?: EntityUpdateManyWithoutEntityTypeNestedInput
  }

  export type EntityTypeUncheckedUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    entity?: EntityUncheckedUpdateManyWithoutEntityTypeNestedInput
  }

  export type EntityTypeCreateManyInput = {
    id?: string
    name?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    organizationId?: string | null
    deleted?: boolean | null
  }

  export type EntityTypeUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type EntityTypeUncheckedUpdateManyInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type businessTypeCreateInput = {
    id?: string
    name?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    deleted?: boolean | null
    organization?: OrganizationCreateNestedOneWithoutBusinessTypeInput
  }

  export type businessTypeUncheckedCreateInput = {
    id?: string
    name?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    deleted?: boolean | null
    organizationId?: string | null
  }

  export type businessTypeUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    organization?: OrganizationUpdateOneWithoutBusinessTypeNestedInput
  }

  export type businessTypeUncheckedUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type businessTypeCreateManyInput = {
    id?: string
    name?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    deleted?: boolean | null
    organizationId?: string | null
  }

  export type businessTypeUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type businessTypeUncheckedUpdateManyInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BusinessCreateInput = {
    id?: string
    name?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    deleted?: boolean | null
    organization?: OrganizationCreateNestedOneWithoutBusinessInput
    location?: LocationBusinessCreateNestedManyWithoutBusinessInput
  }

  export type BusinessUncheckedCreateInput = {
    id?: string
    name?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    organizationId?: string | null
    deleted?: boolean | null
    location?: LocationBusinessUncheckedCreateNestedManyWithoutBusinessInput
  }

  export type BusinessUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    organization?: OrganizationUpdateOneWithoutBusinessNestedInput
    location?: LocationBusinessUpdateManyWithoutBusinessNestedInput
  }

  export type BusinessUncheckedUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    location?: LocationBusinessUncheckedUpdateManyWithoutBusinessNestedInput
  }

  export type BusinessCreateManyInput = {
    id?: string
    name?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    organizationId?: string | null
    deleted?: boolean | null
  }

  export type BusinessUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type BusinessUncheckedUpdateManyInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type FunctionsCreateInput = {
    id?: string
    name?: string | null
    functionId?: string | null
    description?: string | null
    functionHead?: FunctionsCreatefunctionHeadInput | string[]
    functionSpoc?: FunctionsCreatefunctionSpocInput | string[]
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    deleted?: boolean | null
    type?: boolean
    locationId?: FunctionsCreatelocationIdInput | string[]
    businessId?: FunctionsCreatebusinessIdInput | string[]
    unitId?: string | null
    organization?: OrganizationCreateNestedOneWithoutFunctionInput
    entity?: EntityCreateNestedManyWithoutFunctionInput
  }

  export type FunctionsUncheckedCreateInput = {
    id?: string
    name?: string | null
    functionId?: string | null
    description?: string | null
    functionHead?: FunctionsCreatefunctionHeadInput | string[]
    functionSpoc?: FunctionsCreatefunctionSpocInput | string[]
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    deleted?: boolean | null
    organizationId?: string | null
    type?: boolean
    locationId?: FunctionsCreatelocationIdInput | string[]
    businessId?: FunctionsCreatebusinessIdInput | string[]
    unitId?: string | null
    entity?: EntityUncheckedCreateNestedManyWithoutFunctionInput
  }

  export type FunctionsUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    functionId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    functionHead?: FunctionsUpdatefunctionHeadInput | string[]
    functionSpoc?: FunctionsUpdatefunctionSpocInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    type?: BoolFieldUpdateOperationsInput | boolean
    locationId?: FunctionsUpdatelocationIdInput | string[]
    businessId?: FunctionsUpdatebusinessIdInput | string[]
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: OrganizationUpdateOneWithoutFunctionNestedInput
    entity?: EntityUpdateManyWithoutFunctionNestedInput
  }

  export type FunctionsUncheckedUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    functionId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    functionHead?: FunctionsUpdatefunctionHeadInput | string[]
    functionSpoc?: FunctionsUpdatefunctionSpocInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: BoolFieldUpdateOperationsInput | boolean
    locationId?: FunctionsUpdatelocationIdInput | string[]
    businessId?: FunctionsUpdatebusinessIdInput | string[]
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
    entity?: EntityUncheckedUpdateManyWithoutFunctionNestedInput
  }

  export type FunctionsCreateManyInput = {
    id?: string
    name?: string | null
    functionId?: string | null
    description?: string | null
    functionHead?: FunctionsCreatefunctionHeadInput | string[]
    functionSpoc?: FunctionsCreatefunctionSpocInput | string[]
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    deleted?: boolean | null
    organizationId?: string | null
    type?: boolean
    locationId?: FunctionsCreatelocationIdInput | string[]
    businessId?: FunctionsCreatebusinessIdInput | string[]
    unitId?: string | null
  }

  export type FunctionsUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    functionId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    functionHead?: FunctionsUpdatefunctionHeadInput | string[]
    functionSpoc?: FunctionsUpdatefunctionSpocInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    type?: BoolFieldUpdateOperationsInput | boolean
    locationId?: FunctionsUpdatelocationIdInput | string[]
    businessId?: FunctionsUpdatebusinessIdInput | string[]
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FunctionsUncheckedUpdateManyInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    functionId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    functionHead?: FunctionsUpdatefunctionHeadInput | string[]
    functionSpoc?: FunctionsUpdatefunctionSpocInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: BoolFieldUpdateOperationsInput | boolean
    locationId?: FunctionsUpdatelocationIdInput | string[]
    businessId?: FunctionsUpdatebusinessIdInput | string[]
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SectionCreateInput = {
    id?: string
    name?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    deleted?: boolean | null
    organization?: OrganizationCreateNestedOneWithoutSectionInput
  }

  export type SectionUncheckedCreateInput = {
    id?: string
    name?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    organizationId?: string | null
    deleted?: boolean | null
  }

  export type SectionUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    organization?: OrganizationUpdateOneWithoutSectionNestedInput
  }

  export type SectionUncheckedUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type SectionCreateManyInput = {
    id?: string
    name?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    organizationId?: string | null
    deleted?: boolean | null
  }

  export type SectionUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type SectionUncheckedUpdateManyInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type LocationCreateInput = {
    id?: string
    locationName?: string | null
    locationType?: string | null
    locationId?: string | null
    description?: string | null
    status?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedBy?: string | null
    functionId?: LocationCreatefunctionIdInput | string[]
    deleted?: boolean | null
    users?: LocationCreateusersInput | InputJsonValue[]
    businessTypeId?: string | null
    type?: string | null
    organization?: OrganizationCreateNestedOneWithoutLocationInput
    Documents?: DocumentsCreateNestedManyWithoutCreatorLocationInput
    entity?: EntityCreateNestedManyWithoutLocationInput
    business?: LocationBusinessCreateNestedManyWithoutLocationInput
    user?: UserCreateNestedManyWithoutLocationInput
    uom?: unitTypeCreateNestedManyWithoutLocationInput
    rolesTable?: rolesTableCreateNestedManyWithoutLocationInput
    Role?: RoleCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateInput = {
    id?: string
    locationName?: string | null
    locationType?: string | null
    locationId?: string | null
    description?: string | null
    status?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedBy?: string | null
    functionId?: LocationCreatefunctionIdInput | string[]
    deleted?: boolean | null
    organizationId?: string | null
    users?: LocationCreateusersInput | InputJsonValue[]
    businessTypeId?: string | null
    type?: string | null
    Documents?: DocumentsUncheckedCreateNestedManyWithoutCreatorLocationInput
    entity?: EntityUncheckedCreateNestedManyWithoutLocationInput
    business?: LocationBusinessUncheckedCreateNestedManyWithoutLocationInput
    user?: UserUncheckedCreateNestedManyWithoutLocationInput
    uom?: unitTypeUncheckedCreateNestedManyWithoutLocationInput
    rolesTable?: rolesTableUncheckedCreateNestedManyWithoutLocationInput
    Role?: RoleUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationUpdateInput = {
    locationName?: NullableStringFieldUpdateOperationsInput | string | null
    locationType?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    functionId?: LocationUpdatefunctionIdInput | string[]
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    users?: LocationUpdateusersInput | InputJsonValue[]
    businessTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: OrganizationUpdateOneWithoutLocationNestedInput
    Documents?: DocumentsUpdateManyWithoutCreatorLocationNestedInput
    entity?: EntityUpdateManyWithoutLocationNestedInput
    business?: LocationBusinessUpdateManyWithoutLocationNestedInput
    user?: UserUpdateManyWithoutLocationNestedInput
    uom?: unitTypeUpdateManyWithoutLocationNestedInput
    rolesTable?: rolesTableUpdateManyWithoutLocationNestedInput
    Role?: RoleUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateInput = {
    locationName?: NullableStringFieldUpdateOperationsInput | string | null
    locationType?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    functionId?: LocationUpdatefunctionIdInput | string[]
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    users?: LocationUpdateusersInput | InputJsonValue[]
    businessTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    Documents?: DocumentsUncheckedUpdateManyWithoutCreatorLocationNestedInput
    entity?: EntityUncheckedUpdateManyWithoutLocationNestedInput
    business?: LocationBusinessUncheckedUpdateManyWithoutLocationNestedInput
    user?: UserUncheckedUpdateManyWithoutLocationNestedInput
    uom?: unitTypeUncheckedUpdateManyWithoutLocationNestedInput
    rolesTable?: rolesTableUncheckedUpdateManyWithoutLocationNestedInput
    Role?: RoleUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type LocationCreateManyInput = {
    id?: string
    locationName?: string | null
    locationType?: string | null
    locationId?: string | null
    description?: string | null
    status?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedBy?: string | null
    functionId?: LocationCreatefunctionIdInput | string[]
    deleted?: boolean | null
    organizationId?: string | null
    users?: LocationCreateusersInput | InputJsonValue[]
    businessTypeId?: string | null
    type?: string | null
  }

  export type LocationUpdateManyMutationInput = {
    locationName?: NullableStringFieldUpdateOperationsInput | string | null
    locationType?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    functionId?: LocationUpdatefunctionIdInput | string[]
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    users?: LocationUpdateusersInput | InputJsonValue[]
    businessTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LocationUncheckedUpdateManyInput = {
    locationName?: NullableStringFieldUpdateOperationsInput | string | null
    locationType?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    functionId?: LocationUpdatefunctionIdInput | string[]
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    users?: LocationUpdateusersInput | InputJsonValue[]
    businessTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EntityCreateInput = {
    id?: string
    entityName?: string | null
    description?: string | null
    createdBy?: string | null
    entityId?: string | null
    deleted?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedBy?: string | null
    users?: EntityCreateusersInput | string[]
    sections?: EntityCreatesectionsInput | string[]
    entityType?: EntityTypeCreateNestedOneWithoutEntityInput
    location?: LocationCreateNestedOneWithoutEntityInput
    organization?: OrganizationCreateNestedOneWithoutEntityInput
    Doctype?: DoctypeCreateNestedManyWithoutEntityInput
    Documents?: DocumentsCreateNestedManyWithoutCreatorEntityInput
    user?: UserCreateNestedManyWithoutEntityInput
    parts?: PartsCreateNestedManyWithoutEntityInput
    claimToEntity?: ClaimToEntityCreateNestedManyWithoutEntityInput
    function?: FunctionsCreateNestedOneWithoutEntityInput
  }

  export type EntityUncheckedCreateInput = {
    id?: string
    entityName?: string | null
    description?: string | null
    entityTypeId?: string | null
    organizationId?: string | null
    locationId?: string | null
    createdBy?: string | null
    entityId?: string | null
    deleted?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedBy?: string | null
    users?: EntityCreateusersInput | string[]
    sections?: EntityCreatesectionsInput | string[]
    functionId?: string | null
    Doctype?: DoctypeUncheckedCreateNestedManyWithoutEntityInput
    Documents?: DocumentsUncheckedCreateNestedManyWithoutCreatorEntityInput
    user?: UserUncheckedCreateNestedManyWithoutEntityInput
    parts?: PartsUncheckedCreateNestedManyWithoutEntityInput
    claimToEntity?: ClaimToEntityUncheckedCreateNestedManyWithoutEntityInput
  }

  export type EntityUpdateInput = {
    entityName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    users?: EntityUpdateusersInput | string[]
    sections?: EntityUpdatesectionsInput | string[]
    entityType?: EntityTypeUpdateOneWithoutEntityNestedInput
    location?: LocationUpdateOneWithoutEntityNestedInput
    organization?: OrganizationUpdateOneWithoutEntityNestedInput
    Doctype?: DoctypeUpdateManyWithoutEntityNestedInput
    Documents?: DocumentsUpdateManyWithoutCreatorEntityNestedInput
    user?: UserUpdateManyWithoutEntityNestedInput
    parts?: PartsUpdateManyWithoutEntityNestedInput
    claimToEntity?: ClaimToEntityUpdateManyWithoutEntityNestedInput
    function?: FunctionsUpdateOneWithoutEntityNestedInput
  }

  export type EntityUncheckedUpdateInput = {
    entityName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    entityTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    users?: EntityUpdateusersInput | string[]
    sections?: EntityUpdatesectionsInput | string[]
    functionId?: NullableStringFieldUpdateOperationsInput | string | null
    Doctype?: DoctypeUncheckedUpdateManyWithoutEntityNestedInput
    Documents?: DocumentsUncheckedUpdateManyWithoutCreatorEntityNestedInput
    user?: UserUncheckedUpdateManyWithoutEntityNestedInput
    parts?: PartsUncheckedUpdateManyWithoutEntityNestedInput
    claimToEntity?: ClaimToEntityUncheckedUpdateManyWithoutEntityNestedInput
  }

  export type EntityCreateManyInput = {
    id?: string
    entityName?: string | null
    description?: string | null
    entityTypeId?: string | null
    organizationId?: string | null
    locationId?: string | null
    createdBy?: string | null
    entityId?: string | null
    deleted?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedBy?: string | null
    users?: EntityCreateusersInput | string[]
    sections?: EntityCreatesectionsInput | string[]
    functionId?: string | null
  }

  export type EntityUpdateManyMutationInput = {
    entityName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    users?: EntityUpdateusersInput | string[]
    sections?: EntityUpdatesectionsInput | string[]
  }

  export type EntityUncheckedUpdateManyInput = {
    entityName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    entityTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    users?: EntityUpdateusersInput | string[]
    sections?: EntityUpdatesectionsInput | string[]
    functionId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LocationBusinessCreateInput = {
    id?: string
    business?: BusinessCreateNestedOneWithoutLocationInput
    location?: LocationCreateNestedOneWithoutBusinessInput
  }

  export type LocationBusinessUncheckedCreateInput = {
    id?: string
    locationId?: string | null
    businessId?: string | null
  }

  export type LocationBusinessUpdateInput = {
    business?: BusinessUpdateOneWithoutLocationNestedInput
    location?: LocationUpdateOneWithoutBusinessNestedInput
  }

  export type LocationBusinessUncheckedUpdateInput = {
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LocationBusinessCreateManyInput = {
    id?: string
    locationId?: string | null
    businessId?: string | null
  }

  export type LocationBusinessUpdateManyMutationInput = {

  }

  export type LocationBusinessUncheckedUpdateManyInput = {
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationCreateInput = {
    id?: string
    type?: string | null
    text: string
    content: string
    creator?: string | null
    date?: Date | string
    style?: string | null
    read?: boolean
    user?: UserCreateNestedOneWithoutNotificationInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    type?: string | null
    text: string
    content: string
    receiver?: string | null
    creator?: string | null
    date?: Date | string
    style?: string | null
    read?: boolean
  }

  export type NotificationUpdateInput = {
    type?: NullableStringFieldUpdateOperationsInput | string | null
    text?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    creator?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    style?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneWithoutNotificationNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    type?: NullableStringFieldUpdateOperationsInput | string | null
    text?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    receiver?: NullableStringFieldUpdateOperationsInput | string | null
    creator?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    style?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NotificationCreateManyInput = {
    id?: string
    type?: string | null
    text: string
    content: string
    receiver?: string | null
    creator?: string | null
    date?: Date | string
    style?: string | null
    read?: boolean
  }

  export type NotificationUpdateManyMutationInput = {
    type?: NullableStringFieldUpdateOperationsInput | string | null
    text?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    creator?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    style?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NotificationUncheckedUpdateManyInput = {
    type?: NullableStringFieldUpdateOperationsInput | string | null
    text?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    receiver?: NullableStringFieldUpdateOperationsInput | string | null
    creator?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    style?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
  }

  export type DoctypeCreateInput = {
    id?: string
    locationId?: DoctypeCreatelocationIdInput | string[]
    documentTypeName?: string | null
    documentNumbering?: string | null
    reviewFrequency?: number | null
    revisionRemind?: number | null
    prefix?: string | null
    suffix?: string | null
    readAccess?: string | null
    readAccessUsers?: DoctypeCreatereadAccessUsersInput | InputJsonValue[]
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedBy?: string | null
    createdBy?: string | null
    applicable_systems?: DoctypeCreateapplicable_systemsInput | InputJsonValue[]
    users?: DoctypeCreateusersInput | InputJsonValue[]
    document_classification?: string | null
    distributionUsers?: DoctypeCreatedistributionUsersInput | InputJsonValue[]
    currentVersion: string
    distributionList?: string | null
    organization?: OrganizationCreateNestedOneWithoutDoctypeInput
    Entity?: EntityCreateNestedOneWithoutDoctypeInput
    Documents?: DocumentsCreateNestedManyWithoutDoctypeInput
    documentAdmins?: documentAdminsCreateNestedManyWithoutDoctypeInput
  }

  export type DoctypeUncheckedCreateInput = {
    id?: string
    locationId?: DoctypeCreatelocationIdInput | string[]
    documentTypeName?: string | null
    documentNumbering?: string | null
    reviewFrequency?: number | null
    revisionRemind?: number | null
    prefix?: string | null
    suffix?: string | null
    organizationId?: string | null
    readAccess?: string | null
    readAccessUsers?: DoctypeCreatereadAccessUsersInput | InputJsonValue[]
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedBy?: string | null
    createdBy?: string | null
    applicable_systems?: DoctypeCreateapplicable_systemsInput | InputJsonValue[]
    users?: DoctypeCreateusersInput | InputJsonValue[]
    document_classification?: string | null
    entityId?: string | null
    distributionUsers?: DoctypeCreatedistributionUsersInput | InputJsonValue[]
    currentVersion: string
    distributionList?: string | null
    Documents?: DocumentsUncheckedCreateNestedManyWithoutDoctypeInput
    documentAdmins?: documentAdminsUncheckedCreateNestedManyWithoutDoctypeInput
  }

  export type DoctypeUpdateInput = {
    locationId?: DoctypeUpdatelocationIdInput | string[]
    documentTypeName?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumbering?: NullableStringFieldUpdateOperationsInput | string | null
    reviewFrequency?: NullableIntFieldUpdateOperationsInput | number | null
    revisionRemind?: NullableIntFieldUpdateOperationsInput | number | null
    prefix?: NullableStringFieldUpdateOperationsInput | string | null
    suffix?: NullableStringFieldUpdateOperationsInput | string | null
    readAccess?: NullableStringFieldUpdateOperationsInput | string | null
    readAccessUsers?: DoctypeUpdatereadAccessUsersInput | InputJsonValue[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    applicable_systems?: DoctypeUpdateapplicable_systemsInput | InputJsonValue[]
    users?: DoctypeUpdateusersInput | InputJsonValue[]
    document_classification?: NullableStringFieldUpdateOperationsInput | string | null
    distributionUsers?: DoctypeUpdatedistributionUsersInput | InputJsonValue[]
    currentVersion?: StringFieldUpdateOperationsInput | string
    distributionList?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: OrganizationUpdateOneWithoutDoctypeNestedInput
    Entity?: EntityUpdateOneWithoutDoctypeNestedInput
    Documents?: DocumentsUpdateManyWithoutDoctypeNestedInput
    documentAdmins?: documentAdminsUpdateManyWithoutDoctypeNestedInput
  }

  export type DoctypeUncheckedUpdateInput = {
    locationId?: DoctypeUpdatelocationIdInput | string[]
    documentTypeName?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumbering?: NullableStringFieldUpdateOperationsInput | string | null
    reviewFrequency?: NullableIntFieldUpdateOperationsInput | number | null
    revisionRemind?: NullableIntFieldUpdateOperationsInput | number | null
    prefix?: NullableStringFieldUpdateOperationsInput | string | null
    suffix?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    readAccess?: NullableStringFieldUpdateOperationsInput | string | null
    readAccessUsers?: DoctypeUpdatereadAccessUsersInput | InputJsonValue[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    applicable_systems?: DoctypeUpdateapplicable_systemsInput | InputJsonValue[]
    users?: DoctypeUpdateusersInput | InputJsonValue[]
    document_classification?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    distributionUsers?: DoctypeUpdatedistributionUsersInput | InputJsonValue[]
    currentVersion?: StringFieldUpdateOperationsInput | string
    distributionList?: NullableStringFieldUpdateOperationsInput | string | null
    Documents?: DocumentsUncheckedUpdateManyWithoutDoctypeNestedInput
    documentAdmins?: documentAdminsUncheckedUpdateManyWithoutDoctypeNestedInput
  }

  export type DoctypeCreateManyInput = {
    id?: string
    locationId?: DoctypeCreatelocationIdInput | string[]
    documentTypeName?: string | null
    documentNumbering?: string | null
    reviewFrequency?: number | null
    revisionRemind?: number | null
    prefix?: string | null
    suffix?: string | null
    organizationId?: string | null
    readAccess?: string | null
    readAccessUsers?: DoctypeCreatereadAccessUsersInput | InputJsonValue[]
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedBy?: string | null
    createdBy?: string | null
    applicable_systems?: DoctypeCreateapplicable_systemsInput | InputJsonValue[]
    users?: DoctypeCreateusersInput | InputJsonValue[]
    document_classification?: string | null
    entityId?: string | null
    distributionUsers?: DoctypeCreatedistributionUsersInput | InputJsonValue[]
    currentVersion: string
    distributionList?: string | null
  }

  export type DoctypeUpdateManyMutationInput = {
    locationId?: DoctypeUpdatelocationIdInput | string[]
    documentTypeName?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumbering?: NullableStringFieldUpdateOperationsInput | string | null
    reviewFrequency?: NullableIntFieldUpdateOperationsInput | number | null
    revisionRemind?: NullableIntFieldUpdateOperationsInput | number | null
    prefix?: NullableStringFieldUpdateOperationsInput | string | null
    suffix?: NullableStringFieldUpdateOperationsInput | string | null
    readAccess?: NullableStringFieldUpdateOperationsInput | string | null
    readAccessUsers?: DoctypeUpdatereadAccessUsersInput | InputJsonValue[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    applicable_systems?: DoctypeUpdateapplicable_systemsInput | InputJsonValue[]
    users?: DoctypeUpdateusersInput | InputJsonValue[]
    document_classification?: NullableStringFieldUpdateOperationsInput | string | null
    distributionUsers?: DoctypeUpdatedistributionUsersInput | InputJsonValue[]
    currentVersion?: StringFieldUpdateOperationsInput | string
    distributionList?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DoctypeUncheckedUpdateManyInput = {
    locationId?: DoctypeUpdatelocationIdInput | string[]
    documentTypeName?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumbering?: NullableStringFieldUpdateOperationsInput | string | null
    reviewFrequency?: NullableIntFieldUpdateOperationsInput | number | null
    revisionRemind?: NullableIntFieldUpdateOperationsInput | number | null
    prefix?: NullableStringFieldUpdateOperationsInput | string | null
    suffix?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    readAccess?: NullableStringFieldUpdateOperationsInput | string | null
    readAccessUsers?: DoctypeUpdatereadAccessUsersInput | InputJsonValue[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    applicable_systems?: DoctypeUpdateapplicable_systemsInput | InputJsonValue[]
    users?: DoctypeUpdateusersInput | InputJsonValue[]
    document_classification?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    distributionUsers?: DoctypeUpdatedistributionUsersInput | InputJsonValue[]
    currentVersion?: StringFieldUpdateOperationsInput | string
    distributionList?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DocumentsCreateInput = {
    id?: string
    documentName?: string | null
    documentNumbering?: string | null
    reasonOfCreation?: string | null
    effectiveDate?: Date | string | null
    nextRevisionDate?: Date | string | null
    currentVersion?: string | null
    documentLink?: string | null
    description?: string | null
    tags?: DocumentsCreatetagsInput | string[]
    documentState?: string | null
    system?: DocumentsCreatesystemInput | string[]
    section?: string | null
    revertComment?: string | null
    docType?: string | null
    documentClassification?: string | null
    issueNumber?: string | null
    retireComment?: string | null
    revisionReminderFlag?: boolean | null
    isVersion?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedDate?: Date | string | null
    countNumber?: number | null
    createdBy?: string | null
    distributionList?: string | null
    documentId?: string | null
    reviewers?: DocumentsCreatereviewersInput | string[]
    approvers?: DocumentsCreateapproversInput | string[]
    creators?: DocumentsCreatecreatorsInput | string[]
    distributionUsers?: DocumentsCreatedistributionUsersInput | InputJsonValue[]
    readAccess?: string | null
    readAccessUsers?: DocumentsCreatereadAccessUsersInput | InputJsonValue[]
    versionInfo?: DocumentsCreateversionInfoInput | InputJsonValue[]
    doctype?: DoctypeCreateNestedOneWithoutDocumentsInput
    organization?: OrganizationCreateNestedOneWithoutDocumentsInput
    creatorLocation?: LocationCreateNestedOneWithoutDocumentsInput
    creatorEntity?: EntityCreateNestedOneWithoutDocumentsInput
    ReferenceDocuments?: ReferenceDocumentsCreateNestedManyWithoutDocumentInput
    DocumentVersions?: DocumentVersionsCreateNestedManyWithoutDocumentInput
    DocumentComments?: DocumentCommentsCreateNestedManyWithoutDocumentInput
    DocumentWorkFlowHistory?: DocumentWorkFlowHistoryCreateNestedManyWithoutDocumentInput
    AdditionalDocumentAdmins?: AdditionalDocumentAdminsCreateNestedManyWithoutDocumentInput
    VersionReferenceDocuments?: VersionReferenceDocumentsCreateNestedManyWithoutDocumentsInput
  }

  export type DocumentsUncheckedCreateInput = {
    id?: string
    doctypeId?: string | null
    organizationId?: string | null
    documentName?: string | null
    documentNumbering?: string | null
    reasonOfCreation?: string | null
    effectiveDate?: Date | string | null
    nextRevisionDate?: Date | string | null
    currentVersion?: string | null
    documentLink?: string | null
    description?: string | null
    tags?: DocumentsCreatetagsInput | string[]
    documentState?: string | null
    locationId: string
    entityId?: string | null
    system?: DocumentsCreatesystemInput | string[]
    section?: string | null
    revertComment?: string | null
    docType?: string | null
    documentClassification?: string | null
    issueNumber?: string | null
    retireComment?: string | null
    revisionReminderFlag?: boolean | null
    isVersion?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedDate?: Date | string | null
    countNumber?: number | null
    createdBy?: string | null
    distributionList?: string | null
    documentId?: string | null
    reviewers?: DocumentsCreatereviewersInput | string[]
    approvers?: DocumentsCreateapproversInput | string[]
    creators?: DocumentsCreatecreatorsInput | string[]
    distributionUsers?: DocumentsCreatedistributionUsersInput | InputJsonValue[]
    readAccess?: string | null
    readAccessUsers?: DocumentsCreatereadAccessUsersInput | InputJsonValue[]
    versionInfo?: DocumentsCreateversionInfoInput | InputJsonValue[]
    ReferenceDocuments?: ReferenceDocumentsUncheckedCreateNestedManyWithoutDocumentInput
    DocumentVersions?: DocumentVersionsUncheckedCreateNestedManyWithoutDocumentInput
    DocumentComments?: DocumentCommentsUncheckedCreateNestedManyWithoutDocumentInput
    DocumentWorkFlowHistory?: DocumentWorkFlowHistoryUncheckedCreateNestedManyWithoutDocumentInput
    AdditionalDocumentAdmins?: AdditionalDocumentAdminsUncheckedCreateNestedManyWithoutDocumentInput
    VersionReferenceDocuments?: VersionReferenceDocumentsUncheckedCreateNestedManyWithoutDocumentsInput
  }

  export type DocumentsUpdateInput = {
    documentName?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumbering?: NullableStringFieldUpdateOperationsInput | string | null
    reasonOfCreation?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextRevisionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentVersion?: NullableStringFieldUpdateOperationsInput | string | null
    documentLink?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: DocumentsUpdatetagsInput | string[]
    documentState?: NullableStringFieldUpdateOperationsInput | string | null
    system?: DocumentsUpdatesystemInput | string[]
    section?: NullableStringFieldUpdateOperationsInput | string | null
    revertComment?: NullableStringFieldUpdateOperationsInput | string | null
    docType?: NullableStringFieldUpdateOperationsInput | string | null
    documentClassification?: NullableStringFieldUpdateOperationsInput | string | null
    issueNumber?: NullableStringFieldUpdateOperationsInput | string | null
    retireComment?: NullableStringFieldUpdateOperationsInput | string | null
    revisionReminderFlag?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isVersion?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    countNumber?: NullableIntFieldUpdateOperationsInput | number | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    distributionList?: NullableStringFieldUpdateOperationsInput | string | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    reviewers?: DocumentsUpdatereviewersInput | string[]
    approvers?: DocumentsUpdateapproversInput | string[]
    creators?: DocumentsUpdatecreatorsInput | string[]
    distributionUsers?: DocumentsUpdatedistributionUsersInput | InputJsonValue[]
    readAccess?: NullableStringFieldUpdateOperationsInput | string | null
    readAccessUsers?: DocumentsUpdatereadAccessUsersInput | InputJsonValue[]
    versionInfo?: DocumentsUpdateversionInfoInput | InputJsonValue[]
    doctype?: DoctypeUpdateOneWithoutDocumentsNestedInput
    organization?: OrganizationUpdateOneWithoutDocumentsNestedInput
    creatorLocation?: LocationUpdateOneWithoutDocumentsNestedInput
    creatorEntity?: EntityUpdateOneWithoutDocumentsNestedInput
    ReferenceDocuments?: ReferenceDocumentsUpdateManyWithoutDocumentNestedInput
    DocumentVersions?: DocumentVersionsUpdateManyWithoutDocumentNestedInput
    DocumentComments?: DocumentCommentsUpdateManyWithoutDocumentNestedInput
    DocumentWorkFlowHistory?: DocumentWorkFlowHistoryUpdateManyWithoutDocumentNestedInput
    AdditionalDocumentAdmins?: AdditionalDocumentAdminsUpdateManyWithoutDocumentNestedInput
    VersionReferenceDocuments?: VersionReferenceDocumentsUpdateManyWithoutDocumentsNestedInput
  }

  export type DocumentsUncheckedUpdateInput = {
    doctypeId?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    documentName?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumbering?: NullableStringFieldUpdateOperationsInput | string | null
    reasonOfCreation?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextRevisionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentVersion?: NullableStringFieldUpdateOperationsInput | string | null
    documentLink?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: DocumentsUpdatetagsInput | string[]
    documentState?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    system?: DocumentsUpdatesystemInput | string[]
    section?: NullableStringFieldUpdateOperationsInput | string | null
    revertComment?: NullableStringFieldUpdateOperationsInput | string | null
    docType?: NullableStringFieldUpdateOperationsInput | string | null
    documentClassification?: NullableStringFieldUpdateOperationsInput | string | null
    issueNumber?: NullableStringFieldUpdateOperationsInput | string | null
    retireComment?: NullableStringFieldUpdateOperationsInput | string | null
    revisionReminderFlag?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isVersion?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    countNumber?: NullableIntFieldUpdateOperationsInput | number | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    distributionList?: NullableStringFieldUpdateOperationsInput | string | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    reviewers?: DocumentsUpdatereviewersInput | string[]
    approvers?: DocumentsUpdateapproversInput | string[]
    creators?: DocumentsUpdatecreatorsInput | string[]
    distributionUsers?: DocumentsUpdatedistributionUsersInput | InputJsonValue[]
    readAccess?: NullableStringFieldUpdateOperationsInput | string | null
    readAccessUsers?: DocumentsUpdatereadAccessUsersInput | InputJsonValue[]
    versionInfo?: DocumentsUpdateversionInfoInput | InputJsonValue[]
    ReferenceDocuments?: ReferenceDocumentsUncheckedUpdateManyWithoutDocumentNestedInput
    DocumentVersions?: DocumentVersionsUncheckedUpdateManyWithoutDocumentNestedInput
    DocumentComments?: DocumentCommentsUncheckedUpdateManyWithoutDocumentNestedInput
    DocumentWorkFlowHistory?: DocumentWorkFlowHistoryUncheckedUpdateManyWithoutDocumentNestedInput
    AdditionalDocumentAdmins?: AdditionalDocumentAdminsUncheckedUpdateManyWithoutDocumentNestedInput
    VersionReferenceDocuments?: VersionReferenceDocumentsUncheckedUpdateManyWithoutDocumentsNestedInput
  }

  export type DocumentsCreateManyInput = {
    id?: string
    doctypeId?: string | null
    organizationId?: string | null
    documentName?: string | null
    documentNumbering?: string | null
    reasonOfCreation?: string | null
    effectiveDate?: Date | string | null
    nextRevisionDate?: Date | string | null
    currentVersion?: string | null
    documentLink?: string | null
    description?: string | null
    tags?: DocumentsCreatetagsInput | string[]
    documentState?: string | null
    locationId: string
    entityId?: string | null
    system?: DocumentsCreatesystemInput | string[]
    section?: string | null
    revertComment?: string | null
    docType?: string | null
    documentClassification?: string | null
    issueNumber?: string | null
    retireComment?: string | null
    revisionReminderFlag?: boolean | null
    isVersion?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedDate?: Date | string | null
    countNumber?: number | null
    createdBy?: string | null
    distributionList?: string | null
    documentId?: string | null
    reviewers?: DocumentsCreatereviewersInput | string[]
    approvers?: DocumentsCreateapproversInput | string[]
    creators?: DocumentsCreatecreatorsInput | string[]
    distributionUsers?: DocumentsCreatedistributionUsersInput | InputJsonValue[]
    readAccess?: string | null
    readAccessUsers?: DocumentsCreatereadAccessUsersInput | InputJsonValue[]
    versionInfo?: DocumentsCreateversionInfoInput | InputJsonValue[]
  }

  export type DocumentsUpdateManyMutationInput = {
    documentName?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumbering?: NullableStringFieldUpdateOperationsInput | string | null
    reasonOfCreation?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextRevisionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentVersion?: NullableStringFieldUpdateOperationsInput | string | null
    documentLink?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: DocumentsUpdatetagsInput | string[]
    documentState?: NullableStringFieldUpdateOperationsInput | string | null
    system?: DocumentsUpdatesystemInput | string[]
    section?: NullableStringFieldUpdateOperationsInput | string | null
    revertComment?: NullableStringFieldUpdateOperationsInput | string | null
    docType?: NullableStringFieldUpdateOperationsInput | string | null
    documentClassification?: NullableStringFieldUpdateOperationsInput | string | null
    issueNumber?: NullableStringFieldUpdateOperationsInput | string | null
    retireComment?: NullableStringFieldUpdateOperationsInput | string | null
    revisionReminderFlag?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isVersion?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    countNumber?: NullableIntFieldUpdateOperationsInput | number | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    distributionList?: NullableStringFieldUpdateOperationsInput | string | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    reviewers?: DocumentsUpdatereviewersInput | string[]
    approvers?: DocumentsUpdateapproversInput | string[]
    creators?: DocumentsUpdatecreatorsInput | string[]
    distributionUsers?: DocumentsUpdatedistributionUsersInput | InputJsonValue[]
    readAccess?: NullableStringFieldUpdateOperationsInput | string | null
    readAccessUsers?: DocumentsUpdatereadAccessUsersInput | InputJsonValue[]
    versionInfo?: DocumentsUpdateversionInfoInput | InputJsonValue[]
  }

  export type DocumentsUncheckedUpdateManyInput = {
    doctypeId?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    documentName?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumbering?: NullableStringFieldUpdateOperationsInput | string | null
    reasonOfCreation?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextRevisionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentVersion?: NullableStringFieldUpdateOperationsInput | string | null
    documentLink?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: DocumentsUpdatetagsInput | string[]
    documentState?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    system?: DocumentsUpdatesystemInput | string[]
    section?: NullableStringFieldUpdateOperationsInput | string | null
    revertComment?: NullableStringFieldUpdateOperationsInput | string | null
    docType?: NullableStringFieldUpdateOperationsInput | string | null
    documentClassification?: NullableStringFieldUpdateOperationsInput | string | null
    issueNumber?: NullableStringFieldUpdateOperationsInput | string | null
    retireComment?: NullableStringFieldUpdateOperationsInput | string | null
    revisionReminderFlag?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isVersion?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    countNumber?: NullableIntFieldUpdateOperationsInput | number | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    distributionList?: NullableStringFieldUpdateOperationsInput | string | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    reviewers?: DocumentsUpdatereviewersInput | string[]
    approvers?: DocumentsUpdateapproversInput | string[]
    creators?: DocumentsUpdatecreatorsInput | string[]
    distributionUsers?: DocumentsUpdatedistributionUsersInput | InputJsonValue[]
    readAccess?: NullableStringFieldUpdateOperationsInput | string | null
    readAccessUsers?: DocumentsUpdatereadAccessUsersInput | InputJsonValue[]
    versionInfo?: DocumentsUpdateversionInfoInput | InputJsonValue[]
  }

  export type documentAttachmentHistoryCreateInput = {
    id?: string
    documentId?: string | null
    updatedLink?: string | null
    updatedBy?: string | null
    updatedAt?: Date | string
  }

  export type documentAttachmentHistoryUncheckedCreateInput = {
    id?: string
    documentId?: string | null
    updatedLink?: string | null
    updatedBy?: string | null
    updatedAt?: Date | string
  }

  export type documentAttachmentHistoryUpdateInput = {
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedLink?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type documentAttachmentHistoryUncheckedUpdateInput = {
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedLink?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type documentAttachmentHistoryCreateManyInput = {
    id?: string
    documentId?: string | null
    updatedLink?: string | null
    updatedBy?: string | null
    updatedAt?: Date | string
  }

  export type documentAttachmentHistoryUpdateManyMutationInput = {
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedLink?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type documentAttachmentHistoryUncheckedUpdateManyInput = {
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedLink?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferenceDocumentsCreateInput = {
    id?: string
    documentLink?: string | null
    type?: string | null
    documentName?: string | null
    version?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    referenceDocId?: string | null
    document?: DocumentsCreateNestedOneWithoutReferenceDocumentsInput
    versionsLinkedWith?: DocumentVersionsCreateNestedOneWithoutReferenceDocumentsInput
  }

  export type ReferenceDocumentsUncheckedCreateInput = {
    id?: string
    documentLink?: string | null
    type?: string | null
    documentName?: string | null
    version?: string | null
    documentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    referenceDocId?: string | null
    versionId?: string | null
  }

  export type ReferenceDocumentsUpdateInput = {
    documentLink?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    documentName?: NullableStringFieldUpdateOperationsInput | string | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referenceDocId?: NullableStringFieldUpdateOperationsInput | string | null
    document?: DocumentsUpdateOneWithoutReferenceDocumentsNestedInput
    versionsLinkedWith?: DocumentVersionsUpdateOneWithoutReferenceDocumentsNestedInput
  }

  export type ReferenceDocumentsUncheckedUpdateInput = {
    documentLink?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    documentName?: NullableStringFieldUpdateOperationsInput | string | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referenceDocId?: NullableStringFieldUpdateOperationsInput | string | null
    versionId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReferenceDocumentsCreateManyInput = {
    id?: string
    documentLink?: string | null
    type?: string | null
    documentName?: string | null
    version?: string | null
    documentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    referenceDocId?: string | null
    versionId?: string | null
  }

  export type ReferenceDocumentsUpdateManyMutationInput = {
    documentLink?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    documentName?: NullableStringFieldUpdateOperationsInput | string | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referenceDocId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReferenceDocumentsUncheckedUpdateManyInput = {
    documentLink?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    documentName?: NullableStringFieldUpdateOperationsInput | string | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referenceDocId?: NullableStringFieldUpdateOperationsInput | string | null
    versionId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VersionReferenceDocumentsCreateInput = {
    id?: string
    documentLink?: string | null
    type?: string | null
    documentName?: string | null
    version?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    referenceDocId?: string | null
    Documents?: DocumentsCreateNestedOneWithoutVersionReferenceDocumentsInput
    versionsLinkedWith?: DocumentVersionsCreateNestedOneWithoutVersionReferenceDocumentsInput
  }

  export type VersionReferenceDocumentsUncheckedCreateInput = {
    id?: string
    documentLink?: string | null
    type?: string | null
    documentName?: string | null
    version?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    referenceDocId?: string | null
    versionId?: string | null
    documentsId?: string | null
  }

  export type VersionReferenceDocumentsUpdateInput = {
    documentLink?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    documentName?: NullableStringFieldUpdateOperationsInput | string | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referenceDocId?: NullableStringFieldUpdateOperationsInput | string | null
    Documents?: DocumentsUpdateOneWithoutVersionReferenceDocumentsNestedInput
    versionsLinkedWith?: DocumentVersionsUpdateOneWithoutVersionReferenceDocumentsNestedInput
  }

  export type VersionReferenceDocumentsUncheckedUpdateInput = {
    documentLink?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    documentName?: NullableStringFieldUpdateOperationsInput | string | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referenceDocId?: NullableStringFieldUpdateOperationsInput | string | null
    versionId?: NullableStringFieldUpdateOperationsInput | string | null
    documentsId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VersionReferenceDocumentsCreateManyInput = {
    id?: string
    documentLink?: string | null
    type?: string | null
    documentName?: string | null
    version?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    referenceDocId?: string | null
    versionId?: string | null
    documentsId?: string | null
  }

  export type VersionReferenceDocumentsUpdateManyMutationInput = {
    documentLink?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    documentName?: NullableStringFieldUpdateOperationsInput | string | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referenceDocId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VersionReferenceDocumentsUncheckedUpdateManyInput = {
    documentLink?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    documentName?: NullableStringFieldUpdateOperationsInput | string | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referenceDocId?: NullableStringFieldUpdateOperationsInput | string | null
    versionId?: NullableStringFieldUpdateOperationsInput | string | null
    documentsId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DocumentVersionsCreateInput = {
    id?: string
    versionName: string
    by?: string | null
    approvedDate?: Date | string | null
    versionLink: string
    createdAt?: Date | string
    updatedAt?: Date | string
    documentName?: string | null
    documentNumbering?: string | null
    reasonOfCreation?: string | null
    effectiveDate?: Date | string | null
    description?: string | null
    issueNumber?: string | null
    document?: DocumentsCreateNestedOneWithoutDocumentVersionsInput
    user?: UserCreateNestedOneWithoutDocumentVersionsInput
    ReferenceDocuments?: ReferenceDocumentsCreateNestedManyWithoutVersionsLinkedWithInput
    VersionReferenceDocuments?: VersionReferenceDocumentsCreateNestedManyWithoutVersionsLinkedWithInput
  }

  export type DocumentVersionsUncheckedCreateInput = {
    id?: string
    versionName: string
    userId?: string | null
    by?: string | null
    approvedDate?: Date | string | null
    versionLink: string
    documentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    documentName?: string | null
    documentNumbering?: string | null
    reasonOfCreation?: string | null
    effectiveDate?: Date | string | null
    description?: string | null
    issueNumber?: string | null
    ReferenceDocuments?: ReferenceDocumentsUncheckedCreateNestedManyWithoutVersionsLinkedWithInput
    VersionReferenceDocuments?: VersionReferenceDocumentsUncheckedCreateNestedManyWithoutVersionsLinkedWithInput
  }

  export type DocumentVersionsUpdateInput = {
    versionName?: StringFieldUpdateOperationsInput | string
    by?: NullableStringFieldUpdateOperationsInput | string | null
    approvedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    versionLink?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documentName?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumbering?: NullableStringFieldUpdateOperationsInput | string | null
    reasonOfCreation?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    issueNumber?: NullableStringFieldUpdateOperationsInput | string | null
    document?: DocumentsUpdateOneWithoutDocumentVersionsNestedInput
    user?: UserUpdateOneWithoutDocumentVersionsNestedInput
    ReferenceDocuments?: ReferenceDocumentsUpdateManyWithoutVersionsLinkedWithNestedInput
    VersionReferenceDocuments?: VersionReferenceDocumentsUpdateManyWithoutVersionsLinkedWithNestedInput
  }

  export type DocumentVersionsUncheckedUpdateInput = {
    versionName?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    by?: NullableStringFieldUpdateOperationsInput | string | null
    approvedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    versionLink?: StringFieldUpdateOperationsInput | string
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documentName?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumbering?: NullableStringFieldUpdateOperationsInput | string | null
    reasonOfCreation?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    issueNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ReferenceDocuments?: ReferenceDocumentsUncheckedUpdateManyWithoutVersionsLinkedWithNestedInput
    VersionReferenceDocuments?: VersionReferenceDocumentsUncheckedUpdateManyWithoutVersionsLinkedWithNestedInput
  }

  export type DocumentVersionsCreateManyInput = {
    id?: string
    versionName: string
    userId?: string | null
    by?: string | null
    approvedDate?: Date | string | null
    versionLink: string
    documentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    documentName?: string | null
    documentNumbering?: string | null
    reasonOfCreation?: string | null
    effectiveDate?: Date | string | null
    description?: string | null
    issueNumber?: string | null
  }

  export type DocumentVersionsUpdateManyMutationInput = {
    versionName?: StringFieldUpdateOperationsInput | string
    by?: NullableStringFieldUpdateOperationsInput | string | null
    approvedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    versionLink?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documentName?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumbering?: NullableStringFieldUpdateOperationsInput | string | null
    reasonOfCreation?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    issueNumber?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DocumentVersionsUncheckedUpdateManyInput = {
    versionName?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    by?: NullableStringFieldUpdateOperationsInput | string | null
    approvedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    versionLink?: StringFieldUpdateOperationsInput | string
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documentName?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumbering?: NullableStringFieldUpdateOperationsInput | string | null
    reasonOfCreation?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    issueNumber?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DocumentCommentsCreateInput = {
    id?: string
    commentBy?: string | null
    commentText: string
    createdAt?: Date | string
    updatedAt?: Date | string
    document?: DocumentsCreateNestedOneWithoutDocumentCommentsInput
    user?: UserCreateNestedOneWithoutDocumentCommentsInput
  }

  export type DocumentCommentsUncheckedCreateInput = {
    id?: string
    userId?: string | null
    commentBy?: string | null
    commentText: string
    documentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentCommentsUpdateInput = {
    commentBy?: NullableStringFieldUpdateOperationsInput | string | null
    commentText?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    document?: DocumentsUpdateOneWithoutDocumentCommentsNestedInput
    user?: UserUpdateOneWithoutDocumentCommentsNestedInput
  }

  export type DocumentCommentsUncheckedUpdateInput = {
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    commentBy?: NullableStringFieldUpdateOperationsInput | string | null
    commentText?: StringFieldUpdateOperationsInput | string
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentCommentsCreateManyInput = {
    id?: string
    userId?: string | null
    commentBy?: string | null
    commentText: string
    documentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentCommentsUpdateManyMutationInput = {
    commentBy?: NullableStringFieldUpdateOperationsInput | string | null
    commentText?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentCommentsUncheckedUpdateManyInput = {
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    commentBy?: NullableStringFieldUpdateOperationsInput | string | null
    commentText?: StringFieldUpdateOperationsInput | string
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentWorkFlowHistoryCreateInput = {
    id?: string
    actionName: string
    actionBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    document?: DocumentsCreateNestedOneWithoutDocumentWorkFlowHistoryInput
    user?: UserCreateNestedOneWithoutDocumentWorkFlowHistoryInput
  }

  export type DocumentWorkFlowHistoryUncheckedCreateInput = {
    id?: string
    actionName: string
    userId?: string | null
    actionBy?: string | null
    documentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentWorkFlowHistoryUpdateInput = {
    actionName?: StringFieldUpdateOperationsInput | string
    actionBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    document?: DocumentsUpdateOneWithoutDocumentWorkFlowHistoryNestedInput
    user?: UserUpdateOneWithoutDocumentWorkFlowHistoryNestedInput
  }

  export type DocumentWorkFlowHistoryUncheckedUpdateInput = {
    actionName?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    actionBy?: NullableStringFieldUpdateOperationsInput | string | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentWorkFlowHistoryCreateManyInput = {
    id?: string
    actionName: string
    userId?: string | null
    actionBy?: string | null
    documentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentWorkFlowHistoryUpdateManyMutationInput = {
    actionName?: StringFieldUpdateOperationsInput | string
    actionBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentWorkFlowHistoryUncheckedUpdateManyInput = {
    actionName?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    actionBy?: NullableStringFieldUpdateOperationsInput | string | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type documentAdminsCreateInput = {
    id?: string
    type: string
    firstname: string
    lastname: string
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
    doctype?: DoctypeCreateNestedOneWithoutDocumentAdminsInput
    user: UserCreateNestedOneWithoutDocumentAdminsInput
  }

  export type documentAdminsUncheckedCreateInput = {
    id?: string
    type: string
    firstname: string
    lastname: string
    email: string
    userId: string
    doctypeId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type documentAdminsUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doctype?: DoctypeUpdateOneWithoutDocumentAdminsNestedInput
    user?: UserUpdateOneRequiredWithoutDocumentAdminsNestedInput
  }

  export type documentAdminsUncheckedUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    doctypeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type documentAdminsCreateManyInput = {
    id?: string
    type: string
    firstname: string
    lastname: string
    email: string
    userId: string
    doctypeId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type documentAdminsUpdateManyMutationInput = {
    type?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type documentAdminsUncheckedUpdateManyInput = {
    type?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    doctypeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdditionalDocumentAdminsCreateInput = {
    id?: string
    type: string
    firstname: string
    lastname: string
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
    document?: DocumentsCreateNestedOneWithoutAdditionalDocumentAdminsInput
    user: UserCreateNestedOneWithoutAdditionalDocumentAdminsInput
  }

  export type AdditionalDocumentAdminsUncheckedCreateInput = {
    id?: string
    type: string
    firstname: string
    lastname: string
    email: string
    userId: string
    documentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdditionalDocumentAdminsUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    document?: DocumentsUpdateOneWithoutAdditionalDocumentAdminsNestedInput
    user?: UserUpdateOneRequiredWithoutAdditionalDocumentAdminsNestedInput
  }

  export type AdditionalDocumentAdminsUncheckedUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdditionalDocumentAdminsCreateManyInput = {
    id?: string
    type: string
    firstname: string
    lastname: string
    email: string
    userId: string
    documentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdditionalDocumentAdminsUpdateManyMutationInput = {
    type?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdditionalDocumentAdminsUncheckedUpdateManyInput = {
    type?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogsCreateInput = {
    id?: string
    action: string
    resource: string
    type: string
    additionalDetails: InputJsonValue
    user: UserCreateNestedOneWithoutLogsInput
  }

  export type LogsUncheckedCreateInput = {
    id?: string
    userId: string
    action: string
    resource: string
    type: string
    additionalDetails: InputJsonValue
  }

  export type LogsUpdateInput = {
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    additionalDetails?: InputJsonValue | InputJsonValue
    user?: UserUpdateOneRequiredWithoutLogsNestedInput
  }

  export type LogsUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    additionalDetails?: InputJsonValue | InputJsonValue
  }

  export type LogsCreateManyInput = {
    id?: string
    userId: string
    action: string
    resource: string
    type: string
    additionalDetails: InputJsonValue
  }

  export type LogsUpdateManyMutationInput = {
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    additionalDetails?: InputJsonValue | InputJsonValue
  }

  export type LogsUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    additionalDetails?: InputJsonValue | InputJsonValue
  }

  export type userPersonalisationCreateInput = {
    id?: string
    targetObject: string
    targetObjectId?: userPersonalisationCreatetargetObjectIdInput | string[]
    Organization?: OrganizationCreateNestedOneWithoutUserPersonalisationInput
    user: UserCreateNestedOneWithoutUserPersonalisationInput
  }

  export type userPersonalisationUncheckedCreateInput = {
    id?: string
    userId: string
    organizationId?: string | null
    targetObject: string
    targetObjectId?: userPersonalisationCreatetargetObjectIdInput | string[]
  }

  export type userPersonalisationUpdateInput = {
    targetObject?: StringFieldUpdateOperationsInput | string
    targetObjectId?: userPersonalisationUpdatetargetObjectIdInput | string[]
    Organization?: OrganizationUpdateOneWithoutUserPersonalisationNestedInput
    user?: UserUpdateOneRequiredWithoutUserPersonalisationNestedInput
  }

  export type userPersonalisationUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    targetObject?: StringFieldUpdateOperationsInput | string
    targetObjectId?: userPersonalisationUpdatetargetObjectIdInput | string[]
  }

  export type userPersonalisationCreateManyInput = {
    id?: string
    userId: string
    organizationId?: string | null
    targetObject: string
    targetObjectId?: userPersonalisationCreatetargetObjectIdInput | string[]
  }

  export type userPersonalisationUpdateManyMutationInput = {
    targetObject?: StringFieldUpdateOperationsInput | string
    targetObjectId?: userPersonalisationUpdatetargetObjectIdInput | string[]
  }

  export type userPersonalisationUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    targetObject?: StringFieldUpdateOperationsInput | string
    targetObjectId?: userPersonalisationUpdatetargetObjectIdInput | string[]
  }

  export type ConnectedAppsCreateInput = {
    id?: string
    sourceName: string
    clientId: string
    clientSecret: string
    baseURL: string
    user?: string | null
    password?: string | null
    redirectURL?: string | null
    grantType?: string | null
    description: string
    deleted?: boolean | null
    createdModifiedBy: string
    createdModifiedAt?: Date | string
    locationId?: ConnectedAppsCreatelocationIdInput | string[]
    Status: boolean
    organization?: OrganizationCreateNestedOneWithoutConnectedAppsInput
    uom?: unitTypeCreateNestedManyWithoutConnectedAppsInput
    kpi?: kpiCreateNestedManyWithoutConnectedAppsInput
  }

  export type ConnectedAppsUncheckedCreateInput = {
    id?: string
    sourceName: string
    clientId: string
    clientSecret: string
    baseURL: string
    user?: string | null
    password?: string | null
    redirectURL?: string | null
    grantType?: string | null
    description: string
    deleted?: boolean | null
    organizationId?: string | null
    createdModifiedBy: string
    createdModifiedAt?: Date | string
    locationId?: ConnectedAppsCreatelocationIdInput | string[]
    Status: boolean
    uom?: unitTypeUncheckedCreateNestedManyWithoutConnectedAppsInput
    kpi?: kpiUncheckedCreateNestedManyWithoutConnectedAppsInput
  }

  export type ConnectedAppsUpdateInput = {
    sourceName?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    clientSecret?: StringFieldUpdateOperationsInput | string
    baseURL?: StringFieldUpdateOperationsInput | string
    user?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    redirectURL?: NullableStringFieldUpdateOperationsInput | string | null
    grantType?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdModifiedBy?: StringFieldUpdateOperationsInput | string
    createdModifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locationId?: ConnectedAppsUpdatelocationIdInput | string[]
    Status?: BoolFieldUpdateOperationsInput | boolean
    organization?: OrganizationUpdateOneWithoutConnectedAppsNestedInput
    uom?: unitTypeUpdateManyWithoutConnectedAppsNestedInput
    kpi?: kpiUpdateManyWithoutConnectedAppsNestedInput
  }

  export type ConnectedAppsUncheckedUpdateInput = {
    sourceName?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    clientSecret?: StringFieldUpdateOperationsInput | string
    baseURL?: StringFieldUpdateOperationsInput | string
    user?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    redirectURL?: NullableStringFieldUpdateOperationsInput | string | null
    grantType?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdModifiedBy?: StringFieldUpdateOperationsInput | string
    createdModifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locationId?: ConnectedAppsUpdatelocationIdInput | string[]
    Status?: BoolFieldUpdateOperationsInput | boolean
    uom?: unitTypeUncheckedUpdateManyWithoutConnectedAppsNestedInput
    kpi?: kpiUncheckedUpdateManyWithoutConnectedAppsNestedInput
  }

  export type ConnectedAppsCreateManyInput = {
    id?: string
    sourceName: string
    clientId: string
    clientSecret: string
    baseURL: string
    user?: string | null
    password?: string | null
    redirectURL?: string | null
    grantType?: string | null
    description: string
    deleted?: boolean | null
    organizationId?: string | null
    createdModifiedBy: string
    createdModifiedAt?: Date | string
    locationId?: ConnectedAppsCreatelocationIdInput | string[]
    Status: boolean
  }

  export type ConnectedAppsUpdateManyMutationInput = {
    sourceName?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    clientSecret?: StringFieldUpdateOperationsInput | string
    baseURL?: StringFieldUpdateOperationsInput | string
    user?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    redirectURL?: NullableStringFieldUpdateOperationsInput | string | null
    grantType?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdModifiedBy?: StringFieldUpdateOperationsInput | string
    createdModifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locationId?: ConnectedAppsUpdatelocationIdInput | string[]
    Status?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ConnectedAppsUncheckedUpdateManyInput = {
    sourceName?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    clientSecret?: StringFieldUpdateOperationsInput | string
    baseURL?: StringFieldUpdateOperationsInput | string
    user?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    redirectURL?: NullableStringFieldUpdateOperationsInput | string | null
    grantType?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdModifiedBy?: StringFieldUpdateOperationsInput | string
    createdModifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locationId?: ConnectedAppsUpdatelocationIdInput | string[]
    Status?: BoolFieldUpdateOperationsInput | boolean
  }

  export type unitTypeCreateInput = {
    id?: string
    unitType: string
    unitOfMeasurement?: unitTypeCreateunitOfMeasurementInput | string[]
    deleted?: boolean | null
    createdModifiedBy: string
    createdModifiedAt?: Date | string
    kpi?: kpiCreateNestedManyWithoutUnitTypeInput
    organization?: OrganizationCreateNestedOneWithoutUnitOfMeasurementInput
    location?: LocationCreateNestedOneWithoutUomInput
    ConnectedApps?: ConnectedAppsCreateNestedOneWithoutUomInput
  }

  export type unitTypeUncheckedCreateInput = {
    id?: string
    unitType: string
    unitOfMeasurement?: unitTypeCreateunitOfMeasurementInput | string[]
    organizationId?: string | null
    locationId?: string | null
    deleted?: boolean | null
    createdModifiedBy: string
    createdModifiedAt?: Date | string
    connectedAppsId?: string | null
    kpi?: kpiUncheckedCreateNestedManyWithoutUnitTypeInput
  }

  export type unitTypeUpdateInput = {
    unitType?: StringFieldUpdateOperationsInput | string
    unitOfMeasurement?: unitTypeUpdateunitOfMeasurementInput | string[]
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdModifiedBy?: StringFieldUpdateOperationsInput | string
    createdModifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kpi?: kpiUpdateManyWithoutUnitTypeNestedInput
    organization?: OrganizationUpdateOneWithoutUnitOfMeasurementNestedInput
    location?: LocationUpdateOneWithoutUomNestedInput
    ConnectedApps?: ConnectedAppsUpdateOneWithoutUomNestedInput
  }

  export type unitTypeUncheckedUpdateInput = {
    unitType?: StringFieldUpdateOperationsInput | string
    unitOfMeasurement?: unitTypeUpdateunitOfMeasurementInput | string[]
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdModifiedBy?: StringFieldUpdateOperationsInput | string
    createdModifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    connectedAppsId?: NullableStringFieldUpdateOperationsInput | string | null
    kpi?: kpiUncheckedUpdateManyWithoutUnitTypeNestedInput
  }

  export type unitTypeCreateManyInput = {
    id?: string
    unitType: string
    unitOfMeasurement?: unitTypeCreateunitOfMeasurementInput | string[]
    organizationId?: string | null
    locationId?: string | null
    deleted?: boolean | null
    createdModifiedBy: string
    createdModifiedAt?: Date | string
    connectedAppsId?: string | null
  }

  export type unitTypeUpdateManyMutationInput = {
    unitType?: StringFieldUpdateOperationsInput | string
    unitOfMeasurement?: unitTypeUpdateunitOfMeasurementInput | string[]
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdModifiedBy?: StringFieldUpdateOperationsInput | string
    createdModifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type unitTypeUncheckedUpdateManyInput = {
    unitType?: StringFieldUpdateOperationsInput | string
    unitOfMeasurement?: unitTypeUpdateunitOfMeasurementInput | string[]
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdModifiedBy?: StringFieldUpdateOperationsInput | string
    createdModifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    connectedAppsId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type kpiCreateInput = {
    id?: string
    kpiName: string
    kpiType?: string | null
    keyFields?: kpiCreatekeyFieldsInput | string[]
    uom: string
    status: boolean
    apiEndPoint?: string | null
    kpiDescription?: string | null
    kpiTargetType?: boolean | null
    locationId?: kpiCreatelocationIdInput | string[]
    createdModifiedBy: string
    createdModifiedAt?: Date | string
    unitType?: unitTypeCreateNestedOneWithoutKpiInput
    ConnectedApps?: ConnectedAppsCreateNestedOneWithoutKpiInput
    organization?: OrganizationCreateNestedOneWithoutKpiInput
  }

  export type kpiUncheckedCreateInput = {
    id?: string
    kpiName: string
    kpiType?: string | null
    keyFields?: kpiCreatekeyFieldsInput | string[]
    unitTypeId?: string | null
    uom: string
    sourceId?: string | null
    status: boolean
    apiEndPoint?: string | null
    kpiDescription?: string | null
    kpiTargetType?: boolean | null
    organizationId?: string | null
    locationId?: kpiCreatelocationIdInput | string[]
    createdModifiedBy: string
    createdModifiedAt?: Date | string
  }

  export type kpiUpdateInput = {
    kpiName?: StringFieldUpdateOperationsInput | string
    kpiType?: NullableStringFieldUpdateOperationsInput | string | null
    keyFields?: kpiUpdatekeyFieldsInput | string[]
    uom?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    apiEndPoint?: NullableStringFieldUpdateOperationsInput | string | null
    kpiDescription?: NullableStringFieldUpdateOperationsInput | string | null
    kpiTargetType?: NullableBoolFieldUpdateOperationsInput | boolean | null
    locationId?: kpiUpdatelocationIdInput | string[]
    createdModifiedBy?: StringFieldUpdateOperationsInput | string
    createdModifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    unitType?: unitTypeUpdateOneWithoutKpiNestedInput
    ConnectedApps?: ConnectedAppsUpdateOneWithoutKpiNestedInput
    organization?: OrganizationUpdateOneWithoutKpiNestedInput
  }

  export type kpiUncheckedUpdateInput = {
    kpiName?: StringFieldUpdateOperationsInput | string
    kpiType?: NullableStringFieldUpdateOperationsInput | string | null
    keyFields?: kpiUpdatekeyFieldsInput | string[]
    unitTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    uom?: StringFieldUpdateOperationsInput | string
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    apiEndPoint?: NullableStringFieldUpdateOperationsInput | string | null
    kpiDescription?: NullableStringFieldUpdateOperationsInput | string | null
    kpiTargetType?: NullableBoolFieldUpdateOperationsInput | boolean | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: kpiUpdatelocationIdInput | string[]
    createdModifiedBy?: StringFieldUpdateOperationsInput | string
    createdModifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type kpiCreateManyInput = {
    id?: string
    kpiName: string
    kpiType?: string | null
    keyFields?: kpiCreatekeyFieldsInput | string[]
    unitTypeId?: string | null
    uom: string
    sourceId?: string | null
    status: boolean
    apiEndPoint?: string | null
    kpiDescription?: string | null
    kpiTargetType?: boolean | null
    organizationId?: string | null
    locationId?: kpiCreatelocationIdInput | string[]
    createdModifiedBy: string
    createdModifiedAt?: Date | string
  }

  export type kpiUpdateManyMutationInput = {
    kpiName?: StringFieldUpdateOperationsInput | string
    kpiType?: NullableStringFieldUpdateOperationsInput | string | null
    keyFields?: kpiUpdatekeyFieldsInput | string[]
    uom?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    apiEndPoint?: NullableStringFieldUpdateOperationsInput | string | null
    kpiDescription?: NullableStringFieldUpdateOperationsInput | string | null
    kpiTargetType?: NullableBoolFieldUpdateOperationsInput | boolean | null
    locationId?: kpiUpdatelocationIdInput | string[]
    createdModifiedBy?: StringFieldUpdateOperationsInput | string
    createdModifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type kpiUncheckedUpdateManyInput = {
    kpiName?: StringFieldUpdateOperationsInput | string
    kpiType?: NullableStringFieldUpdateOperationsInput | string | null
    keyFields?: kpiUpdatekeyFieldsInput | string[]
    unitTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    uom?: StringFieldUpdateOperationsInput | string
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    apiEndPoint?: NullableStringFieldUpdateOperationsInput | string | null
    kpiDescription?: NullableStringFieldUpdateOperationsInput | string | null
    kpiTargetType?: NullableBoolFieldUpdateOperationsInput | boolean | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: kpiUpdatelocationIdInput | string[]
    createdModifiedBy?: StringFieldUpdateOperationsInput | string
    createdModifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type auditTrialCreateInput = {
    id?: string
    moduleType?: string | null
    actionType?: string | null
    transactionId?: string | null
    actionDate?: Date | string | null
    user?: UserCreateNestedOneWithoutAuditTrialInput
  }

  export type auditTrialUncheckedCreateInput = {
    id?: string
    moduleType?: string | null
    actionType?: string | null
    transactionId?: string | null
    actionBy?: string | null
    actionDate?: Date | string | null
  }

  export type auditTrialUpdateInput = {
    moduleType?: NullableStringFieldUpdateOperationsInput | string | null
    actionType?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    actionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneWithoutAuditTrialNestedInput
  }

  export type auditTrialUncheckedUpdateInput = {
    moduleType?: NullableStringFieldUpdateOperationsInput | string | null
    actionType?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    actionBy?: NullableStringFieldUpdateOperationsInput | string | null
    actionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type auditTrialCreateManyInput = {
    id?: string
    moduleType?: string | null
    actionType?: string | null
    transactionId?: string | null
    actionBy?: string | null
    actionDate?: Date | string | null
  }

  export type auditTrialUpdateManyMutationInput = {
    moduleType?: NullableStringFieldUpdateOperationsInput | string | null
    actionType?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    actionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type auditTrialUncheckedUpdateManyInput = {
    moduleType?: NullableStringFieldUpdateOperationsInput | string | null
    actionType?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    actionBy?: NullableStringFieldUpdateOperationsInput | string | null
    actionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type prefixSuffixCreateInput = {
    id?: string
    prefix?: string | null
    suffix?: string | null
    moduleType?: string | null
    location?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    organization?: OrganizationCreateNestedOneWithoutPrefixSuffixInput
  }

  export type prefixSuffixUncheckedCreateInput = {
    id?: string
    prefix?: string | null
    suffix?: string | null
    moduleType?: string | null
    location?: string | null
    organizationId?: string | null
    createdBy?: string | null
    createdAt?: Date | string
  }

  export type prefixSuffixUpdateInput = {
    prefix?: NullableStringFieldUpdateOperationsInput | string | null
    suffix?: NullableStringFieldUpdateOperationsInput | string | null
    moduleType?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneWithoutPrefixSuffixNestedInput
  }

  export type prefixSuffixUncheckedUpdateInput = {
    prefix?: NullableStringFieldUpdateOperationsInput | string | null
    suffix?: NullableStringFieldUpdateOperationsInput | string | null
    moduleType?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type prefixSuffixCreateManyInput = {
    id?: string
    prefix?: string | null
    suffix?: string | null
    moduleType?: string | null
    location?: string | null
    organizationId?: string | null
    createdBy?: string | null
    createdAt?: Date | string
  }

  export type prefixSuffixUpdateManyMutationInput = {
    prefix?: NullableStringFieldUpdateOperationsInput | string | null
    suffix?: NullableStringFieldUpdateOperationsInput | string | null
    moduleType?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type prefixSuffixUncheckedUpdateManyInput = {
    prefix?: NullableStringFieldUpdateOperationsInput | string | null
    suffix?: NullableStringFieldUpdateOperationsInput | string | null
    moduleType?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type serialNumberCreateInput = {
    id?: string
    moduleType?: string | null
    location?: string | null
    entity?: string | null
    year?: string | null
    tid?: string | null
    serialNumber?: number
    createdBy?: string | null
    createdAt?: Date | string
    organization?: OrganizationCreateNestedOneWithoutSerialNumberInput
  }

  export type serialNumberUncheckedCreateInput = {
    id?: string
    moduleType?: string | null
    location?: string | null
    entity?: string | null
    year?: string | null
    tid?: string | null
    serialNumber?: number
    createdBy?: string | null
    createdAt?: Date | string
    organizationId?: string | null
  }

  export type serialNumberUpdateInput = {
    moduleType?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    entity?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    tid?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: IntFieldUpdateOperationsInput | number
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneWithoutSerialNumberNestedInput
  }

  export type serialNumberUncheckedUpdateInput = {
    moduleType?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    entity?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    tid?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: IntFieldUpdateOperationsInput | number
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type serialNumberCreateManyInput = {
    id?: string
    moduleType?: string | null
    location?: string | null
    entity?: string | null
    year?: string | null
    tid?: string | null
    serialNumber?: number
    createdBy?: string | null
    createdAt?: Date | string
    organizationId?: string | null
  }

  export type serialNumberUpdateManyMutationInput = {
    moduleType?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    entity?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    tid?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: IntFieldUpdateOperationsInput | number
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type serialNumberUncheckedUpdateManyInput = {
    moduleType?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    entity?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    tid?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: IntFieldUpdateOperationsInput | number
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type rolesTableCreateInput = {
    id?: string
    users?: rolesTableCreateusersInput | string[]
    roleId?: rolesTableCreateroleIdInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutRolesTableInput
    location: LocationCreateNestedOneWithoutRolesTableInput
  }

  export type rolesTableUncheckedCreateInput = {
    id?: string
    orgId: string
    unitId: string
    users?: rolesTableCreateusersInput | string[]
    roleId?: rolesTableCreateroleIdInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type rolesTableUpdateInput = {
    users?: rolesTableUpdateusersInput | string[]
    roleId?: rolesTableUpdateroleIdInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutRolesTableNestedInput
    location?: LocationUpdateOneRequiredWithoutRolesTableNestedInput
  }

  export type rolesTableUncheckedUpdateInput = {
    orgId?: StringFieldUpdateOperationsInput | string
    unitId?: StringFieldUpdateOperationsInput | string
    users?: rolesTableUpdateusersInput | string[]
    roleId?: rolesTableUpdateroleIdInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type rolesTableCreateManyInput = {
    id?: string
    orgId: string
    unitId: string
    users?: rolesTableCreateusersInput | string[]
    roleId?: rolesTableCreateroleIdInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type rolesTableUpdateManyMutationInput = {
    users?: rolesTableUpdateusersInput | string[]
    roleId?: rolesTableUpdateroleIdInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type rolesTableUncheckedUpdateManyInput = {
    orgId?: StringFieldUpdateOperationsInput | string
    unitId?: StringFieldUpdateOperationsInput | string
    users?: rolesTableUpdateusersInput | string[]
    roleId?: rolesTableUpdateroleIdInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
    isSet?: boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
    isSet?: boolean
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    isSet?: boolean
  }

  export type EntityNullableRelationFilter = {
    is?: EntityWhereInput | null
    isNot?: EntityWhereInput | null
  }

  export type LocationNullableRelationFilter = {
    is?: LocationWhereInput | null
    isNot?: LocationWhereInput | null
  }

  export type OrganizationNullableRelationFilter = {
    is?: OrganizationWhereInput | null
    isNot?: OrganizationWhereInput | null
  }

  export type AdditionalDocumentAdminsListRelationFilter = {
    every?: AdditionalDocumentAdminsWhereInput
    some?: AdditionalDocumentAdminsWhereInput
    none?: AdditionalDocumentAdminsWhereInput
  }

  export type DocumentCommentsListRelationFilter = {
    every?: DocumentCommentsWhereInput
    some?: DocumentCommentsWhereInput
    none?: DocumentCommentsWhereInput
  }

  export type DocumentVersionsListRelationFilter = {
    every?: DocumentVersionsWhereInput
    some?: DocumentVersionsWhereInput
    none?: DocumentVersionsWhereInput
  }

  export type DocumentWorkFlowHistoryListRelationFilter = {
    every?: DocumentWorkFlowHistoryWhereInput
    some?: DocumentWorkFlowHistoryWhereInput
    none?: DocumentWorkFlowHistoryWhereInput
  }

  export type LogsListRelationFilter = {
    every?: LogsWhereInput
    some?: LogsWhereInput
    none?: LogsWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type DocumentAdminsListRelationFilter = {
    every?: documentAdminsWhereInput
    some?: documentAdminsWhereInput
    none?: documentAdminsWhereInput
  }

  export type UserPersonalisationListRelationFilter = {
    every?: userPersonalisationWhereInput
    some?: userPersonalisationWhereInput
    none?: userPersonalisationWhereInput
  }

  export type AuditTrialListRelationFilter = {
    every?: auditTrialWhereInput
    some?: auditTrialWhereInput
    none?: auditTrialWhereInput
  }

  export type AdditionalDocumentAdminsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DocumentCommentsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DocumentVersionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DocumentWorkFlowHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LogsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type documentAdminsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type userPersonalisationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type auditTrialOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    kcId?: SortOrder
    email?: SortOrder
    username?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    enabled?: SortOrder
    organizationId?: SortOrder
    locationId?: SortOrder
    entityId?: SortOrder
    userType?: SortOrder
    status?: SortOrder
    avatar?: SortOrder
    deleted?: SortOrder
    roleId?: SortOrder
    functionId?: SortOrder
    additionalUnits?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    kcId?: SortOrder
    email?: SortOrder
    username?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    enabled?: SortOrder
    organizationId?: SortOrder
    locationId?: SortOrder
    entityId?: SortOrder
    userType?: SortOrder
    status?: SortOrder
    avatar?: SortOrder
    deleted?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    kcId?: SortOrder
    email?: SortOrder
    username?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    enabled?: SortOrder
    organizationId?: SortOrder
    locationId?: SortOrder
    entityId?: SortOrder
    userType?: SortOrder
    status?: SortOrder
    avatar?: SortOrder
    deleted?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
    isSet?: boolean
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type ClaimListRelationFilter = {
    every?: ClaimWhereInput
    some?: ClaimWhereInput
    none?: ClaimWhereInput
  }

  export type OrganizationRelationFilter = {
    is?: OrganizationWhereInput
    isNot?: OrganizationWhereInput
  }

  export type PartsListRelationFilter = {
    every?: PartsWhereInput
    some?: PartsWhereInput
    none?: PartsWhereInput
  }

  export type ClaimOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PartsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ModelsCountOrderByAggregateInput = {
    id?: SortOrder
    modelNo?: SortOrder
    modelName?: SortOrder
    description?: SortOrder
    organizationId?: SortOrder
    partsId?: SortOrder
    claimId?: SortOrder
  }

  export type ModelsMaxOrderByAggregateInput = {
    id?: SortOrder
    modelNo?: SortOrder
    modelName?: SortOrder
    description?: SortOrder
    organizationId?: SortOrder
  }

  export type ModelsMinOrderByAggregateInput = {
    id?: SortOrder
    modelNo?: SortOrder
    modelName?: SortOrder
    description?: SortOrder
    organizationId?: SortOrder
  }

  export type ModelsListRelationFilter = {
    every?: ModelsWhereInput
    some?: ModelsWhereInput
    none?: ModelsWhereInput
  }

  export type ModelsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PartsCountOrderByAggregateInput = {
    id?: SortOrder
    partNo?: SortOrder
    partName?: SortOrder
    description?: SortOrder
    organizationId?: SortOrder
    entityId?: SortOrder
    claimId?: SortOrder
    modelsId?: SortOrder
  }

  export type PartsMaxOrderByAggregateInput = {
    id?: SortOrder
    partNo?: SortOrder
    partName?: SortOrder
    description?: SortOrder
    organizationId?: SortOrder
    entityId?: SortOrder
  }

  export type PartsMinOrderByAggregateInput = {
    id?: SortOrder
    partNo?: SortOrder
    partName?: SortOrder
    description?: SortOrder
    organizationId?: SortOrder
    entityId?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type ProblemNullableRelationFilter = {
    is?: ProblemWhereInput | null
    isNot?: ProblemWhereInput | null
  }

  export type InvestigationNullableRelationFilter = {
    is?: InvestigationWhereInput | null
    isNot?: InvestigationWhereInput | null
  }

  export type ModelsNullableRelationFilter = {
    is?: ModelsWhereInput | null
    isNot?: ModelsWhereInput | null
  }

  export type PartsNullableRelationFilter = {
    is?: PartsWhereInput | null
    isNot?: PartsWhereInput | null
  }

  export type ShipmentNullableRelationFilter = {
    is?: ShipmentWhereInput | null
    isNot?: ShipmentWhereInput | null
  }

  export type ClaimToEntityListRelationFilter = {
    every?: ClaimToEntityWhereInput
    some?: ClaimToEntityWhereInput
    none?: ClaimToEntityWhereInput
  }

  export type ClaimToEntityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClaimCountOrderByAggregateInput = {
    id?: SortOrder
    partId?: SortOrder
    modelId?: SortOrder
    partRecieptDate?: SortOrder
    vehicleType?: SortOrder
    FrameNo?: SortOrder
    prNo?: SortOrder
    lineOffDate?: SortOrder
    saleDate?: SortOrder
    repairDate?: SortOrder
    shipmentId?: SortOrder
    investigationId?: SortOrder
    settleMonth?: SortOrder
    kms?: SortOrder
    problemId?: SortOrder
    mis?: SortOrder
    claimNo?: SortOrder
  }

  export type ClaimAvgOrderByAggregateInput = {
    kms?: SortOrder
    mis?: SortOrder
    claimNo?: SortOrder
  }

  export type ClaimMaxOrderByAggregateInput = {
    id?: SortOrder
    partId?: SortOrder
    modelId?: SortOrder
    partRecieptDate?: SortOrder
    vehicleType?: SortOrder
    FrameNo?: SortOrder
    prNo?: SortOrder
    lineOffDate?: SortOrder
    saleDate?: SortOrder
    repairDate?: SortOrder
    shipmentId?: SortOrder
    investigationId?: SortOrder
    settleMonth?: SortOrder
    kms?: SortOrder
    problemId?: SortOrder
    mis?: SortOrder
    claimNo?: SortOrder
  }

  export type ClaimMinOrderByAggregateInput = {
    id?: SortOrder
    partId?: SortOrder
    modelId?: SortOrder
    partRecieptDate?: SortOrder
    vehicleType?: SortOrder
    FrameNo?: SortOrder
    prNo?: SortOrder
    lineOffDate?: SortOrder
    saleDate?: SortOrder
    repairDate?: SortOrder
    shipmentId?: SortOrder
    investigationId?: SortOrder
    settleMonth?: SortOrder
    kms?: SortOrder
    problemId?: SortOrder
    mis?: SortOrder
    claimNo?: SortOrder
  }

  export type ClaimSumOrderByAggregateInput = {
    kms?: SortOrder
    mis?: SortOrder
    claimNo?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type InvestigationListRelationFilter = {
    every?: InvestigationWhereInput
    some?: InvestigationWhereInput
    none?: InvestigationWhereInput
  }

  export type InvestigationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProblemCountOrderByAggregateInput = {
    id?: SortOrder
    problem?: SortOrder
    createdAt?: SortOrder
    organizationId?: SortOrder
  }

  export type ProblemMaxOrderByAggregateInput = {
    id?: SortOrder
    problem?: SortOrder
    createdAt?: SortOrder
    organizationId?: SortOrder
  }

  export type ProblemMinOrderByAggregateInput = {
    id?: SortOrder
    problem?: SortOrder
    createdAt?: SortOrder
    organizationId?: SortOrder
  }

  export type ClaimRelationFilter = {
    is?: ClaimWhereInput
    isNot?: ClaimWhereInput
  }

  export type EntityRelationFilter = {
    is?: EntityWhereInput
    isNot?: EntityWhereInput
  }

  export type ClaimToEntityCountOrderByAggregateInput = {
    id?: SortOrder
    claimId?: SortOrder
    entityId?: SortOrder
  }

  export type ClaimToEntityMaxOrderByAggregateInput = {
    id?: SortOrder
    claimId?: SortOrder
    entityId?: SortOrder
  }

  export type ClaimToEntityMinOrderByAggregateInput = {
    id?: SortOrder
    claimId?: SortOrder
    entityId?: SortOrder
  }
  export type JsonNullableListFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableListFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableListFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableListFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableListFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableListFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue[] | ListJsonFieldRefInput<$PrismaModel> | null
    has?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    hasEvery?: InputJsonValue[] | ListJsonFieldRefInput<$PrismaModel>
    hasSome?: InputJsonValue[] | ListJsonFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type InvestigationCountOrderByAggregateInput = {
    id?: SortOrder
    rootCause?: SortOrder
    counterMeasure?: SortOrder
    leadTime?: SortOrder
    claimType?: SortOrder
    implementDate?: SortOrder
    attachment?: SortOrder
    claimNo?: SortOrder
    problemId?: SortOrder
  }

  export type InvestigationAvgOrderByAggregateInput = {
    claimNo?: SortOrder
  }

  export type InvestigationMaxOrderByAggregateInput = {
    id?: SortOrder
    rootCause?: SortOrder
    counterMeasure?: SortOrder
    leadTime?: SortOrder
    claimType?: SortOrder
    implementDate?: SortOrder
    claimNo?: SortOrder
    problemId?: SortOrder
  }

  export type InvestigationMinOrderByAggregateInput = {
    id?: SortOrder
    rootCause?: SortOrder
    counterMeasure?: SortOrder
    leadTime?: SortOrder
    claimType?: SortOrder
    implementDate?: SortOrder
    claimNo?: SortOrder
    problemId?: SortOrder
  }

  export type InvestigationSumOrderByAggregateInput = {
    claimNo?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }

  export type ShipmentCountOrderByAggregateInput = {
    id?: SortOrder
    shipmentDate?: SortOrder
    quantity?: SortOrder
    location?: SortOrder
    InvoiceNumber?: SortOrder
    dueDate?: SortOrder
    shipmentCost?: SortOrder
    createdBy?: SortOrder
    awb?: SortOrder
    supplierName?: SortOrder
    supplierReport?: SortOrder
  }

  export type ShipmentAvgOrderByAggregateInput = {
    quantity?: SortOrder
    shipmentCost?: SortOrder
  }

  export type ShipmentMaxOrderByAggregateInput = {
    id?: SortOrder
    shipmentDate?: SortOrder
    quantity?: SortOrder
    location?: SortOrder
    InvoiceNumber?: SortOrder
    dueDate?: SortOrder
    shipmentCost?: SortOrder
    createdBy?: SortOrder
    awb?: SortOrder
    supplierName?: SortOrder
  }

  export type ShipmentMinOrderByAggregateInput = {
    id?: SortOrder
    shipmentDate?: SortOrder
    quantity?: SortOrder
    location?: SortOrder
    InvoiceNumber?: SortOrder
    dueDate?: SortOrder
    shipmentCost?: SortOrder
    createdBy?: SortOrder
    awb?: SortOrder
    supplierName?: SortOrder
  }

  export type ShipmentSumOrderByAggregateInput = {
    quantity?: SortOrder
    shipmentCost?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type BusinessListRelationFilter = {
    every?: BusinessWhereInput
    some?: BusinessWhereInput
    none?: BusinessWhereInput
  }

  export type DoctypeListRelationFilter = {
    every?: DoctypeWhereInput
    some?: DoctypeWhereInput
    none?: DoctypeWhereInput
  }

  export type DocumentsListRelationFilter = {
    every?: DocumentsWhereInput
    some?: DocumentsWhereInput
    none?: DocumentsWhereInput
  }

  export type EntityListRelationFilter = {
    every?: EntityWhereInput
    some?: EntityWhereInput
    none?: EntityWhereInput
  }

  export type EntityTypeListRelationFilter = {
    every?: EntityTypeWhereInput
    some?: EntityTypeWhereInput
    none?: EntityTypeWhereInput
  }

  export type LocationListRelationFilter = {
    every?: LocationWhereInput
    some?: LocationWhereInput
    none?: LocationWhereInput
  }

  export type RoleListRelationFilter = {
    every?: RoleWhereInput
    some?: RoleWhereInput
    none?: RoleWhereInput
  }

  export type SectionListRelationFilter = {
    every?: SectionWhereInput
    some?: SectionWhereInput
    none?: SectionWhereInput
  }

  export type SystemTypeListRelationFilter = {
    every?: SystemTypeWhereInput
    some?: SystemTypeWhereInput
    none?: SystemTypeWhereInput
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type ConnectedAppsListRelationFilter = {
    every?: ConnectedAppsWhereInput
    some?: ConnectedAppsWhereInput
    none?: ConnectedAppsWhereInput
  }

  export type UnitTypeListRelationFilter = {
    every?: unitTypeWhereInput
    some?: unitTypeWhereInput
    none?: unitTypeWhereInput
  }

  export type KpiListRelationFilter = {
    every?: kpiWhereInput
    some?: kpiWhereInput
    none?: kpiWhereInput
  }

  export type BusinessTypeListRelationFilter = {
    every?: businessTypeWhereInput
    some?: businessTypeWhereInput
    none?: businessTypeWhereInput
  }

  export type PrefixSuffixListRelationFilter = {
    every?: prefixSuffixWhereInput
    some?: prefixSuffixWhereInput
    none?: prefixSuffixWhereInput
  }

  export type SerialNumberListRelationFilter = {
    every?: serialNumberWhereInput
    some?: serialNumberWhereInput
    none?: serialNumberWhereInput
  }

  export type FunctionsListRelationFilter = {
    every?: FunctionsWhereInput
    some?: FunctionsWhereInput
    none?: FunctionsWhereInput
  }

  export type RolesTableListRelationFilter = {
    every?: rolesTableWhereInput
    some?: rolesTableWhereInput
    none?: rolesTableWhereInput
  }

  export type ProblemListRelationFilter = {
    every?: ProblemWhereInput
    some?: ProblemWhereInput
    none?: ProblemWhereInput
  }

  export type BusinessOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DoctypeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DocumentsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EntityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EntityTypeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LocationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SectionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SystemTypeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConnectedAppsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type unitTypeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type kpiOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type businessTypeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type prefixSuffixOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type serialNumberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FunctionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type rolesTableOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProblemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrganizationCountOrderByAggregateInput = {
    id?: SortOrder
    kcId?: SortOrder
    organizationName?: SortOrder
    realmName?: SortOrder
    instanceUrl?: SortOrder
    principalGeography?: SortOrder
    loginUrl?: SortOrder
    logoutUrl?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    activeModules?: SortOrder
    clientID?: SortOrder
    clientSecret?: SortOrder
    fiscalYearQuarters?: SortOrder
    fiscalYearFormat?: SortOrder
    auditYear?: SortOrder
    logoUrl?: SortOrder
    deleted?: SortOrder
  }

  export type OrganizationMaxOrderByAggregateInput = {
    id?: SortOrder
    kcId?: SortOrder
    organizationName?: SortOrder
    realmName?: SortOrder
    instanceUrl?: SortOrder
    principalGeography?: SortOrder
    loginUrl?: SortOrder
    logoutUrl?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    clientID?: SortOrder
    clientSecret?: SortOrder
    fiscalYearQuarters?: SortOrder
    fiscalYearFormat?: SortOrder
    auditYear?: SortOrder
    logoUrl?: SortOrder
    deleted?: SortOrder
  }

  export type OrganizationMinOrderByAggregateInput = {
    id?: SortOrder
    kcId?: SortOrder
    organizationName?: SortOrder
    realmName?: SortOrder
    instanceUrl?: SortOrder
    principalGeography?: SortOrder
    loginUrl?: SortOrder
    logoutUrl?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    clientID?: SortOrder
    clientSecret?: SortOrder
    fiscalYearQuarters?: SortOrder
    fiscalYearFormat?: SortOrder
    auditYear?: SortOrder
    logoUrl?: SortOrder
    deleted?: SortOrder
  }

  export type RoleCountOrderByAggregateInput = {
    id?: SortOrder
    kcId?: SortOrder
    roleName?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    deleted?: SortOrder
    organizationId?: SortOrder
    locationId?: SortOrder
  }

  export type RoleMaxOrderByAggregateInput = {
    id?: SortOrder
    kcId?: SortOrder
    roleName?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    deleted?: SortOrder
    organizationId?: SortOrder
    locationId?: SortOrder
  }

  export type RoleMinOrderByAggregateInput = {
    id?: SortOrder
    kcId?: SortOrder
    roleName?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    deleted?: SortOrder
    organizationId?: SortOrder
    locationId?: SortOrder
  }

  export type SystemTypeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    color?: SortOrder
    updatedBy?: SortOrder
    deleted?: SortOrder
    organizationId?: SortOrder
  }

  export type SystemTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    color?: SortOrder
    updatedBy?: SortOrder
    deleted?: SortOrder
    organizationId?: SortOrder
  }

  export type SystemTypeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    color?: SortOrder
    updatedBy?: SortOrder
    deleted?: SortOrder
    organizationId?: SortOrder
  }

  export type EntityTypeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    organizationId?: SortOrder
    deleted?: SortOrder
  }

  export type EntityTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    organizationId?: SortOrder
    deleted?: SortOrder
  }

  export type EntityTypeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    organizationId?: SortOrder
    deleted?: SortOrder
  }

  export type businessTypeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    deleted?: SortOrder
    organizationId?: SortOrder
  }

  export type businessTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    deleted?: SortOrder
    organizationId?: SortOrder
  }

  export type businessTypeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    deleted?: SortOrder
    organizationId?: SortOrder
  }

  export type LocationBusinessListRelationFilter = {
    every?: LocationBusinessWhereInput
    some?: LocationBusinessWhereInput
    none?: LocationBusinessWhereInput
  }

  export type LocationBusinessOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BusinessCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    organizationId?: SortOrder
    deleted?: SortOrder
  }

  export type BusinessMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    organizationId?: SortOrder
    deleted?: SortOrder
  }

  export type BusinessMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    organizationId?: SortOrder
    deleted?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type FunctionsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    functionId?: SortOrder
    description?: SortOrder
    functionHead?: SortOrder
    functionSpoc?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    deleted?: SortOrder
    organizationId?: SortOrder
    type?: SortOrder
    locationId?: SortOrder
    businessId?: SortOrder
    unitId?: SortOrder
  }

  export type FunctionsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    functionId?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    deleted?: SortOrder
    organizationId?: SortOrder
    type?: SortOrder
    unitId?: SortOrder
  }

  export type FunctionsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    functionId?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    deleted?: SortOrder
    organizationId?: SortOrder
    type?: SortOrder
    unitId?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type SectionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    organizationId?: SortOrder
    deleted?: SortOrder
  }

  export type SectionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    organizationId?: SortOrder
    deleted?: SortOrder
  }

  export type SectionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    organizationId?: SortOrder
    deleted?: SortOrder
  }

  export type LocationCountOrderByAggregateInput = {
    id?: SortOrder
    locationName?: SortOrder
    locationType?: SortOrder
    locationId?: SortOrder
    description?: SortOrder
    status?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    functionId?: SortOrder
    deleted?: SortOrder
    organizationId?: SortOrder
    users?: SortOrder
    businessTypeId?: SortOrder
    type?: SortOrder
  }

  export type LocationMaxOrderByAggregateInput = {
    id?: SortOrder
    locationName?: SortOrder
    locationType?: SortOrder
    locationId?: SortOrder
    description?: SortOrder
    status?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    deleted?: SortOrder
    organizationId?: SortOrder
    businessTypeId?: SortOrder
    type?: SortOrder
  }

  export type LocationMinOrderByAggregateInput = {
    id?: SortOrder
    locationName?: SortOrder
    locationType?: SortOrder
    locationId?: SortOrder
    description?: SortOrder
    status?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    deleted?: SortOrder
    organizationId?: SortOrder
    businessTypeId?: SortOrder
    type?: SortOrder
  }

  export type EntityTypeNullableRelationFilter = {
    is?: EntityTypeWhereInput | null
    isNot?: EntityTypeWhereInput | null
  }

  export type FunctionsNullableRelationFilter = {
    is?: FunctionsWhereInput | null
    isNot?: FunctionsWhereInput | null
  }

  export type EntityCountOrderByAggregateInput = {
    id?: SortOrder
    entityName?: SortOrder
    description?: SortOrder
    entityTypeId?: SortOrder
    organizationId?: SortOrder
    locationId?: SortOrder
    createdBy?: SortOrder
    entityId?: SortOrder
    deleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    users?: SortOrder
    sections?: SortOrder
    functionId?: SortOrder
  }

  export type EntityMaxOrderByAggregateInput = {
    id?: SortOrder
    entityName?: SortOrder
    description?: SortOrder
    entityTypeId?: SortOrder
    organizationId?: SortOrder
    locationId?: SortOrder
    createdBy?: SortOrder
    entityId?: SortOrder
    deleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    functionId?: SortOrder
  }

  export type EntityMinOrderByAggregateInput = {
    id?: SortOrder
    entityName?: SortOrder
    description?: SortOrder
    entityTypeId?: SortOrder
    organizationId?: SortOrder
    locationId?: SortOrder
    createdBy?: SortOrder
    entityId?: SortOrder
    deleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    functionId?: SortOrder
  }

  export type BusinessNullableRelationFilter = {
    is?: BusinessWhereInput | null
    isNot?: BusinessWhereInput | null
  }

  export type LocationBusinessCountOrderByAggregateInput = {
    id?: SortOrder
    locationId?: SortOrder
    businessId?: SortOrder
  }

  export type LocationBusinessMaxOrderByAggregateInput = {
    id?: SortOrder
    locationId?: SortOrder
    businessId?: SortOrder
  }

  export type LocationBusinessMinOrderByAggregateInput = {
    id?: SortOrder
    locationId?: SortOrder
    businessId?: SortOrder
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    text?: SortOrder
    content?: SortOrder
    receiver?: SortOrder
    creator?: SortOrder
    date?: SortOrder
    style?: SortOrder
    read?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    text?: SortOrder
    content?: SortOrder
    receiver?: SortOrder
    creator?: SortOrder
    date?: SortOrder
    style?: SortOrder
    read?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    text?: SortOrder
    content?: SortOrder
    receiver?: SortOrder
    creator?: SortOrder
    date?: SortOrder
    style?: SortOrder
    read?: SortOrder
  }

  export type DoctypeDocUniqueCompoundUniqueInput = {
    documentTypeName: string
    applicable_systems: InputJsonValue[]
    document_classification: string
    organizationId: string
  }

  export type DoctypeCountOrderByAggregateInput = {
    id?: SortOrder
    locationId?: SortOrder
    documentTypeName?: SortOrder
    documentNumbering?: SortOrder
    reviewFrequency?: SortOrder
    revisionRemind?: SortOrder
    prefix?: SortOrder
    suffix?: SortOrder
    organizationId?: SortOrder
    readAccess?: SortOrder
    readAccessUsers?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    createdBy?: SortOrder
    applicable_systems?: SortOrder
    users?: SortOrder
    document_classification?: SortOrder
    entityId?: SortOrder
    distributionUsers?: SortOrder
    currentVersion?: SortOrder
    distributionList?: SortOrder
  }

  export type DoctypeAvgOrderByAggregateInput = {
    reviewFrequency?: SortOrder
    revisionRemind?: SortOrder
  }

  export type DoctypeMaxOrderByAggregateInput = {
    id?: SortOrder
    documentTypeName?: SortOrder
    documentNumbering?: SortOrder
    reviewFrequency?: SortOrder
    revisionRemind?: SortOrder
    prefix?: SortOrder
    suffix?: SortOrder
    organizationId?: SortOrder
    readAccess?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    createdBy?: SortOrder
    document_classification?: SortOrder
    entityId?: SortOrder
    currentVersion?: SortOrder
    distributionList?: SortOrder
  }

  export type DoctypeMinOrderByAggregateInput = {
    id?: SortOrder
    documentTypeName?: SortOrder
    documentNumbering?: SortOrder
    reviewFrequency?: SortOrder
    revisionRemind?: SortOrder
    prefix?: SortOrder
    suffix?: SortOrder
    organizationId?: SortOrder
    readAccess?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    createdBy?: SortOrder
    document_classification?: SortOrder
    entityId?: SortOrder
    currentVersion?: SortOrder
    distributionList?: SortOrder
  }

  export type DoctypeSumOrderByAggregateInput = {
    reviewFrequency?: SortOrder
    revisionRemind?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
    isSet?: boolean
  }

  export type DoctypeNullableRelationFilter = {
    is?: DoctypeWhereInput | null
    isNot?: DoctypeWhereInput | null
  }

  export type ReferenceDocumentsListRelationFilter = {
    every?: ReferenceDocumentsWhereInput
    some?: ReferenceDocumentsWhereInput
    none?: ReferenceDocumentsWhereInput
  }

  export type VersionReferenceDocumentsListRelationFilter = {
    every?: VersionReferenceDocumentsWhereInput
    some?: VersionReferenceDocumentsWhereInput
    none?: VersionReferenceDocumentsWhereInput
  }

  export type ReferenceDocumentsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VersionReferenceDocumentsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DocumentsCountOrderByAggregateInput = {
    id?: SortOrder
    doctypeId?: SortOrder
    organizationId?: SortOrder
    documentName?: SortOrder
    documentNumbering?: SortOrder
    reasonOfCreation?: SortOrder
    effectiveDate?: SortOrder
    nextRevisionDate?: SortOrder
    currentVersion?: SortOrder
    documentLink?: SortOrder
    description?: SortOrder
    tags?: SortOrder
    documentState?: SortOrder
    locationId?: SortOrder
    entityId?: SortOrder
    system?: SortOrder
    section?: SortOrder
    revertComment?: SortOrder
    docType?: SortOrder
    documentClassification?: SortOrder
    issueNumber?: SortOrder
    retireComment?: SortOrder
    revisionReminderFlag?: SortOrder
    isVersion?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    approvedDate?: SortOrder
    countNumber?: SortOrder
    createdBy?: SortOrder
    distributionList?: SortOrder
    documentId?: SortOrder
    reviewers?: SortOrder
    approvers?: SortOrder
    creators?: SortOrder
    distributionUsers?: SortOrder
    readAccess?: SortOrder
    readAccessUsers?: SortOrder
    versionInfo?: SortOrder
  }

  export type DocumentsAvgOrderByAggregateInput = {
    countNumber?: SortOrder
  }

  export type DocumentsMaxOrderByAggregateInput = {
    id?: SortOrder
    doctypeId?: SortOrder
    organizationId?: SortOrder
    documentName?: SortOrder
    documentNumbering?: SortOrder
    reasonOfCreation?: SortOrder
    effectiveDate?: SortOrder
    nextRevisionDate?: SortOrder
    currentVersion?: SortOrder
    documentLink?: SortOrder
    description?: SortOrder
    documentState?: SortOrder
    locationId?: SortOrder
    entityId?: SortOrder
    section?: SortOrder
    revertComment?: SortOrder
    docType?: SortOrder
    documentClassification?: SortOrder
    issueNumber?: SortOrder
    retireComment?: SortOrder
    revisionReminderFlag?: SortOrder
    isVersion?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    approvedDate?: SortOrder
    countNumber?: SortOrder
    createdBy?: SortOrder
    distributionList?: SortOrder
    documentId?: SortOrder
    readAccess?: SortOrder
  }

  export type DocumentsMinOrderByAggregateInput = {
    id?: SortOrder
    doctypeId?: SortOrder
    organizationId?: SortOrder
    documentName?: SortOrder
    documentNumbering?: SortOrder
    reasonOfCreation?: SortOrder
    effectiveDate?: SortOrder
    nextRevisionDate?: SortOrder
    currentVersion?: SortOrder
    documentLink?: SortOrder
    description?: SortOrder
    documentState?: SortOrder
    locationId?: SortOrder
    entityId?: SortOrder
    section?: SortOrder
    revertComment?: SortOrder
    docType?: SortOrder
    documentClassification?: SortOrder
    issueNumber?: SortOrder
    retireComment?: SortOrder
    revisionReminderFlag?: SortOrder
    isVersion?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    approvedDate?: SortOrder
    countNumber?: SortOrder
    createdBy?: SortOrder
    distributionList?: SortOrder
    documentId?: SortOrder
    readAccess?: SortOrder
  }

  export type DocumentsSumOrderByAggregateInput = {
    countNumber?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type documentAttachmentHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    documentId?: SortOrder
    updatedLink?: SortOrder
    updatedBy?: SortOrder
    updatedAt?: SortOrder
  }

  export type documentAttachmentHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    documentId?: SortOrder
    updatedLink?: SortOrder
    updatedBy?: SortOrder
    updatedAt?: SortOrder
  }

  export type documentAttachmentHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    documentId?: SortOrder
    updatedLink?: SortOrder
    updatedBy?: SortOrder
    updatedAt?: SortOrder
  }

  export type DocumentsNullableRelationFilter = {
    is?: DocumentsWhereInput | null
    isNot?: DocumentsWhereInput | null
  }

  export type DocumentVersionsNullableRelationFilter = {
    is?: DocumentVersionsWhereInput | null
    isNot?: DocumentVersionsWhereInput | null
  }

  export type ReferenceDocumentsCountOrderByAggregateInput = {
    id?: SortOrder
    documentLink?: SortOrder
    type?: SortOrder
    documentName?: SortOrder
    version?: SortOrder
    documentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    referenceDocId?: SortOrder
    versionId?: SortOrder
  }

  export type ReferenceDocumentsMaxOrderByAggregateInput = {
    id?: SortOrder
    documentLink?: SortOrder
    type?: SortOrder
    documentName?: SortOrder
    version?: SortOrder
    documentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    referenceDocId?: SortOrder
    versionId?: SortOrder
  }

  export type ReferenceDocumentsMinOrderByAggregateInput = {
    id?: SortOrder
    documentLink?: SortOrder
    type?: SortOrder
    documentName?: SortOrder
    version?: SortOrder
    documentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    referenceDocId?: SortOrder
    versionId?: SortOrder
  }

  export type VersionReferenceDocumentsCountOrderByAggregateInput = {
    id?: SortOrder
    documentLink?: SortOrder
    type?: SortOrder
    documentName?: SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    referenceDocId?: SortOrder
    versionId?: SortOrder
    documentsId?: SortOrder
  }

  export type VersionReferenceDocumentsMaxOrderByAggregateInput = {
    id?: SortOrder
    documentLink?: SortOrder
    type?: SortOrder
    documentName?: SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    referenceDocId?: SortOrder
    versionId?: SortOrder
    documentsId?: SortOrder
  }

  export type VersionReferenceDocumentsMinOrderByAggregateInput = {
    id?: SortOrder
    documentLink?: SortOrder
    type?: SortOrder
    documentName?: SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    referenceDocId?: SortOrder
    versionId?: SortOrder
    documentsId?: SortOrder
  }

  export type DocumentVersionsCountOrderByAggregateInput = {
    id?: SortOrder
    versionName?: SortOrder
    userId?: SortOrder
    by?: SortOrder
    approvedDate?: SortOrder
    versionLink?: SortOrder
    documentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    documentName?: SortOrder
    documentNumbering?: SortOrder
    reasonOfCreation?: SortOrder
    effectiveDate?: SortOrder
    description?: SortOrder
    issueNumber?: SortOrder
  }

  export type DocumentVersionsMaxOrderByAggregateInput = {
    id?: SortOrder
    versionName?: SortOrder
    userId?: SortOrder
    by?: SortOrder
    approvedDate?: SortOrder
    versionLink?: SortOrder
    documentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    documentName?: SortOrder
    documentNumbering?: SortOrder
    reasonOfCreation?: SortOrder
    effectiveDate?: SortOrder
    description?: SortOrder
    issueNumber?: SortOrder
  }

  export type DocumentVersionsMinOrderByAggregateInput = {
    id?: SortOrder
    versionName?: SortOrder
    userId?: SortOrder
    by?: SortOrder
    approvedDate?: SortOrder
    versionLink?: SortOrder
    documentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    documentName?: SortOrder
    documentNumbering?: SortOrder
    reasonOfCreation?: SortOrder
    effectiveDate?: SortOrder
    description?: SortOrder
    issueNumber?: SortOrder
  }

  export type DocumentCommentsCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    commentBy?: SortOrder
    commentText?: SortOrder
    documentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DocumentCommentsMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    commentBy?: SortOrder
    commentText?: SortOrder
    documentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DocumentCommentsMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    commentBy?: SortOrder
    commentText?: SortOrder
    documentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DocumentWorkFlowHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    actionName?: SortOrder
    userId?: SortOrder
    actionBy?: SortOrder
    documentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DocumentWorkFlowHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    actionName?: SortOrder
    userId?: SortOrder
    actionBy?: SortOrder
    documentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DocumentWorkFlowHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    actionName?: SortOrder
    userId?: SortOrder
    actionBy?: SortOrder
    documentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type documentAdminsCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    email?: SortOrder
    userId?: SortOrder
    doctypeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type documentAdminsMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    email?: SortOrder
    userId?: SortOrder
    doctypeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type documentAdminsMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    email?: SortOrder
    userId?: SortOrder
    doctypeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdditionalDocumentAdminsCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    email?: SortOrder
    userId?: SortOrder
    documentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdditionalDocumentAdminsMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    email?: SortOrder
    userId?: SortOrder
    documentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdditionalDocumentAdminsMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    email?: SortOrder
    userId?: SortOrder
    documentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
  }

  export type LogsCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    type?: SortOrder
    additionalDetails?: SortOrder
  }

  export type LogsMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    type?: SortOrder
  }

  export type LogsMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    type?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type userPersonalisationUserIdTargetObjectCompoundUniqueInput = {
    userId: string
    targetObject: string
  }

  export type userPersonalisationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    organizationId?: SortOrder
    targetObject?: SortOrder
    targetObjectId?: SortOrder
  }

  export type userPersonalisationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    organizationId?: SortOrder
    targetObject?: SortOrder
  }

  export type userPersonalisationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    organizationId?: SortOrder
    targetObject?: SortOrder
  }

  export type ConnectedAppsOrganizationIdSourceNameCompoundUniqueInput = {
    organizationId: string
    sourceName: string
  }

  export type ConnectedAppsCountOrderByAggregateInput = {
    id?: SortOrder
    sourceName?: SortOrder
    clientId?: SortOrder
    clientSecret?: SortOrder
    baseURL?: SortOrder
    user?: SortOrder
    password?: SortOrder
    redirectURL?: SortOrder
    grantType?: SortOrder
    description?: SortOrder
    deleted?: SortOrder
    organizationId?: SortOrder
    createdModifiedBy?: SortOrder
    createdModifiedAt?: SortOrder
    locationId?: SortOrder
    Status?: SortOrder
  }

  export type ConnectedAppsMaxOrderByAggregateInput = {
    id?: SortOrder
    sourceName?: SortOrder
    clientId?: SortOrder
    clientSecret?: SortOrder
    baseURL?: SortOrder
    user?: SortOrder
    password?: SortOrder
    redirectURL?: SortOrder
    grantType?: SortOrder
    description?: SortOrder
    deleted?: SortOrder
    organizationId?: SortOrder
    createdModifiedBy?: SortOrder
    createdModifiedAt?: SortOrder
    Status?: SortOrder
  }

  export type ConnectedAppsMinOrderByAggregateInput = {
    id?: SortOrder
    sourceName?: SortOrder
    clientId?: SortOrder
    clientSecret?: SortOrder
    baseURL?: SortOrder
    user?: SortOrder
    password?: SortOrder
    redirectURL?: SortOrder
    grantType?: SortOrder
    description?: SortOrder
    deleted?: SortOrder
    organizationId?: SortOrder
    createdModifiedBy?: SortOrder
    createdModifiedAt?: SortOrder
    Status?: SortOrder
  }

  export type ConnectedAppsNullableRelationFilter = {
    is?: ConnectedAppsWhereInput | null
    isNot?: ConnectedAppsWhereInput | null
  }

  export type unitTypeOrganizationIdUnitTypeCompoundUniqueInput = {
    organizationId: string
    unitType: string
  }

  export type unitTypeCountOrderByAggregateInput = {
    id?: SortOrder
    unitType?: SortOrder
    unitOfMeasurement?: SortOrder
    organizationId?: SortOrder
    locationId?: SortOrder
    deleted?: SortOrder
    createdModifiedBy?: SortOrder
    createdModifiedAt?: SortOrder
    connectedAppsId?: SortOrder
  }

  export type unitTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    unitType?: SortOrder
    organizationId?: SortOrder
    locationId?: SortOrder
    deleted?: SortOrder
    createdModifiedBy?: SortOrder
    createdModifiedAt?: SortOrder
    connectedAppsId?: SortOrder
  }

  export type unitTypeMinOrderByAggregateInput = {
    id?: SortOrder
    unitType?: SortOrder
    organizationId?: SortOrder
    locationId?: SortOrder
    deleted?: SortOrder
    createdModifiedBy?: SortOrder
    createdModifiedAt?: SortOrder
    connectedAppsId?: SortOrder
  }

  export type UnitTypeNullableRelationFilter = {
    is?: unitTypeWhereInput | null
    isNot?: unitTypeWhereInput | null
  }

  export type kpiCountOrderByAggregateInput = {
    id?: SortOrder
    kpiName?: SortOrder
    kpiType?: SortOrder
    keyFields?: SortOrder
    unitTypeId?: SortOrder
    uom?: SortOrder
    sourceId?: SortOrder
    status?: SortOrder
    apiEndPoint?: SortOrder
    kpiDescription?: SortOrder
    kpiTargetType?: SortOrder
    organizationId?: SortOrder
    locationId?: SortOrder
    createdModifiedBy?: SortOrder
    createdModifiedAt?: SortOrder
  }

  export type kpiMaxOrderByAggregateInput = {
    id?: SortOrder
    kpiName?: SortOrder
    kpiType?: SortOrder
    unitTypeId?: SortOrder
    uom?: SortOrder
    sourceId?: SortOrder
    status?: SortOrder
    apiEndPoint?: SortOrder
    kpiDescription?: SortOrder
    kpiTargetType?: SortOrder
    organizationId?: SortOrder
    createdModifiedBy?: SortOrder
    createdModifiedAt?: SortOrder
  }

  export type kpiMinOrderByAggregateInput = {
    id?: SortOrder
    kpiName?: SortOrder
    kpiType?: SortOrder
    unitTypeId?: SortOrder
    uom?: SortOrder
    sourceId?: SortOrder
    status?: SortOrder
    apiEndPoint?: SortOrder
    kpiDescription?: SortOrder
    kpiTargetType?: SortOrder
    organizationId?: SortOrder
    createdModifiedBy?: SortOrder
    createdModifiedAt?: SortOrder
  }

  export type auditTrialCountOrderByAggregateInput = {
    id?: SortOrder
    moduleType?: SortOrder
    actionType?: SortOrder
    transactionId?: SortOrder
    actionBy?: SortOrder
    actionDate?: SortOrder
  }

  export type auditTrialMaxOrderByAggregateInput = {
    id?: SortOrder
    moduleType?: SortOrder
    actionType?: SortOrder
    transactionId?: SortOrder
    actionBy?: SortOrder
    actionDate?: SortOrder
  }

  export type auditTrialMinOrderByAggregateInput = {
    id?: SortOrder
    moduleType?: SortOrder
    actionType?: SortOrder
    transactionId?: SortOrder
    actionBy?: SortOrder
    actionDate?: SortOrder
  }

  export type prefixSuffixCountOrderByAggregateInput = {
    id?: SortOrder
    prefix?: SortOrder
    suffix?: SortOrder
    moduleType?: SortOrder
    location?: SortOrder
    organizationId?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type prefixSuffixMaxOrderByAggregateInput = {
    id?: SortOrder
    prefix?: SortOrder
    suffix?: SortOrder
    moduleType?: SortOrder
    location?: SortOrder
    organizationId?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type prefixSuffixMinOrderByAggregateInput = {
    id?: SortOrder
    prefix?: SortOrder
    suffix?: SortOrder
    moduleType?: SortOrder
    location?: SortOrder
    organizationId?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type serialNumberModuleTypeLocationEntityYearTidCompoundUniqueInput = {
    moduleType: string
    location: string
    entity: string
    year: string
    tid: string
  }

  export type serialNumberCountOrderByAggregateInput = {
    id?: SortOrder
    moduleType?: SortOrder
    location?: SortOrder
    entity?: SortOrder
    year?: SortOrder
    tid?: SortOrder
    serialNumber?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    organizationId?: SortOrder
  }

  export type serialNumberAvgOrderByAggregateInput = {
    serialNumber?: SortOrder
  }

  export type serialNumberMaxOrderByAggregateInput = {
    id?: SortOrder
    moduleType?: SortOrder
    location?: SortOrder
    entity?: SortOrder
    year?: SortOrder
    tid?: SortOrder
    serialNumber?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    organizationId?: SortOrder
  }

  export type serialNumberMinOrderByAggregateInput = {
    id?: SortOrder
    moduleType?: SortOrder
    location?: SortOrder
    entity?: SortOrder
    year?: SortOrder
    tid?: SortOrder
    serialNumber?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    organizationId?: SortOrder
  }

  export type serialNumberSumOrderByAggregateInput = {
    serialNumber?: SortOrder
  }

  export type LocationRelationFilter = {
    is?: LocationWhereInput
    isNot?: LocationWhereInput
  }

  export type rolesTableCountOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    unitId?: SortOrder
    users?: SortOrder
    roleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type rolesTableMaxOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    unitId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type rolesTableMinOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    unitId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserCreateroleIdInput = {
    set: string[]
  }

  export type UserCreateadditionalUnitsInput = {
    set: string[]
  }

  export type EntityCreateNestedOneWithoutUserInput = {
    create?: XOR<EntityCreateWithoutUserInput, EntityUncheckedCreateWithoutUserInput>
    connectOrCreate?: EntityCreateOrConnectWithoutUserInput
    connect?: EntityWhereUniqueInput
  }

  export type LocationCreateNestedOneWithoutUserInput = {
    create?: XOR<LocationCreateWithoutUserInput, LocationUncheckedCreateWithoutUserInput>
    connectOrCreate?: LocationCreateOrConnectWithoutUserInput
    connect?: LocationWhereUniqueInput
  }

  export type OrganizationCreateNestedOneWithoutUserInput = {
    create?: XOR<OrganizationCreateWithoutUserInput, OrganizationUncheckedCreateWithoutUserInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutUserInput
    connect?: OrganizationWhereUniqueInput
  }

  export type AdditionalDocumentAdminsCreateNestedManyWithoutUserInput = {
    create?: XOR<AdditionalDocumentAdminsCreateWithoutUserInput, AdditionalDocumentAdminsUncheckedCreateWithoutUserInput> | AdditionalDocumentAdminsCreateWithoutUserInput[] | AdditionalDocumentAdminsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AdditionalDocumentAdminsCreateOrConnectWithoutUserInput | AdditionalDocumentAdminsCreateOrConnectWithoutUserInput[]
    createMany?: AdditionalDocumentAdminsCreateManyUserInputEnvelope
    connect?: AdditionalDocumentAdminsWhereUniqueInput | AdditionalDocumentAdminsWhereUniqueInput[]
  }

  export type DocumentCommentsCreateNestedManyWithoutUserInput = {
    create?: XOR<DocumentCommentsCreateWithoutUserInput, DocumentCommentsUncheckedCreateWithoutUserInput> | DocumentCommentsCreateWithoutUserInput[] | DocumentCommentsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DocumentCommentsCreateOrConnectWithoutUserInput | DocumentCommentsCreateOrConnectWithoutUserInput[]
    createMany?: DocumentCommentsCreateManyUserInputEnvelope
    connect?: DocumentCommentsWhereUniqueInput | DocumentCommentsWhereUniqueInput[]
  }

  export type DocumentVersionsCreateNestedManyWithoutUserInput = {
    create?: XOR<DocumentVersionsCreateWithoutUserInput, DocumentVersionsUncheckedCreateWithoutUserInput> | DocumentVersionsCreateWithoutUserInput[] | DocumentVersionsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DocumentVersionsCreateOrConnectWithoutUserInput | DocumentVersionsCreateOrConnectWithoutUserInput[]
    createMany?: DocumentVersionsCreateManyUserInputEnvelope
    connect?: DocumentVersionsWhereUniqueInput | DocumentVersionsWhereUniqueInput[]
  }

  export type DocumentWorkFlowHistoryCreateNestedManyWithoutUserInput = {
    create?: XOR<DocumentWorkFlowHistoryCreateWithoutUserInput, DocumentWorkFlowHistoryUncheckedCreateWithoutUserInput> | DocumentWorkFlowHistoryCreateWithoutUserInput[] | DocumentWorkFlowHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DocumentWorkFlowHistoryCreateOrConnectWithoutUserInput | DocumentWorkFlowHistoryCreateOrConnectWithoutUserInput[]
    createMany?: DocumentWorkFlowHistoryCreateManyUserInputEnvelope
    connect?: DocumentWorkFlowHistoryWhereUniqueInput | DocumentWorkFlowHistoryWhereUniqueInput[]
  }

  export type LogsCreateNestedManyWithoutUserInput = {
    create?: XOR<LogsCreateWithoutUserInput, LogsUncheckedCreateWithoutUserInput> | LogsCreateWithoutUserInput[] | LogsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LogsCreateOrConnectWithoutUserInput | LogsCreateOrConnectWithoutUserInput[]
    createMany?: LogsCreateManyUserInputEnvelope
    connect?: LogsWhereUniqueInput | LogsWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type documentAdminsCreateNestedManyWithoutUserInput = {
    create?: XOR<documentAdminsCreateWithoutUserInput, documentAdminsUncheckedCreateWithoutUserInput> | documentAdminsCreateWithoutUserInput[] | documentAdminsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: documentAdminsCreateOrConnectWithoutUserInput | documentAdminsCreateOrConnectWithoutUserInput[]
    createMany?: documentAdminsCreateManyUserInputEnvelope
    connect?: documentAdminsWhereUniqueInput | documentAdminsWhereUniqueInput[]
  }

  export type userPersonalisationCreateNestedManyWithoutUserInput = {
    create?: XOR<userPersonalisationCreateWithoutUserInput, userPersonalisationUncheckedCreateWithoutUserInput> | userPersonalisationCreateWithoutUserInput[] | userPersonalisationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: userPersonalisationCreateOrConnectWithoutUserInput | userPersonalisationCreateOrConnectWithoutUserInput[]
    createMany?: userPersonalisationCreateManyUserInputEnvelope
    connect?: userPersonalisationWhereUniqueInput | userPersonalisationWhereUniqueInput[]
  }

  export type auditTrialCreateNestedManyWithoutUserInput = {
    create?: XOR<auditTrialCreateWithoutUserInput, auditTrialUncheckedCreateWithoutUserInput> | auditTrialCreateWithoutUserInput[] | auditTrialUncheckedCreateWithoutUserInput[]
    connectOrCreate?: auditTrialCreateOrConnectWithoutUserInput | auditTrialCreateOrConnectWithoutUserInput[]
    createMany?: auditTrialCreateManyUserInputEnvelope
    connect?: auditTrialWhereUniqueInput | auditTrialWhereUniqueInput[]
  }

  export type AdditionalDocumentAdminsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AdditionalDocumentAdminsCreateWithoutUserInput, AdditionalDocumentAdminsUncheckedCreateWithoutUserInput> | AdditionalDocumentAdminsCreateWithoutUserInput[] | AdditionalDocumentAdminsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AdditionalDocumentAdminsCreateOrConnectWithoutUserInput | AdditionalDocumentAdminsCreateOrConnectWithoutUserInput[]
    createMany?: AdditionalDocumentAdminsCreateManyUserInputEnvelope
    connect?: AdditionalDocumentAdminsWhereUniqueInput | AdditionalDocumentAdminsWhereUniqueInput[]
  }

  export type DocumentCommentsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<DocumentCommentsCreateWithoutUserInput, DocumentCommentsUncheckedCreateWithoutUserInput> | DocumentCommentsCreateWithoutUserInput[] | DocumentCommentsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DocumentCommentsCreateOrConnectWithoutUserInput | DocumentCommentsCreateOrConnectWithoutUserInput[]
    createMany?: DocumentCommentsCreateManyUserInputEnvelope
    connect?: DocumentCommentsWhereUniqueInput | DocumentCommentsWhereUniqueInput[]
  }

  export type DocumentVersionsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<DocumentVersionsCreateWithoutUserInput, DocumentVersionsUncheckedCreateWithoutUserInput> | DocumentVersionsCreateWithoutUserInput[] | DocumentVersionsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DocumentVersionsCreateOrConnectWithoutUserInput | DocumentVersionsCreateOrConnectWithoutUserInput[]
    createMany?: DocumentVersionsCreateManyUserInputEnvelope
    connect?: DocumentVersionsWhereUniqueInput | DocumentVersionsWhereUniqueInput[]
  }

  export type DocumentWorkFlowHistoryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<DocumentWorkFlowHistoryCreateWithoutUserInput, DocumentWorkFlowHistoryUncheckedCreateWithoutUserInput> | DocumentWorkFlowHistoryCreateWithoutUserInput[] | DocumentWorkFlowHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DocumentWorkFlowHistoryCreateOrConnectWithoutUserInput | DocumentWorkFlowHistoryCreateOrConnectWithoutUserInput[]
    createMany?: DocumentWorkFlowHistoryCreateManyUserInputEnvelope
    connect?: DocumentWorkFlowHistoryWhereUniqueInput | DocumentWorkFlowHistoryWhereUniqueInput[]
  }

  export type LogsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<LogsCreateWithoutUserInput, LogsUncheckedCreateWithoutUserInput> | LogsCreateWithoutUserInput[] | LogsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LogsCreateOrConnectWithoutUserInput | LogsCreateOrConnectWithoutUserInput[]
    createMany?: LogsCreateManyUserInputEnvelope
    connect?: LogsWhereUniqueInput | LogsWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type documentAdminsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<documentAdminsCreateWithoutUserInput, documentAdminsUncheckedCreateWithoutUserInput> | documentAdminsCreateWithoutUserInput[] | documentAdminsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: documentAdminsCreateOrConnectWithoutUserInput | documentAdminsCreateOrConnectWithoutUserInput[]
    createMany?: documentAdminsCreateManyUserInputEnvelope
    connect?: documentAdminsWhereUniqueInput | documentAdminsWhereUniqueInput[]
  }

  export type userPersonalisationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<userPersonalisationCreateWithoutUserInput, userPersonalisationUncheckedCreateWithoutUserInput> | userPersonalisationCreateWithoutUserInput[] | userPersonalisationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: userPersonalisationCreateOrConnectWithoutUserInput | userPersonalisationCreateOrConnectWithoutUserInput[]
    createMany?: userPersonalisationCreateManyUserInputEnvelope
    connect?: userPersonalisationWhereUniqueInput | userPersonalisationWhereUniqueInput[]
  }

  export type auditTrialUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<auditTrialCreateWithoutUserInput, auditTrialUncheckedCreateWithoutUserInput> | auditTrialCreateWithoutUserInput[] | auditTrialUncheckedCreateWithoutUserInput[]
    connectOrCreate?: auditTrialCreateOrConnectWithoutUserInput | auditTrialCreateOrConnectWithoutUserInput[]
    createMany?: auditTrialCreateManyUserInputEnvelope
    connect?: auditTrialWhereUniqueInput | auditTrialWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
    unset?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
    unset?: boolean
  }

  export type UserUpdateroleIdInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateadditionalUnitsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EntityUpdateOneWithoutUserNestedInput = {
    create?: XOR<EntityCreateWithoutUserInput, EntityUncheckedCreateWithoutUserInput>
    connectOrCreate?: EntityCreateOrConnectWithoutUserInput
    upsert?: EntityUpsertWithoutUserInput
    disconnect?: boolean
    delete?: EntityWhereInput | boolean
    connect?: EntityWhereUniqueInput
    update?: XOR<XOR<EntityUpdateToOneWithWhereWithoutUserInput, EntityUpdateWithoutUserInput>, EntityUncheckedUpdateWithoutUserInput>
  }

  export type LocationUpdateOneWithoutUserNestedInput = {
    create?: XOR<LocationCreateWithoutUserInput, LocationUncheckedCreateWithoutUserInput>
    connectOrCreate?: LocationCreateOrConnectWithoutUserInput
    upsert?: LocationUpsertWithoutUserInput
    disconnect?: boolean
    delete?: LocationWhereInput | boolean
    connect?: LocationWhereUniqueInput
    update?: XOR<XOR<LocationUpdateToOneWithWhereWithoutUserInput, LocationUpdateWithoutUserInput>, LocationUncheckedUpdateWithoutUserInput>
  }

  export type OrganizationUpdateOneWithoutUserNestedInput = {
    create?: XOR<OrganizationCreateWithoutUserInput, OrganizationUncheckedCreateWithoutUserInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutUserInput
    upsert?: OrganizationUpsertWithoutUserInput
    disconnect?: boolean
    delete?: OrganizationWhereInput | boolean
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutUserInput, OrganizationUpdateWithoutUserInput>, OrganizationUncheckedUpdateWithoutUserInput>
  }

  export type AdditionalDocumentAdminsUpdateManyWithoutUserNestedInput = {
    create?: XOR<AdditionalDocumentAdminsCreateWithoutUserInput, AdditionalDocumentAdminsUncheckedCreateWithoutUserInput> | AdditionalDocumentAdminsCreateWithoutUserInput[] | AdditionalDocumentAdminsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AdditionalDocumentAdminsCreateOrConnectWithoutUserInput | AdditionalDocumentAdminsCreateOrConnectWithoutUserInput[]
    upsert?: AdditionalDocumentAdminsUpsertWithWhereUniqueWithoutUserInput | AdditionalDocumentAdminsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AdditionalDocumentAdminsCreateManyUserInputEnvelope
    set?: AdditionalDocumentAdminsWhereUniqueInput | AdditionalDocumentAdminsWhereUniqueInput[]
    disconnect?: AdditionalDocumentAdminsWhereUniqueInput | AdditionalDocumentAdminsWhereUniqueInput[]
    delete?: AdditionalDocumentAdminsWhereUniqueInput | AdditionalDocumentAdminsWhereUniqueInput[]
    connect?: AdditionalDocumentAdminsWhereUniqueInput | AdditionalDocumentAdminsWhereUniqueInput[]
    update?: AdditionalDocumentAdminsUpdateWithWhereUniqueWithoutUserInput | AdditionalDocumentAdminsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AdditionalDocumentAdminsUpdateManyWithWhereWithoutUserInput | AdditionalDocumentAdminsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AdditionalDocumentAdminsScalarWhereInput | AdditionalDocumentAdminsScalarWhereInput[]
  }

  export type DocumentCommentsUpdateManyWithoutUserNestedInput = {
    create?: XOR<DocumentCommentsCreateWithoutUserInput, DocumentCommentsUncheckedCreateWithoutUserInput> | DocumentCommentsCreateWithoutUserInput[] | DocumentCommentsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DocumentCommentsCreateOrConnectWithoutUserInput | DocumentCommentsCreateOrConnectWithoutUserInput[]
    upsert?: DocumentCommentsUpsertWithWhereUniqueWithoutUserInput | DocumentCommentsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DocumentCommentsCreateManyUserInputEnvelope
    set?: DocumentCommentsWhereUniqueInput | DocumentCommentsWhereUniqueInput[]
    disconnect?: DocumentCommentsWhereUniqueInput | DocumentCommentsWhereUniqueInput[]
    delete?: DocumentCommentsWhereUniqueInput | DocumentCommentsWhereUniqueInput[]
    connect?: DocumentCommentsWhereUniqueInput | DocumentCommentsWhereUniqueInput[]
    update?: DocumentCommentsUpdateWithWhereUniqueWithoutUserInput | DocumentCommentsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DocumentCommentsUpdateManyWithWhereWithoutUserInput | DocumentCommentsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DocumentCommentsScalarWhereInput | DocumentCommentsScalarWhereInput[]
  }

  export type DocumentVersionsUpdateManyWithoutUserNestedInput = {
    create?: XOR<DocumentVersionsCreateWithoutUserInput, DocumentVersionsUncheckedCreateWithoutUserInput> | DocumentVersionsCreateWithoutUserInput[] | DocumentVersionsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DocumentVersionsCreateOrConnectWithoutUserInput | DocumentVersionsCreateOrConnectWithoutUserInput[]
    upsert?: DocumentVersionsUpsertWithWhereUniqueWithoutUserInput | DocumentVersionsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DocumentVersionsCreateManyUserInputEnvelope
    set?: DocumentVersionsWhereUniqueInput | DocumentVersionsWhereUniqueInput[]
    disconnect?: DocumentVersionsWhereUniqueInput | DocumentVersionsWhereUniqueInput[]
    delete?: DocumentVersionsWhereUniqueInput | DocumentVersionsWhereUniqueInput[]
    connect?: DocumentVersionsWhereUniqueInput | DocumentVersionsWhereUniqueInput[]
    update?: DocumentVersionsUpdateWithWhereUniqueWithoutUserInput | DocumentVersionsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DocumentVersionsUpdateManyWithWhereWithoutUserInput | DocumentVersionsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DocumentVersionsScalarWhereInput | DocumentVersionsScalarWhereInput[]
  }

  export type DocumentWorkFlowHistoryUpdateManyWithoutUserNestedInput = {
    create?: XOR<DocumentWorkFlowHistoryCreateWithoutUserInput, DocumentWorkFlowHistoryUncheckedCreateWithoutUserInput> | DocumentWorkFlowHistoryCreateWithoutUserInput[] | DocumentWorkFlowHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DocumentWorkFlowHistoryCreateOrConnectWithoutUserInput | DocumentWorkFlowHistoryCreateOrConnectWithoutUserInput[]
    upsert?: DocumentWorkFlowHistoryUpsertWithWhereUniqueWithoutUserInput | DocumentWorkFlowHistoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DocumentWorkFlowHistoryCreateManyUserInputEnvelope
    set?: DocumentWorkFlowHistoryWhereUniqueInput | DocumentWorkFlowHistoryWhereUniqueInput[]
    disconnect?: DocumentWorkFlowHistoryWhereUniqueInput | DocumentWorkFlowHistoryWhereUniqueInput[]
    delete?: DocumentWorkFlowHistoryWhereUniqueInput | DocumentWorkFlowHistoryWhereUniqueInput[]
    connect?: DocumentWorkFlowHistoryWhereUniqueInput | DocumentWorkFlowHistoryWhereUniqueInput[]
    update?: DocumentWorkFlowHistoryUpdateWithWhereUniqueWithoutUserInput | DocumentWorkFlowHistoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DocumentWorkFlowHistoryUpdateManyWithWhereWithoutUserInput | DocumentWorkFlowHistoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DocumentWorkFlowHistoryScalarWhereInput | DocumentWorkFlowHistoryScalarWhereInput[]
  }

  export type LogsUpdateManyWithoutUserNestedInput = {
    create?: XOR<LogsCreateWithoutUserInput, LogsUncheckedCreateWithoutUserInput> | LogsCreateWithoutUserInput[] | LogsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LogsCreateOrConnectWithoutUserInput | LogsCreateOrConnectWithoutUserInput[]
    upsert?: LogsUpsertWithWhereUniqueWithoutUserInput | LogsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LogsCreateManyUserInputEnvelope
    set?: LogsWhereUniqueInput | LogsWhereUniqueInput[]
    disconnect?: LogsWhereUniqueInput | LogsWhereUniqueInput[]
    delete?: LogsWhereUniqueInput | LogsWhereUniqueInput[]
    connect?: LogsWhereUniqueInput | LogsWhereUniqueInput[]
    update?: LogsUpdateWithWhereUniqueWithoutUserInput | LogsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LogsUpdateManyWithWhereWithoutUserInput | LogsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LogsScalarWhereInput | LogsScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type documentAdminsUpdateManyWithoutUserNestedInput = {
    create?: XOR<documentAdminsCreateWithoutUserInput, documentAdminsUncheckedCreateWithoutUserInput> | documentAdminsCreateWithoutUserInput[] | documentAdminsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: documentAdminsCreateOrConnectWithoutUserInput | documentAdminsCreateOrConnectWithoutUserInput[]
    upsert?: documentAdminsUpsertWithWhereUniqueWithoutUserInput | documentAdminsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: documentAdminsCreateManyUserInputEnvelope
    set?: documentAdminsWhereUniqueInput | documentAdminsWhereUniqueInput[]
    disconnect?: documentAdminsWhereUniqueInput | documentAdminsWhereUniqueInput[]
    delete?: documentAdminsWhereUniqueInput | documentAdminsWhereUniqueInput[]
    connect?: documentAdminsWhereUniqueInput | documentAdminsWhereUniqueInput[]
    update?: documentAdminsUpdateWithWhereUniqueWithoutUserInput | documentAdminsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: documentAdminsUpdateManyWithWhereWithoutUserInput | documentAdminsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: documentAdminsScalarWhereInput | documentAdminsScalarWhereInput[]
  }

  export type userPersonalisationUpdateManyWithoutUserNestedInput = {
    create?: XOR<userPersonalisationCreateWithoutUserInput, userPersonalisationUncheckedCreateWithoutUserInput> | userPersonalisationCreateWithoutUserInput[] | userPersonalisationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: userPersonalisationCreateOrConnectWithoutUserInput | userPersonalisationCreateOrConnectWithoutUserInput[]
    upsert?: userPersonalisationUpsertWithWhereUniqueWithoutUserInput | userPersonalisationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: userPersonalisationCreateManyUserInputEnvelope
    set?: userPersonalisationWhereUniqueInput | userPersonalisationWhereUniqueInput[]
    disconnect?: userPersonalisationWhereUniqueInput | userPersonalisationWhereUniqueInput[]
    delete?: userPersonalisationWhereUniqueInput | userPersonalisationWhereUniqueInput[]
    connect?: userPersonalisationWhereUniqueInput | userPersonalisationWhereUniqueInput[]
    update?: userPersonalisationUpdateWithWhereUniqueWithoutUserInput | userPersonalisationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: userPersonalisationUpdateManyWithWhereWithoutUserInput | userPersonalisationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: userPersonalisationScalarWhereInput | userPersonalisationScalarWhereInput[]
  }

  export type auditTrialUpdateManyWithoutUserNestedInput = {
    create?: XOR<auditTrialCreateWithoutUserInput, auditTrialUncheckedCreateWithoutUserInput> | auditTrialCreateWithoutUserInput[] | auditTrialUncheckedCreateWithoutUserInput[]
    connectOrCreate?: auditTrialCreateOrConnectWithoutUserInput | auditTrialCreateOrConnectWithoutUserInput[]
    upsert?: auditTrialUpsertWithWhereUniqueWithoutUserInput | auditTrialUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: auditTrialCreateManyUserInputEnvelope
    set?: auditTrialWhereUniqueInput | auditTrialWhereUniqueInput[]
    disconnect?: auditTrialWhereUniqueInput | auditTrialWhereUniqueInput[]
    delete?: auditTrialWhereUniqueInput | auditTrialWhereUniqueInput[]
    connect?: auditTrialWhereUniqueInput | auditTrialWhereUniqueInput[]
    update?: auditTrialUpdateWithWhereUniqueWithoutUserInput | auditTrialUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: auditTrialUpdateManyWithWhereWithoutUserInput | auditTrialUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: auditTrialScalarWhereInput | auditTrialScalarWhereInput[]
  }

  export type AdditionalDocumentAdminsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AdditionalDocumentAdminsCreateWithoutUserInput, AdditionalDocumentAdminsUncheckedCreateWithoutUserInput> | AdditionalDocumentAdminsCreateWithoutUserInput[] | AdditionalDocumentAdminsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AdditionalDocumentAdminsCreateOrConnectWithoutUserInput | AdditionalDocumentAdminsCreateOrConnectWithoutUserInput[]
    upsert?: AdditionalDocumentAdminsUpsertWithWhereUniqueWithoutUserInput | AdditionalDocumentAdminsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AdditionalDocumentAdminsCreateManyUserInputEnvelope
    set?: AdditionalDocumentAdminsWhereUniqueInput | AdditionalDocumentAdminsWhereUniqueInput[]
    disconnect?: AdditionalDocumentAdminsWhereUniqueInput | AdditionalDocumentAdminsWhereUniqueInput[]
    delete?: AdditionalDocumentAdminsWhereUniqueInput | AdditionalDocumentAdminsWhereUniqueInput[]
    connect?: AdditionalDocumentAdminsWhereUniqueInput | AdditionalDocumentAdminsWhereUniqueInput[]
    update?: AdditionalDocumentAdminsUpdateWithWhereUniqueWithoutUserInput | AdditionalDocumentAdminsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AdditionalDocumentAdminsUpdateManyWithWhereWithoutUserInput | AdditionalDocumentAdminsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AdditionalDocumentAdminsScalarWhereInput | AdditionalDocumentAdminsScalarWhereInput[]
  }

  export type DocumentCommentsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<DocumentCommentsCreateWithoutUserInput, DocumentCommentsUncheckedCreateWithoutUserInput> | DocumentCommentsCreateWithoutUserInput[] | DocumentCommentsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DocumentCommentsCreateOrConnectWithoutUserInput | DocumentCommentsCreateOrConnectWithoutUserInput[]
    upsert?: DocumentCommentsUpsertWithWhereUniqueWithoutUserInput | DocumentCommentsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DocumentCommentsCreateManyUserInputEnvelope
    set?: DocumentCommentsWhereUniqueInput | DocumentCommentsWhereUniqueInput[]
    disconnect?: DocumentCommentsWhereUniqueInput | DocumentCommentsWhereUniqueInput[]
    delete?: DocumentCommentsWhereUniqueInput | DocumentCommentsWhereUniqueInput[]
    connect?: DocumentCommentsWhereUniqueInput | DocumentCommentsWhereUniqueInput[]
    update?: DocumentCommentsUpdateWithWhereUniqueWithoutUserInput | DocumentCommentsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DocumentCommentsUpdateManyWithWhereWithoutUserInput | DocumentCommentsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DocumentCommentsScalarWhereInput | DocumentCommentsScalarWhereInput[]
  }

  export type DocumentVersionsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<DocumentVersionsCreateWithoutUserInput, DocumentVersionsUncheckedCreateWithoutUserInput> | DocumentVersionsCreateWithoutUserInput[] | DocumentVersionsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DocumentVersionsCreateOrConnectWithoutUserInput | DocumentVersionsCreateOrConnectWithoutUserInput[]
    upsert?: DocumentVersionsUpsertWithWhereUniqueWithoutUserInput | DocumentVersionsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DocumentVersionsCreateManyUserInputEnvelope
    set?: DocumentVersionsWhereUniqueInput | DocumentVersionsWhereUniqueInput[]
    disconnect?: DocumentVersionsWhereUniqueInput | DocumentVersionsWhereUniqueInput[]
    delete?: DocumentVersionsWhereUniqueInput | DocumentVersionsWhereUniqueInput[]
    connect?: DocumentVersionsWhereUniqueInput | DocumentVersionsWhereUniqueInput[]
    update?: DocumentVersionsUpdateWithWhereUniqueWithoutUserInput | DocumentVersionsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DocumentVersionsUpdateManyWithWhereWithoutUserInput | DocumentVersionsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DocumentVersionsScalarWhereInput | DocumentVersionsScalarWhereInput[]
  }

  export type DocumentWorkFlowHistoryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<DocumentWorkFlowHistoryCreateWithoutUserInput, DocumentWorkFlowHistoryUncheckedCreateWithoutUserInput> | DocumentWorkFlowHistoryCreateWithoutUserInput[] | DocumentWorkFlowHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DocumentWorkFlowHistoryCreateOrConnectWithoutUserInput | DocumentWorkFlowHistoryCreateOrConnectWithoutUserInput[]
    upsert?: DocumentWorkFlowHistoryUpsertWithWhereUniqueWithoutUserInput | DocumentWorkFlowHistoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DocumentWorkFlowHistoryCreateManyUserInputEnvelope
    set?: DocumentWorkFlowHistoryWhereUniqueInput | DocumentWorkFlowHistoryWhereUniqueInput[]
    disconnect?: DocumentWorkFlowHistoryWhereUniqueInput | DocumentWorkFlowHistoryWhereUniqueInput[]
    delete?: DocumentWorkFlowHistoryWhereUniqueInput | DocumentWorkFlowHistoryWhereUniqueInput[]
    connect?: DocumentWorkFlowHistoryWhereUniqueInput | DocumentWorkFlowHistoryWhereUniqueInput[]
    update?: DocumentWorkFlowHistoryUpdateWithWhereUniqueWithoutUserInput | DocumentWorkFlowHistoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DocumentWorkFlowHistoryUpdateManyWithWhereWithoutUserInput | DocumentWorkFlowHistoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DocumentWorkFlowHistoryScalarWhereInput | DocumentWorkFlowHistoryScalarWhereInput[]
  }

  export type LogsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<LogsCreateWithoutUserInput, LogsUncheckedCreateWithoutUserInput> | LogsCreateWithoutUserInput[] | LogsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LogsCreateOrConnectWithoutUserInput | LogsCreateOrConnectWithoutUserInput[]
    upsert?: LogsUpsertWithWhereUniqueWithoutUserInput | LogsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LogsCreateManyUserInputEnvelope
    set?: LogsWhereUniqueInput | LogsWhereUniqueInput[]
    disconnect?: LogsWhereUniqueInput | LogsWhereUniqueInput[]
    delete?: LogsWhereUniqueInput | LogsWhereUniqueInput[]
    connect?: LogsWhereUniqueInput | LogsWhereUniqueInput[]
    update?: LogsUpdateWithWhereUniqueWithoutUserInput | LogsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LogsUpdateManyWithWhereWithoutUserInput | LogsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LogsScalarWhereInput | LogsScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type documentAdminsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<documentAdminsCreateWithoutUserInput, documentAdminsUncheckedCreateWithoutUserInput> | documentAdminsCreateWithoutUserInput[] | documentAdminsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: documentAdminsCreateOrConnectWithoutUserInput | documentAdminsCreateOrConnectWithoutUserInput[]
    upsert?: documentAdminsUpsertWithWhereUniqueWithoutUserInput | documentAdminsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: documentAdminsCreateManyUserInputEnvelope
    set?: documentAdminsWhereUniqueInput | documentAdminsWhereUniqueInput[]
    disconnect?: documentAdminsWhereUniqueInput | documentAdminsWhereUniqueInput[]
    delete?: documentAdminsWhereUniqueInput | documentAdminsWhereUniqueInput[]
    connect?: documentAdminsWhereUniqueInput | documentAdminsWhereUniqueInput[]
    update?: documentAdminsUpdateWithWhereUniqueWithoutUserInput | documentAdminsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: documentAdminsUpdateManyWithWhereWithoutUserInput | documentAdminsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: documentAdminsScalarWhereInput | documentAdminsScalarWhereInput[]
  }

  export type userPersonalisationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<userPersonalisationCreateWithoutUserInput, userPersonalisationUncheckedCreateWithoutUserInput> | userPersonalisationCreateWithoutUserInput[] | userPersonalisationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: userPersonalisationCreateOrConnectWithoutUserInput | userPersonalisationCreateOrConnectWithoutUserInput[]
    upsert?: userPersonalisationUpsertWithWhereUniqueWithoutUserInput | userPersonalisationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: userPersonalisationCreateManyUserInputEnvelope
    set?: userPersonalisationWhereUniqueInput | userPersonalisationWhereUniqueInput[]
    disconnect?: userPersonalisationWhereUniqueInput | userPersonalisationWhereUniqueInput[]
    delete?: userPersonalisationWhereUniqueInput | userPersonalisationWhereUniqueInput[]
    connect?: userPersonalisationWhereUniqueInput | userPersonalisationWhereUniqueInput[]
    update?: userPersonalisationUpdateWithWhereUniqueWithoutUserInput | userPersonalisationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: userPersonalisationUpdateManyWithWhereWithoutUserInput | userPersonalisationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: userPersonalisationScalarWhereInput | userPersonalisationScalarWhereInput[]
  }

  export type auditTrialUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<auditTrialCreateWithoutUserInput, auditTrialUncheckedCreateWithoutUserInput> | auditTrialCreateWithoutUserInput[] | auditTrialUncheckedCreateWithoutUserInput[]
    connectOrCreate?: auditTrialCreateOrConnectWithoutUserInput | auditTrialCreateOrConnectWithoutUserInput[]
    upsert?: auditTrialUpsertWithWhereUniqueWithoutUserInput | auditTrialUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: auditTrialCreateManyUserInputEnvelope
    set?: auditTrialWhereUniqueInput | auditTrialWhereUniqueInput[]
    disconnect?: auditTrialWhereUniqueInput | auditTrialWhereUniqueInput[]
    delete?: auditTrialWhereUniqueInput | auditTrialWhereUniqueInput[]
    connect?: auditTrialWhereUniqueInput | auditTrialWhereUniqueInput[]
    update?: auditTrialUpdateWithWhereUniqueWithoutUserInput | auditTrialUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: auditTrialUpdateManyWithWhereWithoutUserInput | auditTrialUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: auditTrialScalarWhereInput | auditTrialScalarWhereInput[]
  }

  export type ModelsCreateclaimIdInput = {
    set: string[]
  }

  export type ClaimCreateNestedManyWithoutModelsInput = {
    create?: XOR<ClaimCreateWithoutModelsInput, ClaimUncheckedCreateWithoutModelsInput> | ClaimCreateWithoutModelsInput[] | ClaimUncheckedCreateWithoutModelsInput[]
    connectOrCreate?: ClaimCreateOrConnectWithoutModelsInput | ClaimCreateOrConnectWithoutModelsInput[]
    createMany?: ClaimCreateManyModelsInputEnvelope
    connect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
  }

  export type OrganizationCreateNestedOneWithoutModelsInput = {
    create?: XOR<OrganizationCreateWithoutModelsInput, OrganizationUncheckedCreateWithoutModelsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutModelsInput
    connect?: OrganizationWhereUniqueInput
  }

  export type PartsCreateNestedManyWithoutModelsInput = {
    create?: XOR<PartsCreateWithoutModelsInput, PartsUncheckedCreateWithoutModelsInput> | PartsCreateWithoutModelsInput[] | PartsUncheckedCreateWithoutModelsInput[]
    connectOrCreate?: PartsCreateOrConnectWithoutModelsInput | PartsCreateOrConnectWithoutModelsInput[]
    connect?: PartsWhereUniqueInput | PartsWhereUniqueInput[]
  }

  export type ModelsCreatepartsIdInput = {
    set: string[]
  }

  export type ClaimUncheckedCreateNestedManyWithoutModelsInput = {
    create?: XOR<ClaimCreateWithoutModelsInput, ClaimUncheckedCreateWithoutModelsInput> | ClaimCreateWithoutModelsInput[] | ClaimUncheckedCreateWithoutModelsInput[]
    connectOrCreate?: ClaimCreateOrConnectWithoutModelsInput | ClaimCreateOrConnectWithoutModelsInput[]
    createMany?: ClaimCreateManyModelsInputEnvelope
    connect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
  }

  export type PartsUncheckedCreateNestedManyWithoutModelsInput = {
    create?: XOR<PartsCreateWithoutModelsInput, PartsUncheckedCreateWithoutModelsInput> | PartsCreateWithoutModelsInput[] | PartsUncheckedCreateWithoutModelsInput[]
    connectOrCreate?: PartsCreateOrConnectWithoutModelsInput | PartsCreateOrConnectWithoutModelsInput[]
    connect?: PartsWhereUniqueInput | PartsWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type ModelsUpdateclaimIdInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ClaimUpdateManyWithoutModelsNestedInput = {
    create?: XOR<ClaimCreateWithoutModelsInput, ClaimUncheckedCreateWithoutModelsInput> | ClaimCreateWithoutModelsInput[] | ClaimUncheckedCreateWithoutModelsInput[]
    connectOrCreate?: ClaimCreateOrConnectWithoutModelsInput | ClaimCreateOrConnectWithoutModelsInput[]
    upsert?: ClaimUpsertWithWhereUniqueWithoutModelsInput | ClaimUpsertWithWhereUniqueWithoutModelsInput[]
    createMany?: ClaimCreateManyModelsInputEnvelope
    set?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    disconnect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    delete?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    connect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    update?: ClaimUpdateWithWhereUniqueWithoutModelsInput | ClaimUpdateWithWhereUniqueWithoutModelsInput[]
    updateMany?: ClaimUpdateManyWithWhereWithoutModelsInput | ClaimUpdateManyWithWhereWithoutModelsInput[]
    deleteMany?: ClaimScalarWhereInput | ClaimScalarWhereInput[]
  }

  export type OrganizationUpdateOneRequiredWithoutModelsNestedInput = {
    create?: XOR<OrganizationCreateWithoutModelsInput, OrganizationUncheckedCreateWithoutModelsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutModelsInput
    upsert?: OrganizationUpsertWithoutModelsInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutModelsInput, OrganizationUpdateWithoutModelsInput>, OrganizationUncheckedUpdateWithoutModelsInput>
  }

  export type PartsUpdateManyWithoutModelsNestedInput = {
    create?: XOR<PartsCreateWithoutModelsInput, PartsUncheckedCreateWithoutModelsInput> | PartsCreateWithoutModelsInput[] | PartsUncheckedCreateWithoutModelsInput[]
    connectOrCreate?: PartsCreateOrConnectWithoutModelsInput | PartsCreateOrConnectWithoutModelsInput[]
    upsert?: PartsUpsertWithWhereUniqueWithoutModelsInput | PartsUpsertWithWhereUniqueWithoutModelsInput[]
    set?: PartsWhereUniqueInput | PartsWhereUniqueInput[]
    disconnect?: PartsWhereUniqueInput | PartsWhereUniqueInput[]
    delete?: PartsWhereUniqueInput | PartsWhereUniqueInput[]
    connect?: PartsWhereUniqueInput | PartsWhereUniqueInput[]
    update?: PartsUpdateWithWhereUniqueWithoutModelsInput | PartsUpdateWithWhereUniqueWithoutModelsInput[]
    updateMany?: PartsUpdateManyWithWhereWithoutModelsInput | PartsUpdateManyWithWhereWithoutModelsInput[]
    deleteMany?: PartsScalarWhereInput | PartsScalarWhereInput[]
  }

  export type ModelsUpdatepartsIdInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ClaimUncheckedUpdateManyWithoutModelsNestedInput = {
    create?: XOR<ClaimCreateWithoutModelsInput, ClaimUncheckedCreateWithoutModelsInput> | ClaimCreateWithoutModelsInput[] | ClaimUncheckedCreateWithoutModelsInput[]
    connectOrCreate?: ClaimCreateOrConnectWithoutModelsInput | ClaimCreateOrConnectWithoutModelsInput[]
    upsert?: ClaimUpsertWithWhereUniqueWithoutModelsInput | ClaimUpsertWithWhereUniqueWithoutModelsInput[]
    createMany?: ClaimCreateManyModelsInputEnvelope
    set?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    disconnect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    delete?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    connect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    update?: ClaimUpdateWithWhereUniqueWithoutModelsInput | ClaimUpdateWithWhereUniqueWithoutModelsInput[]
    updateMany?: ClaimUpdateManyWithWhereWithoutModelsInput | ClaimUpdateManyWithWhereWithoutModelsInput[]
    deleteMany?: ClaimScalarWhereInput | ClaimScalarWhereInput[]
  }

  export type PartsUncheckedUpdateManyWithoutModelsNestedInput = {
    create?: XOR<PartsCreateWithoutModelsInput, PartsUncheckedCreateWithoutModelsInput> | PartsCreateWithoutModelsInput[] | PartsUncheckedCreateWithoutModelsInput[]
    connectOrCreate?: PartsCreateOrConnectWithoutModelsInput | PartsCreateOrConnectWithoutModelsInput[]
    upsert?: PartsUpsertWithWhereUniqueWithoutModelsInput | PartsUpsertWithWhereUniqueWithoutModelsInput[]
    set?: PartsWhereUniqueInput | PartsWhereUniqueInput[]
    disconnect?: PartsWhereUniqueInput | PartsWhereUniqueInput[]
    delete?: PartsWhereUniqueInput | PartsWhereUniqueInput[]
    connect?: PartsWhereUniqueInput | PartsWhereUniqueInput[]
    update?: PartsUpdateWithWhereUniqueWithoutModelsInput | PartsUpdateWithWhereUniqueWithoutModelsInput[]
    updateMany?: PartsUpdateManyWithWhereWithoutModelsInput | PartsUpdateManyWithWhereWithoutModelsInput[]
    deleteMany?: PartsScalarWhereInput | PartsScalarWhereInput[]
  }

  export type PartsCreateclaimIdInput = {
    set: string[]
  }

  export type ClaimCreateNestedManyWithoutPartsInput = {
    create?: XOR<ClaimCreateWithoutPartsInput, ClaimUncheckedCreateWithoutPartsInput> | ClaimCreateWithoutPartsInput[] | ClaimUncheckedCreateWithoutPartsInput[]
    connectOrCreate?: ClaimCreateOrConnectWithoutPartsInput | ClaimCreateOrConnectWithoutPartsInput[]
    createMany?: ClaimCreateManyPartsInputEnvelope
    connect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
  }

  export type EntityCreateNestedOneWithoutPartsInput = {
    create?: XOR<EntityCreateWithoutPartsInput, EntityUncheckedCreateWithoutPartsInput>
    connectOrCreate?: EntityCreateOrConnectWithoutPartsInput
    connect?: EntityWhereUniqueInput
  }

  export type OrganizationCreateNestedOneWithoutPartsInput = {
    create?: XOR<OrganizationCreateWithoutPartsInput, OrganizationUncheckedCreateWithoutPartsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutPartsInput
    connect?: OrganizationWhereUniqueInput
  }

  export type ModelsCreateNestedManyWithoutPartsInput = {
    create?: XOR<ModelsCreateWithoutPartsInput, ModelsUncheckedCreateWithoutPartsInput> | ModelsCreateWithoutPartsInput[] | ModelsUncheckedCreateWithoutPartsInput[]
    connectOrCreate?: ModelsCreateOrConnectWithoutPartsInput | ModelsCreateOrConnectWithoutPartsInput[]
    connect?: ModelsWhereUniqueInput | ModelsWhereUniqueInput[]
  }

  export type PartsCreatemodelsIdInput = {
    set: string[]
  }

  export type ClaimUncheckedCreateNestedManyWithoutPartsInput = {
    create?: XOR<ClaimCreateWithoutPartsInput, ClaimUncheckedCreateWithoutPartsInput> | ClaimCreateWithoutPartsInput[] | ClaimUncheckedCreateWithoutPartsInput[]
    connectOrCreate?: ClaimCreateOrConnectWithoutPartsInput | ClaimCreateOrConnectWithoutPartsInput[]
    createMany?: ClaimCreateManyPartsInputEnvelope
    connect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
  }

  export type ModelsUncheckedCreateNestedManyWithoutPartsInput = {
    create?: XOR<ModelsCreateWithoutPartsInput, ModelsUncheckedCreateWithoutPartsInput> | ModelsCreateWithoutPartsInput[] | ModelsUncheckedCreateWithoutPartsInput[]
    connectOrCreate?: ModelsCreateOrConnectWithoutPartsInput | ModelsCreateOrConnectWithoutPartsInput[]
    connect?: ModelsWhereUniqueInput | ModelsWhereUniqueInput[]
  }

  export type PartsUpdateclaimIdInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ClaimUpdateManyWithoutPartsNestedInput = {
    create?: XOR<ClaimCreateWithoutPartsInput, ClaimUncheckedCreateWithoutPartsInput> | ClaimCreateWithoutPartsInput[] | ClaimUncheckedCreateWithoutPartsInput[]
    connectOrCreate?: ClaimCreateOrConnectWithoutPartsInput | ClaimCreateOrConnectWithoutPartsInput[]
    upsert?: ClaimUpsertWithWhereUniqueWithoutPartsInput | ClaimUpsertWithWhereUniqueWithoutPartsInput[]
    createMany?: ClaimCreateManyPartsInputEnvelope
    set?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    disconnect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    delete?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    connect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    update?: ClaimUpdateWithWhereUniqueWithoutPartsInput | ClaimUpdateWithWhereUniqueWithoutPartsInput[]
    updateMany?: ClaimUpdateManyWithWhereWithoutPartsInput | ClaimUpdateManyWithWhereWithoutPartsInput[]
    deleteMany?: ClaimScalarWhereInput | ClaimScalarWhereInput[]
  }

  export type EntityUpdateOneWithoutPartsNestedInput = {
    create?: XOR<EntityCreateWithoutPartsInput, EntityUncheckedCreateWithoutPartsInput>
    connectOrCreate?: EntityCreateOrConnectWithoutPartsInput
    upsert?: EntityUpsertWithoutPartsInput
    disconnect?: boolean
    delete?: EntityWhereInput | boolean
    connect?: EntityWhereUniqueInput
    update?: XOR<XOR<EntityUpdateToOneWithWhereWithoutPartsInput, EntityUpdateWithoutPartsInput>, EntityUncheckedUpdateWithoutPartsInput>
  }

  export type OrganizationUpdateOneWithoutPartsNestedInput = {
    create?: XOR<OrganizationCreateWithoutPartsInput, OrganizationUncheckedCreateWithoutPartsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutPartsInput
    upsert?: OrganizationUpsertWithoutPartsInput
    disconnect?: boolean
    delete?: OrganizationWhereInput | boolean
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutPartsInput, OrganizationUpdateWithoutPartsInput>, OrganizationUncheckedUpdateWithoutPartsInput>
  }

  export type ModelsUpdateManyWithoutPartsNestedInput = {
    create?: XOR<ModelsCreateWithoutPartsInput, ModelsUncheckedCreateWithoutPartsInput> | ModelsCreateWithoutPartsInput[] | ModelsUncheckedCreateWithoutPartsInput[]
    connectOrCreate?: ModelsCreateOrConnectWithoutPartsInput | ModelsCreateOrConnectWithoutPartsInput[]
    upsert?: ModelsUpsertWithWhereUniqueWithoutPartsInput | ModelsUpsertWithWhereUniqueWithoutPartsInput[]
    set?: ModelsWhereUniqueInput | ModelsWhereUniqueInput[]
    disconnect?: ModelsWhereUniqueInput | ModelsWhereUniqueInput[]
    delete?: ModelsWhereUniqueInput | ModelsWhereUniqueInput[]
    connect?: ModelsWhereUniqueInput | ModelsWhereUniqueInput[]
    update?: ModelsUpdateWithWhereUniqueWithoutPartsInput | ModelsUpdateWithWhereUniqueWithoutPartsInput[]
    updateMany?: ModelsUpdateManyWithWhereWithoutPartsInput | ModelsUpdateManyWithWhereWithoutPartsInput[]
    deleteMany?: ModelsScalarWhereInput | ModelsScalarWhereInput[]
  }

  export type PartsUpdatemodelsIdInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ClaimUncheckedUpdateManyWithoutPartsNestedInput = {
    create?: XOR<ClaimCreateWithoutPartsInput, ClaimUncheckedCreateWithoutPartsInput> | ClaimCreateWithoutPartsInput[] | ClaimUncheckedCreateWithoutPartsInput[]
    connectOrCreate?: ClaimCreateOrConnectWithoutPartsInput | ClaimCreateOrConnectWithoutPartsInput[]
    upsert?: ClaimUpsertWithWhereUniqueWithoutPartsInput | ClaimUpsertWithWhereUniqueWithoutPartsInput[]
    createMany?: ClaimCreateManyPartsInputEnvelope
    set?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    disconnect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    delete?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    connect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    update?: ClaimUpdateWithWhereUniqueWithoutPartsInput | ClaimUpdateWithWhereUniqueWithoutPartsInput[]
    updateMany?: ClaimUpdateManyWithWhereWithoutPartsInput | ClaimUpdateManyWithWhereWithoutPartsInput[]
    deleteMany?: ClaimScalarWhereInput | ClaimScalarWhereInput[]
  }

  export type ModelsUncheckedUpdateManyWithoutPartsNestedInput = {
    create?: XOR<ModelsCreateWithoutPartsInput, ModelsUncheckedCreateWithoutPartsInput> | ModelsCreateWithoutPartsInput[] | ModelsUncheckedCreateWithoutPartsInput[]
    connectOrCreate?: ModelsCreateOrConnectWithoutPartsInput | ModelsCreateOrConnectWithoutPartsInput[]
    upsert?: ModelsUpsertWithWhereUniqueWithoutPartsInput | ModelsUpsertWithWhereUniqueWithoutPartsInput[]
    set?: ModelsWhereUniqueInput | ModelsWhereUniqueInput[]
    disconnect?: ModelsWhereUniqueInput | ModelsWhereUniqueInput[]
    delete?: ModelsWhereUniqueInput | ModelsWhereUniqueInput[]
    connect?: ModelsWhereUniqueInput | ModelsWhereUniqueInput[]
    update?: ModelsUpdateWithWhereUniqueWithoutPartsInput | ModelsUpdateWithWhereUniqueWithoutPartsInput[]
    updateMany?: ModelsUpdateManyWithWhereWithoutPartsInput | ModelsUpdateManyWithWhereWithoutPartsInput[]
    deleteMany?: ModelsScalarWhereInput | ModelsScalarWhereInput[]
  }

  export type ProblemCreateNestedOneWithoutClaimInput = {
    create?: XOR<ProblemCreateWithoutClaimInput, ProblemUncheckedCreateWithoutClaimInput>
    connectOrCreate?: ProblemCreateOrConnectWithoutClaimInput
    connect?: ProblemWhereUniqueInput
  }

  export type InvestigationCreateNestedOneWithoutClaimsInput = {
    create?: XOR<InvestigationCreateWithoutClaimsInput, InvestigationUncheckedCreateWithoutClaimsInput>
    connectOrCreate?: InvestigationCreateOrConnectWithoutClaimsInput
    connect?: InvestigationWhereUniqueInput
  }

  export type ModelsCreateNestedOneWithoutClaimsInput = {
    create?: XOR<ModelsCreateWithoutClaimsInput, ModelsUncheckedCreateWithoutClaimsInput>
    connectOrCreate?: ModelsCreateOrConnectWithoutClaimsInput
    connect?: ModelsWhereUniqueInput
  }

  export type PartsCreateNestedOneWithoutClaimsInput = {
    create?: XOR<PartsCreateWithoutClaimsInput, PartsUncheckedCreateWithoutClaimsInput>
    connectOrCreate?: PartsCreateOrConnectWithoutClaimsInput
    connect?: PartsWhereUniqueInput
  }

  export type ShipmentCreateNestedOneWithoutClaimsInput = {
    create?: XOR<ShipmentCreateWithoutClaimsInput, ShipmentUncheckedCreateWithoutClaimsInput>
    connectOrCreate?: ShipmentCreateOrConnectWithoutClaimsInput
    connect?: ShipmentWhereUniqueInput
  }

  export type ClaimToEntityCreateNestedManyWithoutClaimInput = {
    create?: XOR<ClaimToEntityCreateWithoutClaimInput, ClaimToEntityUncheckedCreateWithoutClaimInput> | ClaimToEntityCreateWithoutClaimInput[] | ClaimToEntityUncheckedCreateWithoutClaimInput[]
    connectOrCreate?: ClaimToEntityCreateOrConnectWithoutClaimInput | ClaimToEntityCreateOrConnectWithoutClaimInput[]
    createMany?: ClaimToEntityCreateManyClaimInputEnvelope
    connect?: ClaimToEntityWhereUniqueInput | ClaimToEntityWhereUniqueInput[]
  }

  export type ClaimToEntityUncheckedCreateNestedManyWithoutClaimInput = {
    create?: XOR<ClaimToEntityCreateWithoutClaimInput, ClaimToEntityUncheckedCreateWithoutClaimInput> | ClaimToEntityCreateWithoutClaimInput[] | ClaimToEntityUncheckedCreateWithoutClaimInput[]
    connectOrCreate?: ClaimToEntityCreateOrConnectWithoutClaimInput | ClaimToEntityCreateOrConnectWithoutClaimInput[]
    createMany?: ClaimToEntityCreateManyClaimInputEnvelope
    connect?: ClaimToEntityWhereUniqueInput | ClaimToEntityWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ProblemUpdateOneWithoutClaimNestedInput = {
    create?: XOR<ProblemCreateWithoutClaimInput, ProblemUncheckedCreateWithoutClaimInput>
    connectOrCreate?: ProblemCreateOrConnectWithoutClaimInput
    upsert?: ProblemUpsertWithoutClaimInput
    disconnect?: boolean
    delete?: ProblemWhereInput | boolean
    connect?: ProblemWhereUniqueInput
    update?: XOR<XOR<ProblemUpdateToOneWithWhereWithoutClaimInput, ProblemUpdateWithoutClaimInput>, ProblemUncheckedUpdateWithoutClaimInput>
  }

  export type InvestigationUpdateOneWithoutClaimsNestedInput = {
    create?: XOR<InvestigationCreateWithoutClaimsInput, InvestigationUncheckedCreateWithoutClaimsInput>
    connectOrCreate?: InvestigationCreateOrConnectWithoutClaimsInput
    upsert?: InvestigationUpsertWithoutClaimsInput
    disconnect?: boolean
    delete?: InvestigationWhereInput | boolean
    connect?: InvestigationWhereUniqueInput
    update?: XOR<XOR<InvestigationUpdateToOneWithWhereWithoutClaimsInput, InvestigationUpdateWithoutClaimsInput>, InvestigationUncheckedUpdateWithoutClaimsInput>
  }

  export type ModelsUpdateOneWithoutClaimsNestedInput = {
    create?: XOR<ModelsCreateWithoutClaimsInput, ModelsUncheckedCreateWithoutClaimsInput>
    connectOrCreate?: ModelsCreateOrConnectWithoutClaimsInput
    upsert?: ModelsUpsertWithoutClaimsInput
    disconnect?: boolean
    delete?: ModelsWhereInput | boolean
    connect?: ModelsWhereUniqueInput
    update?: XOR<XOR<ModelsUpdateToOneWithWhereWithoutClaimsInput, ModelsUpdateWithoutClaimsInput>, ModelsUncheckedUpdateWithoutClaimsInput>
  }

  export type PartsUpdateOneWithoutClaimsNestedInput = {
    create?: XOR<PartsCreateWithoutClaimsInput, PartsUncheckedCreateWithoutClaimsInput>
    connectOrCreate?: PartsCreateOrConnectWithoutClaimsInput
    upsert?: PartsUpsertWithoutClaimsInput
    disconnect?: boolean
    delete?: PartsWhereInput | boolean
    connect?: PartsWhereUniqueInput
    update?: XOR<XOR<PartsUpdateToOneWithWhereWithoutClaimsInput, PartsUpdateWithoutClaimsInput>, PartsUncheckedUpdateWithoutClaimsInput>
  }

  export type ShipmentUpdateOneWithoutClaimsNestedInput = {
    create?: XOR<ShipmentCreateWithoutClaimsInput, ShipmentUncheckedCreateWithoutClaimsInput>
    connectOrCreate?: ShipmentCreateOrConnectWithoutClaimsInput
    upsert?: ShipmentUpsertWithoutClaimsInput
    disconnect?: boolean
    delete?: ShipmentWhereInput | boolean
    connect?: ShipmentWhereUniqueInput
    update?: XOR<XOR<ShipmentUpdateToOneWithWhereWithoutClaimsInput, ShipmentUpdateWithoutClaimsInput>, ShipmentUncheckedUpdateWithoutClaimsInput>
  }

  export type ClaimToEntityUpdateManyWithoutClaimNestedInput = {
    create?: XOR<ClaimToEntityCreateWithoutClaimInput, ClaimToEntityUncheckedCreateWithoutClaimInput> | ClaimToEntityCreateWithoutClaimInput[] | ClaimToEntityUncheckedCreateWithoutClaimInput[]
    connectOrCreate?: ClaimToEntityCreateOrConnectWithoutClaimInput | ClaimToEntityCreateOrConnectWithoutClaimInput[]
    upsert?: ClaimToEntityUpsertWithWhereUniqueWithoutClaimInput | ClaimToEntityUpsertWithWhereUniqueWithoutClaimInput[]
    createMany?: ClaimToEntityCreateManyClaimInputEnvelope
    set?: ClaimToEntityWhereUniqueInput | ClaimToEntityWhereUniqueInput[]
    disconnect?: ClaimToEntityWhereUniqueInput | ClaimToEntityWhereUniqueInput[]
    delete?: ClaimToEntityWhereUniqueInput | ClaimToEntityWhereUniqueInput[]
    connect?: ClaimToEntityWhereUniqueInput | ClaimToEntityWhereUniqueInput[]
    update?: ClaimToEntityUpdateWithWhereUniqueWithoutClaimInput | ClaimToEntityUpdateWithWhereUniqueWithoutClaimInput[]
    updateMany?: ClaimToEntityUpdateManyWithWhereWithoutClaimInput | ClaimToEntityUpdateManyWithWhereWithoutClaimInput[]
    deleteMany?: ClaimToEntityScalarWhereInput | ClaimToEntityScalarWhereInput[]
  }

  export type ClaimToEntityUncheckedUpdateManyWithoutClaimNestedInput = {
    create?: XOR<ClaimToEntityCreateWithoutClaimInput, ClaimToEntityUncheckedCreateWithoutClaimInput> | ClaimToEntityCreateWithoutClaimInput[] | ClaimToEntityUncheckedCreateWithoutClaimInput[]
    connectOrCreate?: ClaimToEntityCreateOrConnectWithoutClaimInput | ClaimToEntityCreateOrConnectWithoutClaimInput[]
    upsert?: ClaimToEntityUpsertWithWhereUniqueWithoutClaimInput | ClaimToEntityUpsertWithWhereUniqueWithoutClaimInput[]
    createMany?: ClaimToEntityCreateManyClaimInputEnvelope
    set?: ClaimToEntityWhereUniqueInput | ClaimToEntityWhereUniqueInput[]
    disconnect?: ClaimToEntityWhereUniqueInput | ClaimToEntityWhereUniqueInput[]
    delete?: ClaimToEntityWhereUniqueInput | ClaimToEntityWhereUniqueInput[]
    connect?: ClaimToEntityWhereUniqueInput | ClaimToEntityWhereUniqueInput[]
    update?: ClaimToEntityUpdateWithWhereUniqueWithoutClaimInput | ClaimToEntityUpdateWithWhereUniqueWithoutClaimInput[]
    updateMany?: ClaimToEntityUpdateManyWithWhereWithoutClaimInput | ClaimToEntityUpdateManyWithWhereWithoutClaimInput[]
    deleteMany?: ClaimToEntityScalarWhereInput | ClaimToEntityScalarWhereInput[]
  }

  export type InvestigationCreateNestedManyWithoutProblemInput = {
    create?: XOR<InvestigationCreateWithoutProblemInput, InvestigationUncheckedCreateWithoutProblemInput> | InvestigationCreateWithoutProblemInput[] | InvestigationUncheckedCreateWithoutProblemInput[]
    connectOrCreate?: InvestigationCreateOrConnectWithoutProblemInput | InvestigationCreateOrConnectWithoutProblemInput[]
    createMany?: InvestigationCreateManyProblemInputEnvelope
    connect?: InvestigationWhereUniqueInput | InvestigationWhereUniqueInput[]
  }

  export type ClaimCreateNestedManyWithoutProblemInput = {
    create?: XOR<ClaimCreateWithoutProblemInput, ClaimUncheckedCreateWithoutProblemInput> | ClaimCreateWithoutProblemInput[] | ClaimUncheckedCreateWithoutProblemInput[]
    connectOrCreate?: ClaimCreateOrConnectWithoutProblemInput | ClaimCreateOrConnectWithoutProblemInput[]
    createMany?: ClaimCreateManyProblemInputEnvelope
    connect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
  }

  export type OrganizationCreateNestedOneWithoutProblemInput = {
    create?: XOR<OrganizationCreateWithoutProblemInput, OrganizationUncheckedCreateWithoutProblemInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutProblemInput
    connect?: OrganizationWhereUniqueInput
  }

  export type InvestigationUncheckedCreateNestedManyWithoutProblemInput = {
    create?: XOR<InvestigationCreateWithoutProblemInput, InvestigationUncheckedCreateWithoutProblemInput> | InvestigationCreateWithoutProblemInput[] | InvestigationUncheckedCreateWithoutProblemInput[]
    connectOrCreate?: InvestigationCreateOrConnectWithoutProblemInput | InvestigationCreateOrConnectWithoutProblemInput[]
    createMany?: InvestigationCreateManyProblemInputEnvelope
    connect?: InvestigationWhereUniqueInput | InvestigationWhereUniqueInput[]
  }

  export type ClaimUncheckedCreateNestedManyWithoutProblemInput = {
    create?: XOR<ClaimCreateWithoutProblemInput, ClaimUncheckedCreateWithoutProblemInput> | ClaimCreateWithoutProblemInput[] | ClaimUncheckedCreateWithoutProblemInput[]
    connectOrCreate?: ClaimCreateOrConnectWithoutProblemInput | ClaimCreateOrConnectWithoutProblemInput[]
    createMany?: ClaimCreateManyProblemInputEnvelope
    connect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
  }

  export type InvestigationUpdateManyWithoutProblemNestedInput = {
    create?: XOR<InvestigationCreateWithoutProblemInput, InvestigationUncheckedCreateWithoutProblemInput> | InvestigationCreateWithoutProblemInput[] | InvestigationUncheckedCreateWithoutProblemInput[]
    connectOrCreate?: InvestigationCreateOrConnectWithoutProblemInput | InvestigationCreateOrConnectWithoutProblemInput[]
    upsert?: InvestigationUpsertWithWhereUniqueWithoutProblemInput | InvestigationUpsertWithWhereUniqueWithoutProblemInput[]
    createMany?: InvestigationCreateManyProblemInputEnvelope
    set?: InvestigationWhereUniqueInput | InvestigationWhereUniqueInput[]
    disconnect?: InvestigationWhereUniqueInput | InvestigationWhereUniqueInput[]
    delete?: InvestigationWhereUniqueInput | InvestigationWhereUniqueInput[]
    connect?: InvestigationWhereUniqueInput | InvestigationWhereUniqueInput[]
    update?: InvestigationUpdateWithWhereUniqueWithoutProblemInput | InvestigationUpdateWithWhereUniqueWithoutProblemInput[]
    updateMany?: InvestigationUpdateManyWithWhereWithoutProblemInput | InvestigationUpdateManyWithWhereWithoutProblemInput[]
    deleteMany?: InvestigationScalarWhereInput | InvestigationScalarWhereInput[]
  }

  export type ClaimUpdateManyWithoutProblemNestedInput = {
    create?: XOR<ClaimCreateWithoutProblemInput, ClaimUncheckedCreateWithoutProblemInput> | ClaimCreateWithoutProblemInput[] | ClaimUncheckedCreateWithoutProblemInput[]
    connectOrCreate?: ClaimCreateOrConnectWithoutProblemInput | ClaimCreateOrConnectWithoutProblemInput[]
    upsert?: ClaimUpsertWithWhereUniqueWithoutProblemInput | ClaimUpsertWithWhereUniqueWithoutProblemInput[]
    createMany?: ClaimCreateManyProblemInputEnvelope
    set?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    disconnect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    delete?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    connect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    update?: ClaimUpdateWithWhereUniqueWithoutProblemInput | ClaimUpdateWithWhereUniqueWithoutProblemInput[]
    updateMany?: ClaimUpdateManyWithWhereWithoutProblemInput | ClaimUpdateManyWithWhereWithoutProblemInput[]
    deleteMany?: ClaimScalarWhereInput | ClaimScalarWhereInput[]
  }

  export type OrganizationUpdateOneRequiredWithoutProblemNestedInput = {
    create?: XOR<OrganizationCreateWithoutProblemInput, OrganizationUncheckedCreateWithoutProblemInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutProblemInput
    upsert?: OrganizationUpsertWithoutProblemInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutProblemInput, OrganizationUpdateWithoutProblemInput>, OrganizationUncheckedUpdateWithoutProblemInput>
  }

  export type InvestigationUncheckedUpdateManyWithoutProblemNestedInput = {
    create?: XOR<InvestigationCreateWithoutProblemInput, InvestigationUncheckedCreateWithoutProblemInput> | InvestigationCreateWithoutProblemInput[] | InvestigationUncheckedCreateWithoutProblemInput[]
    connectOrCreate?: InvestigationCreateOrConnectWithoutProblemInput | InvestigationCreateOrConnectWithoutProblemInput[]
    upsert?: InvestigationUpsertWithWhereUniqueWithoutProblemInput | InvestigationUpsertWithWhereUniqueWithoutProblemInput[]
    createMany?: InvestigationCreateManyProblemInputEnvelope
    set?: InvestigationWhereUniqueInput | InvestigationWhereUniqueInput[]
    disconnect?: InvestigationWhereUniqueInput | InvestigationWhereUniqueInput[]
    delete?: InvestigationWhereUniqueInput | InvestigationWhereUniqueInput[]
    connect?: InvestigationWhereUniqueInput | InvestigationWhereUniqueInput[]
    update?: InvestigationUpdateWithWhereUniqueWithoutProblemInput | InvestigationUpdateWithWhereUniqueWithoutProblemInput[]
    updateMany?: InvestigationUpdateManyWithWhereWithoutProblemInput | InvestigationUpdateManyWithWhereWithoutProblemInput[]
    deleteMany?: InvestigationScalarWhereInput | InvestigationScalarWhereInput[]
  }

  export type ClaimUncheckedUpdateManyWithoutProblemNestedInput = {
    create?: XOR<ClaimCreateWithoutProblemInput, ClaimUncheckedCreateWithoutProblemInput> | ClaimCreateWithoutProblemInput[] | ClaimUncheckedCreateWithoutProblemInput[]
    connectOrCreate?: ClaimCreateOrConnectWithoutProblemInput | ClaimCreateOrConnectWithoutProblemInput[]
    upsert?: ClaimUpsertWithWhereUniqueWithoutProblemInput | ClaimUpsertWithWhereUniqueWithoutProblemInput[]
    createMany?: ClaimCreateManyProblemInputEnvelope
    set?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    disconnect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    delete?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    connect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    update?: ClaimUpdateWithWhereUniqueWithoutProblemInput | ClaimUpdateWithWhereUniqueWithoutProblemInput[]
    updateMany?: ClaimUpdateManyWithWhereWithoutProblemInput | ClaimUpdateManyWithWhereWithoutProblemInput[]
    deleteMany?: ClaimScalarWhereInput | ClaimScalarWhereInput[]
  }

  export type ClaimCreateNestedOneWithoutClaimToEntityInput = {
    create?: XOR<ClaimCreateWithoutClaimToEntityInput, ClaimUncheckedCreateWithoutClaimToEntityInput>
    connectOrCreate?: ClaimCreateOrConnectWithoutClaimToEntityInput
    connect?: ClaimWhereUniqueInput
  }

  export type EntityCreateNestedOneWithoutClaimToEntityInput = {
    create?: XOR<EntityCreateWithoutClaimToEntityInput, EntityUncheckedCreateWithoutClaimToEntityInput>
    connectOrCreate?: EntityCreateOrConnectWithoutClaimToEntityInput
    connect?: EntityWhereUniqueInput
  }

  export type ClaimUpdateOneRequiredWithoutClaimToEntityNestedInput = {
    create?: XOR<ClaimCreateWithoutClaimToEntityInput, ClaimUncheckedCreateWithoutClaimToEntityInput>
    connectOrCreate?: ClaimCreateOrConnectWithoutClaimToEntityInput
    upsert?: ClaimUpsertWithoutClaimToEntityInput
    connect?: ClaimWhereUniqueInput
    update?: XOR<XOR<ClaimUpdateToOneWithWhereWithoutClaimToEntityInput, ClaimUpdateWithoutClaimToEntityInput>, ClaimUncheckedUpdateWithoutClaimToEntityInput>
  }

  export type EntityUpdateOneRequiredWithoutClaimToEntityNestedInput = {
    create?: XOR<EntityCreateWithoutClaimToEntityInput, EntityUncheckedCreateWithoutClaimToEntityInput>
    connectOrCreate?: EntityCreateOrConnectWithoutClaimToEntityInput
    upsert?: EntityUpsertWithoutClaimToEntityInput
    connect?: EntityWhereUniqueInput
    update?: XOR<XOR<EntityUpdateToOneWithWhereWithoutClaimToEntityInput, EntityUpdateWithoutClaimToEntityInput>, EntityUncheckedUpdateWithoutClaimToEntityInput>
  }

  export type InvestigationCreateattachmentInput = {
    set: InputJsonValue[]
  }

  export type ClaimCreateNestedManyWithoutInvestigationsInput = {
    create?: XOR<ClaimCreateWithoutInvestigationsInput, ClaimUncheckedCreateWithoutInvestigationsInput> | ClaimCreateWithoutInvestigationsInput[] | ClaimUncheckedCreateWithoutInvestigationsInput[]
    connectOrCreate?: ClaimCreateOrConnectWithoutInvestigationsInput | ClaimCreateOrConnectWithoutInvestigationsInput[]
    createMany?: ClaimCreateManyInvestigationsInputEnvelope
    connect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
  }

  export type ProblemCreateNestedOneWithoutInvestigationsInput = {
    create?: XOR<ProblemCreateWithoutInvestigationsInput, ProblemUncheckedCreateWithoutInvestigationsInput>
    connectOrCreate?: ProblemCreateOrConnectWithoutInvestigationsInput
    connect?: ProblemWhereUniqueInput
  }

  export type ClaimUncheckedCreateNestedManyWithoutInvestigationsInput = {
    create?: XOR<ClaimCreateWithoutInvestigationsInput, ClaimUncheckedCreateWithoutInvestigationsInput> | ClaimCreateWithoutInvestigationsInput[] | ClaimUncheckedCreateWithoutInvestigationsInput[]
    connectOrCreate?: ClaimCreateOrConnectWithoutInvestigationsInput | ClaimCreateOrConnectWithoutInvestigationsInput[]
    createMany?: ClaimCreateManyInvestigationsInputEnvelope
    connect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
  }

  export type InvestigationUpdateattachmentInput = {
    set?: InputJsonValue[]
    push?: InputJsonValue | InputJsonValue[]
  }

  export type ClaimUpdateManyWithoutInvestigationsNestedInput = {
    create?: XOR<ClaimCreateWithoutInvestigationsInput, ClaimUncheckedCreateWithoutInvestigationsInput> | ClaimCreateWithoutInvestigationsInput[] | ClaimUncheckedCreateWithoutInvestigationsInput[]
    connectOrCreate?: ClaimCreateOrConnectWithoutInvestigationsInput | ClaimCreateOrConnectWithoutInvestigationsInput[]
    upsert?: ClaimUpsertWithWhereUniqueWithoutInvestigationsInput | ClaimUpsertWithWhereUniqueWithoutInvestigationsInput[]
    createMany?: ClaimCreateManyInvestigationsInputEnvelope
    set?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    disconnect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    delete?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    connect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    update?: ClaimUpdateWithWhereUniqueWithoutInvestigationsInput | ClaimUpdateWithWhereUniqueWithoutInvestigationsInput[]
    updateMany?: ClaimUpdateManyWithWhereWithoutInvestigationsInput | ClaimUpdateManyWithWhereWithoutInvestigationsInput[]
    deleteMany?: ClaimScalarWhereInput | ClaimScalarWhereInput[]
  }

  export type ProblemUpdateOneWithoutInvestigationsNestedInput = {
    create?: XOR<ProblemCreateWithoutInvestigationsInput, ProblemUncheckedCreateWithoutInvestigationsInput>
    connectOrCreate?: ProblemCreateOrConnectWithoutInvestigationsInput
    upsert?: ProblemUpsertWithoutInvestigationsInput
    disconnect?: boolean
    delete?: ProblemWhereInput | boolean
    connect?: ProblemWhereUniqueInput
    update?: XOR<XOR<ProblemUpdateToOneWithWhereWithoutInvestigationsInput, ProblemUpdateWithoutInvestigationsInput>, ProblemUncheckedUpdateWithoutInvestigationsInput>
  }

  export type ClaimUncheckedUpdateManyWithoutInvestigationsNestedInput = {
    create?: XOR<ClaimCreateWithoutInvestigationsInput, ClaimUncheckedCreateWithoutInvestigationsInput> | ClaimCreateWithoutInvestigationsInput[] | ClaimUncheckedCreateWithoutInvestigationsInput[]
    connectOrCreate?: ClaimCreateOrConnectWithoutInvestigationsInput | ClaimCreateOrConnectWithoutInvestigationsInput[]
    upsert?: ClaimUpsertWithWhereUniqueWithoutInvestigationsInput | ClaimUpsertWithWhereUniqueWithoutInvestigationsInput[]
    createMany?: ClaimCreateManyInvestigationsInputEnvelope
    set?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    disconnect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    delete?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    connect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    update?: ClaimUpdateWithWhereUniqueWithoutInvestigationsInput | ClaimUpdateWithWhereUniqueWithoutInvestigationsInput[]
    updateMany?: ClaimUpdateManyWithWhereWithoutInvestigationsInput | ClaimUpdateManyWithWhereWithoutInvestigationsInput[]
    deleteMany?: ClaimScalarWhereInput | ClaimScalarWhereInput[]
  }

  export type ShipmentCreatesupplierReportInput = {
    set: InputJsonValue[]
  }

  export type ClaimCreateNestedManyWithoutShipmentsInput = {
    create?: XOR<ClaimCreateWithoutShipmentsInput, ClaimUncheckedCreateWithoutShipmentsInput> | ClaimCreateWithoutShipmentsInput[] | ClaimUncheckedCreateWithoutShipmentsInput[]
    connectOrCreate?: ClaimCreateOrConnectWithoutShipmentsInput | ClaimCreateOrConnectWithoutShipmentsInput[]
    createMany?: ClaimCreateManyShipmentsInputEnvelope
    connect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
  }

  export type ClaimUncheckedCreateNestedManyWithoutShipmentsInput = {
    create?: XOR<ClaimCreateWithoutShipmentsInput, ClaimUncheckedCreateWithoutShipmentsInput> | ClaimCreateWithoutShipmentsInput[] | ClaimUncheckedCreateWithoutShipmentsInput[]
    connectOrCreate?: ClaimCreateOrConnectWithoutShipmentsInput | ClaimCreateOrConnectWithoutShipmentsInput[]
    createMany?: ClaimCreateManyShipmentsInputEnvelope
    connect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
    unset?: boolean
  }

  export type ShipmentUpdatesupplierReportInput = {
    set?: InputJsonValue[]
    push?: InputJsonValue | InputJsonValue[]
  }

  export type ClaimUpdateManyWithoutShipmentsNestedInput = {
    create?: XOR<ClaimCreateWithoutShipmentsInput, ClaimUncheckedCreateWithoutShipmentsInput> | ClaimCreateWithoutShipmentsInput[] | ClaimUncheckedCreateWithoutShipmentsInput[]
    connectOrCreate?: ClaimCreateOrConnectWithoutShipmentsInput | ClaimCreateOrConnectWithoutShipmentsInput[]
    upsert?: ClaimUpsertWithWhereUniqueWithoutShipmentsInput | ClaimUpsertWithWhereUniqueWithoutShipmentsInput[]
    createMany?: ClaimCreateManyShipmentsInputEnvelope
    set?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    disconnect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    delete?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    connect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    update?: ClaimUpdateWithWhereUniqueWithoutShipmentsInput | ClaimUpdateWithWhereUniqueWithoutShipmentsInput[]
    updateMany?: ClaimUpdateManyWithWhereWithoutShipmentsInput | ClaimUpdateManyWithWhereWithoutShipmentsInput[]
    deleteMany?: ClaimScalarWhereInput | ClaimScalarWhereInput[]
  }

  export type ClaimUncheckedUpdateManyWithoutShipmentsNestedInput = {
    create?: XOR<ClaimCreateWithoutShipmentsInput, ClaimUncheckedCreateWithoutShipmentsInput> | ClaimCreateWithoutShipmentsInput[] | ClaimUncheckedCreateWithoutShipmentsInput[]
    connectOrCreate?: ClaimCreateOrConnectWithoutShipmentsInput | ClaimCreateOrConnectWithoutShipmentsInput[]
    upsert?: ClaimUpsertWithWhereUniqueWithoutShipmentsInput | ClaimUpsertWithWhereUniqueWithoutShipmentsInput[]
    createMany?: ClaimCreateManyShipmentsInputEnvelope
    set?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    disconnect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    delete?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    connect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    update?: ClaimUpdateWithWhereUniqueWithoutShipmentsInput | ClaimUpdateWithWhereUniqueWithoutShipmentsInput[]
    updateMany?: ClaimUpdateManyWithWhereWithoutShipmentsInput | ClaimUpdateManyWithWhereWithoutShipmentsInput[]
    deleteMany?: ClaimScalarWhereInput | ClaimScalarWhereInput[]
  }

  export type OrganizationCreateactiveModulesInput = {
    set: string[]
  }

  export type BusinessCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<BusinessCreateWithoutOrganizationInput, BusinessUncheckedCreateWithoutOrganizationInput> | BusinessCreateWithoutOrganizationInput[] | BusinessUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: BusinessCreateOrConnectWithoutOrganizationInput | BusinessCreateOrConnectWithoutOrganizationInput[]
    createMany?: BusinessCreateManyOrganizationInputEnvelope
    connect?: BusinessWhereUniqueInput | BusinessWhereUniqueInput[]
  }

  export type DoctypeCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<DoctypeCreateWithoutOrganizationInput, DoctypeUncheckedCreateWithoutOrganizationInput> | DoctypeCreateWithoutOrganizationInput[] | DoctypeUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: DoctypeCreateOrConnectWithoutOrganizationInput | DoctypeCreateOrConnectWithoutOrganizationInput[]
    createMany?: DoctypeCreateManyOrganizationInputEnvelope
    connect?: DoctypeWhereUniqueInput | DoctypeWhereUniqueInput[]
  }

  export type DocumentsCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<DocumentsCreateWithoutOrganizationInput, DocumentsUncheckedCreateWithoutOrganizationInput> | DocumentsCreateWithoutOrganizationInput[] | DocumentsUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: DocumentsCreateOrConnectWithoutOrganizationInput | DocumentsCreateOrConnectWithoutOrganizationInput[]
    createMany?: DocumentsCreateManyOrganizationInputEnvelope
    connect?: DocumentsWhereUniqueInput | DocumentsWhereUniqueInput[]
  }

  export type EntityCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<EntityCreateWithoutOrganizationInput, EntityUncheckedCreateWithoutOrganizationInput> | EntityCreateWithoutOrganizationInput[] | EntityUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: EntityCreateOrConnectWithoutOrganizationInput | EntityCreateOrConnectWithoutOrganizationInput[]
    createMany?: EntityCreateManyOrganizationInputEnvelope
    connect?: EntityWhereUniqueInput | EntityWhereUniqueInput[]
  }

  export type EntityTypeCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<EntityTypeCreateWithoutOrganizationInput, EntityTypeUncheckedCreateWithoutOrganizationInput> | EntityTypeCreateWithoutOrganizationInput[] | EntityTypeUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: EntityTypeCreateOrConnectWithoutOrganizationInput | EntityTypeCreateOrConnectWithoutOrganizationInput[]
    createMany?: EntityTypeCreateManyOrganizationInputEnvelope
    connect?: EntityTypeWhereUniqueInput | EntityTypeWhereUniqueInput[]
  }

  export type LocationCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<LocationCreateWithoutOrganizationInput, LocationUncheckedCreateWithoutOrganizationInput> | LocationCreateWithoutOrganizationInput[] | LocationUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: LocationCreateOrConnectWithoutOrganizationInput | LocationCreateOrConnectWithoutOrganizationInput[]
    createMany?: LocationCreateManyOrganizationInputEnvelope
    connect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
  }

  export type RoleCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<RoleCreateWithoutOrganizationInput, RoleUncheckedCreateWithoutOrganizationInput> | RoleCreateWithoutOrganizationInput[] | RoleUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: RoleCreateOrConnectWithoutOrganizationInput | RoleCreateOrConnectWithoutOrganizationInput[]
    createMany?: RoleCreateManyOrganizationInputEnvelope
    connect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
  }

  export type SectionCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<SectionCreateWithoutOrganizationInput, SectionUncheckedCreateWithoutOrganizationInput> | SectionCreateWithoutOrganizationInput[] | SectionUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: SectionCreateOrConnectWithoutOrganizationInput | SectionCreateOrConnectWithoutOrganizationInput[]
    createMany?: SectionCreateManyOrganizationInputEnvelope
    connect?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
  }

  export type SystemTypeCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<SystemTypeCreateWithoutOrganizationInput, SystemTypeUncheckedCreateWithoutOrganizationInput> | SystemTypeCreateWithoutOrganizationInput[] | SystemTypeUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: SystemTypeCreateOrConnectWithoutOrganizationInput | SystemTypeCreateOrConnectWithoutOrganizationInput[]
    createMany?: SystemTypeCreateManyOrganizationInputEnvelope
    connect?: SystemTypeWhereUniqueInput | SystemTypeWhereUniqueInput[]
  }

  export type UserCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<UserCreateWithoutOrganizationInput, UserUncheckedCreateWithoutOrganizationInput> | UserCreateWithoutOrganizationInput[] | UserUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: UserCreateOrConnectWithoutOrganizationInput | UserCreateOrConnectWithoutOrganizationInput[]
    createMany?: UserCreateManyOrganizationInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type userPersonalisationCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<userPersonalisationCreateWithoutOrganizationInput, userPersonalisationUncheckedCreateWithoutOrganizationInput> | userPersonalisationCreateWithoutOrganizationInput[] | userPersonalisationUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: userPersonalisationCreateOrConnectWithoutOrganizationInput | userPersonalisationCreateOrConnectWithoutOrganizationInput[]
    createMany?: userPersonalisationCreateManyOrganizationInputEnvelope
    connect?: userPersonalisationWhereUniqueInput | userPersonalisationWhereUniqueInput[]
  }

  export type ConnectedAppsCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<ConnectedAppsCreateWithoutOrganizationInput, ConnectedAppsUncheckedCreateWithoutOrganizationInput> | ConnectedAppsCreateWithoutOrganizationInput[] | ConnectedAppsUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: ConnectedAppsCreateOrConnectWithoutOrganizationInput | ConnectedAppsCreateOrConnectWithoutOrganizationInput[]
    createMany?: ConnectedAppsCreateManyOrganizationInputEnvelope
    connect?: ConnectedAppsWhereUniqueInput | ConnectedAppsWhereUniqueInput[]
  }

  export type unitTypeCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<unitTypeCreateWithoutOrganizationInput, unitTypeUncheckedCreateWithoutOrganizationInput> | unitTypeCreateWithoutOrganizationInput[] | unitTypeUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: unitTypeCreateOrConnectWithoutOrganizationInput | unitTypeCreateOrConnectWithoutOrganizationInput[]
    createMany?: unitTypeCreateManyOrganizationInputEnvelope
    connect?: unitTypeWhereUniqueInput | unitTypeWhereUniqueInput[]
  }

  export type kpiCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<kpiCreateWithoutOrganizationInput, kpiUncheckedCreateWithoutOrganizationInput> | kpiCreateWithoutOrganizationInput[] | kpiUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: kpiCreateOrConnectWithoutOrganizationInput | kpiCreateOrConnectWithoutOrganizationInput[]
    createMany?: kpiCreateManyOrganizationInputEnvelope
    connect?: kpiWhereUniqueInput | kpiWhereUniqueInput[]
  }

  export type businessTypeCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<businessTypeCreateWithoutOrganizationInput, businessTypeUncheckedCreateWithoutOrganizationInput> | businessTypeCreateWithoutOrganizationInput[] | businessTypeUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: businessTypeCreateOrConnectWithoutOrganizationInput | businessTypeCreateOrConnectWithoutOrganizationInput[]
    createMany?: businessTypeCreateManyOrganizationInputEnvelope
    connect?: businessTypeWhereUniqueInput | businessTypeWhereUniqueInput[]
  }

  export type prefixSuffixCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<prefixSuffixCreateWithoutOrganizationInput, prefixSuffixUncheckedCreateWithoutOrganizationInput> | prefixSuffixCreateWithoutOrganizationInput[] | prefixSuffixUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: prefixSuffixCreateOrConnectWithoutOrganizationInput | prefixSuffixCreateOrConnectWithoutOrganizationInput[]
    createMany?: prefixSuffixCreateManyOrganizationInputEnvelope
    connect?: prefixSuffixWhereUniqueInput | prefixSuffixWhereUniqueInput[]
  }

  export type serialNumberCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<serialNumberCreateWithoutOrganizationInput, serialNumberUncheckedCreateWithoutOrganizationInput> | serialNumberCreateWithoutOrganizationInput[] | serialNumberUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: serialNumberCreateOrConnectWithoutOrganizationInput | serialNumberCreateOrConnectWithoutOrganizationInput[]
    createMany?: serialNumberCreateManyOrganizationInputEnvelope
    connect?: serialNumberWhereUniqueInput | serialNumberWhereUniqueInput[]
  }

  export type FunctionsCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<FunctionsCreateWithoutOrganizationInput, FunctionsUncheckedCreateWithoutOrganizationInput> | FunctionsCreateWithoutOrganizationInput[] | FunctionsUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: FunctionsCreateOrConnectWithoutOrganizationInput | FunctionsCreateOrConnectWithoutOrganizationInput[]
    createMany?: FunctionsCreateManyOrganizationInputEnvelope
    connect?: FunctionsWhereUniqueInput | FunctionsWhereUniqueInput[]
  }

  export type rolesTableCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<rolesTableCreateWithoutOrganizationInput, rolesTableUncheckedCreateWithoutOrganizationInput> | rolesTableCreateWithoutOrganizationInput[] | rolesTableUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: rolesTableCreateOrConnectWithoutOrganizationInput | rolesTableCreateOrConnectWithoutOrganizationInput[]
    createMany?: rolesTableCreateManyOrganizationInputEnvelope
    connect?: rolesTableWhereUniqueInput | rolesTableWhereUniqueInput[]
  }

  export type ProblemCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<ProblemCreateWithoutOrganizationInput, ProblemUncheckedCreateWithoutOrganizationInput> | ProblemCreateWithoutOrganizationInput[] | ProblemUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: ProblemCreateOrConnectWithoutOrganizationInput | ProblemCreateOrConnectWithoutOrganizationInput[]
    createMany?: ProblemCreateManyOrganizationInputEnvelope
    connect?: ProblemWhereUniqueInput | ProblemWhereUniqueInput[]
  }

  export type PartsCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<PartsCreateWithoutOrganizationInput, PartsUncheckedCreateWithoutOrganizationInput> | PartsCreateWithoutOrganizationInput[] | PartsUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: PartsCreateOrConnectWithoutOrganizationInput | PartsCreateOrConnectWithoutOrganizationInput[]
    createMany?: PartsCreateManyOrganizationInputEnvelope
    connect?: PartsWhereUniqueInput | PartsWhereUniqueInput[]
  }

  export type ModelsCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<ModelsCreateWithoutOrganizationInput, ModelsUncheckedCreateWithoutOrganizationInput> | ModelsCreateWithoutOrganizationInput[] | ModelsUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: ModelsCreateOrConnectWithoutOrganizationInput | ModelsCreateOrConnectWithoutOrganizationInput[]
    createMany?: ModelsCreateManyOrganizationInputEnvelope
    connect?: ModelsWhereUniqueInput | ModelsWhereUniqueInput[]
  }

  export type BusinessUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<BusinessCreateWithoutOrganizationInput, BusinessUncheckedCreateWithoutOrganizationInput> | BusinessCreateWithoutOrganizationInput[] | BusinessUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: BusinessCreateOrConnectWithoutOrganizationInput | BusinessCreateOrConnectWithoutOrganizationInput[]
    createMany?: BusinessCreateManyOrganizationInputEnvelope
    connect?: BusinessWhereUniqueInput | BusinessWhereUniqueInput[]
  }

  export type DoctypeUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<DoctypeCreateWithoutOrganizationInput, DoctypeUncheckedCreateWithoutOrganizationInput> | DoctypeCreateWithoutOrganizationInput[] | DoctypeUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: DoctypeCreateOrConnectWithoutOrganizationInput | DoctypeCreateOrConnectWithoutOrganizationInput[]
    createMany?: DoctypeCreateManyOrganizationInputEnvelope
    connect?: DoctypeWhereUniqueInput | DoctypeWhereUniqueInput[]
  }

  export type DocumentsUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<DocumentsCreateWithoutOrganizationInput, DocumentsUncheckedCreateWithoutOrganizationInput> | DocumentsCreateWithoutOrganizationInput[] | DocumentsUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: DocumentsCreateOrConnectWithoutOrganizationInput | DocumentsCreateOrConnectWithoutOrganizationInput[]
    createMany?: DocumentsCreateManyOrganizationInputEnvelope
    connect?: DocumentsWhereUniqueInput | DocumentsWhereUniqueInput[]
  }

  export type EntityUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<EntityCreateWithoutOrganizationInput, EntityUncheckedCreateWithoutOrganizationInput> | EntityCreateWithoutOrganizationInput[] | EntityUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: EntityCreateOrConnectWithoutOrganizationInput | EntityCreateOrConnectWithoutOrganizationInput[]
    createMany?: EntityCreateManyOrganizationInputEnvelope
    connect?: EntityWhereUniqueInput | EntityWhereUniqueInput[]
  }

  export type EntityTypeUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<EntityTypeCreateWithoutOrganizationInput, EntityTypeUncheckedCreateWithoutOrganizationInput> | EntityTypeCreateWithoutOrganizationInput[] | EntityTypeUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: EntityTypeCreateOrConnectWithoutOrganizationInput | EntityTypeCreateOrConnectWithoutOrganizationInput[]
    createMany?: EntityTypeCreateManyOrganizationInputEnvelope
    connect?: EntityTypeWhereUniqueInput | EntityTypeWhereUniqueInput[]
  }

  export type LocationUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<LocationCreateWithoutOrganizationInput, LocationUncheckedCreateWithoutOrganizationInput> | LocationCreateWithoutOrganizationInput[] | LocationUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: LocationCreateOrConnectWithoutOrganizationInput | LocationCreateOrConnectWithoutOrganizationInput[]
    createMany?: LocationCreateManyOrganizationInputEnvelope
    connect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
  }

  export type RoleUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<RoleCreateWithoutOrganizationInput, RoleUncheckedCreateWithoutOrganizationInput> | RoleCreateWithoutOrganizationInput[] | RoleUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: RoleCreateOrConnectWithoutOrganizationInput | RoleCreateOrConnectWithoutOrganizationInput[]
    createMany?: RoleCreateManyOrganizationInputEnvelope
    connect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
  }

  export type SectionUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<SectionCreateWithoutOrganizationInput, SectionUncheckedCreateWithoutOrganizationInput> | SectionCreateWithoutOrganizationInput[] | SectionUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: SectionCreateOrConnectWithoutOrganizationInput | SectionCreateOrConnectWithoutOrganizationInput[]
    createMany?: SectionCreateManyOrganizationInputEnvelope
    connect?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
  }

  export type SystemTypeUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<SystemTypeCreateWithoutOrganizationInput, SystemTypeUncheckedCreateWithoutOrganizationInput> | SystemTypeCreateWithoutOrganizationInput[] | SystemTypeUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: SystemTypeCreateOrConnectWithoutOrganizationInput | SystemTypeCreateOrConnectWithoutOrganizationInput[]
    createMany?: SystemTypeCreateManyOrganizationInputEnvelope
    connect?: SystemTypeWhereUniqueInput | SystemTypeWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<UserCreateWithoutOrganizationInput, UserUncheckedCreateWithoutOrganizationInput> | UserCreateWithoutOrganizationInput[] | UserUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: UserCreateOrConnectWithoutOrganizationInput | UserCreateOrConnectWithoutOrganizationInput[]
    createMany?: UserCreateManyOrganizationInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type userPersonalisationUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<userPersonalisationCreateWithoutOrganizationInput, userPersonalisationUncheckedCreateWithoutOrganizationInput> | userPersonalisationCreateWithoutOrganizationInput[] | userPersonalisationUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: userPersonalisationCreateOrConnectWithoutOrganizationInput | userPersonalisationCreateOrConnectWithoutOrganizationInput[]
    createMany?: userPersonalisationCreateManyOrganizationInputEnvelope
    connect?: userPersonalisationWhereUniqueInput | userPersonalisationWhereUniqueInput[]
  }

  export type ConnectedAppsUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<ConnectedAppsCreateWithoutOrganizationInput, ConnectedAppsUncheckedCreateWithoutOrganizationInput> | ConnectedAppsCreateWithoutOrganizationInput[] | ConnectedAppsUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: ConnectedAppsCreateOrConnectWithoutOrganizationInput | ConnectedAppsCreateOrConnectWithoutOrganizationInput[]
    createMany?: ConnectedAppsCreateManyOrganizationInputEnvelope
    connect?: ConnectedAppsWhereUniqueInput | ConnectedAppsWhereUniqueInput[]
  }

  export type unitTypeUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<unitTypeCreateWithoutOrganizationInput, unitTypeUncheckedCreateWithoutOrganizationInput> | unitTypeCreateWithoutOrganizationInput[] | unitTypeUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: unitTypeCreateOrConnectWithoutOrganizationInput | unitTypeCreateOrConnectWithoutOrganizationInput[]
    createMany?: unitTypeCreateManyOrganizationInputEnvelope
    connect?: unitTypeWhereUniqueInput | unitTypeWhereUniqueInput[]
  }

  export type kpiUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<kpiCreateWithoutOrganizationInput, kpiUncheckedCreateWithoutOrganizationInput> | kpiCreateWithoutOrganizationInput[] | kpiUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: kpiCreateOrConnectWithoutOrganizationInput | kpiCreateOrConnectWithoutOrganizationInput[]
    createMany?: kpiCreateManyOrganizationInputEnvelope
    connect?: kpiWhereUniqueInput | kpiWhereUniqueInput[]
  }

  export type businessTypeUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<businessTypeCreateWithoutOrganizationInput, businessTypeUncheckedCreateWithoutOrganizationInput> | businessTypeCreateWithoutOrganizationInput[] | businessTypeUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: businessTypeCreateOrConnectWithoutOrganizationInput | businessTypeCreateOrConnectWithoutOrganizationInput[]
    createMany?: businessTypeCreateManyOrganizationInputEnvelope
    connect?: businessTypeWhereUniqueInput | businessTypeWhereUniqueInput[]
  }

  export type prefixSuffixUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<prefixSuffixCreateWithoutOrganizationInput, prefixSuffixUncheckedCreateWithoutOrganizationInput> | prefixSuffixCreateWithoutOrganizationInput[] | prefixSuffixUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: prefixSuffixCreateOrConnectWithoutOrganizationInput | prefixSuffixCreateOrConnectWithoutOrganizationInput[]
    createMany?: prefixSuffixCreateManyOrganizationInputEnvelope
    connect?: prefixSuffixWhereUniqueInput | prefixSuffixWhereUniqueInput[]
  }

  export type serialNumberUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<serialNumberCreateWithoutOrganizationInput, serialNumberUncheckedCreateWithoutOrganizationInput> | serialNumberCreateWithoutOrganizationInput[] | serialNumberUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: serialNumberCreateOrConnectWithoutOrganizationInput | serialNumberCreateOrConnectWithoutOrganizationInput[]
    createMany?: serialNumberCreateManyOrganizationInputEnvelope
    connect?: serialNumberWhereUniqueInput | serialNumberWhereUniqueInput[]
  }

  export type FunctionsUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<FunctionsCreateWithoutOrganizationInput, FunctionsUncheckedCreateWithoutOrganizationInput> | FunctionsCreateWithoutOrganizationInput[] | FunctionsUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: FunctionsCreateOrConnectWithoutOrganizationInput | FunctionsCreateOrConnectWithoutOrganizationInput[]
    createMany?: FunctionsCreateManyOrganizationInputEnvelope
    connect?: FunctionsWhereUniqueInput | FunctionsWhereUniqueInput[]
  }

  export type rolesTableUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<rolesTableCreateWithoutOrganizationInput, rolesTableUncheckedCreateWithoutOrganizationInput> | rolesTableCreateWithoutOrganizationInput[] | rolesTableUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: rolesTableCreateOrConnectWithoutOrganizationInput | rolesTableCreateOrConnectWithoutOrganizationInput[]
    createMany?: rolesTableCreateManyOrganizationInputEnvelope
    connect?: rolesTableWhereUniqueInput | rolesTableWhereUniqueInput[]
  }

  export type ProblemUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<ProblemCreateWithoutOrganizationInput, ProblemUncheckedCreateWithoutOrganizationInput> | ProblemCreateWithoutOrganizationInput[] | ProblemUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: ProblemCreateOrConnectWithoutOrganizationInput | ProblemCreateOrConnectWithoutOrganizationInput[]
    createMany?: ProblemCreateManyOrganizationInputEnvelope
    connect?: ProblemWhereUniqueInput | ProblemWhereUniqueInput[]
  }

  export type PartsUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<PartsCreateWithoutOrganizationInput, PartsUncheckedCreateWithoutOrganizationInput> | PartsCreateWithoutOrganizationInput[] | PartsUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: PartsCreateOrConnectWithoutOrganizationInput | PartsCreateOrConnectWithoutOrganizationInput[]
    createMany?: PartsCreateManyOrganizationInputEnvelope
    connect?: PartsWhereUniqueInput | PartsWhereUniqueInput[]
  }

  export type ModelsUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<ModelsCreateWithoutOrganizationInput, ModelsUncheckedCreateWithoutOrganizationInput> | ModelsCreateWithoutOrganizationInput[] | ModelsUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: ModelsCreateOrConnectWithoutOrganizationInput | ModelsCreateOrConnectWithoutOrganizationInput[]
    createMany?: ModelsCreateManyOrganizationInputEnvelope
    connect?: ModelsWhereUniqueInput | ModelsWhereUniqueInput[]
  }

  export type OrganizationUpdateactiveModulesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type BusinessUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<BusinessCreateWithoutOrganizationInput, BusinessUncheckedCreateWithoutOrganizationInput> | BusinessCreateWithoutOrganizationInput[] | BusinessUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: BusinessCreateOrConnectWithoutOrganizationInput | BusinessCreateOrConnectWithoutOrganizationInput[]
    upsert?: BusinessUpsertWithWhereUniqueWithoutOrganizationInput | BusinessUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: BusinessCreateManyOrganizationInputEnvelope
    set?: BusinessWhereUniqueInput | BusinessWhereUniqueInput[]
    disconnect?: BusinessWhereUniqueInput | BusinessWhereUniqueInput[]
    delete?: BusinessWhereUniqueInput | BusinessWhereUniqueInput[]
    connect?: BusinessWhereUniqueInput | BusinessWhereUniqueInput[]
    update?: BusinessUpdateWithWhereUniqueWithoutOrganizationInput | BusinessUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: BusinessUpdateManyWithWhereWithoutOrganizationInput | BusinessUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: BusinessScalarWhereInput | BusinessScalarWhereInput[]
  }

  export type DoctypeUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<DoctypeCreateWithoutOrganizationInput, DoctypeUncheckedCreateWithoutOrganizationInput> | DoctypeCreateWithoutOrganizationInput[] | DoctypeUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: DoctypeCreateOrConnectWithoutOrganizationInput | DoctypeCreateOrConnectWithoutOrganizationInput[]
    upsert?: DoctypeUpsertWithWhereUniqueWithoutOrganizationInput | DoctypeUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: DoctypeCreateManyOrganizationInputEnvelope
    set?: DoctypeWhereUniqueInput | DoctypeWhereUniqueInput[]
    disconnect?: DoctypeWhereUniqueInput | DoctypeWhereUniqueInput[]
    delete?: DoctypeWhereUniqueInput | DoctypeWhereUniqueInput[]
    connect?: DoctypeWhereUniqueInput | DoctypeWhereUniqueInput[]
    update?: DoctypeUpdateWithWhereUniqueWithoutOrganizationInput | DoctypeUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: DoctypeUpdateManyWithWhereWithoutOrganizationInput | DoctypeUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: DoctypeScalarWhereInput | DoctypeScalarWhereInput[]
  }

  export type DocumentsUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<DocumentsCreateWithoutOrganizationInput, DocumentsUncheckedCreateWithoutOrganizationInput> | DocumentsCreateWithoutOrganizationInput[] | DocumentsUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: DocumentsCreateOrConnectWithoutOrganizationInput | DocumentsCreateOrConnectWithoutOrganizationInput[]
    upsert?: DocumentsUpsertWithWhereUniqueWithoutOrganizationInput | DocumentsUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: DocumentsCreateManyOrganizationInputEnvelope
    set?: DocumentsWhereUniqueInput | DocumentsWhereUniqueInput[]
    disconnect?: DocumentsWhereUniqueInput | DocumentsWhereUniqueInput[]
    delete?: DocumentsWhereUniqueInput | DocumentsWhereUniqueInput[]
    connect?: DocumentsWhereUniqueInput | DocumentsWhereUniqueInput[]
    update?: DocumentsUpdateWithWhereUniqueWithoutOrganizationInput | DocumentsUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: DocumentsUpdateManyWithWhereWithoutOrganizationInput | DocumentsUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: DocumentsScalarWhereInput | DocumentsScalarWhereInput[]
  }

  export type EntityUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<EntityCreateWithoutOrganizationInput, EntityUncheckedCreateWithoutOrganizationInput> | EntityCreateWithoutOrganizationInput[] | EntityUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: EntityCreateOrConnectWithoutOrganizationInput | EntityCreateOrConnectWithoutOrganizationInput[]
    upsert?: EntityUpsertWithWhereUniqueWithoutOrganizationInput | EntityUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: EntityCreateManyOrganizationInputEnvelope
    set?: EntityWhereUniqueInput | EntityWhereUniqueInput[]
    disconnect?: EntityWhereUniqueInput | EntityWhereUniqueInput[]
    delete?: EntityWhereUniqueInput | EntityWhereUniqueInput[]
    connect?: EntityWhereUniqueInput | EntityWhereUniqueInput[]
    update?: EntityUpdateWithWhereUniqueWithoutOrganizationInput | EntityUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: EntityUpdateManyWithWhereWithoutOrganizationInput | EntityUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: EntityScalarWhereInput | EntityScalarWhereInput[]
  }

  export type EntityTypeUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<EntityTypeCreateWithoutOrganizationInput, EntityTypeUncheckedCreateWithoutOrganizationInput> | EntityTypeCreateWithoutOrganizationInput[] | EntityTypeUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: EntityTypeCreateOrConnectWithoutOrganizationInput | EntityTypeCreateOrConnectWithoutOrganizationInput[]
    upsert?: EntityTypeUpsertWithWhereUniqueWithoutOrganizationInput | EntityTypeUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: EntityTypeCreateManyOrganizationInputEnvelope
    set?: EntityTypeWhereUniqueInput | EntityTypeWhereUniqueInput[]
    disconnect?: EntityTypeWhereUniqueInput | EntityTypeWhereUniqueInput[]
    delete?: EntityTypeWhereUniqueInput | EntityTypeWhereUniqueInput[]
    connect?: EntityTypeWhereUniqueInput | EntityTypeWhereUniqueInput[]
    update?: EntityTypeUpdateWithWhereUniqueWithoutOrganizationInput | EntityTypeUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: EntityTypeUpdateManyWithWhereWithoutOrganizationInput | EntityTypeUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: EntityTypeScalarWhereInput | EntityTypeScalarWhereInput[]
  }

  export type LocationUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<LocationCreateWithoutOrganizationInput, LocationUncheckedCreateWithoutOrganizationInput> | LocationCreateWithoutOrganizationInput[] | LocationUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: LocationCreateOrConnectWithoutOrganizationInput | LocationCreateOrConnectWithoutOrganizationInput[]
    upsert?: LocationUpsertWithWhereUniqueWithoutOrganizationInput | LocationUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: LocationCreateManyOrganizationInputEnvelope
    set?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    disconnect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    delete?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    connect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    update?: LocationUpdateWithWhereUniqueWithoutOrganizationInput | LocationUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: LocationUpdateManyWithWhereWithoutOrganizationInput | LocationUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: LocationScalarWhereInput | LocationScalarWhereInput[]
  }

  export type RoleUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<RoleCreateWithoutOrganizationInput, RoleUncheckedCreateWithoutOrganizationInput> | RoleCreateWithoutOrganizationInput[] | RoleUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: RoleCreateOrConnectWithoutOrganizationInput | RoleCreateOrConnectWithoutOrganizationInput[]
    upsert?: RoleUpsertWithWhereUniqueWithoutOrganizationInput | RoleUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: RoleCreateManyOrganizationInputEnvelope
    set?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    disconnect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    delete?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    connect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    update?: RoleUpdateWithWhereUniqueWithoutOrganizationInput | RoleUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: RoleUpdateManyWithWhereWithoutOrganizationInput | RoleUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: RoleScalarWhereInput | RoleScalarWhereInput[]
  }

  export type SectionUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<SectionCreateWithoutOrganizationInput, SectionUncheckedCreateWithoutOrganizationInput> | SectionCreateWithoutOrganizationInput[] | SectionUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: SectionCreateOrConnectWithoutOrganizationInput | SectionCreateOrConnectWithoutOrganizationInput[]
    upsert?: SectionUpsertWithWhereUniqueWithoutOrganizationInput | SectionUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: SectionCreateManyOrganizationInputEnvelope
    set?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    disconnect?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    delete?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    connect?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    update?: SectionUpdateWithWhereUniqueWithoutOrganizationInput | SectionUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: SectionUpdateManyWithWhereWithoutOrganizationInput | SectionUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: SectionScalarWhereInput | SectionScalarWhereInput[]
  }

  export type SystemTypeUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<SystemTypeCreateWithoutOrganizationInput, SystemTypeUncheckedCreateWithoutOrganizationInput> | SystemTypeCreateWithoutOrganizationInput[] | SystemTypeUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: SystemTypeCreateOrConnectWithoutOrganizationInput | SystemTypeCreateOrConnectWithoutOrganizationInput[]
    upsert?: SystemTypeUpsertWithWhereUniqueWithoutOrganizationInput | SystemTypeUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: SystemTypeCreateManyOrganizationInputEnvelope
    set?: SystemTypeWhereUniqueInput | SystemTypeWhereUniqueInput[]
    disconnect?: SystemTypeWhereUniqueInput | SystemTypeWhereUniqueInput[]
    delete?: SystemTypeWhereUniqueInput | SystemTypeWhereUniqueInput[]
    connect?: SystemTypeWhereUniqueInput | SystemTypeWhereUniqueInput[]
    update?: SystemTypeUpdateWithWhereUniqueWithoutOrganizationInput | SystemTypeUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: SystemTypeUpdateManyWithWhereWithoutOrganizationInput | SystemTypeUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: SystemTypeScalarWhereInput | SystemTypeScalarWhereInput[]
  }

  export type UserUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<UserCreateWithoutOrganizationInput, UserUncheckedCreateWithoutOrganizationInput> | UserCreateWithoutOrganizationInput[] | UserUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: UserCreateOrConnectWithoutOrganizationInput | UserCreateOrConnectWithoutOrganizationInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutOrganizationInput | UserUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: UserCreateManyOrganizationInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutOrganizationInput | UserUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: UserUpdateManyWithWhereWithoutOrganizationInput | UserUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type userPersonalisationUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<userPersonalisationCreateWithoutOrganizationInput, userPersonalisationUncheckedCreateWithoutOrganizationInput> | userPersonalisationCreateWithoutOrganizationInput[] | userPersonalisationUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: userPersonalisationCreateOrConnectWithoutOrganizationInput | userPersonalisationCreateOrConnectWithoutOrganizationInput[]
    upsert?: userPersonalisationUpsertWithWhereUniqueWithoutOrganizationInput | userPersonalisationUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: userPersonalisationCreateManyOrganizationInputEnvelope
    set?: userPersonalisationWhereUniqueInput | userPersonalisationWhereUniqueInput[]
    disconnect?: userPersonalisationWhereUniqueInput | userPersonalisationWhereUniqueInput[]
    delete?: userPersonalisationWhereUniqueInput | userPersonalisationWhereUniqueInput[]
    connect?: userPersonalisationWhereUniqueInput | userPersonalisationWhereUniqueInput[]
    update?: userPersonalisationUpdateWithWhereUniqueWithoutOrganizationInput | userPersonalisationUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: userPersonalisationUpdateManyWithWhereWithoutOrganizationInput | userPersonalisationUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: userPersonalisationScalarWhereInput | userPersonalisationScalarWhereInput[]
  }

  export type ConnectedAppsUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<ConnectedAppsCreateWithoutOrganizationInput, ConnectedAppsUncheckedCreateWithoutOrganizationInput> | ConnectedAppsCreateWithoutOrganizationInput[] | ConnectedAppsUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: ConnectedAppsCreateOrConnectWithoutOrganizationInput | ConnectedAppsCreateOrConnectWithoutOrganizationInput[]
    upsert?: ConnectedAppsUpsertWithWhereUniqueWithoutOrganizationInput | ConnectedAppsUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: ConnectedAppsCreateManyOrganizationInputEnvelope
    set?: ConnectedAppsWhereUniqueInput | ConnectedAppsWhereUniqueInput[]
    disconnect?: ConnectedAppsWhereUniqueInput | ConnectedAppsWhereUniqueInput[]
    delete?: ConnectedAppsWhereUniqueInput | ConnectedAppsWhereUniqueInput[]
    connect?: ConnectedAppsWhereUniqueInput | ConnectedAppsWhereUniqueInput[]
    update?: ConnectedAppsUpdateWithWhereUniqueWithoutOrganizationInput | ConnectedAppsUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: ConnectedAppsUpdateManyWithWhereWithoutOrganizationInput | ConnectedAppsUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: ConnectedAppsScalarWhereInput | ConnectedAppsScalarWhereInput[]
  }

  export type unitTypeUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<unitTypeCreateWithoutOrganizationInput, unitTypeUncheckedCreateWithoutOrganizationInput> | unitTypeCreateWithoutOrganizationInput[] | unitTypeUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: unitTypeCreateOrConnectWithoutOrganizationInput | unitTypeCreateOrConnectWithoutOrganizationInput[]
    upsert?: unitTypeUpsertWithWhereUniqueWithoutOrganizationInput | unitTypeUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: unitTypeCreateManyOrganizationInputEnvelope
    set?: unitTypeWhereUniqueInput | unitTypeWhereUniqueInput[]
    disconnect?: unitTypeWhereUniqueInput | unitTypeWhereUniqueInput[]
    delete?: unitTypeWhereUniqueInput | unitTypeWhereUniqueInput[]
    connect?: unitTypeWhereUniqueInput | unitTypeWhereUniqueInput[]
    update?: unitTypeUpdateWithWhereUniqueWithoutOrganizationInput | unitTypeUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: unitTypeUpdateManyWithWhereWithoutOrganizationInput | unitTypeUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: unitTypeScalarWhereInput | unitTypeScalarWhereInput[]
  }

  export type kpiUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<kpiCreateWithoutOrganizationInput, kpiUncheckedCreateWithoutOrganizationInput> | kpiCreateWithoutOrganizationInput[] | kpiUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: kpiCreateOrConnectWithoutOrganizationInput | kpiCreateOrConnectWithoutOrganizationInput[]
    upsert?: kpiUpsertWithWhereUniqueWithoutOrganizationInput | kpiUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: kpiCreateManyOrganizationInputEnvelope
    set?: kpiWhereUniqueInput | kpiWhereUniqueInput[]
    disconnect?: kpiWhereUniqueInput | kpiWhereUniqueInput[]
    delete?: kpiWhereUniqueInput | kpiWhereUniqueInput[]
    connect?: kpiWhereUniqueInput | kpiWhereUniqueInput[]
    update?: kpiUpdateWithWhereUniqueWithoutOrganizationInput | kpiUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: kpiUpdateManyWithWhereWithoutOrganizationInput | kpiUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: kpiScalarWhereInput | kpiScalarWhereInput[]
  }

  export type businessTypeUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<businessTypeCreateWithoutOrganizationInput, businessTypeUncheckedCreateWithoutOrganizationInput> | businessTypeCreateWithoutOrganizationInput[] | businessTypeUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: businessTypeCreateOrConnectWithoutOrganizationInput | businessTypeCreateOrConnectWithoutOrganizationInput[]
    upsert?: businessTypeUpsertWithWhereUniqueWithoutOrganizationInput | businessTypeUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: businessTypeCreateManyOrganizationInputEnvelope
    set?: businessTypeWhereUniqueInput | businessTypeWhereUniqueInput[]
    disconnect?: businessTypeWhereUniqueInput | businessTypeWhereUniqueInput[]
    delete?: businessTypeWhereUniqueInput | businessTypeWhereUniqueInput[]
    connect?: businessTypeWhereUniqueInput | businessTypeWhereUniqueInput[]
    update?: businessTypeUpdateWithWhereUniqueWithoutOrganizationInput | businessTypeUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: businessTypeUpdateManyWithWhereWithoutOrganizationInput | businessTypeUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: businessTypeScalarWhereInput | businessTypeScalarWhereInput[]
  }

  export type prefixSuffixUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<prefixSuffixCreateWithoutOrganizationInput, prefixSuffixUncheckedCreateWithoutOrganizationInput> | prefixSuffixCreateWithoutOrganizationInput[] | prefixSuffixUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: prefixSuffixCreateOrConnectWithoutOrganizationInput | prefixSuffixCreateOrConnectWithoutOrganizationInput[]
    upsert?: prefixSuffixUpsertWithWhereUniqueWithoutOrganizationInput | prefixSuffixUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: prefixSuffixCreateManyOrganizationInputEnvelope
    set?: prefixSuffixWhereUniqueInput | prefixSuffixWhereUniqueInput[]
    disconnect?: prefixSuffixWhereUniqueInput | prefixSuffixWhereUniqueInput[]
    delete?: prefixSuffixWhereUniqueInput | prefixSuffixWhereUniqueInput[]
    connect?: prefixSuffixWhereUniqueInput | prefixSuffixWhereUniqueInput[]
    update?: prefixSuffixUpdateWithWhereUniqueWithoutOrganizationInput | prefixSuffixUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: prefixSuffixUpdateManyWithWhereWithoutOrganizationInput | prefixSuffixUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: prefixSuffixScalarWhereInput | prefixSuffixScalarWhereInput[]
  }

  export type serialNumberUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<serialNumberCreateWithoutOrganizationInput, serialNumberUncheckedCreateWithoutOrganizationInput> | serialNumberCreateWithoutOrganizationInput[] | serialNumberUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: serialNumberCreateOrConnectWithoutOrganizationInput | serialNumberCreateOrConnectWithoutOrganizationInput[]
    upsert?: serialNumberUpsertWithWhereUniqueWithoutOrganizationInput | serialNumberUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: serialNumberCreateManyOrganizationInputEnvelope
    set?: serialNumberWhereUniqueInput | serialNumberWhereUniqueInput[]
    disconnect?: serialNumberWhereUniqueInput | serialNumberWhereUniqueInput[]
    delete?: serialNumberWhereUniqueInput | serialNumberWhereUniqueInput[]
    connect?: serialNumberWhereUniqueInput | serialNumberWhereUniqueInput[]
    update?: serialNumberUpdateWithWhereUniqueWithoutOrganizationInput | serialNumberUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: serialNumberUpdateManyWithWhereWithoutOrganizationInput | serialNumberUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: serialNumberScalarWhereInput | serialNumberScalarWhereInput[]
  }

  export type FunctionsUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<FunctionsCreateWithoutOrganizationInput, FunctionsUncheckedCreateWithoutOrganizationInput> | FunctionsCreateWithoutOrganizationInput[] | FunctionsUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: FunctionsCreateOrConnectWithoutOrganizationInput | FunctionsCreateOrConnectWithoutOrganizationInput[]
    upsert?: FunctionsUpsertWithWhereUniqueWithoutOrganizationInput | FunctionsUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: FunctionsCreateManyOrganizationInputEnvelope
    set?: FunctionsWhereUniqueInput | FunctionsWhereUniqueInput[]
    disconnect?: FunctionsWhereUniqueInput | FunctionsWhereUniqueInput[]
    delete?: FunctionsWhereUniqueInput | FunctionsWhereUniqueInput[]
    connect?: FunctionsWhereUniqueInput | FunctionsWhereUniqueInput[]
    update?: FunctionsUpdateWithWhereUniqueWithoutOrganizationInput | FunctionsUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: FunctionsUpdateManyWithWhereWithoutOrganizationInput | FunctionsUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: FunctionsScalarWhereInput | FunctionsScalarWhereInput[]
  }

  export type rolesTableUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<rolesTableCreateWithoutOrganizationInput, rolesTableUncheckedCreateWithoutOrganizationInput> | rolesTableCreateWithoutOrganizationInput[] | rolesTableUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: rolesTableCreateOrConnectWithoutOrganizationInput | rolesTableCreateOrConnectWithoutOrganizationInput[]
    upsert?: rolesTableUpsertWithWhereUniqueWithoutOrganizationInput | rolesTableUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: rolesTableCreateManyOrganizationInputEnvelope
    set?: rolesTableWhereUniqueInput | rolesTableWhereUniqueInput[]
    disconnect?: rolesTableWhereUniqueInput | rolesTableWhereUniqueInput[]
    delete?: rolesTableWhereUniqueInput | rolesTableWhereUniqueInput[]
    connect?: rolesTableWhereUniqueInput | rolesTableWhereUniqueInput[]
    update?: rolesTableUpdateWithWhereUniqueWithoutOrganizationInput | rolesTableUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: rolesTableUpdateManyWithWhereWithoutOrganizationInput | rolesTableUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: rolesTableScalarWhereInput | rolesTableScalarWhereInput[]
  }

  export type ProblemUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<ProblemCreateWithoutOrganizationInput, ProblemUncheckedCreateWithoutOrganizationInput> | ProblemCreateWithoutOrganizationInput[] | ProblemUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: ProblemCreateOrConnectWithoutOrganizationInput | ProblemCreateOrConnectWithoutOrganizationInput[]
    upsert?: ProblemUpsertWithWhereUniqueWithoutOrganizationInput | ProblemUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: ProblemCreateManyOrganizationInputEnvelope
    set?: ProblemWhereUniqueInput | ProblemWhereUniqueInput[]
    disconnect?: ProblemWhereUniqueInput | ProblemWhereUniqueInput[]
    delete?: ProblemWhereUniqueInput | ProblemWhereUniqueInput[]
    connect?: ProblemWhereUniqueInput | ProblemWhereUniqueInput[]
    update?: ProblemUpdateWithWhereUniqueWithoutOrganizationInput | ProblemUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: ProblemUpdateManyWithWhereWithoutOrganizationInput | ProblemUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: ProblemScalarWhereInput | ProblemScalarWhereInput[]
  }

  export type PartsUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<PartsCreateWithoutOrganizationInput, PartsUncheckedCreateWithoutOrganizationInput> | PartsCreateWithoutOrganizationInput[] | PartsUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: PartsCreateOrConnectWithoutOrganizationInput | PartsCreateOrConnectWithoutOrganizationInput[]
    upsert?: PartsUpsertWithWhereUniqueWithoutOrganizationInput | PartsUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: PartsCreateManyOrganizationInputEnvelope
    set?: PartsWhereUniqueInput | PartsWhereUniqueInput[]
    disconnect?: PartsWhereUniqueInput | PartsWhereUniqueInput[]
    delete?: PartsWhereUniqueInput | PartsWhereUniqueInput[]
    connect?: PartsWhereUniqueInput | PartsWhereUniqueInput[]
    update?: PartsUpdateWithWhereUniqueWithoutOrganizationInput | PartsUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: PartsUpdateManyWithWhereWithoutOrganizationInput | PartsUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: PartsScalarWhereInput | PartsScalarWhereInput[]
  }

  export type ModelsUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<ModelsCreateWithoutOrganizationInput, ModelsUncheckedCreateWithoutOrganizationInput> | ModelsCreateWithoutOrganizationInput[] | ModelsUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: ModelsCreateOrConnectWithoutOrganizationInput | ModelsCreateOrConnectWithoutOrganizationInput[]
    upsert?: ModelsUpsertWithWhereUniqueWithoutOrganizationInput | ModelsUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: ModelsCreateManyOrganizationInputEnvelope
    set?: ModelsWhereUniqueInput | ModelsWhereUniqueInput[]
    disconnect?: ModelsWhereUniqueInput | ModelsWhereUniqueInput[]
    delete?: ModelsWhereUniqueInput | ModelsWhereUniqueInput[]
    connect?: ModelsWhereUniqueInput | ModelsWhereUniqueInput[]
    update?: ModelsUpdateWithWhereUniqueWithoutOrganizationInput | ModelsUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: ModelsUpdateManyWithWhereWithoutOrganizationInput | ModelsUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: ModelsScalarWhereInput | ModelsScalarWhereInput[]
  }

  export type BusinessUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<BusinessCreateWithoutOrganizationInput, BusinessUncheckedCreateWithoutOrganizationInput> | BusinessCreateWithoutOrganizationInput[] | BusinessUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: BusinessCreateOrConnectWithoutOrganizationInput | BusinessCreateOrConnectWithoutOrganizationInput[]
    upsert?: BusinessUpsertWithWhereUniqueWithoutOrganizationInput | BusinessUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: BusinessCreateManyOrganizationInputEnvelope
    set?: BusinessWhereUniqueInput | BusinessWhereUniqueInput[]
    disconnect?: BusinessWhereUniqueInput | BusinessWhereUniqueInput[]
    delete?: BusinessWhereUniqueInput | BusinessWhereUniqueInput[]
    connect?: BusinessWhereUniqueInput | BusinessWhereUniqueInput[]
    update?: BusinessUpdateWithWhereUniqueWithoutOrganizationInput | BusinessUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: BusinessUpdateManyWithWhereWithoutOrganizationInput | BusinessUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: BusinessScalarWhereInput | BusinessScalarWhereInput[]
  }

  export type DoctypeUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<DoctypeCreateWithoutOrganizationInput, DoctypeUncheckedCreateWithoutOrganizationInput> | DoctypeCreateWithoutOrganizationInput[] | DoctypeUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: DoctypeCreateOrConnectWithoutOrganizationInput | DoctypeCreateOrConnectWithoutOrganizationInput[]
    upsert?: DoctypeUpsertWithWhereUniqueWithoutOrganizationInput | DoctypeUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: DoctypeCreateManyOrganizationInputEnvelope
    set?: DoctypeWhereUniqueInput | DoctypeWhereUniqueInput[]
    disconnect?: DoctypeWhereUniqueInput | DoctypeWhereUniqueInput[]
    delete?: DoctypeWhereUniqueInput | DoctypeWhereUniqueInput[]
    connect?: DoctypeWhereUniqueInput | DoctypeWhereUniqueInput[]
    update?: DoctypeUpdateWithWhereUniqueWithoutOrganizationInput | DoctypeUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: DoctypeUpdateManyWithWhereWithoutOrganizationInput | DoctypeUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: DoctypeScalarWhereInput | DoctypeScalarWhereInput[]
  }

  export type DocumentsUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<DocumentsCreateWithoutOrganizationInput, DocumentsUncheckedCreateWithoutOrganizationInput> | DocumentsCreateWithoutOrganizationInput[] | DocumentsUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: DocumentsCreateOrConnectWithoutOrganizationInput | DocumentsCreateOrConnectWithoutOrganizationInput[]
    upsert?: DocumentsUpsertWithWhereUniqueWithoutOrganizationInput | DocumentsUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: DocumentsCreateManyOrganizationInputEnvelope
    set?: DocumentsWhereUniqueInput | DocumentsWhereUniqueInput[]
    disconnect?: DocumentsWhereUniqueInput | DocumentsWhereUniqueInput[]
    delete?: DocumentsWhereUniqueInput | DocumentsWhereUniqueInput[]
    connect?: DocumentsWhereUniqueInput | DocumentsWhereUniqueInput[]
    update?: DocumentsUpdateWithWhereUniqueWithoutOrganizationInput | DocumentsUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: DocumentsUpdateManyWithWhereWithoutOrganizationInput | DocumentsUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: DocumentsScalarWhereInput | DocumentsScalarWhereInput[]
  }

  export type EntityUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<EntityCreateWithoutOrganizationInput, EntityUncheckedCreateWithoutOrganizationInput> | EntityCreateWithoutOrganizationInput[] | EntityUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: EntityCreateOrConnectWithoutOrganizationInput | EntityCreateOrConnectWithoutOrganizationInput[]
    upsert?: EntityUpsertWithWhereUniqueWithoutOrganizationInput | EntityUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: EntityCreateManyOrganizationInputEnvelope
    set?: EntityWhereUniqueInput | EntityWhereUniqueInput[]
    disconnect?: EntityWhereUniqueInput | EntityWhereUniqueInput[]
    delete?: EntityWhereUniqueInput | EntityWhereUniqueInput[]
    connect?: EntityWhereUniqueInput | EntityWhereUniqueInput[]
    update?: EntityUpdateWithWhereUniqueWithoutOrganizationInput | EntityUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: EntityUpdateManyWithWhereWithoutOrganizationInput | EntityUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: EntityScalarWhereInput | EntityScalarWhereInput[]
  }

  export type EntityTypeUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<EntityTypeCreateWithoutOrganizationInput, EntityTypeUncheckedCreateWithoutOrganizationInput> | EntityTypeCreateWithoutOrganizationInput[] | EntityTypeUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: EntityTypeCreateOrConnectWithoutOrganizationInput | EntityTypeCreateOrConnectWithoutOrganizationInput[]
    upsert?: EntityTypeUpsertWithWhereUniqueWithoutOrganizationInput | EntityTypeUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: EntityTypeCreateManyOrganizationInputEnvelope
    set?: EntityTypeWhereUniqueInput | EntityTypeWhereUniqueInput[]
    disconnect?: EntityTypeWhereUniqueInput | EntityTypeWhereUniqueInput[]
    delete?: EntityTypeWhereUniqueInput | EntityTypeWhereUniqueInput[]
    connect?: EntityTypeWhereUniqueInput | EntityTypeWhereUniqueInput[]
    update?: EntityTypeUpdateWithWhereUniqueWithoutOrganizationInput | EntityTypeUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: EntityTypeUpdateManyWithWhereWithoutOrganizationInput | EntityTypeUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: EntityTypeScalarWhereInput | EntityTypeScalarWhereInput[]
  }

  export type LocationUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<LocationCreateWithoutOrganizationInput, LocationUncheckedCreateWithoutOrganizationInput> | LocationCreateWithoutOrganizationInput[] | LocationUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: LocationCreateOrConnectWithoutOrganizationInput | LocationCreateOrConnectWithoutOrganizationInput[]
    upsert?: LocationUpsertWithWhereUniqueWithoutOrganizationInput | LocationUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: LocationCreateManyOrganizationInputEnvelope
    set?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    disconnect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    delete?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    connect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    update?: LocationUpdateWithWhereUniqueWithoutOrganizationInput | LocationUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: LocationUpdateManyWithWhereWithoutOrganizationInput | LocationUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: LocationScalarWhereInput | LocationScalarWhereInput[]
  }

  export type RoleUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<RoleCreateWithoutOrganizationInput, RoleUncheckedCreateWithoutOrganizationInput> | RoleCreateWithoutOrganizationInput[] | RoleUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: RoleCreateOrConnectWithoutOrganizationInput | RoleCreateOrConnectWithoutOrganizationInput[]
    upsert?: RoleUpsertWithWhereUniqueWithoutOrganizationInput | RoleUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: RoleCreateManyOrganizationInputEnvelope
    set?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    disconnect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    delete?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    connect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    update?: RoleUpdateWithWhereUniqueWithoutOrganizationInput | RoleUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: RoleUpdateManyWithWhereWithoutOrganizationInput | RoleUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: RoleScalarWhereInput | RoleScalarWhereInput[]
  }

  export type SectionUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<SectionCreateWithoutOrganizationInput, SectionUncheckedCreateWithoutOrganizationInput> | SectionCreateWithoutOrganizationInput[] | SectionUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: SectionCreateOrConnectWithoutOrganizationInput | SectionCreateOrConnectWithoutOrganizationInput[]
    upsert?: SectionUpsertWithWhereUniqueWithoutOrganizationInput | SectionUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: SectionCreateManyOrganizationInputEnvelope
    set?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    disconnect?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    delete?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    connect?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    update?: SectionUpdateWithWhereUniqueWithoutOrganizationInput | SectionUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: SectionUpdateManyWithWhereWithoutOrganizationInput | SectionUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: SectionScalarWhereInput | SectionScalarWhereInput[]
  }

  export type SystemTypeUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<SystemTypeCreateWithoutOrganizationInput, SystemTypeUncheckedCreateWithoutOrganizationInput> | SystemTypeCreateWithoutOrganizationInput[] | SystemTypeUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: SystemTypeCreateOrConnectWithoutOrganizationInput | SystemTypeCreateOrConnectWithoutOrganizationInput[]
    upsert?: SystemTypeUpsertWithWhereUniqueWithoutOrganizationInput | SystemTypeUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: SystemTypeCreateManyOrganizationInputEnvelope
    set?: SystemTypeWhereUniqueInput | SystemTypeWhereUniqueInput[]
    disconnect?: SystemTypeWhereUniqueInput | SystemTypeWhereUniqueInput[]
    delete?: SystemTypeWhereUniqueInput | SystemTypeWhereUniqueInput[]
    connect?: SystemTypeWhereUniqueInput | SystemTypeWhereUniqueInput[]
    update?: SystemTypeUpdateWithWhereUniqueWithoutOrganizationInput | SystemTypeUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: SystemTypeUpdateManyWithWhereWithoutOrganizationInput | SystemTypeUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: SystemTypeScalarWhereInput | SystemTypeScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<UserCreateWithoutOrganizationInput, UserUncheckedCreateWithoutOrganizationInput> | UserCreateWithoutOrganizationInput[] | UserUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: UserCreateOrConnectWithoutOrganizationInput | UserCreateOrConnectWithoutOrganizationInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutOrganizationInput | UserUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: UserCreateManyOrganizationInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutOrganizationInput | UserUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: UserUpdateManyWithWhereWithoutOrganizationInput | UserUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type userPersonalisationUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<userPersonalisationCreateWithoutOrganizationInput, userPersonalisationUncheckedCreateWithoutOrganizationInput> | userPersonalisationCreateWithoutOrganizationInput[] | userPersonalisationUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: userPersonalisationCreateOrConnectWithoutOrganizationInput | userPersonalisationCreateOrConnectWithoutOrganizationInput[]
    upsert?: userPersonalisationUpsertWithWhereUniqueWithoutOrganizationInput | userPersonalisationUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: userPersonalisationCreateManyOrganizationInputEnvelope
    set?: userPersonalisationWhereUniqueInput | userPersonalisationWhereUniqueInput[]
    disconnect?: userPersonalisationWhereUniqueInput | userPersonalisationWhereUniqueInput[]
    delete?: userPersonalisationWhereUniqueInput | userPersonalisationWhereUniqueInput[]
    connect?: userPersonalisationWhereUniqueInput | userPersonalisationWhereUniqueInput[]
    update?: userPersonalisationUpdateWithWhereUniqueWithoutOrganizationInput | userPersonalisationUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: userPersonalisationUpdateManyWithWhereWithoutOrganizationInput | userPersonalisationUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: userPersonalisationScalarWhereInput | userPersonalisationScalarWhereInput[]
  }

  export type ConnectedAppsUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<ConnectedAppsCreateWithoutOrganizationInput, ConnectedAppsUncheckedCreateWithoutOrganizationInput> | ConnectedAppsCreateWithoutOrganizationInput[] | ConnectedAppsUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: ConnectedAppsCreateOrConnectWithoutOrganizationInput | ConnectedAppsCreateOrConnectWithoutOrganizationInput[]
    upsert?: ConnectedAppsUpsertWithWhereUniqueWithoutOrganizationInput | ConnectedAppsUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: ConnectedAppsCreateManyOrganizationInputEnvelope
    set?: ConnectedAppsWhereUniqueInput | ConnectedAppsWhereUniqueInput[]
    disconnect?: ConnectedAppsWhereUniqueInput | ConnectedAppsWhereUniqueInput[]
    delete?: ConnectedAppsWhereUniqueInput | ConnectedAppsWhereUniqueInput[]
    connect?: ConnectedAppsWhereUniqueInput | ConnectedAppsWhereUniqueInput[]
    update?: ConnectedAppsUpdateWithWhereUniqueWithoutOrganizationInput | ConnectedAppsUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: ConnectedAppsUpdateManyWithWhereWithoutOrganizationInput | ConnectedAppsUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: ConnectedAppsScalarWhereInput | ConnectedAppsScalarWhereInput[]
  }

  export type unitTypeUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<unitTypeCreateWithoutOrganizationInput, unitTypeUncheckedCreateWithoutOrganizationInput> | unitTypeCreateWithoutOrganizationInput[] | unitTypeUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: unitTypeCreateOrConnectWithoutOrganizationInput | unitTypeCreateOrConnectWithoutOrganizationInput[]
    upsert?: unitTypeUpsertWithWhereUniqueWithoutOrganizationInput | unitTypeUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: unitTypeCreateManyOrganizationInputEnvelope
    set?: unitTypeWhereUniqueInput | unitTypeWhereUniqueInput[]
    disconnect?: unitTypeWhereUniqueInput | unitTypeWhereUniqueInput[]
    delete?: unitTypeWhereUniqueInput | unitTypeWhereUniqueInput[]
    connect?: unitTypeWhereUniqueInput | unitTypeWhereUniqueInput[]
    update?: unitTypeUpdateWithWhereUniqueWithoutOrganizationInput | unitTypeUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: unitTypeUpdateManyWithWhereWithoutOrganizationInput | unitTypeUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: unitTypeScalarWhereInput | unitTypeScalarWhereInput[]
  }

  export type kpiUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<kpiCreateWithoutOrganizationInput, kpiUncheckedCreateWithoutOrganizationInput> | kpiCreateWithoutOrganizationInput[] | kpiUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: kpiCreateOrConnectWithoutOrganizationInput | kpiCreateOrConnectWithoutOrganizationInput[]
    upsert?: kpiUpsertWithWhereUniqueWithoutOrganizationInput | kpiUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: kpiCreateManyOrganizationInputEnvelope
    set?: kpiWhereUniqueInput | kpiWhereUniqueInput[]
    disconnect?: kpiWhereUniqueInput | kpiWhereUniqueInput[]
    delete?: kpiWhereUniqueInput | kpiWhereUniqueInput[]
    connect?: kpiWhereUniqueInput | kpiWhereUniqueInput[]
    update?: kpiUpdateWithWhereUniqueWithoutOrganizationInput | kpiUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: kpiUpdateManyWithWhereWithoutOrganizationInput | kpiUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: kpiScalarWhereInput | kpiScalarWhereInput[]
  }

  export type businessTypeUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<businessTypeCreateWithoutOrganizationInput, businessTypeUncheckedCreateWithoutOrganizationInput> | businessTypeCreateWithoutOrganizationInput[] | businessTypeUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: businessTypeCreateOrConnectWithoutOrganizationInput | businessTypeCreateOrConnectWithoutOrganizationInput[]
    upsert?: businessTypeUpsertWithWhereUniqueWithoutOrganizationInput | businessTypeUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: businessTypeCreateManyOrganizationInputEnvelope
    set?: businessTypeWhereUniqueInput | businessTypeWhereUniqueInput[]
    disconnect?: businessTypeWhereUniqueInput | businessTypeWhereUniqueInput[]
    delete?: businessTypeWhereUniqueInput | businessTypeWhereUniqueInput[]
    connect?: businessTypeWhereUniqueInput | businessTypeWhereUniqueInput[]
    update?: businessTypeUpdateWithWhereUniqueWithoutOrganizationInput | businessTypeUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: businessTypeUpdateManyWithWhereWithoutOrganizationInput | businessTypeUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: businessTypeScalarWhereInput | businessTypeScalarWhereInput[]
  }

  export type prefixSuffixUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<prefixSuffixCreateWithoutOrganizationInput, prefixSuffixUncheckedCreateWithoutOrganizationInput> | prefixSuffixCreateWithoutOrganizationInput[] | prefixSuffixUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: prefixSuffixCreateOrConnectWithoutOrganizationInput | prefixSuffixCreateOrConnectWithoutOrganizationInput[]
    upsert?: prefixSuffixUpsertWithWhereUniqueWithoutOrganizationInput | prefixSuffixUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: prefixSuffixCreateManyOrganizationInputEnvelope
    set?: prefixSuffixWhereUniqueInput | prefixSuffixWhereUniqueInput[]
    disconnect?: prefixSuffixWhereUniqueInput | prefixSuffixWhereUniqueInput[]
    delete?: prefixSuffixWhereUniqueInput | prefixSuffixWhereUniqueInput[]
    connect?: prefixSuffixWhereUniqueInput | prefixSuffixWhereUniqueInput[]
    update?: prefixSuffixUpdateWithWhereUniqueWithoutOrganizationInput | prefixSuffixUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: prefixSuffixUpdateManyWithWhereWithoutOrganizationInput | prefixSuffixUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: prefixSuffixScalarWhereInput | prefixSuffixScalarWhereInput[]
  }

  export type serialNumberUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<serialNumberCreateWithoutOrganizationInput, serialNumberUncheckedCreateWithoutOrganizationInput> | serialNumberCreateWithoutOrganizationInput[] | serialNumberUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: serialNumberCreateOrConnectWithoutOrganizationInput | serialNumberCreateOrConnectWithoutOrganizationInput[]
    upsert?: serialNumberUpsertWithWhereUniqueWithoutOrganizationInput | serialNumberUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: serialNumberCreateManyOrganizationInputEnvelope
    set?: serialNumberWhereUniqueInput | serialNumberWhereUniqueInput[]
    disconnect?: serialNumberWhereUniqueInput | serialNumberWhereUniqueInput[]
    delete?: serialNumberWhereUniqueInput | serialNumberWhereUniqueInput[]
    connect?: serialNumberWhereUniqueInput | serialNumberWhereUniqueInput[]
    update?: serialNumberUpdateWithWhereUniqueWithoutOrganizationInput | serialNumberUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: serialNumberUpdateManyWithWhereWithoutOrganizationInput | serialNumberUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: serialNumberScalarWhereInput | serialNumberScalarWhereInput[]
  }

  export type FunctionsUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<FunctionsCreateWithoutOrganizationInput, FunctionsUncheckedCreateWithoutOrganizationInput> | FunctionsCreateWithoutOrganizationInput[] | FunctionsUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: FunctionsCreateOrConnectWithoutOrganizationInput | FunctionsCreateOrConnectWithoutOrganizationInput[]
    upsert?: FunctionsUpsertWithWhereUniqueWithoutOrganizationInput | FunctionsUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: FunctionsCreateManyOrganizationInputEnvelope
    set?: FunctionsWhereUniqueInput | FunctionsWhereUniqueInput[]
    disconnect?: FunctionsWhereUniqueInput | FunctionsWhereUniqueInput[]
    delete?: FunctionsWhereUniqueInput | FunctionsWhereUniqueInput[]
    connect?: FunctionsWhereUniqueInput | FunctionsWhereUniqueInput[]
    update?: FunctionsUpdateWithWhereUniqueWithoutOrganizationInput | FunctionsUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: FunctionsUpdateManyWithWhereWithoutOrganizationInput | FunctionsUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: FunctionsScalarWhereInput | FunctionsScalarWhereInput[]
  }

  export type rolesTableUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<rolesTableCreateWithoutOrganizationInput, rolesTableUncheckedCreateWithoutOrganizationInput> | rolesTableCreateWithoutOrganizationInput[] | rolesTableUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: rolesTableCreateOrConnectWithoutOrganizationInput | rolesTableCreateOrConnectWithoutOrganizationInput[]
    upsert?: rolesTableUpsertWithWhereUniqueWithoutOrganizationInput | rolesTableUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: rolesTableCreateManyOrganizationInputEnvelope
    set?: rolesTableWhereUniqueInput | rolesTableWhereUniqueInput[]
    disconnect?: rolesTableWhereUniqueInput | rolesTableWhereUniqueInput[]
    delete?: rolesTableWhereUniqueInput | rolesTableWhereUniqueInput[]
    connect?: rolesTableWhereUniqueInput | rolesTableWhereUniqueInput[]
    update?: rolesTableUpdateWithWhereUniqueWithoutOrganizationInput | rolesTableUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: rolesTableUpdateManyWithWhereWithoutOrganizationInput | rolesTableUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: rolesTableScalarWhereInput | rolesTableScalarWhereInput[]
  }

  export type ProblemUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<ProblemCreateWithoutOrganizationInput, ProblemUncheckedCreateWithoutOrganizationInput> | ProblemCreateWithoutOrganizationInput[] | ProblemUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: ProblemCreateOrConnectWithoutOrganizationInput | ProblemCreateOrConnectWithoutOrganizationInput[]
    upsert?: ProblemUpsertWithWhereUniqueWithoutOrganizationInput | ProblemUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: ProblemCreateManyOrganizationInputEnvelope
    set?: ProblemWhereUniqueInput | ProblemWhereUniqueInput[]
    disconnect?: ProblemWhereUniqueInput | ProblemWhereUniqueInput[]
    delete?: ProblemWhereUniqueInput | ProblemWhereUniqueInput[]
    connect?: ProblemWhereUniqueInput | ProblemWhereUniqueInput[]
    update?: ProblemUpdateWithWhereUniqueWithoutOrganizationInput | ProblemUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: ProblemUpdateManyWithWhereWithoutOrganizationInput | ProblemUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: ProblemScalarWhereInput | ProblemScalarWhereInput[]
  }

  export type PartsUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<PartsCreateWithoutOrganizationInput, PartsUncheckedCreateWithoutOrganizationInput> | PartsCreateWithoutOrganizationInput[] | PartsUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: PartsCreateOrConnectWithoutOrganizationInput | PartsCreateOrConnectWithoutOrganizationInput[]
    upsert?: PartsUpsertWithWhereUniqueWithoutOrganizationInput | PartsUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: PartsCreateManyOrganizationInputEnvelope
    set?: PartsWhereUniqueInput | PartsWhereUniqueInput[]
    disconnect?: PartsWhereUniqueInput | PartsWhereUniqueInput[]
    delete?: PartsWhereUniqueInput | PartsWhereUniqueInput[]
    connect?: PartsWhereUniqueInput | PartsWhereUniqueInput[]
    update?: PartsUpdateWithWhereUniqueWithoutOrganizationInput | PartsUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: PartsUpdateManyWithWhereWithoutOrganizationInput | PartsUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: PartsScalarWhereInput | PartsScalarWhereInput[]
  }

  export type ModelsUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<ModelsCreateWithoutOrganizationInput, ModelsUncheckedCreateWithoutOrganizationInput> | ModelsCreateWithoutOrganizationInput[] | ModelsUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: ModelsCreateOrConnectWithoutOrganizationInput | ModelsCreateOrConnectWithoutOrganizationInput[]
    upsert?: ModelsUpsertWithWhereUniqueWithoutOrganizationInput | ModelsUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: ModelsCreateManyOrganizationInputEnvelope
    set?: ModelsWhereUniqueInput | ModelsWhereUniqueInput[]
    disconnect?: ModelsWhereUniqueInput | ModelsWhereUniqueInput[]
    delete?: ModelsWhereUniqueInput | ModelsWhereUniqueInput[]
    connect?: ModelsWhereUniqueInput | ModelsWhereUniqueInput[]
    update?: ModelsUpdateWithWhereUniqueWithoutOrganizationInput | ModelsUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: ModelsUpdateManyWithWhereWithoutOrganizationInput | ModelsUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: ModelsScalarWhereInput | ModelsScalarWhereInput[]
  }

  export type OrganizationCreateNestedOneWithoutRoleInput = {
    create?: XOR<OrganizationCreateWithoutRoleInput, OrganizationUncheckedCreateWithoutRoleInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutRoleInput
    connect?: OrganizationWhereUniqueInput
  }

  export type LocationCreateNestedOneWithoutRoleInput = {
    create?: XOR<LocationCreateWithoutRoleInput, LocationUncheckedCreateWithoutRoleInput>
    connectOrCreate?: LocationCreateOrConnectWithoutRoleInput
    connect?: LocationWhereUniqueInput
  }

  export type OrganizationUpdateOneWithoutRoleNestedInput = {
    create?: XOR<OrganizationCreateWithoutRoleInput, OrganizationUncheckedCreateWithoutRoleInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutRoleInput
    upsert?: OrganizationUpsertWithoutRoleInput
    disconnect?: boolean
    delete?: OrganizationWhereInput | boolean
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutRoleInput, OrganizationUpdateWithoutRoleInput>, OrganizationUncheckedUpdateWithoutRoleInput>
  }

  export type LocationUpdateOneWithoutRoleNestedInput = {
    create?: XOR<LocationCreateWithoutRoleInput, LocationUncheckedCreateWithoutRoleInput>
    connectOrCreate?: LocationCreateOrConnectWithoutRoleInput
    upsert?: LocationUpsertWithoutRoleInput
    disconnect?: boolean
    delete?: LocationWhereInput | boolean
    connect?: LocationWhereUniqueInput
    update?: XOR<XOR<LocationUpdateToOneWithWhereWithoutRoleInput, LocationUpdateWithoutRoleInput>, LocationUncheckedUpdateWithoutRoleInput>
  }

  export type OrganizationCreateNestedOneWithoutSystemTypeInput = {
    create?: XOR<OrganizationCreateWithoutSystemTypeInput, OrganizationUncheckedCreateWithoutSystemTypeInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutSystemTypeInput
    connect?: OrganizationWhereUniqueInput
  }

  export type OrganizationUpdateOneWithoutSystemTypeNestedInput = {
    create?: XOR<OrganizationCreateWithoutSystemTypeInput, OrganizationUncheckedCreateWithoutSystemTypeInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutSystemTypeInput
    upsert?: OrganizationUpsertWithoutSystemTypeInput
    disconnect?: boolean
    delete?: OrganizationWhereInput | boolean
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutSystemTypeInput, OrganizationUpdateWithoutSystemTypeInput>, OrganizationUncheckedUpdateWithoutSystemTypeInput>
  }

  export type OrganizationCreateNestedOneWithoutEntityTypeInput = {
    create?: XOR<OrganizationCreateWithoutEntityTypeInput, OrganizationUncheckedCreateWithoutEntityTypeInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutEntityTypeInput
    connect?: OrganizationWhereUniqueInput
  }

  export type EntityCreateNestedManyWithoutEntityTypeInput = {
    create?: XOR<EntityCreateWithoutEntityTypeInput, EntityUncheckedCreateWithoutEntityTypeInput> | EntityCreateWithoutEntityTypeInput[] | EntityUncheckedCreateWithoutEntityTypeInput[]
    connectOrCreate?: EntityCreateOrConnectWithoutEntityTypeInput | EntityCreateOrConnectWithoutEntityTypeInput[]
    createMany?: EntityCreateManyEntityTypeInputEnvelope
    connect?: EntityWhereUniqueInput | EntityWhereUniqueInput[]
  }

  export type EntityUncheckedCreateNestedManyWithoutEntityTypeInput = {
    create?: XOR<EntityCreateWithoutEntityTypeInput, EntityUncheckedCreateWithoutEntityTypeInput> | EntityCreateWithoutEntityTypeInput[] | EntityUncheckedCreateWithoutEntityTypeInput[]
    connectOrCreate?: EntityCreateOrConnectWithoutEntityTypeInput | EntityCreateOrConnectWithoutEntityTypeInput[]
    createMany?: EntityCreateManyEntityTypeInputEnvelope
    connect?: EntityWhereUniqueInput | EntityWhereUniqueInput[]
  }

  export type OrganizationUpdateOneWithoutEntityTypeNestedInput = {
    create?: XOR<OrganizationCreateWithoutEntityTypeInput, OrganizationUncheckedCreateWithoutEntityTypeInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutEntityTypeInput
    upsert?: OrganizationUpsertWithoutEntityTypeInput
    disconnect?: boolean
    delete?: OrganizationWhereInput | boolean
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutEntityTypeInput, OrganizationUpdateWithoutEntityTypeInput>, OrganizationUncheckedUpdateWithoutEntityTypeInput>
  }

  export type EntityUpdateManyWithoutEntityTypeNestedInput = {
    create?: XOR<EntityCreateWithoutEntityTypeInput, EntityUncheckedCreateWithoutEntityTypeInput> | EntityCreateWithoutEntityTypeInput[] | EntityUncheckedCreateWithoutEntityTypeInput[]
    connectOrCreate?: EntityCreateOrConnectWithoutEntityTypeInput | EntityCreateOrConnectWithoutEntityTypeInput[]
    upsert?: EntityUpsertWithWhereUniqueWithoutEntityTypeInput | EntityUpsertWithWhereUniqueWithoutEntityTypeInput[]
    createMany?: EntityCreateManyEntityTypeInputEnvelope
    set?: EntityWhereUniqueInput | EntityWhereUniqueInput[]
    disconnect?: EntityWhereUniqueInput | EntityWhereUniqueInput[]
    delete?: EntityWhereUniqueInput | EntityWhereUniqueInput[]
    connect?: EntityWhereUniqueInput | EntityWhereUniqueInput[]
    update?: EntityUpdateWithWhereUniqueWithoutEntityTypeInput | EntityUpdateWithWhereUniqueWithoutEntityTypeInput[]
    updateMany?: EntityUpdateManyWithWhereWithoutEntityTypeInput | EntityUpdateManyWithWhereWithoutEntityTypeInput[]
    deleteMany?: EntityScalarWhereInput | EntityScalarWhereInput[]
  }

  export type EntityUncheckedUpdateManyWithoutEntityTypeNestedInput = {
    create?: XOR<EntityCreateWithoutEntityTypeInput, EntityUncheckedCreateWithoutEntityTypeInput> | EntityCreateWithoutEntityTypeInput[] | EntityUncheckedCreateWithoutEntityTypeInput[]
    connectOrCreate?: EntityCreateOrConnectWithoutEntityTypeInput | EntityCreateOrConnectWithoutEntityTypeInput[]
    upsert?: EntityUpsertWithWhereUniqueWithoutEntityTypeInput | EntityUpsertWithWhereUniqueWithoutEntityTypeInput[]
    createMany?: EntityCreateManyEntityTypeInputEnvelope
    set?: EntityWhereUniqueInput | EntityWhereUniqueInput[]
    disconnect?: EntityWhereUniqueInput | EntityWhereUniqueInput[]
    delete?: EntityWhereUniqueInput | EntityWhereUniqueInput[]
    connect?: EntityWhereUniqueInput | EntityWhereUniqueInput[]
    update?: EntityUpdateWithWhereUniqueWithoutEntityTypeInput | EntityUpdateWithWhereUniqueWithoutEntityTypeInput[]
    updateMany?: EntityUpdateManyWithWhereWithoutEntityTypeInput | EntityUpdateManyWithWhereWithoutEntityTypeInput[]
    deleteMany?: EntityScalarWhereInput | EntityScalarWhereInput[]
  }

  export type OrganizationCreateNestedOneWithoutBusinessTypeInput = {
    create?: XOR<OrganizationCreateWithoutBusinessTypeInput, OrganizationUncheckedCreateWithoutBusinessTypeInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutBusinessTypeInput
    connect?: OrganizationWhereUniqueInput
  }

  export type OrganizationUpdateOneWithoutBusinessTypeNestedInput = {
    create?: XOR<OrganizationCreateWithoutBusinessTypeInput, OrganizationUncheckedCreateWithoutBusinessTypeInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutBusinessTypeInput
    upsert?: OrganizationUpsertWithoutBusinessTypeInput
    disconnect?: boolean
    delete?: OrganizationWhereInput | boolean
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutBusinessTypeInput, OrganizationUpdateWithoutBusinessTypeInput>, OrganizationUncheckedUpdateWithoutBusinessTypeInput>
  }

  export type OrganizationCreateNestedOneWithoutBusinessInput = {
    create?: XOR<OrganizationCreateWithoutBusinessInput, OrganizationUncheckedCreateWithoutBusinessInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutBusinessInput
    connect?: OrganizationWhereUniqueInput
  }

  export type LocationBusinessCreateNestedManyWithoutBusinessInput = {
    create?: XOR<LocationBusinessCreateWithoutBusinessInput, LocationBusinessUncheckedCreateWithoutBusinessInput> | LocationBusinessCreateWithoutBusinessInput[] | LocationBusinessUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: LocationBusinessCreateOrConnectWithoutBusinessInput | LocationBusinessCreateOrConnectWithoutBusinessInput[]
    createMany?: LocationBusinessCreateManyBusinessInputEnvelope
    connect?: LocationBusinessWhereUniqueInput | LocationBusinessWhereUniqueInput[]
  }

  export type LocationBusinessUncheckedCreateNestedManyWithoutBusinessInput = {
    create?: XOR<LocationBusinessCreateWithoutBusinessInput, LocationBusinessUncheckedCreateWithoutBusinessInput> | LocationBusinessCreateWithoutBusinessInput[] | LocationBusinessUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: LocationBusinessCreateOrConnectWithoutBusinessInput | LocationBusinessCreateOrConnectWithoutBusinessInput[]
    createMany?: LocationBusinessCreateManyBusinessInputEnvelope
    connect?: LocationBusinessWhereUniqueInput | LocationBusinessWhereUniqueInput[]
  }

  export type OrganizationUpdateOneWithoutBusinessNestedInput = {
    create?: XOR<OrganizationCreateWithoutBusinessInput, OrganizationUncheckedCreateWithoutBusinessInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutBusinessInput
    upsert?: OrganizationUpsertWithoutBusinessInput
    disconnect?: boolean
    delete?: OrganizationWhereInput | boolean
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutBusinessInput, OrganizationUpdateWithoutBusinessInput>, OrganizationUncheckedUpdateWithoutBusinessInput>
  }

  export type LocationBusinessUpdateManyWithoutBusinessNestedInput = {
    create?: XOR<LocationBusinessCreateWithoutBusinessInput, LocationBusinessUncheckedCreateWithoutBusinessInput> | LocationBusinessCreateWithoutBusinessInput[] | LocationBusinessUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: LocationBusinessCreateOrConnectWithoutBusinessInput | LocationBusinessCreateOrConnectWithoutBusinessInput[]
    upsert?: LocationBusinessUpsertWithWhereUniqueWithoutBusinessInput | LocationBusinessUpsertWithWhereUniqueWithoutBusinessInput[]
    createMany?: LocationBusinessCreateManyBusinessInputEnvelope
    set?: LocationBusinessWhereUniqueInput | LocationBusinessWhereUniqueInput[]
    disconnect?: LocationBusinessWhereUniqueInput | LocationBusinessWhereUniqueInput[]
    delete?: LocationBusinessWhereUniqueInput | LocationBusinessWhereUniqueInput[]
    connect?: LocationBusinessWhereUniqueInput | LocationBusinessWhereUniqueInput[]
    update?: LocationBusinessUpdateWithWhereUniqueWithoutBusinessInput | LocationBusinessUpdateWithWhereUniqueWithoutBusinessInput[]
    updateMany?: LocationBusinessUpdateManyWithWhereWithoutBusinessInput | LocationBusinessUpdateManyWithWhereWithoutBusinessInput[]
    deleteMany?: LocationBusinessScalarWhereInput | LocationBusinessScalarWhereInput[]
  }

  export type LocationBusinessUncheckedUpdateManyWithoutBusinessNestedInput = {
    create?: XOR<LocationBusinessCreateWithoutBusinessInput, LocationBusinessUncheckedCreateWithoutBusinessInput> | LocationBusinessCreateWithoutBusinessInput[] | LocationBusinessUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: LocationBusinessCreateOrConnectWithoutBusinessInput | LocationBusinessCreateOrConnectWithoutBusinessInput[]
    upsert?: LocationBusinessUpsertWithWhereUniqueWithoutBusinessInput | LocationBusinessUpsertWithWhereUniqueWithoutBusinessInput[]
    createMany?: LocationBusinessCreateManyBusinessInputEnvelope
    set?: LocationBusinessWhereUniqueInput | LocationBusinessWhereUniqueInput[]
    disconnect?: LocationBusinessWhereUniqueInput | LocationBusinessWhereUniqueInput[]
    delete?: LocationBusinessWhereUniqueInput | LocationBusinessWhereUniqueInput[]
    connect?: LocationBusinessWhereUniqueInput | LocationBusinessWhereUniqueInput[]
    update?: LocationBusinessUpdateWithWhereUniqueWithoutBusinessInput | LocationBusinessUpdateWithWhereUniqueWithoutBusinessInput[]
    updateMany?: LocationBusinessUpdateManyWithWhereWithoutBusinessInput | LocationBusinessUpdateManyWithWhereWithoutBusinessInput[]
    deleteMany?: LocationBusinessScalarWhereInput | LocationBusinessScalarWhereInput[]
  }

  export type FunctionsCreatefunctionHeadInput = {
    set: string[]
  }

  export type FunctionsCreatefunctionSpocInput = {
    set: string[]
  }

  export type FunctionsCreatelocationIdInput = {
    set: string[]
  }

  export type FunctionsCreatebusinessIdInput = {
    set: string[]
  }

  export type OrganizationCreateNestedOneWithoutFunctionInput = {
    create?: XOR<OrganizationCreateWithoutFunctionInput, OrganizationUncheckedCreateWithoutFunctionInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutFunctionInput
    connect?: OrganizationWhereUniqueInput
  }

  export type EntityCreateNestedManyWithoutFunctionInput = {
    create?: XOR<EntityCreateWithoutFunctionInput, EntityUncheckedCreateWithoutFunctionInput> | EntityCreateWithoutFunctionInput[] | EntityUncheckedCreateWithoutFunctionInput[]
    connectOrCreate?: EntityCreateOrConnectWithoutFunctionInput | EntityCreateOrConnectWithoutFunctionInput[]
    createMany?: EntityCreateManyFunctionInputEnvelope
    connect?: EntityWhereUniqueInput | EntityWhereUniqueInput[]
  }

  export type EntityUncheckedCreateNestedManyWithoutFunctionInput = {
    create?: XOR<EntityCreateWithoutFunctionInput, EntityUncheckedCreateWithoutFunctionInput> | EntityCreateWithoutFunctionInput[] | EntityUncheckedCreateWithoutFunctionInput[]
    connectOrCreate?: EntityCreateOrConnectWithoutFunctionInput | EntityCreateOrConnectWithoutFunctionInput[]
    createMany?: EntityCreateManyFunctionInputEnvelope
    connect?: EntityWhereUniqueInput | EntityWhereUniqueInput[]
  }

  export type FunctionsUpdatefunctionHeadInput = {
    set?: string[]
    push?: string | string[]
  }

  export type FunctionsUpdatefunctionSpocInput = {
    set?: string[]
    push?: string | string[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type FunctionsUpdatelocationIdInput = {
    set?: string[]
    push?: string | string[]
  }

  export type FunctionsUpdatebusinessIdInput = {
    set?: string[]
    push?: string | string[]
  }

  export type OrganizationUpdateOneWithoutFunctionNestedInput = {
    create?: XOR<OrganizationCreateWithoutFunctionInput, OrganizationUncheckedCreateWithoutFunctionInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutFunctionInput
    upsert?: OrganizationUpsertWithoutFunctionInput
    disconnect?: boolean
    delete?: OrganizationWhereInput | boolean
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutFunctionInput, OrganizationUpdateWithoutFunctionInput>, OrganizationUncheckedUpdateWithoutFunctionInput>
  }

  export type EntityUpdateManyWithoutFunctionNestedInput = {
    create?: XOR<EntityCreateWithoutFunctionInput, EntityUncheckedCreateWithoutFunctionInput> | EntityCreateWithoutFunctionInput[] | EntityUncheckedCreateWithoutFunctionInput[]
    connectOrCreate?: EntityCreateOrConnectWithoutFunctionInput | EntityCreateOrConnectWithoutFunctionInput[]
    upsert?: EntityUpsertWithWhereUniqueWithoutFunctionInput | EntityUpsertWithWhereUniqueWithoutFunctionInput[]
    createMany?: EntityCreateManyFunctionInputEnvelope
    set?: EntityWhereUniqueInput | EntityWhereUniqueInput[]
    disconnect?: EntityWhereUniqueInput | EntityWhereUniqueInput[]
    delete?: EntityWhereUniqueInput | EntityWhereUniqueInput[]
    connect?: EntityWhereUniqueInput | EntityWhereUniqueInput[]
    update?: EntityUpdateWithWhereUniqueWithoutFunctionInput | EntityUpdateWithWhereUniqueWithoutFunctionInput[]
    updateMany?: EntityUpdateManyWithWhereWithoutFunctionInput | EntityUpdateManyWithWhereWithoutFunctionInput[]
    deleteMany?: EntityScalarWhereInput | EntityScalarWhereInput[]
  }

  export type EntityUncheckedUpdateManyWithoutFunctionNestedInput = {
    create?: XOR<EntityCreateWithoutFunctionInput, EntityUncheckedCreateWithoutFunctionInput> | EntityCreateWithoutFunctionInput[] | EntityUncheckedCreateWithoutFunctionInput[]
    connectOrCreate?: EntityCreateOrConnectWithoutFunctionInput | EntityCreateOrConnectWithoutFunctionInput[]
    upsert?: EntityUpsertWithWhereUniqueWithoutFunctionInput | EntityUpsertWithWhereUniqueWithoutFunctionInput[]
    createMany?: EntityCreateManyFunctionInputEnvelope
    set?: EntityWhereUniqueInput | EntityWhereUniqueInput[]
    disconnect?: EntityWhereUniqueInput | EntityWhereUniqueInput[]
    delete?: EntityWhereUniqueInput | EntityWhereUniqueInput[]
    connect?: EntityWhereUniqueInput | EntityWhereUniqueInput[]
    update?: EntityUpdateWithWhereUniqueWithoutFunctionInput | EntityUpdateWithWhereUniqueWithoutFunctionInput[]
    updateMany?: EntityUpdateManyWithWhereWithoutFunctionInput | EntityUpdateManyWithWhereWithoutFunctionInput[]
    deleteMany?: EntityScalarWhereInput | EntityScalarWhereInput[]
  }

  export type OrganizationCreateNestedOneWithoutSectionInput = {
    create?: XOR<OrganizationCreateWithoutSectionInput, OrganizationUncheckedCreateWithoutSectionInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutSectionInput
    connect?: OrganizationWhereUniqueInput
  }

  export type OrganizationUpdateOneWithoutSectionNestedInput = {
    create?: XOR<OrganizationCreateWithoutSectionInput, OrganizationUncheckedCreateWithoutSectionInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutSectionInput
    upsert?: OrganizationUpsertWithoutSectionInput
    disconnect?: boolean
    delete?: OrganizationWhereInput | boolean
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutSectionInput, OrganizationUpdateWithoutSectionInput>, OrganizationUncheckedUpdateWithoutSectionInput>
  }

  export type LocationCreatefunctionIdInput = {
    set: string[]
  }

  export type LocationCreateusersInput = {
    set: InputJsonValue[]
  }

  export type OrganizationCreateNestedOneWithoutLocationInput = {
    create?: XOR<OrganizationCreateWithoutLocationInput, OrganizationUncheckedCreateWithoutLocationInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutLocationInput
    connect?: OrganizationWhereUniqueInput
  }

  export type DocumentsCreateNestedManyWithoutCreatorLocationInput = {
    create?: XOR<DocumentsCreateWithoutCreatorLocationInput, DocumentsUncheckedCreateWithoutCreatorLocationInput> | DocumentsCreateWithoutCreatorLocationInput[] | DocumentsUncheckedCreateWithoutCreatorLocationInput[]
    connectOrCreate?: DocumentsCreateOrConnectWithoutCreatorLocationInput | DocumentsCreateOrConnectWithoutCreatorLocationInput[]
    createMany?: DocumentsCreateManyCreatorLocationInputEnvelope
    connect?: DocumentsWhereUniqueInput | DocumentsWhereUniqueInput[]
  }

  export type EntityCreateNestedManyWithoutLocationInput = {
    create?: XOR<EntityCreateWithoutLocationInput, EntityUncheckedCreateWithoutLocationInput> | EntityCreateWithoutLocationInput[] | EntityUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: EntityCreateOrConnectWithoutLocationInput | EntityCreateOrConnectWithoutLocationInput[]
    createMany?: EntityCreateManyLocationInputEnvelope
    connect?: EntityWhereUniqueInput | EntityWhereUniqueInput[]
  }

  export type LocationBusinessCreateNestedManyWithoutLocationInput = {
    create?: XOR<LocationBusinessCreateWithoutLocationInput, LocationBusinessUncheckedCreateWithoutLocationInput> | LocationBusinessCreateWithoutLocationInput[] | LocationBusinessUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: LocationBusinessCreateOrConnectWithoutLocationInput | LocationBusinessCreateOrConnectWithoutLocationInput[]
    createMany?: LocationBusinessCreateManyLocationInputEnvelope
    connect?: LocationBusinessWhereUniqueInput | LocationBusinessWhereUniqueInput[]
  }

  export type UserCreateNestedManyWithoutLocationInput = {
    create?: XOR<UserCreateWithoutLocationInput, UserUncheckedCreateWithoutLocationInput> | UserCreateWithoutLocationInput[] | UserUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: UserCreateOrConnectWithoutLocationInput | UserCreateOrConnectWithoutLocationInput[]
    createMany?: UserCreateManyLocationInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type unitTypeCreateNestedManyWithoutLocationInput = {
    create?: XOR<unitTypeCreateWithoutLocationInput, unitTypeUncheckedCreateWithoutLocationInput> | unitTypeCreateWithoutLocationInput[] | unitTypeUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: unitTypeCreateOrConnectWithoutLocationInput | unitTypeCreateOrConnectWithoutLocationInput[]
    createMany?: unitTypeCreateManyLocationInputEnvelope
    connect?: unitTypeWhereUniqueInput | unitTypeWhereUniqueInput[]
  }

  export type rolesTableCreateNestedManyWithoutLocationInput = {
    create?: XOR<rolesTableCreateWithoutLocationInput, rolesTableUncheckedCreateWithoutLocationInput> | rolesTableCreateWithoutLocationInput[] | rolesTableUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: rolesTableCreateOrConnectWithoutLocationInput | rolesTableCreateOrConnectWithoutLocationInput[]
    createMany?: rolesTableCreateManyLocationInputEnvelope
    connect?: rolesTableWhereUniqueInput | rolesTableWhereUniqueInput[]
  }

  export type RoleCreateNestedManyWithoutLocationInput = {
    create?: XOR<RoleCreateWithoutLocationInput, RoleUncheckedCreateWithoutLocationInput> | RoleCreateWithoutLocationInput[] | RoleUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: RoleCreateOrConnectWithoutLocationInput | RoleCreateOrConnectWithoutLocationInput[]
    createMany?: RoleCreateManyLocationInputEnvelope
    connect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
  }

  export type DocumentsUncheckedCreateNestedManyWithoutCreatorLocationInput = {
    create?: XOR<DocumentsCreateWithoutCreatorLocationInput, DocumentsUncheckedCreateWithoutCreatorLocationInput> | DocumentsCreateWithoutCreatorLocationInput[] | DocumentsUncheckedCreateWithoutCreatorLocationInput[]
    connectOrCreate?: DocumentsCreateOrConnectWithoutCreatorLocationInput | DocumentsCreateOrConnectWithoutCreatorLocationInput[]
    createMany?: DocumentsCreateManyCreatorLocationInputEnvelope
    connect?: DocumentsWhereUniqueInput | DocumentsWhereUniqueInput[]
  }

  export type EntityUncheckedCreateNestedManyWithoutLocationInput = {
    create?: XOR<EntityCreateWithoutLocationInput, EntityUncheckedCreateWithoutLocationInput> | EntityCreateWithoutLocationInput[] | EntityUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: EntityCreateOrConnectWithoutLocationInput | EntityCreateOrConnectWithoutLocationInput[]
    createMany?: EntityCreateManyLocationInputEnvelope
    connect?: EntityWhereUniqueInput | EntityWhereUniqueInput[]
  }

  export type LocationBusinessUncheckedCreateNestedManyWithoutLocationInput = {
    create?: XOR<LocationBusinessCreateWithoutLocationInput, LocationBusinessUncheckedCreateWithoutLocationInput> | LocationBusinessCreateWithoutLocationInput[] | LocationBusinessUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: LocationBusinessCreateOrConnectWithoutLocationInput | LocationBusinessCreateOrConnectWithoutLocationInput[]
    createMany?: LocationBusinessCreateManyLocationInputEnvelope
    connect?: LocationBusinessWhereUniqueInput | LocationBusinessWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutLocationInput = {
    create?: XOR<UserCreateWithoutLocationInput, UserUncheckedCreateWithoutLocationInput> | UserCreateWithoutLocationInput[] | UserUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: UserCreateOrConnectWithoutLocationInput | UserCreateOrConnectWithoutLocationInput[]
    createMany?: UserCreateManyLocationInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type unitTypeUncheckedCreateNestedManyWithoutLocationInput = {
    create?: XOR<unitTypeCreateWithoutLocationInput, unitTypeUncheckedCreateWithoutLocationInput> | unitTypeCreateWithoutLocationInput[] | unitTypeUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: unitTypeCreateOrConnectWithoutLocationInput | unitTypeCreateOrConnectWithoutLocationInput[]
    createMany?: unitTypeCreateManyLocationInputEnvelope
    connect?: unitTypeWhereUniqueInput | unitTypeWhereUniqueInput[]
  }

  export type rolesTableUncheckedCreateNestedManyWithoutLocationInput = {
    create?: XOR<rolesTableCreateWithoutLocationInput, rolesTableUncheckedCreateWithoutLocationInput> | rolesTableCreateWithoutLocationInput[] | rolesTableUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: rolesTableCreateOrConnectWithoutLocationInput | rolesTableCreateOrConnectWithoutLocationInput[]
    createMany?: rolesTableCreateManyLocationInputEnvelope
    connect?: rolesTableWhereUniqueInput | rolesTableWhereUniqueInput[]
  }

  export type RoleUncheckedCreateNestedManyWithoutLocationInput = {
    create?: XOR<RoleCreateWithoutLocationInput, RoleUncheckedCreateWithoutLocationInput> | RoleCreateWithoutLocationInput[] | RoleUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: RoleCreateOrConnectWithoutLocationInput | RoleCreateOrConnectWithoutLocationInput[]
    createMany?: RoleCreateManyLocationInputEnvelope
    connect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
  }

  export type LocationUpdatefunctionIdInput = {
    set?: string[]
    push?: string | string[]
  }

  export type LocationUpdateusersInput = {
    set?: InputJsonValue[]
    push?: InputJsonValue | InputJsonValue[]
  }

  export type OrganizationUpdateOneWithoutLocationNestedInput = {
    create?: XOR<OrganizationCreateWithoutLocationInput, OrganizationUncheckedCreateWithoutLocationInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutLocationInput
    upsert?: OrganizationUpsertWithoutLocationInput
    disconnect?: boolean
    delete?: OrganizationWhereInput | boolean
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutLocationInput, OrganizationUpdateWithoutLocationInput>, OrganizationUncheckedUpdateWithoutLocationInput>
  }

  export type DocumentsUpdateManyWithoutCreatorLocationNestedInput = {
    create?: XOR<DocumentsCreateWithoutCreatorLocationInput, DocumentsUncheckedCreateWithoutCreatorLocationInput> | DocumentsCreateWithoutCreatorLocationInput[] | DocumentsUncheckedCreateWithoutCreatorLocationInput[]
    connectOrCreate?: DocumentsCreateOrConnectWithoutCreatorLocationInput | DocumentsCreateOrConnectWithoutCreatorLocationInput[]
    upsert?: DocumentsUpsertWithWhereUniqueWithoutCreatorLocationInput | DocumentsUpsertWithWhereUniqueWithoutCreatorLocationInput[]
    createMany?: DocumentsCreateManyCreatorLocationInputEnvelope
    set?: DocumentsWhereUniqueInput | DocumentsWhereUniqueInput[]
    disconnect?: DocumentsWhereUniqueInput | DocumentsWhereUniqueInput[]
    delete?: DocumentsWhereUniqueInput | DocumentsWhereUniqueInput[]
    connect?: DocumentsWhereUniqueInput | DocumentsWhereUniqueInput[]
    update?: DocumentsUpdateWithWhereUniqueWithoutCreatorLocationInput | DocumentsUpdateWithWhereUniqueWithoutCreatorLocationInput[]
    updateMany?: DocumentsUpdateManyWithWhereWithoutCreatorLocationInput | DocumentsUpdateManyWithWhereWithoutCreatorLocationInput[]
    deleteMany?: DocumentsScalarWhereInput | DocumentsScalarWhereInput[]
  }

  export type EntityUpdateManyWithoutLocationNestedInput = {
    create?: XOR<EntityCreateWithoutLocationInput, EntityUncheckedCreateWithoutLocationInput> | EntityCreateWithoutLocationInput[] | EntityUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: EntityCreateOrConnectWithoutLocationInput | EntityCreateOrConnectWithoutLocationInput[]
    upsert?: EntityUpsertWithWhereUniqueWithoutLocationInput | EntityUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: EntityCreateManyLocationInputEnvelope
    set?: EntityWhereUniqueInput | EntityWhereUniqueInput[]
    disconnect?: EntityWhereUniqueInput | EntityWhereUniqueInput[]
    delete?: EntityWhereUniqueInput | EntityWhereUniqueInput[]
    connect?: EntityWhereUniqueInput | EntityWhereUniqueInput[]
    update?: EntityUpdateWithWhereUniqueWithoutLocationInput | EntityUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: EntityUpdateManyWithWhereWithoutLocationInput | EntityUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: EntityScalarWhereInput | EntityScalarWhereInput[]
  }

  export type LocationBusinessUpdateManyWithoutLocationNestedInput = {
    create?: XOR<LocationBusinessCreateWithoutLocationInput, LocationBusinessUncheckedCreateWithoutLocationInput> | LocationBusinessCreateWithoutLocationInput[] | LocationBusinessUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: LocationBusinessCreateOrConnectWithoutLocationInput | LocationBusinessCreateOrConnectWithoutLocationInput[]
    upsert?: LocationBusinessUpsertWithWhereUniqueWithoutLocationInput | LocationBusinessUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: LocationBusinessCreateManyLocationInputEnvelope
    set?: LocationBusinessWhereUniqueInput | LocationBusinessWhereUniqueInput[]
    disconnect?: LocationBusinessWhereUniqueInput | LocationBusinessWhereUniqueInput[]
    delete?: LocationBusinessWhereUniqueInput | LocationBusinessWhereUniqueInput[]
    connect?: LocationBusinessWhereUniqueInput | LocationBusinessWhereUniqueInput[]
    update?: LocationBusinessUpdateWithWhereUniqueWithoutLocationInput | LocationBusinessUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: LocationBusinessUpdateManyWithWhereWithoutLocationInput | LocationBusinessUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: LocationBusinessScalarWhereInput | LocationBusinessScalarWhereInput[]
  }

  export type UserUpdateManyWithoutLocationNestedInput = {
    create?: XOR<UserCreateWithoutLocationInput, UserUncheckedCreateWithoutLocationInput> | UserCreateWithoutLocationInput[] | UserUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: UserCreateOrConnectWithoutLocationInput | UserCreateOrConnectWithoutLocationInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutLocationInput | UserUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: UserCreateManyLocationInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutLocationInput | UserUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: UserUpdateManyWithWhereWithoutLocationInput | UserUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type unitTypeUpdateManyWithoutLocationNestedInput = {
    create?: XOR<unitTypeCreateWithoutLocationInput, unitTypeUncheckedCreateWithoutLocationInput> | unitTypeCreateWithoutLocationInput[] | unitTypeUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: unitTypeCreateOrConnectWithoutLocationInput | unitTypeCreateOrConnectWithoutLocationInput[]
    upsert?: unitTypeUpsertWithWhereUniqueWithoutLocationInput | unitTypeUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: unitTypeCreateManyLocationInputEnvelope
    set?: unitTypeWhereUniqueInput | unitTypeWhereUniqueInput[]
    disconnect?: unitTypeWhereUniqueInput | unitTypeWhereUniqueInput[]
    delete?: unitTypeWhereUniqueInput | unitTypeWhereUniqueInput[]
    connect?: unitTypeWhereUniqueInput | unitTypeWhereUniqueInput[]
    update?: unitTypeUpdateWithWhereUniqueWithoutLocationInput | unitTypeUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: unitTypeUpdateManyWithWhereWithoutLocationInput | unitTypeUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: unitTypeScalarWhereInput | unitTypeScalarWhereInput[]
  }

  export type rolesTableUpdateManyWithoutLocationNestedInput = {
    create?: XOR<rolesTableCreateWithoutLocationInput, rolesTableUncheckedCreateWithoutLocationInput> | rolesTableCreateWithoutLocationInput[] | rolesTableUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: rolesTableCreateOrConnectWithoutLocationInput | rolesTableCreateOrConnectWithoutLocationInput[]
    upsert?: rolesTableUpsertWithWhereUniqueWithoutLocationInput | rolesTableUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: rolesTableCreateManyLocationInputEnvelope
    set?: rolesTableWhereUniqueInput | rolesTableWhereUniqueInput[]
    disconnect?: rolesTableWhereUniqueInput | rolesTableWhereUniqueInput[]
    delete?: rolesTableWhereUniqueInput | rolesTableWhereUniqueInput[]
    connect?: rolesTableWhereUniqueInput | rolesTableWhereUniqueInput[]
    update?: rolesTableUpdateWithWhereUniqueWithoutLocationInput | rolesTableUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: rolesTableUpdateManyWithWhereWithoutLocationInput | rolesTableUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: rolesTableScalarWhereInput | rolesTableScalarWhereInput[]
  }

  export type RoleUpdateManyWithoutLocationNestedInput = {
    create?: XOR<RoleCreateWithoutLocationInput, RoleUncheckedCreateWithoutLocationInput> | RoleCreateWithoutLocationInput[] | RoleUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: RoleCreateOrConnectWithoutLocationInput | RoleCreateOrConnectWithoutLocationInput[]
    upsert?: RoleUpsertWithWhereUniqueWithoutLocationInput | RoleUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: RoleCreateManyLocationInputEnvelope
    set?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    disconnect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    delete?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    connect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    update?: RoleUpdateWithWhereUniqueWithoutLocationInput | RoleUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: RoleUpdateManyWithWhereWithoutLocationInput | RoleUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: RoleScalarWhereInput | RoleScalarWhereInput[]
  }

  export type DocumentsUncheckedUpdateManyWithoutCreatorLocationNestedInput = {
    create?: XOR<DocumentsCreateWithoutCreatorLocationInput, DocumentsUncheckedCreateWithoutCreatorLocationInput> | DocumentsCreateWithoutCreatorLocationInput[] | DocumentsUncheckedCreateWithoutCreatorLocationInput[]
    connectOrCreate?: DocumentsCreateOrConnectWithoutCreatorLocationInput | DocumentsCreateOrConnectWithoutCreatorLocationInput[]
    upsert?: DocumentsUpsertWithWhereUniqueWithoutCreatorLocationInput | DocumentsUpsertWithWhereUniqueWithoutCreatorLocationInput[]
    createMany?: DocumentsCreateManyCreatorLocationInputEnvelope
    set?: DocumentsWhereUniqueInput | DocumentsWhereUniqueInput[]
    disconnect?: DocumentsWhereUniqueInput | DocumentsWhereUniqueInput[]
    delete?: DocumentsWhereUniqueInput | DocumentsWhereUniqueInput[]
    connect?: DocumentsWhereUniqueInput | DocumentsWhereUniqueInput[]
    update?: DocumentsUpdateWithWhereUniqueWithoutCreatorLocationInput | DocumentsUpdateWithWhereUniqueWithoutCreatorLocationInput[]
    updateMany?: DocumentsUpdateManyWithWhereWithoutCreatorLocationInput | DocumentsUpdateManyWithWhereWithoutCreatorLocationInput[]
    deleteMany?: DocumentsScalarWhereInput | DocumentsScalarWhereInput[]
  }

  export type EntityUncheckedUpdateManyWithoutLocationNestedInput = {
    create?: XOR<EntityCreateWithoutLocationInput, EntityUncheckedCreateWithoutLocationInput> | EntityCreateWithoutLocationInput[] | EntityUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: EntityCreateOrConnectWithoutLocationInput | EntityCreateOrConnectWithoutLocationInput[]
    upsert?: EntityUpsertWithWhereUniqueWithoutLocationInput | EntityUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: EntityCreateManyLocationInputEnvelope
    set?: EntityWhereUniqueInput | EntityWhereUniqueInput[]
    disconnect?: EntityWhereUniqueInput | EntityWhereUniqueInput[]
    delete?: EntityWhereUniqueInput | EntityWhereUniqueInput[]
    connect?: EntityWhereUniqueInput | EntityWhereUniqueInput[]
    update?: EntityUpdateWithWhereUniqueWithoutLocationInput | EntityUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: EntityUpdateManyWithWhereWithoutLocationInput | EntityUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: EntityScalarWhereInput | EntityScalarWhereInput[]
  }

  export type LocationBusinessUncheckedUpdateManyWithoutLocationNestedInput = {
    create?: XOR<LocationBusinessCreateWithoutLocationInput, LocationBusinessUncheckedCreateWithoutLocationInput> | LocationBusinessCreateWithoutLocationInput[] | LocationBusinessUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: LocationBusinessCreateOrConnectWithoutLocationInput | LocationBusinessCreateOrConnectWithoutLocationInput[]
    upsert?: LocationBusinessUpsertWithWhereUniqueWithoutLocationInput | LocationBusinessUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: LocationBusinessCreateManyLocationInputEnvelope
    set?: LocationBusinessWhereUniqueInput | LocationBusinessWhereUniqueInput[]
    disconnect?: LocationBusinessWhereUniqueInput | LocationBusinessWhereUniqueInput[]
    delete?: LocationBusinessWhereUniqueInput | LocationBusinessWhereUniqueInput[]
    connect?: LocationBusinessWhereUniqueInput | LocationBusinessWhereUniqueInput[]
    update?: LocationBusinessUpdateWithWhereUniqueWithoutLocationInput | LocationBusinessUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: LocationBusinessUpdateManyWithWhereWithoutLocationInput | LocationBusinessUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: LocationBusinessScalarWhereInput | LocationBusinessScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutLocationNestedInput = {
    create?: XOR<UserCreateWithoutLocationInput, UserUncheckedCreateWithoutLocationInput> | UserCreateWithoutLocationInput[] | UserUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: UserCreateOrConnectWithoutLocationInput | UserCreateOrConnectWithoutLocationInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutLocationInput | UserUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: UserCreateManyLocationInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutLocationInput | UserUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: UserUpdateManyWithWhereWithoutLocationInput | UserUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type unitTypeUncheckedUpdateManyWithoutLocationNestedInput = {
    create?: XOR<unitTypeCreateWithoutLocationInput, unitTypeUncheckedCreateWithoutLocationInput> | unitTypeCreateWithoutLocationInput[] | unitTypeUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: unitTypeCreateOrConnectWithoutLocationInput | unitTypeCreateOrConnectWithoutLocationInput[]
    upsert?: unitTypeUpsertWithWhereUniqueWithoutLocationInput | unitTypeUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: unitTypeCreateManyLocationInputEnvelope
    set?: unitTypeWhereUniqueInput | unitTypeWhereUniqueInput[]
    disconnect?: unitTypeWhereUniqueInput | unitTypeWhereUniqueInput[]
    delete?: unitTypeWhereUniqueInput | unitTypeWhereUniqueInput[]
    connect?: unitTypeWhereUniqueInput | unitTypeWhereUniqueInput[]
    update?: unitTypeUpdateWithWhereUniqueWithoutLocationInput | unitTypeUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: unitTypeUpdateManyWithWhereWithoutLocationInput | unitTypeUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: unitTypeScalarWhereInput | unitTypeScalarWhereInput[]
  }

  export type rolesTableUncheckedUpdateManyWithoutLocationNestedInput = {
    create?: XOR<rolesTableCreateWithoutLocationInput, rolesTableUncheckedCreateWithoutLocationInput> | rolesTableCreateWithoutLocationInput[] | rolesTableUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: rolesTableCreateOrConnectWithoutLocationInput | rolesTableCreateOrConnectWithoutLocationInput[]
    upsert?: rolesTableUpsertWithWhereUniqueWithoutLocationInput | rolesTableUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: rolesTableCreateManyLocationInputEnvelope
    set?: rolesTableWhereUniqueInput | rolesTableWhereUniqueInput[]
    disconnect?: rolesTableWhereUniqueInput | rolesTableWhereUniqueInput[]
    delete?: rolesTableWhereUniqueInput | rolesTableWhereUniqueInput[]
    connect?: rolesTableWhereUniqueInput | rolesTableWhereUniqueInput[]
    update?: rolesTableUpdateWithWhereUniqueWithoutLocationInput | rolesTableUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: rolesTableUpdateManyWithWhereWithoutLocationInput | rolesTableUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: rolesTableScalarWhereInput | rolesTableScalarWhereInput[]
  }

  export type RoleUncheckedUpdateManyWithoutLocationNestedInput = {
    create?: XOR<RoleCreateWithoutLocationInput, RoleUncheckedCreateWithoutLocationInput> | RoleCreateWithoutLocationInput[] | RoleUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: RoleCreateOrConnectWithoutLocationInput | RoleCreateOrConnectWithoutLocationInput[]
    upsert?: RoleUpsertWithWhereUniqueWithoutLocationInput | RoleUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: RoleCreateManyLocationInputEnvelope
    set?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    disconnect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    delete?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    connect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    update?: RoleUpdateWithWhereUniqueWithoutLocationInput | RoleUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: RoleUpdateManyWithWhereWithoutLocationInput | RoleUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: RoleScalarWhereInput | RoleScalarWhereInput[]
  }

  export type EntityCreateusersInput = {
    set: string[]
  }

  export type EntityCreatesectionsInput = {
    set: string[]
  }

  export type EntityTypeCreateNestedOneWithoutEntityInput = {
    create?: XOR<EntityTypeCreateWithoutEntityInput, EntityTypeUncheckedCreateWithoutEntityInput>
    connectOrCreate?: EntityTypeCreateOrConnectWithoutEntityInput
    connect?: EntityTypeWhereUniqueInput
  }

  export type LocationCreateNestedOneWithoutEntityInput = {
    create?: XOR<LocationCreateWithoutEntityInput, LocationUncheckedCreateWithoutEntityInput>
    connectOrCreate?: LocationCreateOrConnectWithoutEntityInput
    connect?: LocationWhereUniqueInput
  }

  export type OrganizationCreateNestedOneWithoutEntityInput = {
    create?: XOR<OrganizationCreateWithoutEntityInput, OrganizationUncheckedCreateWithoutEntityInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutEntityInput
    connect?: OrganizationWhereUniqueInput
  }

  export type DoctypeCreateNestedManyWithoutEntityInput = {
    create?: XOR<DoctypeCreateWithoutEntityInput, DoctypeUncheckedCreateWithoutEntityInput> | DoctypeCreateWithoutEntityInput[] | DoctypeUncheckedCreateWithoutEntityInput[]
    connectOrCreate?: DoctypeCreateOrConnectWithoutEntityInput | DoctypeCreateOrConnectWithoutEntityInput[]
    createMany?: DoctypeCreateManyEntityInputEnvelope
    connect?: DoctypeWhereUniqueInput | DoctypeWhereUniqueInput[]
  }

  export type DocumentsCreateNestedManyWithoutCreatorEntityInput = {
    create?: XOR<DocumentsCreateWithoutCreatorEntityInput, DocumentsUncheckedCreateWithoutCreatorEntityInput> | DocumentsCreateWithoutCreatorEntityInput[] | DocumentsUncheckedCreateWithoutCreatorEntityInput[]
    connectOrCreate?: DocumentsCreateOrConnectWithoutCreatorEntityInput | DocumentsCreateOrConnectWithoutCreatorEntityInput[]
    createMany?: DocumentsCreateManyCreatorEntityInputEnvelope
    connect?: DocumentsWhereUniqueInput | DocumentsWhereUniqueInput[]
  }

  export type UserCreateNestedManyWithoutEntityInput = {
    create?: XOR<UserCreateWithoutEntityInput, UserUncheckedCreateWithoutEntityInput> | UserCreateWithoutEntityInput[] | UserUncheckedCreateWithoutEntityInput[]
    connectOrCreate?: UserCreateOrConnectWithoutEntityInput | UserCreateOrConnectWithoutEntityInput[]
    createMany?: UserCreateManyEntityInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type PartsCreateNestedManyWithoutEntityInput = {
    create?: XOR<PartsCreateWithoutEntityInput, PartsUncheckedCreateWithoutEntityInput> | PartsCreateWithoutEntityInput[] | PartsUncheckedCreateWithoutEntityInput[]
    connectOrCreate?: PartsCreateOrConnectWithoutEntityInput | PartsCreateOrConnectWithoutEntityInput[]
    createMany?: PartsCreateManyEntityInputEnvelope
    connect?: PartsWhereUniqueInput | PartsWhereUniqueInput[]
  }

  export type ClaimToEntityCreateNestedManyWithoutEntityInput = {
    create?: XOR<ClaimToEntityCreateWithoutEntityInput, ClaimToEntityUncheckedCreateWithoutEntityInput> | ClaimToEntityCreateWithoutEntityInput[] | ClaimToEntityUncheckedCreateWithoutEntityInput[]
    connectOrCreate?: ClaimToEntityCreateOrConnectWithoutEntityInput | ClaimToEntityCreateOrConnectWithoutEntityInput[]
    createMany?: ClaimToEntityCreateManyEntityInputEnvelope
    connect?: ClaimToEntityWhereUniqueInput | ClaimToEntityWhereUniqueInput[]
  }

  export type FunctionsCreateNestedOneWithoutEntityInput = {
    create?: XOR<FunctionsCreateWithoutEntityInput, FunctionsUncheckedCreateWithoutEntityInput>
    connectOrCreate?: FunctionsCreateOrConnectWithoutEntityInput
    connect?: FunctionsWhereUniqueInput
  }

  export type DoctypeUncheckedCreateNestedManyWithoutEntityInput = {
    create?: XOR<DoctypeCreateWithoutEntityInput, DoctypeUncheckedCreateWithoutEntityInput> | DoctypeCreateWithoutEntityInput[] | DoctypeUncheckedCreateWithoutEntityInput[]
    connectOrCreate?: DoctypeCreateOrConnectWithoutEntityInput | DoctypeCreateOrConnectWithoutEntityInput[]
    createMany?: DoctypeCreateManyEntityInputEnvelope
    connect?: DoctypeWhereUniqueInput | DoctypeWhereUniqueInput[]
  }

  export type DocumentsUncheckedCreateNestedManyWithoutCreatorEntityInput = {
    create?: XOR<DocumentsCreateWithoutCreatorEntityInput, DocumentsUncheckedCreateWithoutCreatorEntityInput> | DocumentsCreateWithoutCreatorEntityInput[] | DocumentsUncheckedCreateWithoutCreatorEntityInput[]
    connectOrCreate?: DocumentsCreateOrConnectWithoutCreatorEntityInput | DocumentsCreateOrConnectWithoutCreatorEntityInput[]
    createMany?: DocumentsCreateManyCreatorEntityInputEnvelope
    connect?: DocumentsWhereUniqueInput | DocumentsWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutEntityInput = {
    create?: XOR<UserCreateWithoutEntityInput, UserUncheckedCreateWithoutEntityInput> | UserCreateWithoutEntityInput[] | UserUncheckedCreateWithoutEntityInput[]
    connectOrCreate?: UserCreateOrConnectWithoutEntityInput | UserCreateOrConnectWithoutEntityInput[]
    createMany?: UserCreateManyEntityInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type PartsUncheckedCreateNestedManyWithoutEntityInput = {
    create?: XOR<PartsCreateWithoutEntityInput, PartsUncheckedCreateWithoutEntityInput> | PartsCreateWithoutEntityInput[] | PartsUncheckedCreateWithoutEntityInput[]
    connectOrCreate?: PartsCreateOrConnectWithoutEntityInput | PartsCreateOrConnectWithoutEntityInput[]
    createMany?: PartsCreateManyEntityInputEnvelope
    connect?: PartsWhereUniqueInput | PartsWhereUniqueInput[]
  }

  export type ClaimToEntityUncheckedCreateNestedManyWithoutEntityInput = {
    create?: XOR<ClaimToEntityCreateWithoutEntityInput, ClaimToEntityUncheckedCreateWithoutEntityInput> | ClaimToEntityCreateWithoutEntityInput[] | ClaimToEntityUncheckedCreateWithoutEntityInput[]
    connectOrCreate?: ClaimToEntityCreateOrConnectWithoutEntityInput | ClaimToEntityCreateOrConnectWithoutEntityInput[]
    createMany?: ClaimToEntityCreateManyEntityInputEnvelope
    connect?: ClaimToEntityWhereUniqueInput | ClaimToEntityWhereUniqueInput[]
  }

  export type EntityUpdateusersInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EntityUpdatesectionsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EntityTypeUpdateOneWithoutEntityNestedInput = {
    create?: XOR<EntityTypeCreateWithoutEntityInput, EntityTypeUncheckedCreateWithoutEntityInput>
    connectOrCreate?: EntityTypeCreateOrConnectWithoutEntityInput
    upsert?: EntityTypeUpsertWithoutEntityInput
    disconnect?: boolean
    delete?: EntityTypeWhereInput | boolean
    connect?: EntityTypeWhereUniqueInput
    update?: XOR<XOR<EntityTypeUpdateToOneWithWhereWithoutEntityInput, EntityTypeUpdateWithoutEntityInput>, EntityTypeUncheckedUpdateWithoutEntityInput>
  }

  export type LocationUpdateOneWithoutEntityNestedInput = {
    create?: XOR<LocationCreateWithoutEntityInput, LocationUncheckedCreateWithoutEntityInput>
    connectOrCreate?: LocationCreateOrConnectWithoutEntityInput
    upsert?: LocationUpsertWithoutEntityInput
    disconnect?: boolean
    delete?: LocationWhereInput | boolean
    connect?: LocationWhereUniqueInput
    update?: XOR<XOR<LocationUpdateToOneWithWhereWithoutEntityInput, LocationUpdateWithoutEntityInput>, LocationUncheckedUpdateWithoutEntityInput>
  }

  export type OrganizationUpdateOneWithoutEntityNestedInput = {
    create?: XOR<OrganizationCreateWithoutEntityInput, OrganizationUncheckedCreateWithoutEntityInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutEntityInput
    upsert?: OrganizationUpsertWithoutEntityInput
    disconnect?: boolean
    delete?: OrganizationWhereInput | boolean
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutEntityInput, OrganizationUpdateWithoutEntityInput>, OrganizationUncheckedUpdateWithoutEntityInput>
  }

  export type DoctypeUpdateManyWithoutEntityNestedInput = {
    create?: XOR<DoctypeCreateWithoutEntityInput, DoctypeUncheckedCreateWithoutEntityInput> | DoctypeCreateWithoutEntityInput[] | DoctypeUncheckedCreateWithoutEntityInput[]
    connectOrCreate?: DoctypeCreateOrConnectWithoutEntityInput | DoctypeCreateOrConnectWithoutEntityInput[]
    upsert?: DoctypeUpsertWithWhereUniqueWithoutEntityInput | DoctypeUpsertWithWhereUniqueWithoutEntityInput[]
    createMany?: DoctypeCreateManyEntityInputEnvelope
    set?: DoctypeWhereUniqueInput | DoctypeWhereUniqueInput[]
    disconnect?: DoctypeWhereUniqueInput | DoctypeWhereUniqueInput[]
    delete?: DoctypeWhereUniqueInput | DoctypeWhereUniqueInput[]
    connect?: DoctypeWhereUniqueInput | DoctypeWhereUniqueInput[]
    update?: DoctypeUpdateWithWhereUniqueWithoutEntityInput | DoctypeUpdateWithWhereUniqueWithoutEntityInput[]
    updateMany?: DoctypeUpdateManyWithWhereWithoutEntityInput | DoctypeUpdateManyWithWhereWithoutEntityInput[]
    deleteMany?: DoctypeScalarWhereInput | DoctypeScalarWhereInput[]
  }

  export type DocumentsUpdateManyWithoutCreatorEntityNestedInput = {
    create?: XOR<DocumentsCreateWithoutCreatorEntityInput, DocumentsUncheckedCreateWithoutCreatorEntityInput> | DocumentsCreateWithoutCreatorEntityInput[] | DocumentsUncheckedCreateWithoutCreatorEntityInput[]
    connectOrCreate?: DocumentsCreateOrConnectWithoutCreatorEntityInput | DocumentsCreateOrConnectWithoutCreatorEntityInput[]
    upsert?: DocumentsUpsertWithWhereUniqueWithoutCreatorEntityInput | DocumentsUpsertWithWhereUniqueWithoutCreatorEntityInput[]
    createMany?: DocumentsCreateManyCreatorEntityInputEnvelope
    set?: DocumentsWhereUniqueInput | DocumentsWhereUniqueInput[]
    disconnect?: DocumentsWhereUniqueInput | DocumentsWhereUniqueInput[]
    delete?: DocumentsWhereUniqueInput | DocumentsWhereUniqueInput[]
    connect?: DocumentsWhereUniqueInput | DocumentsWhereUniqueInput[]
    update?: DocumentsUpdateWithWhereUniqueWithoutCreatorEntityInput | DocumentsUpdateWithWhereUniqueWithoutCreatorEntityInput[]
    updateMany?: DocumentsUpdateManyWithWhereWithoutCreatorEntityInput | DocumentsUpdateManyWithWhereWithoutCreatorEntityInput[]
    deleteMany?: DocumentsScalarWhereInput | DocumentsScalarWhereInput[]
  }

  export type UserUpdateManyWithoutEntityNestedInput = {
    create?: XOR<UserCreateWithoutEntityInput, UserUncheckedCreateWithoutEntityInput> | UserCreateWithoutEntityInput[] | UserUncheckedCreateWithoutEntityInput[]
    connectOrCreate?: UserCreateOrConnectWithoutEntityInput | UserCreateOrConnectWithoutEntityInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutEntityInput | UserUpsertWithWhereUniqueWithoutEntityInput[]
    createMany?: UserCreateManyEntityInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutEntityInput | UserUpdateWithWhereUniqueWithoutEntityInput[]
    updateMany?: UserUpdateManyWithWhereWithoutEntityInput | UserUpdateManyWithWhereWithoutEntityInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type PartsUpdateManyWithoutEntityNestedInput = {
    create?: XOR<PartsCreateWithoutEntityInput, PartsUncheckedCreateWithoutEntityInput> | PartsCreateWithoutEntityInput[] | PartsUncheckedCreateWithoutEntityInput[]
    connectOrCreate?: PartsCreateOrConnectWithoutEntityInput | PartsCreateOrConnectWithoutEntityInput[]
    upsert?: PartsUpsertWithWhereUniqueWithoutEntityInput | PartsUpsertWithWhereUniqueWithoutEntityInput[]
    createMany?: PartsCreateManyEntityInputEnvelope
    set?: PartsWhereUniqueInput | PartsWhereUniqueInput[]
    disconnect?: PartsWhereUniqueInput | PartsWhereUniqueInput[]
    delete?: PartsWhereUniqueInput | PartsWhereUniqueInput[]
    connect?: PartsWhereUniqueInput | PartsWhereUniqueInput[]
    update?: PartsUpdateWithWhereUniqueWithoutEntityInput | PartsUpdateWithWhereUniqueWithoutEntityInput[]
    updateMany?: PartsUpdateManyWithWhereWithoutEntityInput | PartsUpdateManyWithWhereWithoutEntityInput[]
    deleteMany?: PartsScalarWhereInput | PartsScalarWhereInput[]
  }

  export type ClaimToEntityUpdateManyWithoutEntityNestedInput = {
    create?: XOR<ClaimToEntityCreateWithoutEntityInput, ClaimToEntityUncheckedCreateWithoutEntityInput> | ClaimToEntityCreateWithoutEntityInput[] | ClaimToEntityUncheckedCreateWithoutEntityInput[]
    connectOrCreate?: ClaimToEntityCreateOrConnectWithoutEntityInput | ClaimToEntityCreateOrConnectWithoutEntityInput[]
    upsert?: ClaimToEntityUpsertWithWhereUniqueWithoutEntityInput | ClaimToEntityUpsertWithWhereUniqueWithoutEntityInput[]
    createMany?: ClaimToEntityCreateManyEntityInputEnvelope
    set?: ClaimToEntityWhereUniqueInput | ClaimToEntityWhereUniqueInput[]
    disconnect?: ClaimToEntityWhereUniqueInput | ClaimToEntityWhereUniqueInput[]
    delete?: ClaimToEntityWhereUniqueInput | ClaimToEntityWhereUniqueInput[]
    connect?: ClaimToEntityWhereUniqueInput | ClaimToEntityWhereUniqueInput[]
    update?: ClaimToEntityUpdateWithWhereUniqueWithoutEntityInput | ClaimToEntityUpdateWithWhereUniqueWithoutEntityInput[]
    updateMany?: ClaimToEntityUpdateManyWithWhereWithoutEntityInput | ClaimToEntityUpdateManyWithWhereWithoutEntityInput[]
    deleteMany?: ClaimToEntityScalarWhereInput | ClaimToEntityScalarWhereInput[]
  }

  export type FunctionsUpdateOneWithoutEntityNestedInput = {
    create?: XOR<FunctionsCreateWithoutEntityInput, FunctionsUncheckedCreateWithoutEntityInput>
    connectOrCreate?: FunctionsCreateOrConnectWithoutEntityInput
    upsert?: FunctionsUpsertWithoutEntityInput
    disconnect?: boolean
    delete?: FunctionsWhereInput | boolean
    connect?: FunctionsWhereUniqueInput
    update?: XOR<XOR<FunctionsUpdateToOneWithWhereWithoutEntityInput, FunctionsUpdateWithoutEntityInput>, FunctionsUncheckedUpdateWithoutEntityInput>
  }

  export type DoctypeUncheckedUpdateManyWithoutEntityNestedInput = {
    create?: XOR<DoctypeCreateWithoutEntityInput, DoctypeUncheckedCreateWithoutEntityInput> | DoctypeCreateWithoutEntityInput[] | DoctypeUncheckedCreateWithoutEntityInput[]
    connectOrCreate?: DoctypeCreateOrConnectWithoutEntityInput | DoctypeCreateOrConnectWithoutEntityInput[]
    upsert?: DoctypeUpsertWithWhereUniqueWithoutEntityInput | DoctypeUpsertWithWhereUniqueWithoutEntityInput[]
    createMany?: DoctypeCreateManyEntityInputEnvelope
    set?: DoctypeWhereUniqueInput | DoctypeWhereUniqueInput[]
    disconnect?: DoctypeWhereUniqueInput | DoctypeWhereUniqueInput[]
    delete?: DoctypeWhereUniqueInput | DoctypeWhereUniqueInput[]
    connect?: DoctypeWhereUniqueInput | DoctypeWhereUniqueInput[]
    update?: DoctypeUpdateWithWhereUniqueWithoutEntityInput | DoctypeUpdateWithWhereUniqueWithoutEntityInput[]
    updateMany?: DoctypeUpdateManyWithWhereWithoutEntityInput | DoctypeUpdateManyWithWhereWithoutEntityInput[]
    deleteMany?: DoctypeScalarWhereInput | DoctypeScalarWhereInput[]
  }

  export type DocumentsUncheckedUpdateManyWithoutCreatorEntityNestedInput = {
    create?: XOR<DocumentsCreateWithoutCreatorEntityInput, DocumentsUncheckedCreateWithoutCreatorEntityInput> | DocumentsCreateWithoutCreatorEntityInput[] | DocumentsUncheckedCreateWithoutCreatorEntityInput[]
    connectOrCreate?: DocumentsCreateOrConnectWithoutCreatorEntityInput | DocumentsCreateOrConnectWithoutCreatorEntityInput[]
    upsert?: DocumentsUpsertWithWhereUniqueWithoutCreatorEntityInput | DocumentsUpsertWithWhereUniqueWithoutCreatorEntityInput[]
    createMany?: DocumentsCreateManyCreatorEntityInputEnvelope
    set?: DocumentsWhereUniqueInput | DocumentsWhereUniqueInput[]
    disconnect?: DocumentsWhereUniqueInput | DocumentsWhereUniqueInput[]
    delete?: DocumentsWhereUniqueInput | DocumentsWhereUniqueInput[]
    connect?: DocumentsWhereUniqueInput | DocumentsWhereUniqueInput[]
    update?: DocumentsUpdateWithWhereUniqueWithoutCreatorEntityInput | DocumentsUpdateWithWhereUniqueWithoutCreatorEntityInput[]
    updateMany?: DocumentsUpdateManyWithWhereWithoutCreatorEntityInput | DocumentsUpdateManyWithWhereWithoutCreatorEntityInput[]
    deleteMany?: DocumentsScalarWhereInput | DocumentsScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutEntityNestedInput = {
    create?: XOR<UserCreateWithoutEntityInput, UserUncheckedCreateWithoutEntityInput> | UserCreateWithoutEntityInput[] | UserUncheckedCreateWithoutEntityInput[]
    connectOrCreate?: UserCreateOrConnectWithoutEntityInput | UserCreateOrConnectWithoutEntityInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutEntityInput | UserUpsertWithWhereUniqueWithoutEntityInput[]
    createMany?: UserCreateManyEntityInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutEntityInput | UserUpdateWithWhereUniqueWithoutEntityInput[]
    updateMany?: UserUpdateManyWithWhereWithoutEntityInput | UserUpdateManyWithWhereWithoutEntityInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type PartsUncheckedUpdateManyWithoutEntityNestedInput = {
    create?: XOR<PartsCreateWithoutEntityInput, PartsUncheckedCreateWithoutEntityInput> | PartsCreateWithoutEntityInput[] | PartsUncheckedCreateWithoutEntityInput[]
    connectOrCreate?: PartsCreateOrConnectWithoutEntityInput | PartsCreateOrConnectWithoutEntityInput[]
    upsert?: PartsUpsertWithWhereUniqueWithoutEntityInput | PartsUpsertWithWhereUniqueWithoutEntityInput[]
    createMany?: PartsCreateManyEntityInputEnvelope
    set?: PartsWhereUniqueInput | PartsWhereUniqueInput[]
    disconnect?: PartsWhereUniqueInput | PartsWhereUniqueInput[]
    delete?: PartsWhereUniqueInput | PartsWhereUniqueInput[]
    connect?: PartsWhereUniqueInput | PartsWhereUniqueInput[]
    update?: PartsUpdateWithWhereUniqueWithoutEntityInput | PartsUpdateWithWhereUniqueWithoutEntityInput[]
    updateMany?: PartsUpdateManyWithWhereWithoutEntityInput | PartsUpdateManyWithWhereWithoutEntityInput[]
    deleteMany?: PartsScalarWhereInput | PartsScalarWhereInput[]
  }

  export type ClaimToEntityUncheckedUpdateManyWithoutEntityNestedInput = {
    create?: XOR<ClaimToEntityCreateWithoutEntityInput, ClaimToEntityUncheckedCreateWithoutEntityInput> | ClaimToEntityCreateWithoutEntityInput[] | ClaimToEntityUncheckedCreateWithoutEntityInput[]
    connectOrCreate?: ClaimToEntityCreateOrConnectWithoutEntityInput | ClaimToEntityCreateOrConnectWithoutEntityInput[]
    upsert?: ClaimToEntityUpsertWithWhereUniqueWithoutEntityInput | ClaimToEntityUpsertWithWhereUniqueWithoutEntityInput[]
    createMany?: ClaimToEntityCreateManyEntityInputEnvelope
    set?: ClaimToEntityWhereUniqueInput | ClaimToEntityWhereUniqueInput[]
    disconnect?: ClaimToEntityWhereUniqueInput | ClaimToEntityWhereUniqueInput[]
    delete?: ClaimToEntityWhereUniqueInput | ClaimToEntityWhereUniqueInput[]
    connect?: ClaimToEntityWhereUniqueInput | ClaimToEntityWhereUniqueInput[]
    update?: ClaimToEntityUpdateWithWhereUniqueWithoutEntityInput | ClaimToEntityUpdateWithWhereUniqueWithoutEntityInput[]
    updateMany?: ClaimToEntityUpdateManyWithWhereWithoutEntityInput | ClaimToEntityUpdateManyWithWhereWithoutEntityInput[]
    deleteMany?: ClaimToEntityScalarWhereInput | ClaimToEntityScalarWhereInput[]
  }

  export type BusinessCreateNestedOneWithoutLocationInput = {
    create?: XOR<BusinessCreateWithoutLocationInput, BusinessUncheckedCreateWithoutLocationInput>
    connectOrCreate?: BusinessCreateOrConnectWithoutLocationInput
    connect?: BusinessWhereUniqueInput
  }

  export type LocationCreateNestedOneWithoutBusinessInput = {
    create?: XOR<LocationCreateWithoutBusinessInput, LocationUncheckedCreateWithoutBusinessInput>
    connectOrCreate?: LocationCreateOrConnectWithoutBusinessInput
    connect?: LocationWhereUniqueInput
  }

  export type BusinessUpdateOneWithoutLocationNestedInput = {
    create?: XOR<BusinessCreateWithoutLocationInput, BusinessUncheckedCreateWithoutLocationInput>
    connectOrCreate?: BusinessCreateOrConnectWithoutLocationInput
    upsert?: BusinessUpsertWithoutLocationInput
    disconnect?: boolean
    delete?: BusinessWhereInput | boolean
    connect?: BusinessWhereUniqueInput
    update?: XOR<XOR<BusinessUpdateToOneWithWhereWithoutLocationInput, BusinessUpdateWithoutLocationInput>, BusinessUncheckedUpdateWithoutLocationInput>
  }

  export type LocationUpdateOneWithoutBusinessNestedInput = {
    create?: XOR<LocationCreateWithoutBusinessInput, LocationUncheckedCreateWithoutBusinessInput>
    connectOrCreate?: LocationCreateOrConnectWithoutBusinessInput
    upsert?: LocationUpsertWithoutBusinessInput
    disconnect?: boolean
    delete?: LocationWhereInput | boolean
    connect?: LocationWhereUniqueInput
    update?: XOR<XOR<LocationUpdateToOneWithWhereWithoutBusinessInput, LocationUpdateWithoutBusinessInput>, LocationUncheckedUpdateWithoutBusinessInput>
  }

  export type UserCreateNestedOneWithoutNotificationInput = {
    create?: XOR<UserCreateWithoutNotificationInput, UserUncheckedCreateWithoutNotificationInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutNotificationNestedInput = {
    create?: XOR<UserCreateWithoutNotificationInput, UserUncheckedCreateWithoutNotificationInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationInput
    upsert?: UserUpsertWithoutNotificationInput
    disconnect?: boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationInput, UserUpdateWithoutNotificationInput>, UserUncheckedUpdateWithoutNotificationInput>
  }

  export type DoctypeCreatelocationIdInput = {
    set: string[]
  }

  export type DoctypeCreatereadAccessUsersInput = {
    set: InputJsonValue[]
  }

  export type DoctypeCreateapplicable_systemsInput = {
    set: InputJsonValue[]
  }

  export type DoctypeCreateusersInput = {
    set: InputJsonValue[]
  }

  export type DoctypeCreatedistributionUsersInput = {
    set: InputJsonValue[]
  }

  export type OrganizationCreateNestedOneWithoutDoctypeInput = {
    create?: XOR<OrganizationCreateWithoutDoctypeInput, OrganizationUncheckedCreateWithoutDoctypeInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutDoctypeInput
    connect?: OrganizationWhereUniqueInput
  }

  export type EntityCreateNestedOneWithoutDoctypeInput = {
    create?: XOR<EntityCreateWithoutDoctypeInput, EntityUncheckedCreateWithoutDoctypeInput>
    connectOrCreate?: EntityCreateOrConnectWithoutDoctypeInput
    connect?: EntityWhereUniqueInput
  }

  export type DocumentsCreateNestedManyWithoutDoctypeInput = {
    create?: XOR<DocumentsCreateWithoutDoctypeInput, DocumentsUncheckedCreateWithoutDoctypeInput> | DocumentsCreateWithoutDoctypeInput[] | DocumentsUncheckedCreateWithoutDoctypeInput[]
    connectOrCreate?: DocumentsCreateOrConnectWithoutDoctypeInput | DocumentsCreateOrConnectWithoutDoctypeInput[]
    createMany?: DocumentsCreateManyDoctypeInputEnvelope
    connect?: DocumentsWhereUniqueInput | DocumentsWhereUniqueInput[]
  }

  export type documentAdminsCreateNestedManyWithoutDoctypeInput = {
    create?: XOR<documentAdminsCreateWithoutDoctypeInput, documentAdminsUncheckedCreateWithoutDoctypeInput> | documentAdminsCreateWithoutDoctypeInput[] | documentAdminsUncheckedCreateWithoutDoctypeInput[]
    connectOrCreate?: documentAdminsCreateOrConnectWithoutDoctypeInput | documentAdminsCreateOrConnectWithoutDoctypeInput[]
    createMany?: documentAdminsCreateManyDoctypeInputEnvelope
    connect?: documentAdminsWhereUniqueInput | documentAdminsWhereUniqueInput[]
  }

  export type DocumentsUncheckedCreateNestedManyWithoutDoctypeInput = {
    create?: XOR<DocumentsCreateWithoutDoctypeInput, DocumentsUncheckedCreateWithoutDoctypeInput> | DocumentsCreateWithoutDoctypeInput[] | DocumentsUncheckedCreateWithoutDoctypeInput[]
    connectOrCreate?: DocumentsCreateOrConnectWithoutDoctypeInput | DocumentsCreateOrConnectWithoutDoctypeInput[]
    createMany?: DocumentsCreateManyDoctypeInputEnvelope
    connect?: DocumentsWhereUniqueInput | DocumentsWhereUniqueInput[]
  }

  export type documentAdminsUncheckedCreateNestedManyWithoutDoctypeInput = {
    create?: XOR<documentAdminsCreateWithoutDoctypeInput, documentAdminsUncheckedCreateWithoutDoctypeInput> | documentAdminsCreateWithoutDoctypeInput[] | documentAdminsUncheckedCreateWithoutDoctypeInput[]
    connectOrCreate?: documentAdminsCreateOrConnectWithoutDoctypeInput | documentAdminsCreateOrConnectWithoutDoctypeInput[]
    createMany?: documentAdminsCreateManyDoctypeInputEnvelope
    connect?: documentAdminsWhereUniqueInput | documentAdminsWhereUniqueInput[]
  }

  export type DoctypeUpdatelocationIdInput = {
    set?: string[]
    push?: string | string[]
  }

  export type DoctypeUpdatereadAccessUsersInput = {
    set?: InputJsonValue[]
    push?: InputJsonValue | InputJsonValue[]
  }

  export type DoctypeUpdateapplicable_systemsInput = {
    set?: InputJsonValue[]
    push?: InputJsonValue | InputJsonValue[]
  }

  export type DoctypeUpdateusersInput = {
    set?: InputJsonValue[]
    push?: InputJsonValue | InputJsonValue[]
  }

  export type DoctypeUpdatedistributionUsersInput = {
    set?: InputJsonValue[]
    push?: InputJsonValue | InputJsonValue[]
  }

  export type OrganizationUpdateOneWithoutDoctypeNestedInput = {
    create?: XOR<OrganizationCreateWithoutDoctypeInput, OrganizationUncheckedCreateWithoutDoctypeInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutDoctypeInput
    upsert?: OrganizationUpsertWithoutDoctypeInput
    disconnect?: boolean
    delete?: OrganizationWhereInput | boolean
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutDoctypeInput, OrganizationUpdateWithoutDoctypeInput>, OrganizationUncheckedUpdateWithoutDoctypeInput>
  }

  export type EntityUpdateOneWithoutDoctypeNestedInput = {
    create?: XOR<EntityCreateWithoutDoctypeInput, EntityUncheckedCreateWithoutDoctypeInput>
    connectOrCreate?: EntityCreateOrConnectWithoutDoctypeInput
    upsert?: EntityUpsertWithoutDoctypeInput
    disconnect?: boolean
    delete?: EntityWhereInput | boolean
    connect?: EntityWhereUniqueInput
    update?: XOR<XOR<EntityUpdateToOneWithWhereWithoutDoctypeInput, EntityUpdateWithoutDoctypeInput>, EntityUncheckedUpdateWithoutDoctypeInput>
  }

  export type DocumentsUpdateManyWithoutDoctypeNestedInput = {
    create?: XOR<DocumentsCreateWithoutDoctypeInput, DocumentsUncheckedCreateWithoutDoctypeInput> | DocumentsCreateWithoutDoctypeInput[] | DocumentsUncheckedCreateWithoutDoctypeInput[]
    connectOrCreate?: DocumentsCreateOrConnectWithoutDoctypeInput | DocumentsCreateOrConnectWithoutDoctypeInput[]
    upsert?: DocumentsUpsertWithWhereUniqueWithoutDoctypeInput | DocumentsUpsertWithWhereUniqueWithoutDoctypeInput[]
    createMany?: DocumentsCreateManyDoctypeInputEnvelope
    set?: DocumentsWhereUniqueInput | DocumentsWhereUniqueInput[]
    disconnect?: DocumentsWhereUniqueInput | DocumentsWhereUniqueInput[]
    delete?: DocumentsWhereUniqueInput | DocumentsWhereUniqueInput[]
    connect?: DocumentsWhereUniqueInput | DocumentsWhereUniqueInput[]
    update?: DocumentsUpdateWithWhereUniqueWithoutDoctypeInput | DocumentsUpdateWithWhereUniqueWithoutDoctypeInput[]
    updateMany?: DocumentsUpdateManyWithWhereWithoutDoctypeInput | DocumentsUpdateManyWithWhereWithoutDoctypeInput[]
    deleteMany?: DocumentsScalarWhereInput | DocumentsScalarWhereInput[]
  }

  export type documentAdminsUpdateManyWithoutDoctypeNestedInput = {
    create?: XOR<documentAdminsCreateWithoutDoctypeInput, documentAdminsUncheckedCreateWithoutDoctypeInput> | documentAdminsCreateWithoutDoctypeInput[] | documentAdminsUncheckedCreateWithoutDoctypeInput[]
    connectOrCreate?: documentAdminsCreateOrConnectWithoutDoctypeInput | documentAdminsCreateOrConnectWithoutDoctypeInput[]
    upsert?: documentAdminsUpsertWithWhereUniqueWithoutDoctypeInput | documentAdminsUpsertWithWhereUniqueWithoutDoctypeInput[]
    createMany?: documentAdminsCreateManyDoctypeInputEnvelope
    set?: documentAdminsWhereUniqueInput | documentAdminsWhereUniqueInput[]
    disconnect?: documentAdminsWhereUniqueInput | documentAdminsWhereUniqueInput[]
    delete?: documentAdminsWhereUniqueInput | documentAdminsWhereUniqueInput[]
    connect?: documentAdminsWhereUniqueInput | documentAdminsWhereUniqueInput[]
    update?: documentAdminsUpdateWithWhereUniqueWithoutDoctypeInput | documentAdminsUpdateWithWhereUniqueWithoutDoctypeInput[]
    updateMany?: documentAdminsUpdateManyWithWhereWithoutDoctypeInput | documentAdminsUpdateManyWithWhereWithoutDoctypeInput[]
    deleteMany?: documentAdminsScalarWhereInput | documentAdminsScalarWhereInput[]
  }

  export type DocumentsUncheckedUpdateManyWithoutDoctypeNestedInput = {
    create?: XOR<DocumentsCreateWithoutDoctypeInput, DocumentsUncheckedCreateWithoutDoctypeInput> | DocumentsCreateWithoutDoctypeInput[] | DocumentsUncheckedCreateWithoutDoctypeInput[]
    connectOrCreate?: DocumentsCreateOrConnectWithoutDoctypeInput | DocumentsCreateOrConnectWithoutDoctypeInput[]
    upsert?: DocumentsUpsertWithWhereUniqueWithoutDoctypeInput | DocumentsUpsertWithWhereUniqueWithoutDoctypeInput[]
    createMany?: DocumentsCreateManyDoctypeInputEnvelope
    set?: DocumentsWhereUniqueInput | DocumentsWhereUniqueInput[]
    disconnect?: DocumentsWhereUniqueInput | DocumentsWhereUniqueInput[]
    delete?: DocumentsWhereUniqueInput | DocumentsWhereUniqueInput[]
    connect?: DocumentsWhereUniqueInput | DocumentsWhereUniqueInput[]
    update?: DocumentsUpdateWithWhereUniqueWithoutDoctypeInput | DocumentsUpdateWithWhereUniqueWithoutDoctypeInput[]
    updateMany?: DocumentsUpdateManyWithWhereWithoutDoctypeInput | DocumentsUpdateManyWithWhereWithoutDoctypeInput[]
    deleteMany?: DocumentsScalarWhereInput | DocumentsScalarWhereInput[]
  }

  export type documentAdminsUncheckedUpdateManyWithoutDoctypeNestedInput = {
    create?: XOR<documentAdminsCreateWithoutDoctypeInput, documentAdminsUncheckedCreateWithoutDoctypeInput> | documentAdminsCreateWithoutDoctypeInput[] | documentAdminsUncheckedCreateWithoutDoctypeInput[]
    connectOrCreate?: documentAdminsCreateOrConnectWithoutDoctypeInput | documentAdminsCreateOrConnectWithoutDoctypeInput[]
    upsert?: documentAdminsUpsertWithWhereUniqueWithoutDoctypeInput | documentAdminsUpsertWithWhereUniqueWithoutDoctypeInput[]
    createMany?: documentAdminsCreateManyDoctypeInputEnvelope
    set?: documentAdminsWhereUniqueInput | documentAdminsWhereUniqueInput[]
    disconnect?: documentAdminsWhereUniqueInput | documentAdminsWhereUniqueInput[]
    delete?: documentAdminsWhereUniqueInput | documentAdminsWhereUniqueInput[]
    connect?: documentAdminsWhereUniqueInput | documentAdminsWhereUniqueInput[]
    update?: documentAdminsUpdateWithWhereUniqueWithoutDoctypeInput | documentAdminsUpdateWithWhereUniqueWithoutDoctypeInput[]
    updateMany?: documentAdminsUpdateManyWithWhereWithoutDoctypeInput | documentAdminsUpdateManyWithWhereWithoutDoctypeInput[]
    deleteMany?: documentAdminsScalarWhereInput | documentAdminsScalarWhereInput[]
  }

  export type DocumentsCreatetagsInput = {
    set: string[]
  }

  export type DocumentsCreatesystemInput = {
    set: string[]
  }

  export type DocumentsCreatereviewersInput = {
    set: string[]
  }

  export type DocumentsCreateapproversInput = {
    set: string[]
  }

  export type DocumentsCreatecreatorsInput = {
    set: string[]
  }

  export type DocumentsCreatedistributionUsersInput = {
    set: InputJsonValue[]
  }

  export type DocumentsCreatereadAccessUsersInput = {
    set: InputJsonValue[]
  }

  export type DocumentsCreateversionInfoInput = {
    set: InputJsonValue[]
  }

  export type DoctypeCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<DoctypeCreateWithoutDocumentsInput, DoctypeUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: DoctypeCreateOrConnectWithoutDocumentsInput
    connect?: DoctypeWhereUniqueInput
  }

  export type OrganizationCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<OrganizationCreateWithoutDocumentsInput, OrganizationUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutDocumentsInput
    connect?: OrganizationWhereUniqueInput
  }

  export type LocationCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<LocationCreateWithoutDocumentsInput, LocationUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: LocationCreateOrConnectWithoutDocumentsInput
    connect?: LocationWhereUniqueInput
  }

  export type EntityCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<EntityCreateWithoutDocumentsInput, EntityUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: EntityCreateOrConnectWithoutDocumentsInput
    connect?: EntityWhereUniqueInput
  }

  export type ReferenceDocumentsCreateNestedManyWithoutDocumentInput = {
    create?: XOR<ReferenceDocumentsCreateWithoutDocumentInput, ReferenceDocumentsUncheckedCreateWithoutDocumentInput> | ReferenceDocumentsCreateWithoutDocumentInput[] | ReferenceDocumentsUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: ReferenceDocumentsCreateOrConnectWithoutDocumentInput | ReferenceDocumentsCreateOrConnectWithoutDocumentInput[]
    createMany?: ReferenceDocumentsCreateManyDocumentInputEnvelope
    connect?: ReferenceDocumentsWhereUniqueInput | ReferenceDocumentsWhereUniqueInput[]
  }

  export type DocumentVersionsCreateNestedManyWithoutDocumentInput = {
    create?: XOR<DocumentVersionsCreateWithoutDocumentInput, DocumentVersionsUncheckedCreateWithoutDocumentInput> | DocumentVersionsCreateWithoutDocumentInput[] | DocumentVersionsUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: DocumentVersionsCreateOrConnectWithoutDocumentInput | DocumentVersionsCreateOrConnectWithoutDocumentInput[]
    createMany?: DocumentVersionsCreateManyDocumentInputEnvelope
    connect?: DocumentVersionsWhereUniqueInput | DocumentVersionsWhereUniqueInput[]
  }

  export type DocumentCommentsCreateNestedManyWithoutDocumentInput = {
    create?: XOR<DocumentCommentsCreateWithoutDocumentInput, DocumentCommentsUncheckedCreateWithoutDocumentInput> | DocumentCommentsCreateWithoutDocumentInput[] | DocumentCommentsUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: DocumentCommentsCreateOrConnectWithoutDocumentInput | DocumentCommentsCreateOrConnectWithoutDocumentInput[]
    createMany?: DocumentCommentsCreateManyDocumentInputEnvelope
    connect?: DocumentCommentsWhereUniqueInput | DocumentCommentsWhereUniqueInput[]
  }

  export type DocumentWorkFlowHistoryCreateNestedManyWithoutDocumentInput = {
    create?: XOR<DocumentWorkFlowHistoryCreateWithoutDocumentInput, DocumentWorkFlowHistoryUncheckedCreateWithoutDocumentInput> | DocumentWorkFlowHistoryCreateWithoutDocumentInput[] | DocumentWorkFlowHistoryUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: DocumentWorkFlowHistoryCreateOrConnectWithoutDocumentInput | DocumentWorkFlowHistoryCreateOrConnectWithoutDocumentInput[]
    createMany?: DocumentWorkFlowHistoryCreateManyDocumentInputEnvelope
    connect?: DocumentWorkFlowHistoryWhereUniqueInput | DocumentWorkFlowHistoryWhereUniqueInput[]
  }

  export type AdditionalDocumentAdminsCreateNestedManyWithoutDocumentInput = {
    create?: XOR<AdditionalDocumentAdminsCreateWithoutDocumentInput, AdditionalDocumentAdminsUncheckedCreateWithoutDocumentInput> | AdditionalDocumentAdminsCreateWithoutDocumentInput[] | AdditionalDocumentAdminsUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: AdditionalDocumentAdminsCreateOrConnectWithoutDocumentInput | AdditionalDocumentAdminsCreateOrConnectWithoutDocumentInput[]
    createMany?: AdditionalDocumentAdminsCreateManyDocumentInputEnvelope
    connect?: AdditionalDocumentAdminsWhereUniqueInput | AdditionalDocumentAdminsWhereUniqueInput[]
  }

  export type VersionReferenceDocumentsCreateNestedManyWithoutDocumentsInput = {
    create?: XOR<VersionReferenceDocumentsCreateWithoutDocumentsInput, VersionReferenceDocumentsUncheckedCreateWithoutDocumentsInput> | VersionReferenceDocumentsCreateWithoutDocumentsInput[] | VersionReferenceDocumentsUncheckedCreateWithoutDocumentsInput[]
    connectOrCreate?: VersionReferenceDocumentsCreateOrConnectWithoutDocumentsInput | VersionReferenceDocumentsCreateOrConnectWithoutDocumentsInput[]
    createMany?: VersionReferenceDocumentsCreateManyDocumentsInputEnvelope
    connect?: VersionReferenceDocumentsWhereUniqueInput | VersionReferenceDocumentsWhereUniqueInput[]
  }

  export type ReferenceDocumentsUncheckedCreateNestedManyWithoutDocumentInput = {
    create?: XOR<ReferenceDocumentsCreateWithoutDocumentInput, ReferenceDocumentsUncheckedCreateWithoutDocumentInput> | ReferenceDocumentsCreateWithoutDocumentInput[] | ReferenceDocumentsUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: ReferenceDocumentsCreateOrConnectWithoutDocumentInput | ReferenceDocumentsCreateOrConnectWithoutDocumentInput[]
    createMany?: ReferenceDocumentsCreateManyDocumentInputEnvelope
    connect?: ReferenceDocumentsWhereUniqueInput | ReferenceDocumentsWhereUniqueInput[]
  }

  export type DocumentVersionsUncheckedCreateNestedManyWithoutDocumentInput = {
    create?: XOR<DocumentVersionsCreateWithoutDocumentInput, DocumentVersionsUncheckedCreateWithoutDocumentInput> | DocumentVersionsCreateWithoutDocumentInput[] | DocumentVersionsUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: DocumentVersionsCreateOrConnectWithoutDocumentInput | DocumentVersionsCreateOrConnectWithoutDocumentInput[]
    createMany?: DocumentVersionsCreateManyDocumentInputEnvelope
    connect?: DocumentVersionsWhereUniqueInput | DocumentVersionsWhereUniqueInput[]
  }

  export type DocumentCommentsUncheckedCreateNestedManyWithoutDocumentInput = {
    create?: XOR<DocumentCommentsCreateWithoutDocumentInput, DocumentCommentsUncheckedCreateWithoutDocumentInput> | DocumentCommentsCreateWithoutDocumentInput[] | DocumentCommentsUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: DocumentCommentsCreateOrConnectWithoutDocumentInput | DocumentCommentsCreateOrConnectWithoutDocumentInput[]
    createMany?: DocumentCommentsCreateManyDocumentInputEnvelope
    connect?: DocumentCommentsWhereUniqueInput | DocumentCommentsWhereUniqueInput[]
  }

  export type DocumentWorkFlowHistoryUncheckedCreateNestedManyWithoutDocumentInput = {
    create?: XOR<DocumentWorkFlowHistoryCreateWithoutDocumentInput, DocumentWorkFlowHistoryUncheckedCreateWithoutDocumentInput> | DocumentWorkFlowHistoryCreateWithoutDocumentInput[] | DocumentWorkFlowHistoryUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: DocumentWorkFlowHistoryCreateOrConnectWithoutDocumentInput | DocumentWorkFlowHistoryCreateOrConnectWithoutDocumentInput[]
    createMany?: DocumentWorkFlowHistoryCreateManyDocumentInputEnvelope
    connect?: DocumentWorkFlowHistoryWhereUniqueInput | DocumentWorkFlowHistoryWhereUniqueInput[]
  }

  export type AdditionalDocumentAdminsUncheckedCreateNestedManyWithoutDocumentInput = {
    create?: XOR<AdditionalDocumentAdminsCreateWithoutDocumentInput, AdditionalDocumentAdminsUncheckedCreateWithoutDocumentInput> | AdditionalDocumentAdminsCreateWithoutDocumentInput[] | AdditionalDocumentAdminsUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: AdditionalDocumentAdminsCreateOrConnectWithoutDocumentInput | AdditionalDocumentAdminsCreateOrConnectWithoutDocumentInput[]
    createMany?: AdditionalDocumentAdminsCreateManyDocumentInputEnvelope
    connect?: AdditionalDocumentAdminsWhereUniqueInput | AdditionalDocumentAdminsWhereUniqueInput[]
  }

  export type VersionReferenceDocumentsUncheckedCreateNestedManyWithoutDocumentsInput = {
    create?: XOR<VersionReferenceDocumentsCreateWithoutDocumentsInput, VersionReferenceDocumentsUncheckedCreateWithoutDocumentsInput> | VersionReferenceDocumentsCreateWithoutDocumentsInput[] | VersionReferenceDocumentsUncheckedCreateWithoutDocumentsInput[]
    connectOrCreate?: VersionReferenceDocumentsCreateOrConnectWithoutDocumentsInput | VersionReferenceDocumentsCreateOrConnectWithoutDocumentsInput[]
    createMany?: VersionReferenceDocumentsCreateManyDocumentsInputEnvelope
    connect?: VersionReferenceDocumentsWhereUniqueInput | VersionReferenceDocumentsWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
    unset?: boolean
  }

  export type DocumentsUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type DocumentsUpdatesystemInput = {
    set?: string[]
    push?: string | string[]
  }

  export type DocumentsUpdatereviewersInput = {
    set?: string[]
    push?: string | string[]
  }

  export type DocumentsUpdateapproversInput = {
    set?: string[]
    push?: string | string[]
  }

  export type DocumentsUpdatecreatorsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type DocumentsUpdatedistributionUsersInput = {
    set?: InputJsonValue[]
    push?: InputJsonValue | InputJsonValue[]
  }

  export type DocumentsUpdatereadAccessUsersInput = {
    set?: InputJsonValue[]
    push?: InputJsonValue | InputJsonValue[]
  }

  export type DocumentsUpdateversionInfoInput = {
    set?: InputJsonValue[]
    push?: InputJsonValue | InputJsonValue[]
  }

  export type DoctypeUpdateOneWithoutDocumentsNestedInput = {
    create?: XOR<DoctypeCreateWithoutDocumentsInput, DoctypeUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: DoctypeCreateOrConnectWithoutDocumentsInput
    upsert?: DoctypeUpsertWithoutDocumentsInput
    disconnect?: boolean
    delete?: DoctypeWhereInput | boolean
    connect?: DoctypeWhereUniqueInput
    update?: XOR<XOR<DoctypeUpdateToOneWithWhereWithoutDocumentsInput, DoctypeUpdateWithoutDocumentsInput>, DoctypeUncheckedUpdateWithoutDocumentsInput>
  }

  export type OrganizationUpdateOneWithoutDocumentsNestedInput = {
    create?: XOR<OrganizationCreateWithoutDocumentsInput, OrganizationUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutDocumentsInput
    upsert?: OrganizationUpsertWithoutDocumentsInput
    disconnect?: boolean
    delete?: OrganizationWhereInput | boolean
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutDocumentsInput, OrganizationUpdateWithoutDocumentsInput>, OrganizationUncheckedUpdateWithoutDocumentsInput>
  }

  export type LocationUpdateOneWithoutDocumentsNestedInput = {
    create?: XOR<LocationCreateWithoutDocumentsInput, LocationUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: LocationCreateOrConnectWithoutDocumentsInput
    upsert?: LocationUpsertWithoutDocumentsInput
    disconnect?: boolean
    delete?: LocationWhereInput | boolean
    connect?: LocationWhereUniqueInput
    update?: XOR<XOR<LocationUpdateToOneWithWhereWithoutDocumentsInput, LocationUpdateWithoutDocumentsInput>, LocationUncheckedUpdateWithoutDocumentsInput>
  }

  export type EntityUpdateOneWithoutDocumentsNestedInput = {
    create?: XOR<EntityCreateWithoutDocumentsInput, EntityUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: EntityCreateOrConnectWithoutDocumentsInput
    upsert?: EntityUpsertWithoutDocumentsInput
    disconnect?: boolean
    delete?: EntityWhereInput | boolean
    connect?: EntityWhereUniqueInput
    update?: XOR<XOR<EntityUpdateToOneWithWhereWithoutDocumentsInput, EntityUpdateWithoutDocumentsInput>, EntityUncheckedUpdateWithoutDocumentsInput>
  }

  export type ReferenceDocumentsUpdateManyWithoutDocumentNestedInput = {
    create?: XOR<ReferenceDocumentsCreateWithoutDocumentInput, ReferenceDocumentsUncheckedCreateWithoutDocumentInput> | ReferenceDocumentsCreateWithoutDocumentInput[] | ReferenceDocumentsUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: ReferenceDocumentsCreateOrConnectWithoutDocumentInput | ReferenceDocumentsCreateOrConnectWithoutDocumentInput[]
    upsert?: ReferenceDocumentsUpsertWithWhereUniqueWithoutDocumentInput | ReferenceDocumentsUpsertWithWhereUniqueWithoutDocumentInput[]
    createMany?: ReferenceDocumentsCreateManyDocumentInputEnvelope
    set?: ReferenceDocumentsWhereUniqueInput | ReferenceDocumentsWhereUniqueInput[]
    disconnect?: ReferenceDocumentsWhereUniqueInput | ReferenceDocumentsWhereUniqueInput[]
    delete?: ReferenceDocumentsWhereUniqueInput | ReferenceDocumentsWhereUniqueInput[]
    connect?: ReferenceDocumentsWhereUniqueInput | ReferenceDocumentsWhereUniqueInput[]
    update?: ReferenceDocumentsUpdateWithWhereUniqueWithoutDocumentInput | ReferenceDocumentsUpdateWithWhereUniqueWithoutDocumentInput[]
    updateMany?: ReferenceDocumentsUpdateManyWithWhereWithoutDocumentInput | ReferenceDocumentsUpdateManyWithWhereWithoutDocumentInput[]
    deleteMany?: ReferenceDocumentsScalarWhereInput | ReferenceDocumentsScalarWhereInput[]
  }

  export type DocumentVersionsUpdateManyWithoutDocumentNestedInput = {
    create?: XOR<DocumentVersionsCreateWithoutDocumentInput, DocumentVersionsUncheckedCreateWithoutDocumentInput> | DocumentVersionsCreateWithoutDocumentInput[] | DocumentVersionsUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: DocumentVersionsCreateOrConnectWithoutDocumentInput | DocumentVersionsCreateOrConnectWithoutDocumentInput[]
    upsert?: DocumentVersionsUpsertWithWhereUniqueWithoutDocumentInput | DocumentVersionsUpsertWithWhereUniqueWithoutDocumentInput[]
    createMany?: DocumentVersionsCreateManyDocumentInputEnvelope
    set?: DocumentVersionsWhereUniqueInput | DocumentVersionsWhereUniqueInput[]
    disconnect?: DocumentVersionsWhereUniqueInput | DocumentVersionsWhereUniqueInput[]
    delete?: DocumentVersionsWhereUniqueInput | DocumentVersionsWhereUniqueInput[]
    connect?: DocumentVersionsWhereUniqueInput | DocumentVersionsWhereUniqueInput[]
    update?: DocumentVersionsUpdateWithWhereUniqueWithoutDocumentInput | DocumentVersionsUpdateWithWhereUniqueWithoutDocumentInput[]
    updateMany?: DocumentVersionsUpdateManyWithWhereWithoutDocumentInput | DocumentVersionsUpdateManyWithWhereWithoutDocumentInput[]
    deleteMany?: DocumentVersionsScalarWhereInput | DocumentVersionsScalarWhereInput[]
  }

  export type DocumentCommentsUpdateManyWithoutDocumentNestedInput = {
    create?: XOR<DocumentCommentsCreateWithoutDocumentInput, DocumentCommentsUncheckedCreateWithoutDocumentInput> | DocumentCommentsCreateWithoutDocumentInput[] | DocumentCommentsUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: DocumentCommentsCreateOrConnectWithoutDocumentInput | DocumentCommentsCreateOrConnectWithoutDocumentInput[]
    upsert?: DocumentCommentsUpsertWithWhereUniqueWithoutDocumentInput | DocumentCommentsUpsertWithWhereUniqueWithoutDocumentInput[]
    createMany?: DocumentCommentsCreateManyDocumentInputEnvelope
    set?: DocumentCommentsWhereUniqueInput | DocumentCommentsWhereUniqueInput[]
    disconnect?: DocumentCommentsWhereUniqueInput | DocumentCommentsWhereUniqueInput[]
    delete?: DocumentCommentsWhereUniqueInput | DocumentCommentsWhereUniqueInput[]
    connect?: DocumentCommentsWhereUniqueInput | DocumentCommentsWhereUniqueInput[]
    update?: DocumentCommentsUpdateWithWhereUniqueWithoutDocumentInput | DocumentCommentsUpdateWithWhereUniqueWithoutDocumentInput[]
    updateMany?: DocumentCommentsUpdateManyWithWhereWithoutDocumentInput | DocumentCommentsUpdateManyWithWhereWithoutDocumentInput[]
    deleteMany?: DocumentCommentsScalarWhereInput | DocumentCommentsScalarWhereInput[]
  }

  export type DocumentWorkFlowHistoryUpdateManyWithoutDocumentNestedInput = {
    create?: XOR<DocumentWorkFlowHistoryCreateWithoutDocumentInput, DocumentWorkFlowHistoryUncheckedCreateWithoutDocumentInput> | DocumentWorkFlowHistoryCreateWithoutDocumentInput[] | DocumentWorkFlowHistoryUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: DocumentWorkFlowHistoryCreateOrConnectWithoutDocumentInput | DocumentWorkFlowHistoryCreateOrConnectWithoutDocumentInput[]
    upsert?: DocumentWorkFlowHistoryUpsertWithWhereUniqueWithoutDocumentInput | DocumentWorkFlowHistoryUpsertWithWhereUniqueWithoutDocumentInput[]
    createMany?: DocumentWorkFlowHistoryCreateManyDocumentInputEnvelope
    set?: DocumentWorkFlowHistoryWhereUniqueInput | DocumentWorkFlowHistoryWhereUniqueInput[]
    disconnect?: DocumentWorkFlowHistoryWhereUniqueInput | DocumentWorkFlowHistoryWhereUniqueInput[]
    delete?: DocumentWorkFlowHistoryWhereUniqueInput | DocumentWorkFlowHistoryWhereUniqueInput[]
    connect?: DocumentWorkFlowHistoryWhereUniqueInput | DocumentWorkFlowHistoryWhereUniqueInput[]
    update?: DocumentWorkFlowHistoryUpdateWithWhereUniqueWithoutDocumentInput | DocumentWorkFlowHistoryUpdateWithWhereUniqueWithoutDocumentInput[]
    updateMany?: DocumentWorkFlowHistoryUpdateManyWithWhereWithoutDocumentInput | DocumentWorkFlowHistoryUpdateManyWithWhereWithoutDocumentInput[]
    deleteMany?: DocumentWorkFlowHistoryScalarWhereInput | DocumentWorkFlowHistoryScalarWhereInput[]
  }

  export type AdditionalDocumentAdminsUpdateManyWithoutDocumentNestedInput = {
    create?: XOR<AdditionalDocumentAdminsCreateWithoutDocumentInput, AdditionalDocumentAdminsUncheckedCreateWithoutDocumentInput> | AdditionalDocumentAdminsCreateWithoutDocumentInput[] | AdditionalDocumentAdminsUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: AdditionalDocumentAdminsCreateOrConnectWithoutDocumentInput | AdditionalDocumentAdminsCreateOrConnectWithoutDocumentInput[]
    upsert?: AdditionalDocumentAdminsUpsertWithWhereUniqueWithoutDocumentInput | AdditionalDocumentAdminsUpsertWithWhereUniqueWithoutDocumentInput[]
    createMany?: AdditionalDocumentAdminsCreateManyDocumentInputEnvelope
    set?: AdditionalDocumentAdminsWhereUniqueInput | AdditionalDocumentAdminsWhereUniqueInput[]
    disconnect?: AdditionalDocumentAdminsWhereUniqueInput | AdditionalDocumentAdminsWhereUniqueInput[]
    delete?: AdditionalDocumentAdminsWhereUniqueInput | AdditionalDocumentAdminsWhereUniqueInput[]
    connect?: AdditionalDocumentAdminsWhereUniqueInput | AdditionalDocumentAdminsWhereUniqueInput[]
    update?: AdditionalDocumentAdminsUpdateWithWhereUniqueWithoutDocumentInput | AdditionalDocumentAdminsUpdateWithWhereUniqueWithoutDocumentInput[]
    updateMany?: AdditionalDocumentAdminsUpdateManyWithWhereWithoutDocumentInput | AdditionalDocumentAdminsUpdateManyWithWhereWithoutDocumentInput[]
    deleteMany?: AdditionalDocumentAdminsScalarWhereInput | AdditionalDocumentAdminsScalarWhereInput[]
  }

  export type VersionReferenceDocumentsUpdateManyWithoutDocumentsNestedInput = {
    create?: XOR<VersionReferenceDocumentsCreateWithoutDocumentsInput, VersionReferenceDocumentsUncheckedCreateWithoutDocumentsInput> | VersionReferenceDocumentsCreateWithoutDocumentsInput[] | VersionReferenceDocumentsUncheckedCreateWithoutDocumentsInput[]
    connectOrCreate?: VersionReferenceDocumentsCreateOrConnectWithoutDocumentsInput | VersionReferenceDocumentsCreateOrConnectWithoutDocumentsInput[]
    upsert?: VersionReferenceDocumentsUpsertWithWhereUniqueWithoutDocumentsInput | VersionReferenceDocumentsUpsertWithWhereUniqueWithoutDocumentsInput[]
    createMany?: VersionReferenceDocumentsCreateManyDocumentsInputEnvelope
    set?: VersionReferenceDocumentsWhereUniqueInput | VersionReferenceDocumentsWhereUniqueInput[]
    disconnect?: VersionReferenceDocumentsWhereUniqueInput | VersionReferenceDocumentsWhereUniqueInput[]
    delete?: VersionReferenceDocumentsWhereUniqueInput | VersionReferenceDocumentsWhereUniqueInput[]
    connect?: VersionReferenceDocumentsWhereUniqueInput | VersionReferenceDocumentsWhereUniqueInput[]
    update?: VersionReferenceDocumentsUpdateWithWhereUniqueWithoutDocumentsInput | VersionReferenceDocumentsUpdateWithWhereUniqueWithoutDocumentsInput[]
    updateMany?: VersionReferenceDocumentsUpdateManyWithWhereWithoutDocumentsInput | VersionReferenceDocumentsUpdateManyWithWhereWithoutDocumentsInput[]
    deleteMany?: VersionReferenceDocumentsScalarWhereInput | VersionReferenceDocumentsScalarWhereInput[]
  }

  export type ReferenceDocumentsUncheckedUpdateManyWithoutDocumentNestedInput = {
    create?: XOR<ReferenceDocumentsCreateWithoutDocumentInput, ReferenceDocumentsUncheckedCreateWithoutDocumentInput> | ReferenceDocumentsCreateWithoutDocumentInput[] | ReferenceDocumentsUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: ReferenceDocumentsCreateOrConnectWithoutDocumentInput | ReferenceDocumentsCreateOrConnectWithoutDocumentInput[]
    upsert?: ReferenceDocumentsUpsertWithWhereUniqueWithoutDocumentInput | ReferenceDocumentsUpsertWithWhereUniqueWithoutDocumentInput[]
    createMany?: ReferenceDocumentsCreateManyDocumentInputEnvelope
    set?: ReferenceDocumentsWhereUniqueInput | ReferenceDocumentsWhereUniqueInput[]
    disconnect?: ReferenceDocumentsWhereUniqueInput | ReferenceDocumentsWhereUniqueInput[]
    delete?: ReferenceDocumentsWhereUniqueInput | ReferenceDocumentsWhereUniqueInput[]
    connect?: ReferenceDocumentsWhereUniqueInput | ReferenceDocumentsWhereUniqueInput[]
    update?: ReferenceDocumentsUpdateWithWhereUniqueWithoutDocumentInput | ReferenceDocumentsUpdateWithWhereUniqueWithoutDocumentInput[]
    updateMany?: ReferenceDocumentsUpdateManyWithWhereWithoutDocumentInput | ReferenceDocumentsUpdateManyWithWhereWithoutDocumentInput[]
    deleteMany?: ReferenceDocumentsScalarWhereInput | ReferenceDocumentsScalarWhereInput[]
  }

  export type DocumentVersionsUncheckedUpdateManyWithoutDocumentNestedInput = {
    create?: XOR<DocumentVersionsCreateWithoutDocumentInput, DocumentVersionsUncheckedCreateWithoutDocumentInput> | DocumentVersionsCreateWithoutDocumentInput[] | DocumentVersionsUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: DocumentVersionsCreateOrConnectWithoutDocumentInput | DocumentVersionsCreateOrConnectWithoutDocumentInput[]
    upsert?: DocumentVersionsUpsertWithWhereUniqueWithoutDocumentInput | DocumentVersionsUpsertWithWhereUniqueWithoutDocumentInput[]
    createMany?: DocumentVersionsCreateManyDocumentInputEnvelope
    set?: DocumentVersionsWhereUniqueInput | DocumentVersionsWhereUniqueInput[]
    disconnect?: DocumentVersionsWhereUniqueInput | DocumentVersionsWhereUniqueInput[]
    delete?: DocumentVersionsWhereUniqueInput | DocumentVersionsWhereUniqueInput[]
    connect?: DocumentVersionsWhereUniqueInput | DocumentVersionsWhereUniqueInput[]
    update?: DocumentVersionsUpdateWithWhereUniqueWithoutDocumentInput | DocumentVersionsUpdateWithWhereUniqueWithoutDocumentInput[]
    updateMany?: DocumentVersionsUpdateManyWithWhereWithoutDocumentInput | DocumentVersionsUpdateManyWithWhereWithoutDocumentInput[]
    deleteMany?: DocumentVersionsScalarWhereInput | DocumentVersionsScalarWhereInput[]
  }

  export type DocumentCommentsUncheckedUpdateManyWithoutDocumentNestedInput = {
    create?: XOR<DocumentCommentsCreateWithoutDocumentInput, DocumentCommentsUncheckedCreateWithoutDocumentInput> | DocumentCommentsCreateWithoutDocumentInput[] | DocumentCommentsUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: DocumentCommentsCreateOrConnectWithoutDocumentInput | DocumentCommentsCreateOrConnectWithoutDocumentInput[]
    upsert?: DocumentCommentsUpsertWithWhereUniqueWithoutDocumentInput | DocumentCommentsUpsertWithWhereUniqueWithoutDocumentInput[]
    createMany?: DocumentCommentsCreateManyDocumentInputEnvelope
    set?: DocumentCommentsWhereUniqueInput | DocumentCommentsWhereUniqueInput[]
    disconnect?: DocumentCommentsWhereUniqueInput | DocumentCommentsWhereUniqueInput[]
    delete?: DocumentCommentsWhereUniqueInput | DocumentCommentsWhereUniqueInput[]
    connect?: DocumentCommentsWhereUniqueInput | DocumentCommentsWhereUniqueInput[]
    update?: DocumentCommentsUpdateWithWhereUniqueWithoutDocumentInput | DocumentCommentsUpdateWithWhereUniqueWithoutDocumentInput[]
    updateMany?: DocumentCommentsUpdateManyWithWhereWithoutDocumentInput | DocumentCommentsUpdateManyWithWhereWithoutDocumentInput[]
    deleteMany?: DocumentCommentsScalarWhereInput | DocumentCommentsScalarWhereInput[]
  }

  export type DocumentWorkFlowHistoryUncheckedUpdateManyWithoutDocumentNestedInput = {
    create?: XOR<DocumentWorkFlowHistoryCreateWithoutDocumentInput, DocumentWorkFlowHistoryUncheckedCreateWithoutDocumentInput> | DocumentWorkFlowHistoryCreateWithoutDocumentInput[] | DocumentWorkFlowHistoryUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: DocumentWorkFlowHistoryCreateOrConnectWithoutDocumentInput | DocumentWorkFlowHistoryCreateOrConnectWithoutDocumentInput[]
    upsert?: DocumentWorkFlowHistoryUpsertWithWhereUniqueWithoutDocumentInput | DocumentWorkFlowHistoryUpsertWithWhereUniqueWithoutDocumentInput[]
    createMany?: DocumentWorkFlowHistoryCreateManyDocumentInputEnvelope
    set?: DocumentWorkFlowHistoryWhereUniqueInput | DocumentWorkFlowHistoryWhereUniqueInput[]
    disconnect?: DocumentWorkFlowHistoryWhereUniqueInput | DocumentWorkFlowHistoryWhereUniqueInput[]
    delete?: DocumentWorkFlowHistoryWhereUniqueInput | DocumentWorkFlowHistoryWhereUniqueInput[]
    connect?: DocumentWorkFlowHistoryWhereUniqueInput | DocumentWorkFlowHistoryWhereUniqueInput[]
    update?: DocumentWorkFlowHistoryUpdateWithWhereUniqueWithoutDocumentInput | DocumentWorkFlowHistoryUpdateWithWhereUniqueWithoutDocumentInput[]
    updateMany?: DocumentWorkFlowHistoryUpdateManyWithWhereWithoutDocumentInput | DocumentWorkFlowHistoryUpdateManyWithWhereWithoutDocumentInput[]
    deleteMany?: DocumentWorkFlowHistoryScalarWhereInput | DocumentWorkFlowHistoryScalarWhereInput[]
  }

  export type AdditionalDocumentAdminsUncheckedUpdateManyWithoutDocumentNestedInput = {
    create?: XOR<AdditionalDocumentAdminsCreateWithoutDocumentInput, AdditionalDocumentAdminsUncheckedCreateWithoutDocumentInput> | AdditionalDocumentAdminsCreateWithoutDocumentInput[] | AdditionalDocumentAdminsUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: AdditionalDocumentAdminsCreateOrConnectWithoutDocumentInput | AdditionalDocumentAdminsCreateOrConnectWithoutDocumentInput[]
    upsert?: AdditionalDocumentAdminsUpsertWithWhereUniqueWithoutDocumentInput | AdditionalDocumentAdminsUpsertWithWhereUniqueWithoutDocumentInput[]
    createMany?: AdditionalDocumentAdminsCreateManyDocumentInputEnvelope
    set?: AdditionalDocumentAdminsWhereUniqueInput | AdditionalDocumentAdminsWhereUniqueInput[]
    disconnect?: AdditionalDocumentAdminsWhereUniqueInput | AdditionalDocumentAdminsWhereUniqueInput[]
    delete?: AdditionalDocumentAdminsWhereUniqueInput | AdditionalDocumentAdminsWhereUniqueInput[]
    connect?: AdditionalDocumentAdminsWhereUniqueInput | AdditionalDocumentAdminsWhereUniqueInput[]
    update?: AdditionalDocumentAdminsUpdateWithWhereUniqueWithoutDocumentInput | AdditionalDocumentAdminsUpdateWithWhereUniqueWithoutDocumentInput[]
    updateMany?: AdditionalDocumentAdminsUpdateManyWithWhereWithoutDocumentInput | AdditionalDocumentAdminsUpdateManyWithWhereWithoutDocumentInput[]
    deleteMany?: AdditionalDocumentAdminsScalarWhereInput | AdditionalDocumentAdminsScalarWhereInput[]
  }

  export type VersionReferenceDocumentsUncheckedUpdateManyWithoutDocumentsNestedInput = {
    create?: XOR<VersionReferenceDocumentsCreateWithoutDocumentsInput, VersionReferenceDocumentsUncheckedCreateWithoutDocumentsInput> | VersionReferenceDocumentsCreateWithoutDocumentsInput[] | VersionReferenceDocumentsUncheckedCreateWithoutDocumentsInput[]
    connectOrCreate?: VersionReferenceDocumentsCreateOrConnectWithoutDocumentsInput | VersionReferenceDocumentsCreateOrConnectWithoutDocumentsInput[]
    upsert?: VersionReferenceDocumentsUpsertWithWhereUniqueWithoutDocumentsInput | VersionReferenceDocumentsUpsertWithWhereUniqueWithoutDocumentsInput[]
    createMany?: VersionReferenceDocumentsCreateManyDocumentsInputEnvelope
    set?: VersionReferenceDocumentsWhereUniqueInput | VersionReferenceDocumentsWhereUniqueInput[]
    disconnect?: VersionReferenceDocumentsWhereUniqueInput | VersionReferenceDocumentsWhereUniqueInput[]
    delete?: VersionReferenceDocumentsWhereUniqueInput | VersionReferenceDocumentsWhereUniqueInput[]
    connect?: VersionReferenceDocumentsWhereUniqueInput | VersionReferenceDocumentsWhereUniqueInput[]
    update?: VersionReferenceDocumentsUpdateWithWhereUniqueWithoutDocumentsInput | VersionReferenceDocumentsUpdateWithWhereUniqueWithoutDocumentsInput[]
    updateMany?: VersionReferenceDocumentsUpdateManyWithWhereWithoutDocumentsInput | VersionReferenceDocumentsUpdateManyWithWhereWithoutDocumentsInput[]
    deleteMany?: VersionReferenceDocumentsScalarWhereInput | VersionReferenceDocumentsScalarWhereInput[]
  }

  export type DocumentsCreateNestedOneWithoutReferenceDocumentsInput = {
    create?: XOR<DocumentsCreateWithoutReferenceDocumentsInput, DocumentsUncheckedCreateWithoutReferenceDocumentsInput>
    connectOrCreate?: DocumentsCreateOrConnectWithoutReferenceDocumentsInput
    connect?: DocumentsWhereUniqueInput
  }

  export type DocumentVersionsCreateNestedOneWithoutReferenceDocumentsInput = {
    create?: XOR<DocumentVersionsCreateWithoutReferenceDocumentsInput, DocumentVersionsUncheckedCreateWithoutReferenceDocumentsInput>
    connectOrCreate?: DocumentVersionsCreateOrConnectWithoutReferenceDocumentsInput
    connect?: DocumentVersionsWhereUniqueInput
  }

  export type DocumentsUpdateOneWithoutReferenceDocumentsNestedInput = {
    create?: XOR<DocumentsCreateWithoutReferenceDocumentsInput, DocumentsUncheckedCreateWithoutReferenceDocumentsInput>
    connectOrCreate?: DocumentsCreateOrConnectWithoutReferenceDocumentsInput
    upsert?: DocumentsUpsertWithoutReferenceDocumentsInput
    disconnect?: boolean
    delete?: DocumentsWhereInput | boolean
    connect?: DocumentsWhereUniqueInput
    update?: XOR<XOR<DocumentsUpdateToOneWithWhereWithoutReferenceDocumentsInput, DocumentsUpdateWithoutReferenceDocumentsInput>, DocumentsUncheckedUpdateWithoutReferenceDocumentsInput>
  }

  export type DocumentVersionsUpdateOneWithoutReferenceDocumentsNestedInput = {
    create?: XOR<DocumentVersionsCreateWithoutReferenceDocumentsInput, DocumentVersionsUncheckedCreateWithoutReferenceDocumentsInput>
    connectOrCreate?: DocumentVersionsCreateOrConnectWithoutReferenceDocumentsInput
    upsert?: DocumentVersionsUpsertWithoutReferenceDocumentsInput
    disconnect?: boolean
    delete?: DocumentVersionsWhereInput | boolean
    connect?: DocumentVersionsWhereUniqueInput
    update?: XOR<XOR<DocumentVersionsUpdateToOneWithWhereWithoutReferenceDocumentsInput, DocumentVersionsUpdateWithoutReferenceDocumentsInput>, DocumentVersionsUncheckedUpdateWithoutReferenceDocumentsInput>
  }

  export type DocumentsCreateNestedOneWithoutVersionReferenceDocumentsInput = {
    create?: XOR<DocumentsCreateWithoutVersionReferenceDocumentsInput, DocumentsUncheckedCreateWithoutVersionReferenceDocumentsInput>
    connectOrCreate?: DocumentsCreateOrConnectWithoutVersionReferenceDocumentsInput
    connect?: DocumentsWhereUniqueInput
  }

  export type DocumentVersionsCreateNestedOneWithoutVersionReferenceDocumentsInput = {
    create?: XOR<DocumentVersionsCreateWithoutVersionReferenceDocumentsInput, DocumentVersionsUncheckedCreateWithoutVersionReferenceDocumentsInput>
    connectOrCreate?: DocumentVersionsCreateOrConnectWithoutVersionReferenceDocumentsInput
    connect?: DocumentVersionsWhereUniqueInput
  }

  export type DocumentsUpdateOneWithoutVersionReferenceDocumentsNestedInput = {
    create?: XOR<DocumentsCreateWithoutVersionReferenceDocumentsInput, DocumentsUncheckedCreateWithoutVersionReferenceDocumentsInput>
    connectOrCreate?: DocumentsCreateOrConnectWithoutVersionReferenceDocumentsInput
    upsert?: DocumentsUpsertWithoutVersionReferenceDocumentsInput
    disconnect?: boolean
    delete?: DocumentsWhereInput | boolean
    connect?: DocumentsWhereUniqueInput
    update?: XOR<XOR<DocumentsUpdateToOneWithWhereWithoutVersionReferenceDocumentsInput, DocumentsUpdateWithoutVersionReferenceDocumentsInput>, DocumentsUncheckedUpdateWithoutVersionReferenceDocumentsInput>
  }

  export type DocumentVersionsUpdateOneWithoutVersionReferenceDocumentsNestedInput = {
    create?: XOR<DocumentVersionsCreateWithoutVersionReferenceDocumentsInput, DocumentVersionsUncheckedCreateWithoutVersionReferenceDocumentsInput>
    connectOrCreate?: DocumentVersionsCreateOrConnectWithoutVersionReferenceDocumentsInput
    upsert?: DocumentVersionsUpsertWithoutVersionReferenceDocumentsInput
    disconnect?: boolean
    delete?: DocumentVersionsWhereInput | boolean
    connect?: DocumentVersionsWhereUniqueInput
    update?: XOR<XOR<DocumentVersionsUpdateToOneWithWhereWithoutVersionReferenceDocumentsInput, DocumentVersionsUpdateWithoutVersionReferenceDocumentsInput>, DocumentVersionsUncheckedUpdateWithoutVersionReferenceDocumentsInput>
  }

  export type DocumentsCreateNestedOneWithoutDocumentVersionsInput = {
    create?: XOR<DocumentsCreateWithoutDocumentVersionsInput, DocumentsUncheckedCreateWithoutDocumentVersionsInput>
    connectOrCreate?: DocumentsCreateOrConnectWithoutDocumentVersionsInput
    connect?: DocumentsWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutDocumentVersionsInput = {
    create?: XOR<UserCreateWithoutDocumentVersionsInput, UserUncheckedCreateWithoutDocumentVersionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDocumentVersionsInput
    connect?: UserWhereUniqueInput
  }

  export type ReferenceDocumentsCreateNestedManyWithoutVersionsLinkedWithInput = {
    create?: XOR<ReferenceDocumentsCreateWithoutVersionsLinkedWithInput, ReferenceDocumentsUncheckedCreateWithoutVersionsLinkedWithInput> | ReferenceDocumentsCreateWithoutVersionsLinkedWithInput[] | ReferenceDocumentsUncheckedCreateWithoutVersionsLinkedWithInput[]
    connectOrCreate?: ReferenceDocumentsCreateOrConnectWithoutVersionsLinkedWithInput | ReferenceDocumentsCreateOrConnectWithoutVersionsLinkedWithInput[]
    createMany?: ReferenceDocumentsCreateManyVersionsLinkedWithInputEnvelope
    connect?: ReferenceDocumentsWhereUniqueInput | ReferenceDocumentsWhereUniqueInput[]
  }

  export type VersionReferenceDocumentsCreateNestedManyWithoutVersionsLinkedWithInput = {
    create?: XOR<VersionReferenceDocumentsCreateWithoutVersionsLinkedWithInput, VersionReferenceDocumentsUncheckedCreateWithoutVersionsLinkedWithInput> | VersionReferenceDocumentsCreateWithoutVersionsLinkedWithInput[] | VersionReferenceDocumentsUncheckedCreateWithoutVersionsLinkedWithInput[]
    connectOrCreate?: VersionReferenceDocumentsCreateOrConnectWithoutVersionsLinkedWithInput | VersionReferenceDocumentsCreateOrConnectWithoutVersionsLinkedWithInput[]
    createMany?: VersionReferenceDocumentsCreateManyVersionsLinkedWithInputEnvelope
    connect?: VersionReferenceDocumentsWhereUniqueInput | VersionReferenceDocumentsWhereUniqueInput[]
  }

  export type ReferenceDocumentsUncheckedCreateNestedManyWithoutVersionsLinkedWithInput = {
    create?: XOR<ReferenceDocumentsCreateWithoutVersionsLinkedWithInput, ReferenceDocumentsUncheckedCreateWithoutVersionsLinkedWithInput> | ReferenceDocumentsCreateWithoutVersionsLinkedWithInput[] | ReferenceDocumentsUncheckedCreateWithoutVersionsLinkedWithInput[]
    connectOrCreate?: ReferenceDocumentsCreateOrConnectWithoutVersionsLinkedWithInput | ReferenceDocumentsCreateOrConnectWithoutVersionsLinkedWithInput[]
    createMany?: ReferenceDocumentsCreateManyVersionsLinkedWithInputEnvelope
    connect?: ReferenceDocumentsWhereUniqueInput | ReferenceDocumentsWhereUniqueInput[]
  }

  export type VersionReferenceDocumentsUncheckedCreateNestedManyWithoutVersionsLinkedWithInput = {
    create?: XOR<VersionReferenceDocumentsCreateWithoutVersionsLinkedWithInput, VersionReferenceDocumentsUncheckedCreateWithoutVersionsLinkedWithInput> | VersionReferenceDocumentsCreateWithoutVersionsLinkedWithInput[] | VersionReferenceDocumentsUncheckedCreateWithoutVersionsLinkedWithInput[]
    connectOrCreate?: VersionReferenceDocumentsCreateOrConnectWithoutVersionsLinkedWithInput | VersionReferenceDocumentsCreateOrConnectWithoutVersionsLinkedWithInput[]
    createMany?: VersionReferenceDocumentsCreateManyVersionsLinkedWithInputEnvelope
    connect?: VersionReferenceDocumentsWhereUniqueInput | VersionReferenceDocumentsWhereUniqueInput[]
  }

  export type DocumentsUpdateOneWithoutDocumentVersionsNestedInput = {
    create?: XOR<DocumentsCreateWithoutDocumentVersionsInput, DocumentsUncheckedCreateWithoutDocumentVersionsInput>
    connectOrCreate?: DocumentsCreateOrConnectWithoutDocumentVersionsInput
    upsert?: DocumentsUpsertWithoutDocumentVersionsInput
    disconnect?: boolean
    delete?: DocumentsWhereInput | boolean
    connect?: DocumentsWhereUniqueInput
    update?: XOR<XOR<DocumentsUpdateToOneWithWhereWithoutDocumentVersionsInput, DocumentsUpdateWithoutDocumentVersionsInput>, DocumentsUncheckedUpdateWithoutDocumentVersionsInput>
  }

  export type UserUpdateOneWithoutDocumentVersionsNestedInput = {
    create?: XOR<UserCreateWithoutDocumentVersionsInput, UserUncheckedCreateWithoutDocumentVersionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDocumentVersionsInput
    upsert?: UserUpsertWithoutDocumentVersionsInput
    disconnect?: boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDocumentVersionsInput, UserUpdateWithoutDocumentVersionsInput>, UserUncheckedUpdateWithoutDocumentVersionsInput>
  }

  export type ReferenceDocumentsUpdateManyWithoutVersionsLinkedWithNestedInput = {
    create?: XOR<ReferenceDocumentsCreateWithoutVersionsLinkedWithInput, ReferenceDocumentsUncheckedCreateWithoutVersionsLinkedWithInput> | ReferenceDocumentsCreateWithoutVersionsLinkedWithInput[] | ReferenceDocumentsUncheckedCreateWithoutVersionsLinkedWithInput[]
    connectOrCreate?: ReferenceDocumentsCreateOrConnectWithoutVersionsLinkedWithInput | ReferenceDocumentsCreateOrConnectWithoutVersionsLinkedWithInput[]
    upsert?: ReferenceDocumentsUpsertWithWhereUniqueWithoutVersionsLinkedWithInput | ReferenceDocumentsUpsertWithWhereUniqueWithoutVersionsLinkedWithInput[]
    createMany?: ReferenceDocumentsCreateManyVersionsLinkedWithInputEnvelope
    set?: ReferenceDocumentsWhereUniqueInput | ReferenceDocumentsWhereUniqueInput[]
    disconnect?: ReferenceDocumentsWhereUniqueInput | ReferenceDocumentsWhereUniqueInput[]
    delete?: ReferenceDocumentsWhereUniqueInput | ReferenceDocumentsWhereUniqueInput[]
    connect?: ReferenceDocumentsWhereUniqueInput | ReferenceDocumentsWhereUniqueInput[]
    update?: ReferenceDocumentsUpdateWithWhereUniqueWithoutVersionsLinkedWithInput | ReferenceDocumentsUpdateWithWhereUniqueWithoutVersionsLinkedWithInput[]
    updateMany?: ReferenceDocumentsUpdateManyWithWhereWithoutVersionsLinkedWithInput | ReferenceDocumentsUpdateManyWithWhereWithoutVersionsLinkedWithInput[]
    deleteMany?: ReferenceDocumentsScalarWhereInput | ReferenceDocumentsScalarWhereInput[]
  }

  export type VersionReferenceDocumentsUpdateManyWithoutVersionsLinkedWithNestedInput = {
    create?: XOR<VersionReferenceDocumentsCreateWithoutVersionsLinkedWithInput, VersionReferenceDocumentsUncheckedCreateWithoutVersionsLinkedWithInput> | VersionReferenceDocumentsCreateWithoutVersionsLinkedWithInput[] | VersionReferenceDocumentsUncheckedCreateWithoutVersionsLinkedWithInput[]
    connectOrCreate?: VersionReferenceDocumentsCreateOrConnectWithoutVersionsLinkedWithInput | VersionReferenceDocumentsCreateOrConnectWithoutVersionsLinkedWithInput[]
    upsert?: VersionReferenceDocumentsUpsertWithWhereUniqueWithoutVersionsLinkedWithInput | VersionReferenceDocumentsUpsertWithWhereUniqueWithoutVersionsLinkedWithInput[]
    createMany?: VersionReferenceDocumentsCreateManyVersionsLinkedWithInputEnvelope
    set?: VersionReferenceDocumentsWhereUniqueInput | VersionReferenceDocumentsWhereUniqueInput[]
    disconnect?: VersionReferenceDocumentsWhereUniqueInput | VersionReferenceDocumentsWhereUniqueInput[]
    delete?: VersionReferenceDocumentsWhereUniqueInput | VersionReferenceDocumentsWhereUniqueInput[]
    connect?: VersionReferenceDocumentsWhereUniqueInput | VersionReferenceDocumentsWhereUniqueInput[]
    update?: VersionReferenceDocumentsUpdateWithWhereUniqueWithoutVersionsLinkedWithInput | VersionReferenceDocumentsUpdateWithWhereUniqueWithoutVersionsLinkedWithInput[]
    updateMany?: VersionReferenceDocumentsUpdateManyWithWhereWithoutVersionsLinkedWithInput | VersionReferenceDocumentsUpdateManyWithWhereWithoutVersionsLinkedWithInput[]
    deleteMany?: VersionReferenceDocumentsScalarWhereInput | VersionReferenceDocumentsScalarWhereInput[]
  }

  export type ReferenceDocumentsUncheckedUpdateManyWithoutVersionsLinkedWithNestedInput = {
    create?: XOR<ReferenceDocumentsCreateWithoutVersionsLinkedWithInput, ReferenceDocumentsUncheckedCreateWithoutVersionsLinkedWithInput> | ReferenceDocumentsCreateWithoutVersionsLinkedWithInput[] | ReferenceDocumentsUncheckedCreateWithoutVersionsLinkedWithInput[]
    connectOrCreate?: ReferenceDocumentsCreateOrConnectWithoutVersionsLinkedWithInput | ReferenceDocumentsCreateOrConnectWithoutVersionsLinkedWithInput[]
    upsert?: ReferenceDocumentsUpsertWithWhereUniqueWithoutVersionsLinkedWithInput | ReferenceDocumentsUpsertWithWhereUniqueWithoutVersionsLinkedWithInput[]
    createMany?: ReferenceDocumentsCreateManyVersionsLinkedWithInputEnvelope
    set?: ReferenceDocumentsWhereUniqueInput | ReferenceDocumentsWhereUniqueInput[]
    disconnect?: ReferenceDocumentsWhereUniqueInput | ReferenceDocumentsWhereUniqueInput[]
    delete?: ReferenceDocumentsWhereUniqueInput | ReferenceDocumentsWhereUniqueInput[]
    connect?: ReferenceDocumentsWhereUniqueInput | ReferenceDocumentsWhereUniqueInput[]
    update?: ReferenceDocumentsUpdateWithWhereUniqueWithoutVersionsLinkedWithInput | ReferenceDocumentsUpdateWithWhereUniqueWithoutVersionsLinkedWithInput[]
    updateMany?: ReferenceDocumentsUpdateManyWithWhereWithoutVersionsLinkedWithInput | ReferenceDocumentsUpdateManyWithWhereWithoutVersionsLinkedWithInput[]
    deleteMany?: ReferenceDocumentsScalarWhereInput | ReferenceDocumentsScalarWhereInput[]
  }

  export type VersionReferenceDocumentsUncheckedUpdateManyWithoutVersionsLinkedWithNestedInput = {
    create?: XOR<VersionReferenceDocumentsCreateWithoutVersionsLinkedWithInput, VersionReferenceDocumentsUncheckedCreateWithoutVersionsLinkedWithInput> | VersionReferenceDocumentsCreateWithoutVersionsLinkedWithInput[] | VersionReferenceDocumentsUncheckedCreateWithoutVersionsLinkedWithInput[]
    connectOrCreate?: VersionReferenceDocumentsCreateOrConnectWithoutVersionsLinkedWithInput | VersionReferenceDocumentsCreateOrConnectWithoutVersionsLinkedWithInput[]
    upsert?: VersionReferenceDocumentsUpsertWithWhereUniqueWithoutVersionsLinkedWithInput | VersionReferenceDocumentsUpsertWithWhereUniqueWithoutVersionsLinkedWithInput[]
    createMany?: VersionReferenceDocumentsCreateManyVersionsLinkedWithInputEnvelope
    set?: VersionReferenceDocumentsWhereUniqueInput | VersionReferenceDocumentsWhereUniqueInput[]
    disconnect?: VersionReferenceDocumentsWhereUniqueInput | VersionReferenceDocumentsWhereUniqueInput[]
    delete?: VersionReferenceDocumentsWhereUniqueInput | VersionReferenceDocumentsWhereUniqueInput[]
    connect?: VersionReferenceDocumentsWhereUniqueInput | VersionReferenceDocumentsWhereUniqueInput[]
    update?: VersionReferenceDocumentsUpdateWithWhereUniqueWithoutVersionsLinkedWithInput | VersionReferenceDocumentsUpdateWithWhereUniqueWithoutVersionsLinkedWithInput[]
    updateMany?: VersionReferenceDocumentsUpdateManyWithWhereWithoutVersionsLinkedWithInput | VersionReferenceDocumentsUpdateManyWithWhereWithoutVersionsLinkedWithInput[]
    deleteMany?: VersionReferenceDocumentsScalarWhereInput | VersionReferenceDocumentsScalarWhereInput[]
  }

  export type DocumentsCreateNestedOneWithoutDocumentCommentsInput = {
    create?: XOR<DocumentsCreateWithoutDocumentCommentsInput, DocumentsUncheckedCreateWithoutDocumentCommentsInput>
    connectOrCreate?: DocumentsCreateOrConnectWithoutDocumentCommentsInput
    connect?: DocumentsWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutDocumentCommentsInput = {
    create?: XOR<UserCreateWithoutDocumentCommentsInput, UserUncheckedCreateWithoutDocumentCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDocumentCommentsInput
    connect?: UserWhereUniqueInput
  }

  export type DocumentsUpdateOneWithoutDocumentCommentsNestedInput = {
    create?: XOR<DocumentsCreateWithoutDocumentCommentsInput, DocumentsUncheckedCreateWithoutDocumentCommentsInput>
    connectOrCreate?: DocumentsCreateOrConnectWithoutDocumentCommentsInput
    upsert?: DocumentsUpsertWithoutDocumentCommentsInput
    disconnect?: boolean
    delete?: DocumentsWhereInput | boolean
    connect?: DocumentsWhereUniqueInput
    update?: XOR<XOR<DocumentsUpdateToOneWithWhereWithoutDocumentCommentsInput, DocumentsUpdateWithoutDocumentCommentsInput>, DocumentsUncheckedUpdateWithoutDocumentCommentsInput>
  }

  export type UserUpdateOneWithoutDocumentCommentsNestedInput = {
    create?: XOR<UserCreateWithoutDocumentCommentsInput, UserUncheckedCreateWithoutDocumentCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDocumentCommentsInput
    upsert?: UserUpsertWithoutDocumentCommentsInput
    disconnect?: boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDocumentCommentsInput, UserUpdateWithoutDocumentCommentsInput>, UserUncheckedUpdateWithoutDocumentCommentsInput>
  }

  export type DocumentsCreateNestedOneWithoutDocumentWorkFlowHistoryInput = {
    create?: XOR<DocumentsCreateWithoutDocumentWorkFlowHistoryInput, DocumentsUncheckedCreateWithoutDocumentWorkFlowHistoryInput>
    connectOrCreate?: DocumentsCreateOrConnectWithoutDocumentWorkFlowHistoryInput
    connect?: DocumentsWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutDocumentWorkFlowHistoryInput = {
    create?: XOR<UserCreateWithoutDocumentWorkFlowHistoryInput, UserUncheckedCreateWithoutDocumentWorkFlowHistoryInput>
    connectOrCreate?: UserCreateOrConnectWithoutDocumentWorkFlowHistoryInput
    connect?: UserWhereUniqueInput
  }

  export type DocumentsUpdateOneWithoutDocumentWorkFlowHistoryNestedInput = {
    create?: XOR<DocumentsCreateWithoutDocumentWorkFlowHistoryInput, DocumentsUncheckedCreateWithoutDocumentWorkFlowHistoryInput>
    connectOrCreate?: DocumentsCreateOrConnectWithoutDocumentWorkFlowHistoryInput
    upsert?: DocumentsUpsertWithoutDocumentWorkFlowHistoryInput
    disconnect?: boolean
    delete?: DocumentsWhereInput | boolean
    connect?: DocumentsWhereUniqueInput
    update?: XOR<XOR<DocumentsUpdateToOneWithWhereWithoutDocumentWorkFlowHistoryInput, DocumentsUpdateWithoutDocumentWorkFlowHistoryInput>, DocumentsUncheckedUpdateWithoutDocumentWorkFlowHistoryInput>
  }

  export type UserUpdateOneWithoutDocumentWorkFlowHistoryNestedInput = {
    create?: XOR<UserCreateWithoutDocumentWorkFlowHistoryInput, UserUncheckedCreateWithoutDocumentWorkFlowHistoryInput>
    connectOrCreate?: UserCreateOrConnectWithoutDocumentWorkFlowHistoryInput
    upsert?: UserUpsertWithoutDocumentWorkFlowHistoryInput
    disconnect?: boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDocumentWorkFlowHistoryInput, UserUpdateWithoutDocumentWorkFlowHistoryInput>, UserUncheckedUpdateWithoutDocumentWorkFlowHistoryInput>
  }

  export type DoctypeCreateNestedOneWithoutDocumentAdminsInput = {
    create?: XOR<DoctypeCreateWithoutDocumentAdminsInput, DoctypeUncheckedCreateWithoutDocumentAdminsInput>
    connectOrCreate?: DoctypeCreateOrConnectWithoutDocumentAdminsInput
    connect?: DoctypeWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutDocumentAdminsInput = {
    create?: XOR<UserCreateWithoutDocumentAdminsInput, UserUncheckedCreateWithoutDocumentAdminsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDocumentAdminsInput
    connect?: UserWhereUniqueInput
  }

  export type DoctypeUpdateOneWithoutDocumentAdminsNestedInput = {
    create?: XOR<DoctypeCreateWithoutDocumentAdminsInput, DoctypeUncheckedCreateWithoutDocumentAdminsInput>
    connectOrCreate?: DoctypeCreateOrConnectWithoutDocumentAdminsInput
    upsert?: DoctypeUpsertWithoutDocumentAdminsInput
    disconnect?: boolean
    delete?: DoctypeWhereInput | boolean
    connect?: DoctypeWhereUniqueInput
    update?: XOR<XOR<DoctypeUpdateToOneWithWhereWithoutDocumentAdminsInput, DoctypeUpdateWithoutDocumentAdminsInput>, DoctypeUncheckedUpdateWithoutDocumentAdminsInput>
  }

  export type UserUpdateOneRequiredWithoutDocumentAdminsNestedInput = {
    create?: XOR<UserCreateWithoutDocumentAdminsInput, UserUncheckedCreateWithoutDocumentAdminsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDocumentAdminsInput
    upsert?: UserUpsertWithoutDocumentAdminsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDocumentAdminsInput, UserUpdateWithoutDocumentAdminsInput>, UserUncheckedUpdateWithoutDocumentAdminsInput>
  }

  export type DocumentsCreateNestedOneWithoutAdditionalDocumentAdminsInput = {
    create?: XOR<DocumentsCreateWithoutAdditionalDocumentAdminsInput, DocumentsUncheckedCreateWithoutAdditionalDocumentAdminsInput>
    connectOrCreate?: DocumentsCreateOrConnectWithoutAdditionalDocumentAdminsInput
    connect?: DocumentsWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAdditionalDocumentAdminsInput = {
    create?: XOR<UserCreateWithoutAdditionalDocumentAdminsInput, UserUncheckedCreateWithoutAdditionalDocumentAdminsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdditionalDocumentAdminsInput
    connect?: UserWhereUniqueInput
  }

  export type DocumentsUpdateOneWithoutAdditionalDocumentAdminsNestedInput = {
    create?: XOR<DocumentsCreateWithoutAdditionalDocumentAdminsInput, DocumentsUncheckedCreateWithoutAdditionalDocumentAdminsInput>
    connectOrCreate?: DocumentsCreateOrConnectWithoutAdditionalDocumentAdminsInput
    upsert?: DocumentsUpsertWithoutAdditionalDocumentAdminsInput
    disconnect?: boolean
    delete?: DocumentsWhereInput | boolean
    connect?: DocumentsWhereUniqueInput
    update?: XOR<XOR<DocumentsUpdateToOneWithWhereWithoutAdditionalDocumentAdminsInput, DocumentsUpdateWithoutAdditionalDocumentAdminsInput>, DocumentsUncheckedUpdateWithoutAdditionalDocumentAdminsInput>
  }

  export type UserUpdateOneRequiredWithoutAdditionalDocumentAdminsNestedInput = {
    create?: XOR<UserCreateWithoutAdditionalDocumentAdminsInput, UserUncheckedCreateWithoutAdditionalDocumentAdminsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdditionalDocumentAdminsInput
    upsert?: UserUpsertWithoutAdditionalDocumentAdminsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAdditionalDocumentAdminsInput, UserUpdateWithoutAdditionalDocumentAdminsInput>, UserUncheckedUpdateWithoutAdditionalDocumentAdminsInput>
  }

  export type UserCreateNestedOneWithoutLogsInput = {
    create?: XOR<UserCreateWithoutLogsInput, UserUncheckedCreateWithoutLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLogsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutLogsNestedInput = {
    create?: XOR<UserCreateWithoutLogsInput, UserUncheckedCreateWithoutLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLogsInput
    upsert?: UserUpsertWithoutLogsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLogsInput, UserUpdateWithoutLogsInput>, UserUncheckedUpdateWithoutLogsInput>
  }

  export type userPersonalisationCreatetargetObjectIdInput = {
    set: string[]
  }

  export type OrganizationCreateNestedOneWithoutUserPersonalisationInput = {
    create?: XOR<OrganizationCreateWithoutUserPersonalisationInput, OrganizationUncheckedCreateWithoutUserPersonalisationInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutUserPersonalisationInput
    connect?: OrganizationWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutUserPersonalisationInput = {
    create?: XOR<UserCreateWithoutUserPersonalisationInput, UserUncheckedCreateWithoutUserPersonalisationInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserPersonalisationInput
    connect?: UserWhereUniqueInput
  }

  export type userPersonalisationUpdatetargetObjectIdInput = {
    set?: string[]
    push?: string | string[]
  }

  export type OrganizationUpdateOneWithoutUserPersonalisationNestedInput = {
    create?: XOR<OrganizationCreateWithoutUserPersonalisationInput, OrganizationUncheckedCreateWithoutUserPersonalisationInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutUserPersonalisationInput
    upsert?: OrganizationUpsertWithoutUserPersonalisationInput
    disconnect?: boolean
    delete?: OrganizationWhereInput | boolean
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutUserPersonalisationInput, OrganizationUpdateWithoutUserPersonalisationInput>, OrganizationUncheckedUpdateWithoutUserPersonalisationInput>
  }

  export type UserUpdateOneRequiredWithoutUserPersonalisationNestedInput = {
    create?: XOR<UserCreateWithoutUserPersonalisationInput, UserUncheckedCreateWithoutUserPersonalisationInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserPersonalisationInput
    upsert?: UserUpsertWithoutUserPersonalisationInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserPersonalisationInput, UserUpdateWithoutUserPersonalisationInput>, UserUncheckedUpdateWithoutUserPersonalisationInput>
  }

  export type ConnectedAppsCreatelocationIdInput = {
    set: string[]
  }

  export type OrganizationCreateNestedOneWithoutConnectedAppsInput = {
    create?: XOR<OrganizationCreateWithoutConnectedAppsInput, OrganizationUncheckedCreateWithoutConnectedAppsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutConnectedAppsInput
    connect?: OrganizationWhereUniqueInput
  }

  export type unitTypeCreateNestedManyWithoutConnectedAppsInput = {
    create?: XOR<unitTypeCreateWithoutConnectedAppsInput, unitTypeUncheckedCreateWithoutConnectedAppsInput> | unitTypeCreateWithoutConnectedAppsInput[] | unitTypeUncheckedCreateWithoutConnectedAppsInput[]
    connectOrCreate?: unitTypeCreateOrConnectWithoutConnectedAppsInput | unitTypeCreateOrConnectWithoutConnectedAppsInput[]
    createMany?: unitTypeCreateManyConnectedAppsInputEnvelope
    connect?: unitTypeWhereUniqueInput | unitTypeWhereUniqueInput[]
  }

  export type kpiCreateNestedManyWithoutConnectedAppsInput = {
    create?: XOR<kpiCreateWithoutConnectedAppsInput, kpiUncheckedCreateWithoutConnectedAppsInput> | kpiCreateWithoutConnectedAppsInput[] | kpiUncheckedCreateWithoutConnectedAppsInput[]
    connectOrCreate?: kpiCreateOrConnectWithoutConnectedAppsInput | kpiCreateOrConnectWithoutConnectedAppsInput[]
    createMany?: kpiCreateManyConnectedAppsInputEnvelope
    connect?: kpiWhereUniqueInput | kpiWhereUniqueInput[]
  }

  export type unitTypeUncheckedCreateNestedManyWithoutConnectedAppsInput = {
    create?: XOR<unitTypeCreateWithoutConnectedAppsInput, unitTypeUncheckedCreateWithoutConnectedAppsInput> | unitTypeCreateWithoutConnectedAppsInput[] | unitTypeUncheckedCreateWithoutConnectedAppsInput[]
    connectOrCreate?: unitTypeCreateOrConnectWithoutConnectedAppsInput | unitTypeCreateOrConnectWithoutConnectedAppsInput[]
    createMany?: unitTypeCreateManyConnectedAppsInputEnvelope
    connect?: unitTypeWhereUniqueInput | unitTypeWhereUniqueInput[]
  }

  export type kpiUncheckedCreateNestedManyWithoutConnectedAppsInput = {
    create?: XOR<kpiCreateWithoutConnectedAppsInput, kpiUncheckedCreateWithoutConnectedAppsInput> | kpiCreateWithoutConnectedAppsInput[] | kpiUncheckedCreateWithoutConnectedAppsInput[]
    connectOrCreate?: kpiCreateOrConnectWithoutConnectedAppsInput | kpiCreateOrConnectWithoutConnectedAppsInput[]
    createMany?: kpiCreateManyConnectedAppsInputEnvelope
    connect?: kpiWhereUniqueInput | kpiWhereUniqueInput[]
  }

  export type ConnectedAppsUpdatelocationIdInput = {
    set?: string[]
    push?: string | string[]
  }

  export type OrganizationUpdateOneWithoutConnectedAppsNestedInput = {
    create?: XOR<OrganizationCreateWithoutConnectedAppsInput, OrganizationUncheckedCreateWithoutConnectedAppsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutConnectedAppsInput
    upsert?: OrganizationUpsertWithoutConnectedAppsInput
    disconnect?: boolean
    delete?: OrganizationWhereInput | boolean
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutConnectedAppsInput, OrganizationUpdateWithoutConnectedAppsInput>, OrganizationUncheckedUpdateWithoutConnectedAppsInput>
  }

  export type unitTypeUpdateManyWithoutConnectedAppsNestedInput = {
    create?: XOR<unitTypeCreateWithoutConnectedAppsInput, unitTypeUncheckedCreateWithoutConnectedAppsInput> | unitTypeCreateWithoutConnectedAppsInput[] | unitTypeUncheckedCreateWithoutConnectedAppsInput[]
    connectOrCreate?: unitTypeCreateOrConnectWithoutConnectedAppsInput | unitTypeCreateOrConnectWithoutConnectedAppsInput[]
    upsert?: unitTypeUpsertWithWhereUniqueWithoutConnectedAppsInput | unitTypeUpsertWithWhereUniqueWithoutConnectedAppsInput[]
    createMany?: unitTypeCreateManyConnectedAppsInputEnvelope
    set?: unitTypeWhereUniqueInput | unitTypeWhereUniqueInput[]
    disconnect?: unitTypeWhereUniqueInput | unitTypeWhereUniqueInput[]
    delete?: unitTypeWhereUniqueInput | unitTypeWhereUniqueInput[]
    connect?: unitTypeWhereUniqueInput | unitTypeWhereUniqueInput[]
    update?: unitTypeUpdateWithWhereUniqueWithoutConnectedAppsInput | unitTypeUpdateWithWhereUniqueWithoutConnectedAppsInput[]
    updateMany?: unitTypeUpdateManyWithWhereWithoutConnectedAppsInput | unitTypeUpdateManyWithWhereWithoutConnectedAppsInput[]
    deleteMany?: unitTypeScalarWhereInput | unitTypeScalarWhereInput[]
  }

  export type kpiUpdateManyWithoutConnectedAppsNestedInput = {
    create?: XOR<kpiCreateWithoutConnectedAppsInput, kpiUncheckedCreateWithoutConnectedAppsInput> | kpiCreateWithoutConnectedAppsInput[] | kpiUncheckedCreateWithoutConnectedAppsInput[]
    connectOrCreate?: kpiCreateOrConnectWithoutConnectedAppsInput | kpiCreateOrConnectWithoutConnectedAppsInput[]
    upsert?: kpiUpsertWithWhereUniqueWithoutConnectedAppsInput | kpiUpsertWithWhereUniqueWithoutConnectedAppsInput[]
    createMany?: kpiCreateManyConnectedAppsInputEnvelope
    set?: kpiWhereUniqueInput | kpiWhereUniqueInput[]
    disconnect?: kpiWhereUniqueInput | kpiWhereUniqueInput[]
    delete?: kpiWhereUniqueInput | kpiWhereUniqueInput[]
    connect?: kpiWhereUniqueInput | kpiWhereUniqueInput[]
    update?: kpiUpdateWithWhereUniqueWithoutConnectedAppsInput | kpiUpdateWithWhereUniqueWithoutConnectedAppsInput[]
    updateMany?: kpiUpdateManyWithWhereWithoutConnectedAppsInput | kpiUpdateManyWithWhereWithoutConnectedAppsInput[]
    deleteMany?: kpiScalarWhereInput | kpiScalarWhereInput[]
  }

  export type unitTypeUncheckedUpdateManyWithoutConnectedAppsNestedInput = {
    create?: XOR<unitTypeCreateWithoutConnectedAppsInput, unitTypeUncheckedCreateWithoutConnectedAppsInput> | unitTypeCreateWithoutConnectedAppsInput[] | unitTypeUncheckedCreateWithoutConnectedAppsInput[]
    connectOrCreate?: unitTypeCreateOrConnectWithoutConnectedAppsInput | unitTypeCreateOrConnectWithoutConnectedAppsInput[]
    upsert?: unitTypeUpsertWithWhereUniqueWithoutConnectedAppsInput | unitTypeUpsertWithWhereUniqueWithoutConnectedAppsInput[]
    createMany?: unitTypeCreateManyConnectedAppsInputEnvelope
    set?: unitTypeWhereUniqueInput | unitTypeWhereUniqueInput[]
    disconnect?: unitTypeWhereUniqueInput | unitTypeWhereUniqueInput[]
    delete?: unitTypeWhereUniqueInput | unitTypeWhereUniqueInput[]
    connect?: unitTypeWhereUniqueInput | unitTypeWhereUniqueInput[]
    update?: unitTypeUpdateWithWhereUniqueWithoutConnectedAppsInput | unitTypeUpdateWithWhereUniqueWithoutConnectedAppsInput[]
    updateMany?: unitTypeUpdateManyWithWhereWithoutConnectedAppsInput | unitTypeUpdateManyWithWhereWithoutConnectedAppsInput[]
    deleteMany?: unitTypeScalarWhereInput | unitTypeScalarWhereInput[]
  }

  export type kpiUncheckedUpdateManyWithoutConnectedAppsNestedInput = {
    create?: XOR<kpiCreateWithoutConnectedAppsInput, kpiUncheckedCreateWithoutConnectedAppsInput> | kpiCreateWithoutConnectedAppsInput[] | kpiUncheckedCreateWithoutConnectedAppsInput[]
    connectOrCreate?: kpiCreateOrConnectWithoutConnectedAppsInput | kpiCreateOrConnectWithoutConnectedAppsInput[]
    upsert?: kpiUpsertWithWhereUniqueWithoutConnectedAppsInput | kpiUpsertWithWhereUniqueWithoutConnectedAppsInput[]
    createMany?: kpiCreateManyConnectedAppsInputEnvelope
    set?: kpiWhereUniqueInput | kpiWhereUniqueInput[]
    disconnect?: kpiWhereUniqueInput | kpiWhereUniqueInput[]
    delete?: kpiWhereUniqueInput | kpiWhereUniqueInput[]
    connect?: kpiWhereUniqueInput | kpiWhereUniqueInput[]
    update?: kpiUpdateWithWhereUniqueWithoutConnectedAppsInput | kpiUpdateWithWhereUniqueWithoutConnectedAppsInput[]
    updateMany?: kpiUpdateManyWithWhereWithoutConnectedAppsInput | kpiUpdateManyWithWhereWithoutConnectedAppsInput[]
    deleteMany?: kpiScalarWhereInput | kpiScalarWhereInput[]
  }

  export type unitTypeCreateunitOfMeasurementInput = {
    set: string[]
  }

  export type kpiCreateNestedManyWithoutUnitTypeInput = {
    create?: XOR<kpiCreateWithoutUnitTypeInput, kpiUncheckedCreateWithoutUnitTypeInput> | kpiCreateWithoutUnitTypeInput[] | kpiUncheckedCreateWithoutUnitTypeInput[]
    connectOrCreate?: kpiCreateOrConnectWithoutUnitTypeInput | kpiCreateOrConnectWithoutUnitTypeInput[]
    createMany?: kpiCreateManyUnitTypeInputEnvelope
    connect?: kpiWhereUniqueInput | kpiWhereUniqueInput[]
  }

  export type OrganizationCreateNestedOneWithoutUnitOfMeasurementInput = {
    create?: XOR<OrganizationCreateWithoutUnitOfMeasurementInput, OrganizationUncheckedCreateWithoutUnitOfMeasurementInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutUnitOfMeasurementInput
    connect?: OrganizationWhereUniqueInput
  }

  export type LocationCreateNestedOneWithoutUomInput = {
    create?: XOR<LocationCreateWithoutUomInput, LocationUncheckedCreateWithoutUomInput>
    connectOrCreate?: LocationCreateOrConnectWithoutUomInput
    connect?: LocationWhereUniqueInput
  }

  export type ConnectedAppsCreateNestedOneWithoutUomInput = {
    create?: XOR<ConnectedAppsCreateWithoutUomInput, ConnectedAppsUncheckedCreateWithoutUomInput>
    connectOrCreate?: ConnectedAppsCreateOrConnectWithoutUomInput
    connect?: ConnectedAppsWhereUniqueInput
  }

  export type kpiUncheckedCreateNestedManyWithoutUnitTypeInput = {
    create?: XOR<kpiCreateWithoutUnitTypeInput, kpiUncheckedCreateWithoutUnitTypeInput> | kpiCreateWithoutUnitTypeInput[] | kpiUncheckedCreateWithoutUnitTypeInput[]
    connectOrCreate?: kpiCreateOrConnectWithoutUnitTypeInput | kpiCreateOrConnectWithoutUnitTypeInput[]
    createMany?: kpiCreateManyUnitTypeInputEnvelope
    connect?: kpiWhereUniqueInput | kpiWhereUniqueInput[]
  }

  export type unitTypeUpdateunitOfMeasurementInput = {
    set?: string[]
    push?: string | string[]
  }

  export type kpiUpdateManyWithoutUnitTypeNestedInput = {
    create?: XOR<kpiCreateWithoutUnitTypeInput, kpiUncheckedCreateWithoutUnitTypeInput> | kpiCreateWithoutUnitTypeInput[] | kpiUncheckedCreateWithoutUnitTypeInput[]
    connectOrCreate?: kpiCreateOrConnectWithoutUnitTypeInput | kpiCreateOrConnectWithoutUnitTypeInput[]
    upsert?: kpiUpsertWithWhereUniqueWithoutUnitTypeInput | kpiUpsertWithWhereUniqueWithoutUnitTypeInput[]
    createMany?: kpiCreateManyUnitTypeInputEnvelope
    set?: kpiWhereUniqueInput | kpiWhereUniqueInput[]
    disconnect?: kpiWhereUniqueInput | kpiWhereUniqueInput[]
    delete?: kpiWhereUniqueInput | kpiWhereUniqueInput[]
    connect?: kpiWhereUniqueInput | kpiWhereUniqueInput[]
    update?: kpiUpdateWithWhereUniqueWithoutUnitTypeInput | kpiUpdateWithWhereUniqueWithoutUnitTypeInput[]
    updateMany?: kpiUpdateManyWithWhereWithoutUnitTypeInput | kpiUpdateManyWithWhereWithoutUnitTypeInput[]
    deleteMany?: kpiScalarWhereInput | kpiScalarWhereInput[]
  }

  export type OrganizationUpdateOneWithoutUnitOfMeasurementNestedInput = {
    create?: XOR<OrganizationCreateWithoutUnitOfMeasurementInput, OrganizationUncheckedCreateWithoutUnitOfMeasurementInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutUnitOfMeasurementInput
    upsert?: OrganizationUpsertWithoutUnitOfMeasurementInput
    disconnect?: boolean
    delete?: OrganizationWhereInput | boolean
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutUnitOfMeasurementInput, OrganizationUpdateWithoutUnitOfMeasurementInput>, OrganizationUncheckedUpdateWithoutUnitOfMeasurementInput>
  }

  export type LocationUpdateOneWithoutUomNestedInput = {
    create?: XOR<LocationCreateWithoutUomInput, LocationUncheckedCreateWithoutUomInput>
    connectOrCreate?: LocationCreateOrConnectWithoutUomInput
    upsert?: LocationUpsertWithoutUomInput
    disconnect?: boolean
    delete?: LocationWhereInput | boolean
    connect?: LocationWhereUniqueInput
    update?: XOR<XOR<LocationUpdateToOneWithWhereWithoutUomInput, LocationUpdateWithoutUomInput>, LocationUncheckedUpdateWithoutUomInput>
  }

  export type ConnectedAppsUpdateOneWithoutUomNestedInput = {
    create?: XOR<ConnectedAppsCreateWithoutUomInput, ConnectedAppsUncheckedCreateWithoutUomInput>
    connectOrCreate?: ConnectedAppsCreateOrConnectWithoutUomInput
    upsert?: ConnectedAppsUpsertWithoutUomInput
    disconnect?: boolean
    delete?: ConnectedAppsWhereInput | boolean
    connect?: ConnectedAppsWhereUniqueInput
    update?: XOR<XOR<ConnectedAppsUpdateToOneWithWhereWithoutUomInput, ConnectedAppsUpdateWithoutUomInput>, ConnectedAppsUncheckedUpdateWithoutUomInput>
  }

  export type kpiUncheckedUpdateManyWithoutUnitTypeNestedInput = {
    create?: XOR<kpiCreateWithoutUnitTypeInput, kpiUncheckedCreateWithoutUnitTypeInput> | kpiCreateWithoutUnitTypeInput[] | kpiUncheckedCreateWithoutUnitTypeInput[]
    connectOrCreate?: kpiCreateOrConnectWithoutUnitTypeInput | kpiCreateOrConnectWithoutUnitTypeInput[]
    upsert?: kpiUpsertWithWhereUniqueWithoutUnitTypeInput | kpiUpsertWithWhereUniqueWithoutUnitTypeInput[]
    createMany?: kpiCreateManyUnitTypeInputEnvelope
    set?: kpiWhereUniqueInput | kpiWhereUniqueInput[]
    disconnect?: kpiWhereUniqueInput | kpiWhereUniqueInput[]
    delete?: kpiWhereUniqueInput | kpiWhereUniqueInput[]
    connect?: kpiWhereUniqueInput | kpiWhereUniqueInput[]
    update?: kpiUpdateWithWhereUniqueWithoutUnitTypeInput | kpiUpdateWithWhereUniqueWithoutUnitTypeInput[]
    updateMany?: kpiUpdateManyWithWhereWithoutUnitTypeInput | kpiUpdateManyWithWhereWithoutUnitTypeInput[]
    deleteMany?: kpiScalarWhereInput | kpiScalarWhereInput[]
  }

  export type kpiCreatekeyFieldsInput = {
    set: string[]
  }

  export type kpiCreatelocationIdInput = {
    set: string[]
  }

  export type unitTypeCreateNestedOneWithoutKpiInput = {
    create?: XOR<unitTypeCreateWithoutKpiInput, unitTypeUncheckedCreateWithoutKpiInput>
    connectOrCreate?: unitTypeCreateOrConnectWithoutKpiInput
    connect?: unitTypeWhereUniqueInput
  }

  export type ConnectedAppsCreateNestedOneWithoutKpiInput = {
    create?: XOR<ConnectedAppsCreateWithoutKpiInput, ConnectedAppsUncheckedCreateWithoutKpiInput>
    connectOrCreate?: ConnectedAppsCreateOrConnectWithoutKpiInput
    connect?: ConnectedAppsWhereUniqueInput
  }

  export type OrganizationCreateNestedOneWithoutKpiInput = {
    create?: XOR<OrganizationCreateWithoutKpiInput, OrganizationUncheckedCreateWithoutKpiInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutKpiInput
    connect?: OrganizationWhereUniqueInput
  }

  export type kpiUpdatekeyFieldsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type kpiUpdatelocationIdInput = {
    set?: string[]
    push?: string | string[]
  }

  export type unitTypeUpdateOneWithoutKpiNestedInput = {
    create?: XOR<unitTypeCreateWithoutKpiInput, unitTypeUncheckedCreateWithoutKpiInput>
    connectOrCreate?: unitTypeCreateOrConnectWithoutKpiInput
    upsert?: unitTypeUpsertWithoutKpiInput
    disconnect?: boolean
    delete?: unitTypeWhereInput | boolean
    connect?: unitTypeWhereUniqueInput
    update?: XOR<XOR<unitTypeUpdateToOneWithWhereWithoutKpiInput, unitTypeUpdateWithoutKpiInput>, unitTypeUncheckedUpdateWithoutKpiInput>
  }

  export type ConnectedAppsUpdateOneWithoutKpiNestedInput = {
    create?: XOR<ConnectedAppsCreateWithoutKpiInput, ConnectedAppsUncheckedCreateWithoutKpiInput>
    connectOrCreate?: ConnectedAppsCreateOrConnectWithoutKpiInput
    upsert?: ConnectedAppsUpsertWithoutKpiInput
    disconnect?: boolean
    delete?: ConnectedAppsWhereInput | boolean
    connect?: ConnectedAppsWhereUniqueInput
    update?: XOR<XOR<ConnectedAppsUpdateToOneWithWhereWithoutKpiInput, ConnectedAppsUpdateWithoutKpiInput>, ConnectedAppsUncheckedUpdateWithoutKpiInput>
  }

  export type OrganizationUpdateOneWithoutKpiNestedInput = {
    create?: XOR<OrganizationCreateWithoutKpiInput, OrganizationUncheckedCreateWithoutKpiInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutKpiInput
    upsert?: OrganizationUpsertWithoutKpiInput
    disconnect?: boolean
    delete?: OrganizationWhereInput | boolean
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutKpiInput, OrganizationUpdateWithoutKpiInput>, OrganizationUncheckedUpdateWithoutKpiInput>
  }

  export type UserCreateNestedOneWithoutAuditTrialInput = {
    create?: XOR<UserCreateWithoutAuditTrialInput, UserUncheckedCreateWithoutAuditTrialInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditTrialInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutAuditTrialNestedInput = {
    create?: XOR<UserCreateWithoutAuditTrialInput, UserUncheckedCreateWithoutAuditTrialInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditTrialInput
    upsert?: UserUpsertWithoutAuditTrialInput
    disconnect?: boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditTrialInput, UserUpdateWithoutAuditTrialInput>, UserUncheckedUpdateWithoutAuditTrialInput>
  }

  export type OrganizationCreateNestedOneWithoutPrefixSuffixInput = {
    create?: XOR<OrganizationCreateWithoutPrefixSuffixInput, OrganizationUncheckedCreateWithoutPrefixSuffixInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutPrefixSuffixInput
    connect?: OrganizationWhereUniqueInput
  }

  export type OrganizationUpdateOneWithoutPrefixSuffixNestedInput = {
    create?: XOR<OrganizationCreateWithoutPrefixSuffixInput, OrganizationUncheckedCreateWithoutPrefixSuffixInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutPrefixSuffixInput
    upsert?: OrganizationUpsertWithoutPrefixSuffixInput
    disconnect?: boolean
    delete?: OrganizationWhereInput | boolean
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutPrefixSuffixInput, OrganizationUpdateWithoutPrefixSuffixInput>, OrganizationUncheckedUpdateWithoutPrefixSuffixInput>
  }

  export type OrganizationCreateNestedOneWithoutSerialNumberInput = {
    create?: XOR<OrganizationCreateWithoutSerialNumberInput, OrganizationUncheckedCreateWithoutSerialNumberInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutSerialNumberInput
    connect?: OrganizationWhereUniqueInput
  }

  export type OrganizationUpdateOneWithoutSerialNumberNestedInput = {
    create?: XOR<OrganizationCreateWithoutSerialNumberInput, OrganizationUncheckedCreateWithoutSerialNumberInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutSerialNumberInput
    upsert?: OrganizationUpsertWithoutSerialNumberInput
    disconnect?: boolean
    delete?: OrganizationWhereInput | boolean
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutSerialNumberInput, OrganizationUpdateWithoutSerialNumberInput>, OrganizationUncheckedUpdateWithoutSerialNumberInput>
  }

  export type rolesTableCreateusersInput = {
    set: string[]
  }

  export type rolesTableCreateroleIdInput = {
    set: string[]
  }

  export type OrganizationCreateNestedOneWithoutRolesTableInput = {
    create?: XOR<OrganizationCreateWithoutRolesTableInput, OrganizationUncheckedCreateWithoutRolesTableInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutRolesTableInput
    connect?: OrganizationWhereUniqueInput
  }

  export type LocationCreateNestedOneWithoutRolesTableInput = {
    create?: XOR<LocationCreateWithoutRolesTableInput, LocationUncheckedCreateWithoutRolesTableInput>
    connectOrCreate?: LocationCreateOrConnectWithoutRolesTableInput
    connect?: LocationWhereUniqueInput
  }

  export type rolesTableUpdateusersInput = {
    set?: string[]
    push?: string | string[]
  }

  export type rolesTableUpdateroleIdInput = {
    set?: string[]
    push?: string | string[]
  }

  export type OrganizationUpdateOneRequiredWithoutRolesTableNestedInput = {
    create?: XOR<OrganizationCreateWithoutRolesTableInput, OrganizationUncheckedCreateWithoutRolesTableInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutRolesTableInput
    upsert?: OrganizationUpsertWithoutRolesTableInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutRolesTableInput, OrganizationUpdateWithoutRolesTableInput>, OrganizationUncheckedUpdateWithoutRolesTableInput>
  }

  export type LocationUpdateOneRequiredWithoutRolesTableNestedInput = {
    create?: XOR<LocationCreateWithoutRolesTableInput, LocationUncheckedCreateWithoutRolesTableInput>
    connectOrCreate?: LocationCreateOrConnectWithoutRolesTableInput
    upsert?: LocationUpsertWithoutRolesTableInput
    connect?: LocationWhereUniqueInput
    update?: XOR<XOR<LocationUpdateToOneWithWhereWithoutRolesTableInput, LocationUpdateWithoutRolesTableInput>, LocationUncheckedUpdateWithoutRolesTableInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
    isSet?: boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
    isSet?: boolean
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
    isSet?: boolean
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    isSet?: boolean
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
    isSet?: boolean
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
    isSet?: boolean
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
  }

  export type EntityCreateWithoutUserInput = {
    id?: string
    entityName?: string | null
    description?: string | null
    createdBy?: string | null
    entityId?: string | null
    deleted?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedBy?: string | null
    users?: EntityCreateusersInput | string[]
    sections?: EntityCreatesectionsInput | string[]
    entityType?: EntityTypeCreateNestedOneWithoutEntityInput
    location?: LocationCreateNestedOneWithoutEntityInput
    organization?: OrganizationCreateNestedOneWithoutEntityInput
    Doctype?: DoctypeCreateNestedManyWithoutEntityInput
    Documents?: DocumentsCreateNestedManyWithoutCreatorEntityInput
    parts?: PartsCreateNestedManyWithoutEntityInput
    claimToEntity?: ClaimToEntityCreateNestedManyWithoutEntityInput
    function?: FunctionsCreateNestedOneWithoutEntityInput
  }

  export type EntityUncheckedCreateWithoutUserInput = {
    id?: string
    entityName?: string | null
    description?: string | null
    entityTypeId?: string | null
    organizationId?: string | null
    locationId?: string | null
    createdBy?: string | null
    entityId?: string | null
    deleted?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedBy?: string | null
    users?: EntityCreateusersInput | string[]
    sections?: EntityCreatesectionsInput | string[]
    functionId?: string | null
    Doctype?: DoctypeUncheckedCreateNestedManyWithoutEntityInput
    Documents?: DocumentsUncheckedCreateNestedManyWithoutCreatorEntityInput
    parts?: PartsUncheckedCreateNestedManyWithoutEntityInput
    claimToEntity?: ClaimToEntityUncheckedCreateNestedManyWithoutEntityInput
  }

  export type EntityCreateOrConnectWithoutUserInput = {
    where: EntityWhereUniqueInput
    create: XOR<EntityCreateWithoutUserInput, EntityUncheckedCreateWithoutUserInput>
  }

  export type LocationCreateWithoutUserInput = {
    id?: string
    locationName?: string | null
    locationType?: string | null
    locationId?: string | null
    description?: string | null
    status?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedBy?: string | null
    functionId?: LocationCreatefunctionIdInput | string[]
    deleted?: boolean | null
    users?: LocationCreateusersInput | InputJsonValue[]
    businessTypeId?: string | null
    type?: string | null
    organization?: OrganizationCreateNestedOneWithoutLocationInput
    Documents?: DocumentsCreateNestedManyWithoutCreatorLocationInput
    entity?: EntityCreateNestedManyWithoutLocationInput
    business?: LocationBusinessCreateNestedManyWithoutLocationInput
    uom?: unitTypeCreateNestedManyWithoutLocationInput
    rolesTable?: rolesTableCreateNestedManyWithoutLocationInput
    Role?: RoleCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateWithoutUserInput = {
    id?: string
    locationName?: string | null
    locationType?: string | null
    locationId?: string | null
    description?: string | null
    status?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedBy?: string | null
    functionId?: LocationCreatefunctionIdInput | string[]
    deleted?: boolean | null
    organizationId?: string | null
    users?: LocationCreateusersInput | InputJsonValue[]
    businessTypeId?: string | null
    type?: string | null
    Documents?: DocumentsUncheckedCreateNestedManyWithoutCreatorLocationInput
    entity?: EntityUncheckedCreateNestedManyWithoutLocationInput
    business?: LocationBusinessUncheckedCreateNestedManyWithoutLocationInput
    uom?: unitTypeUncheckedCreateNestedManyWithoutLocationInput
    rolesTable?: rolesTableUncheckedCreateNestedManyWithoutLocationInput
    Role?: RoleUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationCreateOrConnectWithoutUserInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutUserInput, LocationUncheckedCreateWithoutUserInput>
  }

  export type OrganizationCreateWithoutUserInput = {
    id?: string
    kcId?: string | null
    organizationName?: string | null
    realmName?: string | null
    instanceUrl?: string | null
    principalGeography?: string | null
    loginUrl?: string | null
    logoutUrl?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    activeModules?: OrganizationCreateactiveModulesInput | string[]
    clientID?: string | null
    clientSecret?: string | null
    fiscalYearQuarters?: string | null
    fiscalYearFormat?: string | null
    auditYear?: string | null
    logoUrl?: string | null
    deleted?: boolean | null
    business?: BusinessCreateNestedManyWithoutOrganizationInput
    Doctype?: DoctypeCreateNestedManyWithoutOrganizationInput
    Documents?: DocumentsCreateNestedManyWithoutOrganizationInput
    entity?: EntityCreateNestedManyWithoutOrganizationInput
    entityType?: EntityTypeCreateNestedManyWithoutOrganizationInput
    location?: LocationCreateNestedManyWithoutOrganizationInput
    role?: RoleCreateNestedManyWithoutOrganizationInput
    section?: SectionCreateNestedManyWithoutOrganizationInput
    systemType?: SystemTypeCreateNestedManyWithoutOrganizationInput
    userPersonalisation?: userPersonalisationCreateNestedManyWithoutOrganizationInput
    ConnectedApps?: ConnectedAppsCreateNestedManyWithoutOrganizationInput
    unitOfMeasurement?: unitTypeCreateNestedManyWithoutOrganizationInput
    kpi?: kpiCreateNestedManyWithoutOrganizationInput
    businessType?: businessTypeCreateNestedManyWithoutOrganizationInput
    prefixSuffix?: prefixSuffixCreateNestedManyWithoutOrganizationInput
    serialNumber?: serialNumberCreateNestedManyWithoutOrganizationInput
    function?: FunctionsCreateNestedManyWithoutOrganizationInput
    rolesTable?: rolesTableCreateNestedManyWithoutOrganizationInput
    problem?: ProblemCreateNestedManyWithoutOrganizationInput
    parts?: PartsCreateNestedManyWithoutOrganizationInput
    Models?: ModelsCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutUserInput = {
    id?: string
    kcId?: string | null
    organizationName?: string | null
    realmName?: string | null
    instanceUrl?: string | null
    principalGeography?: string | null
    loginUrl?: string | null
    logoutUrl?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    activeModules?: OrganizationCreateactiveModulesInput | string[]
    clientID?: string | null
    clientSecret?: string | null
    fiscalYearQuarters?: string | null
    fiscalYearFormat?: string | null
    auditYear?: string | null
    logoUrl?: string | null
    deleted?: boolean | null
    business?: BusinessUncheckedCreateNestedManyWithoutOrganizationInput
    Doctype?: DoctypeUncheckedCreateNestedManyWithoutOrganizationInput
    Documents?: DocumentsUncheckedCreateNestedManyWithoutOrganizationInput
    entity?: EntityUncheckedCreateNestedManyWithoutOrganizationInput
    entityType?: EntityTypeUncheckedCreateNestedManyWithoutOrganizationInput
    location?: LocationUncheckedCreateNestedManyWithoutOrganizationInput
    role?: RoleUncheckedCreateNestedManyWithoutOrganizationInput
    section?: SectionUncheckedCreateNestedManyWithoutOrganizationInput
    systemType?: SystemTypeUncheckedCreateNestedManyWithoutOrganizationInput
    userPersonalisation?: userPersonalisationUncheckedCreateNestedManyWithoutOrganizationInput
    ConnectedApps?: ConnectedAppsUncheckedCreateNestedManyWithoutOrganizationInput
    unitOfMeasurement?: unitTypeUncheckedCreateNestedManyWithoutOrganizationInput
    kpi?: kpiUncheckedCreateNestedManyWithoutOrganizationInput
    businessType?: businessTypeUncheckedCreateNestedManyWithoutOrganizationInput
    prefixSuffix?: prefixSuffixUncheckedCreateNestedManyWithoutOrganizationInput
    serialNumber?: serialNumberUncheckedCreateNestedManyWithoutOrganizationInput
    function?: FunctionsUncheckedCreateNestedManyWithoutOrganizationInput
    rolesTable?: rolesTableUncheckedCreateNestedManyWithoutOrganizationInput
    problem?: ProblemUncheckedCreateNestedManyWithoutOrganizationInput
    parts?: PartsUncheckedCreateNestedManyWithoutOrganizationInput
    Models?: ModelsUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutUserInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutUserInput, OrganizationUncheckedCreateWithoutUserInput>
  }

  export type AdditionalDocumentAdminsCreateWithoutUserInput = {
    id?: string
    type: string
    firstname: string
    lastname: string
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
    document?: DocumentsCreateNestedOneWithoutAdditionalDocumentAdminsInput
  }

  export type AdditionalDocumentAdminsUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    firstname: string
    lastname: string
    email: string
    documentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdditionalDocumentAdminsCreateOrConnectWithoutUserInput = {
    where: AdditionalDocumentAdminsWhereUniqueInput
    create: XOR<AdditionalDocumentAdminsCreateWithoutUserInput, AdditionalDocumentAdminsUncheckedCreateWithoutUserInput>
  }

  export type AdditionalDocumentAdminsCreateManyUserInputEnvelope = {
    data: AdditionalDocumentAdminsCreateManyUserInput | AdditionalDocumentAdminsCreateManyUserInput[]
  }

  export type DocumentCommentsCreateWithoutUserInput = {
    id?: string
    commentBy?: string | null
    commentText: string
    createdAt?: Date | string
    updatedAt?: Date | string
    document?: DocumentsCreateNestedOneWithoutDocumentCommentsInput
  }

  export type DocumentCommentsUncheckedCreateWithoutUserInput = {
    id?: string
    commentBy?: string | null
    commentText: string
    documentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentCommentsCreateOrConnectWithoutUserInput = {
    where: DocumentCommentsWhereUniqueInput
    create: XOR<DocumentCommentsCreateWithoutUserInput, DocumentCommentsUncheckedCreateWithoutUserInput>
  }

  export type DocumentCommentsCreateManyUserInputEnvelope = {
    data: DocumentCommentsCreateManyUserInput | DocumentCommentsCreateManyUserInput[]
  }

  export type DocumentVersionsCreateWithoutUserInput = {
    id?: string
    versionName: string
    by?: string | null
    approvedDate?: Date | string | null
    versionLink: string
    createdAt?: Date | string
    updatedAt?: Date | string
    documentName?: string | null
    documentNumbering?: string | null
    reasonOfCreation?: string | null
    effectiveDate?: Date | string | null
    description?: string | null
    issueNumber?: string | null
    document?: DocumentsCreateNestedOneWithoutDocumentVersionsInput
    ReferenceDocuments?: ReferenceDocumentsCreateNestedManyWithoutVersionsLinkedWithInput
    VersionReferenceDocuments?: VersionReferenceDocumentsCreateNestedManyWithoutVersionsLinkedWithInput
  }

  export type DocumentVersionsUncheckedCreateWithoutUserInput = {
    id?: string
    versionName: string
    by?: string | null
    approvedDate?: Date | string | null
    versionLink: string
    documentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    documentName?: string | null
    documentNumbering?: string | null
    reasonOfCreation?: string | null
    effectiveDate?: Date | string | null
    description?: string | null
    issueNumber?: string | null
    ReferenceDocuments?: ReferenceDocumentsUncheckedCreateNestedManyWithoutVersionsLinkedWithInput
    VersionReferenceDocuments?: VersionReferenceDocumentsUncheckedCreateNestedManyWithoutVersionsLinkedWithInput
  }

  export type DocumentVersionsCreateOrConnectWithoutUserInput = {
    where: DocumentVersionsWhereUniqueInput
    create: XOR<DocumentVersionsCreateWithoutUserInput, DocumentVersionsUncheckedCreateWithoutUserInput>
  }

  export type DocumentVersionsCreateManyUserInputEnvelope = {
    data: DocumentVersionsCreateManyUserInput | DocumentVersionsCreateManyUserInput[]
  }

  export type DocumentWorkFlowHistoryCreateWithoutUserInput = {
    id?: string
    actionName: string
    actionBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    document?: DocumentsCreateNestedOneWithoutDocumentWorkFlowHistoryInput
  }

  export type DocumentWorkFlowHistoryUncheckedCreateWithoutUserInput = {
    id?: string
    actionName: string
    actionBy?: string | null
    documentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentWorkFlowHistoryCreateOrConnectWithoutUserInput = {
    where: DocumentWorkFlowHistoryWhereUniqueInput
    create: XOR<DocumentWorkFlowHistoryCreateWithoutUserInput, DocumentWorkFlowHistoryUncheckedCreateWithoutUserInput>
  }

  export type DocumentWorkFlowHistoryCreateManyUserInputEnvelope = {
    data: DocumentWorkFlowHistoryCreateManyUserInput | DocumentWorkFlowHistoryCreateManyUserInput[]
  }

  export type LogsCreateWithoutUserInput = {
    id?: string
    action: string
    resource: string
    type: string
    additionalDetails: InputJsonValue
  }

  export type LogsUncheckedCreateWithoutUserInput = {
    id?: string
    action: string
    resource: string
    type: string
    additionalDetails: InputJsonValue
  }

  export type LogsCreateOrConnectWithoutUserInput = {
    where: LogsWhereUniqueInput
    create: XOR<LogsCreateWithoutUserInput, LogsUncheckedCreateWithoutUserInput>
  }

  export type LogsCreateManyUserInputEnvelope = {
    data: LogsCreateManyUserInput | LogsCreateManyUserInput[]
  }

  export type NotificationCreateWithoutUserInput = {
    id?: string
    type?: string | null
    text: string
    content: string
    creator?: string | null
    date?: Date | string
    style?: string | null
    read?: boolean
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: string
    type?: string | null
    text: string
    content: string
    creator?: string | null
    date?: Date | string
    style?: string | null
    read?: boolean
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
  }

  export type documentAdminsCreateWithoutUserInput = {
    id?: string
    type: string
    firstname: string
    lastname: string
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
    doctype?: DoctypeCreateNestedOneWithoutDocumentAdminsInput
  }

  export type documentAdminsUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    firstname: string
    lastname: string
    email: string
    doctypeId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type documentAdminsCreateOrConnectWithoutUserInput = {
    where: documentAdminsWhereUniqueInput
    create: XOR<documentAdminsCreateWithoutUserInput, documentAdminsUncheckedCreateWithoutUserInput>
  }

  export type documentAdminsCreateManyUserInputEnvelope = {
    data: documentAdminsCreateManyUserInput | documentAdminsCreateManyUserInput[]
  }

  export type userPersonalisationCreateWithoutUserInput = {
    id?: string
    targetObject: string
    targetObjectId?: userPersonalisationCreatetargetObjectIdInput | string[]
    Organization?: OrganizationCreateNestedOneWithoutUserPersonalisationInput
  }

  export type userPersonalisationUncheckedCreateWithoutUserInput = {
    id?: string
    organizationId?: string | null
    targetObject: string
    targetObjectId?: userPersonalisationCreatetargetObjectIdInput | string[]
  }

  export type userPersonalisationCreateOrConnectWithoutUserInput = {
    where: userPersonalisationWhereUniqueInput
    create: XOR<userPersonalisationCreateWithoutUserInput, userPersonalisationUncheckedCreateWithoutUserInput>
  }

  export type userPersonalisationCreateManyUserInputEnvelope = {
    data: userPersonalisationCreateManyUserInput | userPersonalisationCreateManyUserInput[]
  }

  export type auditTrialCreateWithoutUserInput = {
    id?: string
    moduleType?: string | null
    actionType?: string | null
    transactionId?: string | null
    actionDate?: Date | string | null
  }

  export type auditTrialUncheckedCreateWithoutUserInput = {
    id?: string
    moduleType?: string | null
    actionType?: string | null
    transactionId?: string | null
    actionDate?: Date | string | null
  }

  export type auditTrialCreateOrConnectWithoutUserInput = {
    where: auditTrialWhereUniqueInput
    create: XOR<auditTrialCreateWithoutUserInput, auditTrialUncheckedCreateWithoutUserInput>
  }

  export type auditTrialCreateManyUserInputEnvelope = {
    data: auditTrialCreateManyUserInput | auditTrialCreateManyUserInput[]
  }

  export type EntityUpsertWithoutUserInput = {
    update: XOR<EntityUpdateWithoutUserInput, EntityUncheckedUpdateWithoutUserInput>
    create: XOR<EntityCreateWithoutUserInput, EntityUncheckedCreateWithoutUserInput>
    where?: EntityWhereInput
  }

  export type EntityUpdateToOneWithWhereWithoutUserInput = {
    where?: EntityWhereInput
    data: XOR<EntityUpdateWithoutUserInput, EntityUncheckedUpdateWithoutUserInput>
  }

  export type EntityUpdateWithoutUserInput = {
    entityName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    users?: EntityUpdateusersInput | string[]
    sections?: EntityUpdatesectionsInput | string[]
    entityType?: EntityTypeUpdateOneWithoutEntityNestedInput
    location?: LocationUpdateOneWithoutEntityNestedInput
    organization?: OrganizationUpdateOneWithoutEntityNestedInput
    Doctype?: DoctypeUpdateManyWithoutEntityNestedInput
    Documents?: DocumentsUpdateManyWithoutCreatorEntityNestedInput
    parts?: PartsUpdateManyWithoutEntityNestedInput
    claimToEntity?: ClaimToEntityUpdateManyWithoutEntityNestedInput
    function?: FunctionsUpdateOneWithoutEntityNestedInput
  }

  export type EntityUncheckedUpdateWithoutUserInput = {
    entityName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    entityTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    users?: EntityUpdateusersInput | string[]
    sections?: EntityUpdatesectionsInput | string[]
    functionId?: NullableStringFieldUpdateOperationsInput | string | null
    Doctype?: DoctypeUncheckedUpdateManyWithoutEntityNestedInput
    Documents?: DocumentsUncheckedUpdateManyWithoutCreatorEntityNestedInput
    parts?: PartsUncheckedUpdateManyWithoutEntityNestedInput
    claimToEntity?: ClaimToEntityUncheckedUpdateManyWithoutEntityNestedInput
  }

  export type LocationUpsertWithoutUserInput = {
    update: XOR<LocationUpdateWithoutUserInput, LocationUncheckedUpdateWithoutUserInput>
    create: XOR<LocationCreateWithoutUserInput, LocationUncheckedCreateWithoutUserInput>
    where?: LocationWhereInput
  }

  export type LocationUpdateToOneWithWhereWithoutUserInput = {
    where?: LocationWhereInput
    data: XOR<LocationUpdateWithoutUserInput, LocationUncheckedUpdateWithoutUserInput>
  }

  export type LocationUpdateWithoutUserInput = {
    locationName?: NullableStringFieldUpdateOperationsInput | string | null
    locationType?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    functionId?: LocationUpdatefunctionIdInput | string[]
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    users?: LocationUpdateusersInput | InputJsonValue[]
    businessTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: OrganizationUpdateOneWithoutLocationNestedInput
    Documents?: DocumentsUpdateManyWithoutCreatorLocationNestedInput
    entity?: EntityUpdateManyWithoutLocationNestedInput
    business?: LocationBusinessUpdateManyWithoutLocationNestedInput
    uom?: unitTypeUpdateManyWithoutLocationNestedInput
    rolesTable?: rolesTableUpdateManyWithoutLocationNestedInput
    Role?: RoleUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateWithoutUserInput = {
    locationName?: NullableStringFieldUpdateOperationsInput | string | null
    locationType?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    functionId?: LocationUpdatefunctionIdInput | string[]
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    users?: LocationUpdateusersInput | InputJsonValue[]
    businessTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    Documents?: DocumentsUncheckedUpdateManyWithoutCreatorLocationNestedInput
    entity?: EntityUncheckedUpdateManyWithoutLocationNestedInput
    business?: LocationBusinessUncheckedUpdateManyWithoutLocationNestedInput
    uom?: unitTypeUncheckedUpdateManyWithoutLocationNestedInput
    rolesTable?: rolesTableUncheckedUpdateManyWithoutLocationNestedInput
    Role?: RoleUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type OrganizationUpsertWithoutUserInput = {
    update: XOR<OrganizationUpdateWithoutUserInput, OrganizationUncheckedUpdateWithoutUserInput>
    create: XOR<OrganizationCreateWithoutUserInput, OrganizationUncheckedCreateWithoutUserInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutUserInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutUserInput, OrganizationUncheckedUpdateWithoutUserInput>
  }

  export type OrganizationUpdateWithoutUserInput = {
    kcId?: NullableStringFieldUpdateOperationsInput | string | null
    organizationName?: NullableStringFieldUpdateOperationsInput | string | null
    realmName?: NullableStringFieldUpdateOperationsInput | string | null
    instanceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    principalGeography?: NullableStringFieldUpdateOperationsInput | string | null
    loginUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoutUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    activeModules?: OrganizationUpdateactiveModulesInput | string[]
    clientID?: NullableStringFieldUpdateOperationsInput | string | null
    clientSecret?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearQuarters?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearFormat?: NullableStringFieldUpdateOperationsInput | string | null
    auditYear?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    business?: BusinessUpdateManyWithoutOrganizationNestedInput
    Doctype?: DoctypeUpdateManyWithoutOrganizationNestedInput
    Documents?: DocumentsUpdateManyWithoutOrganizationNestedInput
    entity?: EntityUpdateManyWithoutOrganizationNestedInput
    entityType?: EntityTypeUpdateManyWithoutOrganizationNestedInput
    location?: LocationUpdateManyWithoutOrganizationNestedInput
    role?: RoleUpdateManyWithoutOrganizationNestedInput
    section?: SectionUpdateManyWithoutOrganizationNestedInput
    systemType?: SystemTypeUpdateManyWithoutOrganizationNestedInput
    userPersonalisation?: userPersonalisationUpdateManyWithoutOrganizationNestedInput
    ConnectedApps?: ConnectedAppsUpdateManyWithoutOrganizationNestedInput
    unitOfMeasurement?: unitTypeUpdateManyWithoutOrganizationNestedInput
    kpi?: kpiUpdateManyWithoutOrganizationNestedInput
    businessType?: businessTypeUpdateManyWithoutOrganizationNestedInput
    prefixSuffix?: prefixSuffixUpdateManyWithoutOrganizationNestedInput
    serialNumber?: serialNumberUpdateManyWithoutOrganizationNestedInput
    function?: FunctionsUpdateManyWithoutOrganizationNestedInput
    rolesTable?: rolesTableUpdateManyWithoutOrganizationNestedInput
    problem?: ProblemUpdateManyWithoutOrganizationNestedInput
    parts?: PartsUpdateManyWithoutOrganizationNestedInput
    Models?: ModelsUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutUserInput = {
    kcId?: NullableStringFieldUpdateOperationsInput | string | null
    organizationName?: NullableStringFieldUpdateOperationsInput | string | null
    realmName?: NullableStringFieldUpdateOperationsInput | string | null
    instanceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    principalGeography?: NullableStringFieldUpdateOperationsInput | string | null
    loginUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoutUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    activeModules?: OrganizationUpdateactiveModulesInput | string[]
    clientID?: NullableStringFieldUpdateOperationsInput | string | null
    clientSecret?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearQuarters?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearFormat?: NullableStringFieldUpdateOperationsInput | string | null
    auditYear?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    business?: BusinessUncheckedUpdateManyWithoutOrganizationNestedInput
    Doctype?: DoctypeUncheckedUpdateManyWithoutOrganizationNestedInput
    Documents?: DocumentsUncheckedUpdateManyWithoutOrganizationNestedInput
    entity?: EntityUncheckedUpdateManyWithoutOrganizationNestedInput
    entityType?: EntityTypeUncheckedUpdateManyWithoutOrganizationNestedInput
    location?: LocationUncheckedUpdateManyWithoutOrganizationNestedInput
    role?: RoleUncheckedUpdateManyWithoutOrganizationNestedInput
    section?: SectionUncheckedUpdateManyWithoutOrganizationNestedInput
    systemType?: SystemTypeUncheckedUpdateManyWithoutOrganizationNestedInput
    userPersonalisation?: userPersonalisationUncheckedUpdateManyWithoutOrganizationNestedInput
    ConnectedApps?: ConnectedAppsUncheckedUpdateManyWithoutOrganizationNestedInput
    unitOfMeasurement?: unitTypeUncheckedUpdateManyWithoutOrganizationNestedInput
    kpi?: kpiUncheckedUpdateManyWithoutOrganizationNestedInput
    businessType?: businessTypeUncheckedUpdateManyWithoutOrganizationNestedInput
    prefixSuffix?: prefixSuffixUncheckedUpdateManyWithoutOrganizationNestedInput
    serialNumber?: serialNumberUncheckedUpdateManyWithoutOrganizationNestedInput
    function?: FunctionsUncheckedUpdateManyWithoutOrganizationNestedInput
    rolesTable?: rolesTableUncheckedUpdateManyWithoutOrganizationNestedInput
    problem?: ProblemUncheckedUpdateManyWithoutOrganizationNestedInput
    parts?: PartsUncheckedUpdateManyWithoutOrganizationNestedInput
    Models?: ModelsUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type AdditionalDocumentAdminsUpsertWithWhereUniqueWithoutUserInput = {
    where: AdditionalDocumentAdminsWhereUniqueInput
    update: XOR<AdditionalDocumentAdminsUpdateWithoutUserInput, AdditionalDocumentAdminsUncheckedUpdateWithoutUserInput>
    create: XOR<AdditionalDocumentAdminsCreateWithoutUserInput, AdditionalDocumentAdminsUncheckedCreateWithoutUserInput>
  }

  export type AdditionalDocumentAdminsUpdateWithWhereUniqueWithoutUserInput = {
    where: AdditionalDocumentAdminsWhereUniqueInput
    data: XOR<AdditionalDocumentAdminsUpdateWithoutUserInput, AdditionalDocumentAdminsUncheckedUpdateWithoutUserInput>
  }

  export type AdditionalDocumentAdminsUpdateManyWithWhereWithoutUserInput = {
    where: AdditionalDocumentAdminsScalarWhereInput
    data: XOR<AdditionalDocumentAdminsUpdateManyMutationInput, AdditionalDocumentAdminsUncheckedUpdateManyWithoutUserInput>
  }

  export type AdditionalDocumentAdminsScalarWhereInput = {
    AND?: AdditionalDocumentAdminsScalarWhereInput | AdditionalDocumentAdminsScalarWhereInput[]
    OR?: AdditionalDocumentAdminsScalarWhereInput[]
    NOT?: AdditionalDocumentAdminsScalarWhereInput | AdditionalDocumentAdminsScalarWhereInput[]
    id?: StringFilter<"AdditionalDocumentAdmins"> | string
    type?: StringFilter<"AdditionalDocumentAdmins"> | string
    firstname?: StringFilter<"AdditionalDocumentAdmins"> | string
    lastname?: StringFilter<"AdditionalDocumentAdmins"> | string
    email?: StringFilter<"AdditionalDocumentAdmins"> | string
    userId?: StringFilter<"AdditionalDocumentAdmins"> | string
    documentId?: StringNullableFilter<"AdditionalDocumentAdmins"> | string | null
    createdAt?: DateTimeFilter<"AdditionalDocumentAdmins"> | Date | string
    updatedAt?: DateTimeFilter<"AdditionalDocumentAdmins"> | Date | string
  }

  export type DocumentCommentsUpsertWithWhereUniqueWithoutUserInput = {
    where: DocumentCommentsWhereUniqueInput
    update: XOR<DocumentCommentsUpdateWithoutUserInput, DocumentCommentsUncheckedUpdateWithoutUserInput>
    create: XOR<DocumentCommentsCreateWithoutUserInput, DocumentCommentsUncheckedCreateWithoutUserInput>
  }

  export type DocumentCommentsUpdateWithWhereUniqueWithoutUserInput = {
    where: DocumentCommentsWhereUniqueInput
    data: XOR<DocumentCommentsUpdateWithoutUserInput, DocumentCommentsUncheckedUpdateWithoutUserInput>
  }

  export type DocumentCommentsUpdateManyWithWhereWithoutUserInput = {
    where: DocumentCommentsScalarWhereInput
    data: XOR<DocumentCommentsUpdateManyMutationInput, DocumentCommentsUncheckedUpdateManyWithoutUserInput>
  }

  export type DocumentCommentsScalarWhereInput = {
    AND?: DocumentCommentsScalarWhereInput | DocumentCommentsScalarWhereInput[]
    OR?: DocumentCommentsScalarWhereInput[]
    NOT?: DocumentCommentsScalarWhereInput | DocumentCommentsScalarWhereInput[]
    id?: StringFilter<"DocumentComments"> | string
    userId?: StringNullableFilter<"DocumentComments"> | string | null
    commentBy?: StringNullableFilter<"DocumentComments"> | string | null
    commentText?: StringFilter<"DocumentComments"> | string
    documentId?: StringNullableFilter<"DocumentComments"> | string | null
    createdAt?: DateTimeFilter<"DocumentComments"> | Date | string
    updatedAt?: DateTimeFilter<"DocumentComments"> | Date | string
  }

  export type DocumentVersionsUpsertWithWhereUniqueWithoutUserInput = {
    where: DocumentVersionsWhereUniqueInput
    update: XOR<DocumentVersionsUpdateWithoutUserInput, DocumentVersionsUncheckedUpdateWithoutUserInput>
    create: XOR<DocumentVersionsCreateWithoutUserInput, DocumentVersionsUncheckedCreateWithoutUserInput>
  }

  export type DocumentVersionsUpdateWithWhereUniqueWithoutUserInput = {
    where: DocumentVersionsWhereUniqueInput
    data: XOR<DocumentVersionsUpdateWithoutUserInput, DocumentVersionsUncheckedUpdateWithoutUserInput>
  }

  export type DocumentVersionsUpdateManyWithWhereWithoutUserInput = {
    where: DocumentVersionsScalarWhereInput
    data: XOR<DocumentVersionsUpdateManyMutationInput, DocumentVersionsUncheckedUpdateManyWithoutUserInput>
  }

  export type DocumentVersionsScalarWhereInput = {
    AND?: DocumentVersionsScalarWhereInput | DocumentVersionsScalarWhereInput[]
    OR?: DocumentVersionsScalarWhereInput[]
    NOT?: DocumentVersionsScalarWhereInput | DocumentVersionsScalarWhereInput[]
    id?: StringFilter<"DocumentVersions"> | string
    versionName?: StringFilter<"DocumentVersions"> | string
    userId?: StringNullableFilter<"DocumentVersions"> | string | null
    by?: StringNullableFilter<"DocumentVersions"> | string | null
    approvedDate?: DateTimeNullableFilter<"DocumentVersions"> | Date | string | null
    versionLink?: StringFilter<"DocumentVersions"> | string
    documentId?: StringNullableFilter<"DocumentVersions"> | string | null
    createdAt?: DateTimeFilter<"DocumentVersions"> | Date | string
    updatedAt?: DateTimeFilter<"DocumentVersions"> | Date | string
    documentName?: StringNullableFilter<"DocumentVersions"> | string | null
    documentNumbering?: StringNullableFilter<"DocumentVersions"> | string | null
    reasonOfCreation?: StringNullableFilter<"DocumentVersions"> | string | null
    effectiveDate?: DateTimeNullableFilter<"DocumentVersions"> | Date | string | null
    description?: StringNullableFilter<"DocumentVersions"> | string | null
    issueNumber?: StringNullableFilter<"DocumentVersions"> | string | null
  }

  export type DocumentWorkFlowHistoryUpsertWithWhereUniqueWithoutUserInput = {
    where: DocumentWorkFlowHistoryWhereUniqueInput
    update: XOR<DocumentWorkFlowHistoryUpdateWithoutUserInput, DocumentWorkFlowHistoryUncheckedUpdateWithoutUserInput>
    create: XOR<DocumentWorkFlowHistoryCreateWithoutUserInput, DocumentWorkFlowHistoryUncheckedCreateWithoutUserInput>
  }

  export type DocumentWorkFlowHistoryUpdateWithWhereUniqueWithoutUserInput = {
    where: DocumentWorkFlowHistoryWhereUniqueInput
    data: XOR<DocumentWorkFlowHistoryUpdateWithoutUserInput, DocumentWorkFlowHistoryUncheckedUpdateWithoutUserInput>
  }

  export type DocumentWorkFlowHistoryUpdateManyWithWhereWithoutUserInput = {
    where: DocumentWorkFlowHistoryScalarWhereInput
    data: XOR<DocumentWorkFlowHistoryUpdateManyMutationInput, DocumentWorkFlowHistoryUncheckedUpdateManyWithoutUserInput>
  }

  export type DocumentWorkFlowHistoryScalarWhereInput = {
    AND?: DocumentWorkFlowHistoryScalarWhereInput | DocumentWorkFlowHistoryScalarWhereInput[]
    OR?: DocumentWorkFlowHistoryScalarWhereInput[]
    NOT?: DocumentWorkFlowHistoryScalarWhereInput | DocumentWorkFlowHistoryScalarWhereInput[]
    id?: StringFilter<"DocumentWorkFlowHistory"> | string
    actionName?: StringFilter<"DocumentWorkFlowHistory"> | string
    userId?: StringNullableFilter<"DocumentWorkFlowHistory"> | string | null
    actionBy?: StringNullableFilter<"DocumentWorkFlowHistory"> | string | null
    documentId?: StringNullableFilter<"DocumentWorkFlowHistory"> | string | null
    createdAt?: DateTimeFilter<"DocumentWorkFlowHistory"> | Date | string
    updatedAt?: DateTimeFilter<"DocumentWorkFlowHistory"> | Date | string
  }

  export type LogsUpsertWithWhereUniqueWithoutUserInput = {
    where: LogsWhereUniqueInput
    update: XOR<LogsUpdateWithoutUserInput, LogsUncheckedUpdateWithoutUserInput>
    create: XOR<LogsCreateWithoutUserInput, LogsUncheckedCreateWithoutUserInput>
  }

  export type LogsUpdateWithWhereUniqueWithoutUserInput = {
    where: LogsWhereUniqueInput
    data: XOR<LogsUpdateWithoutUserInput, LogsUncheckedUpdateWithoutUserInput>
  }

  export type LogsUpdateManyWithWhereWithoutUserInput = {
    where: LogsScalarWhereInput
    data: XOR<LogsUpdateManyMutationInput, LogsUncheckedUpdateManyWithoutUserInput>
  }

  export type LogsScalarWhereInput = {
    AND?: LogsScalarWhereInput | LogsScalarWhereInput[]
    OR?: LogsScalarWhereInput[]
    NOT?: LogsScalarWhereInput | LogsScalarWhereInput[]
    id?: StringFilter<"Logs"> | string
    userId?: StringFilter<"Logs"> | string
    action?: StringFilter<"Logs"> | string
    resource?: StringFilter<"Logs"> | string
    type?: StringFilter<"Logs"> | string
    additionalDetails?: JsonFilter<"Logs">
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    type?: StringNullableFilter<"Notification"> | string | null
    text?: StringFilter<"Notification"> | string
    content?: StringFilter<"Notification"> | string
    receiver?: StringNullableFilter<"Notification"> | string | null
    creator?: StringNullableFilter<"Notification"> | string | null
    date?: DateTimeFilter<"Notification"> | Date | string
    style?: StringNullableFilter<"Notification"> | string | null
    read?: BoolFilter<"Notification"> | boolean
  }

  export type documentAdminsUpsertWithWhereUniqueWithoutUserInput = {
    where: documentAdminsWhereUniqueInput
    update: XOR<documentAdminsUpdateWithoutUserInput, documentAdminsUncheckedUpdateWithoutUserInput>
    create: XOR<documentAdminsCreateWithoutUserInput, documentAdminsUncheckedCreateWithoutUserInput>
  }

  export type documentAdminsUpdateWithWhereUniqueWithoutUserInput = {
    where: documentAdminsWhereUniqueInput
    data: XOR<documentAdminsUpdateWithoutUserInput, documentAdminsUncheckedUpdateWithoutUserInput>
  }

  export type documentAdminsUpdateManyWithWhereWithoutUserInput = {
    where: documentAdminsScalarWhereInput
    data: XOR<documentAdminsUpdateManyMutationInput, documentAdminsUncheckedUpdateManyWithoutUserInput>
  }

  export type documentAdminsScalarWhereInput = {
    AND?: documentAdminsScalarWhereInput | documentAdminsScalarWhereInput[]
    OR?: documentAdminsScalarWhereInput[]
    NOT?: documentAdminsScalarWhereInput | documentAdminsScalarWhereInput[]
    id?: StringFilter<"documentAdmins"> | string
    type?: StringFilter<"documentAdmins"> | string
    firstname?: StringFilter<"documentAdmins"> | string
    lastname?: StringFilter<"documentAdmins"> | string
    email?: StringFilter<"documentAdmins"> | string
    userId?: StringFilter<"documentAdmins"> | string
    doctypeId?: StringNullableFilter<"documentAdmins"> | string | null
    createdAt?: DateTimeFilter<"documentAdmins"> | Date | string
    updatedAt?: DateTimeFilter<"documentAdmins"> | Date | string
  }

  export type userPersonalisationUpsertWithWhereUniqueWithoutUserInput = {
    where: userPersonalisationWhereUniqueInput
    update: XOR<userPersonalisationUpdateWithoutUserInput, userPersonalisationUncheckedUpdateWithoutUserInput>
    create: XOR<userPersonalisationCreateWithoutUserInput, userPersonalisationUncheckedCreateWithoutUserInput>
  }

  export type userPersonalisationUpdateWithWhereUniqueWithoutUserInput = {
    where: userPersonalisationWhereUniqueInput
    data: XOR<userPersonalisationUpdateWithoutUserInput, userPersonalisationUncheckedUpdateWithoutUserInput>
  }

  export type userPersonalisationUpdateManyWithWhereWithoutUserInput = {
    where: userPersonalisationScalarWhereInput
    data: XOR<userPersonalisationUpdateManyMutationInput, userPersonalisationUncheckedUpdateManyWithoutUserInput>
  }

  export type userPersonalisationScalarWhereInput = {
    AND?: userPersonalisationScalarWhereInput | userPersonalisationScalarWhereInput[]
    OR?: userPersonalisationScalarWhereInput[]
    NOT?: userPersonalisationScalarWhereInput | userPersonalisationScalarWhereInput[]
    id?: StringFilter<"userPersonalisation"> | string
    userId?: StringFilter<"userPersonalisation"> | string
    organizationId?: StringNullableFilter<"userPersonalisation"> | string | null
    targetObject?: StringFilter<"userPersonalisation"> | string
    targetObjectId?: StringNullableListFilter<"userPersonalisation">
  }

  export type auditTrialUpsertWithWhereUniqueWithoutUserInput = {
    where: auditTrialWhereUniqueInput
    update: XOR<auditTrialUpdateWithoutUserInput, auditTrialUncheckedUpdateWithoutUserInput>
    create: XOR<auditTrialCreateWithoutUserInput, auditTrialUncheckedCreateWithoutUserInput>
  }

  export type auditTrialUpdateWithWhereUniqueWithoutUserInput = {
    where: auditTrialWhereUniqueInput
    data: XOR<auditTrialUpdateWithoutUserInput, auditTrialUncheckedUpdateWithoutUserInput>
  }

  export type auditTrialUpdateManyWithWhereWithoutUserInput = {
    where: auditTrialScalarWhereInput
    data: XOR<auditTrialUpdateManyMutationInput, auditTrialUncheckedUpdateManyWithoutUserInput>
  }

  export type auditTrialScalarWhereInput = {
    AND?: auditTrialScalarWhereInput | auditTrialScalarWhereInput[]
    OR?: auditTrialScalarWhereInput[]
    NOT?: auditTrialScalarWhereInput | auditTrialScalarWhereInput[]
    id?: StringFilter<"auditTrial"> | string
    moduleType?: StringNullableFilter<"auditTrial"> | string | null
    actionType?: StringNullableFilter<"auditTrial"> | string | null
    transactionId?: StringNullableFilter<"auditTrial"> | string | null
    actionBy?: StringNullableFilter<"auditTrial"> | string | null
    actionDate?: DateTimeNullableFilter<"auditTrial"> | Date | string | null
  }

  export type ClaimCreateWithoutModelsInput = {
    id?: string
    partRecieptDate: string
    vehicleType: string
    FrameNo: string
    prNo: string
    lineOffDate: string
    saleDate: string
    repairDate: string
    settleMonth?: string | null
    kms: number
    mis: number
    claimNo: number
    problem?: ProblemCreateNestedOneWithoutClaimInput
    investigations?: InvestigationCreateNestedOneWithoutClaimsInput
    parts?: PartsCreateNestedOneWithoutClaimsInput
    shipments?: ShipmentCreateNestedOneWithoutClaimsInput
    claimToEntity?: ClaimToEntityCreateNestedManyWithoutClaimInput
  }

  export type ClaimUncheckedCreateWithoutModelsInput = {
    id?: string
    partId?: string | null
    partRecieptDate: string
    vehicleType: string
    FrameNo: string
    prNo: string
    lineOffDate: string
    saleDate: string
    repairDate: string
    shipmentId?: string | null
    investigationId?: string | null
    settleMonth?: string | null
    kms: number
    problemId?: string | null
    mis: number
    claimNo: number
    claimToEntity?: ClaimToEntityUncheckedCreateNestedManyWithoutClaimInput
  }

  export type ClaimCreateOrConnectWithoutModelsInput = {
    where: ClaimWhereUniqueInput
    create: XOR<ClaimCreateWithoutModelsInput, ClaimUncheckedCreateWithoutModelsInput>
  }

  export type ClaimCreateManyModelsInputEnvelope = {
    data: ClaimCreateManyModelsInput | ClaimCreateManyModelsInput[]
  }

  export type OrganizationCreateWithoutModelsInput = {
    id?: string
    kcId?: string | null
    organizationName?: string | null
    realmName?: string | null
    instanceUrl?: string | null
    principalGeography?: string | null
    loginUrl?: string | null
    logoutUrl?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    activeModules?: OrganizationCreateactiveModulesInput | string[]
    clientID?: string | null
    clientSecret?: string | null
    fiscalYearQuarters?: string | null
    fiscalYearFormat?: string | null
    auditYear?: string | null
    logoUrl?: string | null
    deleted?: boolean | null
    business?: BusinessCreateNestedManyWithoutOrganizationInput
    Doctype?: DoctypeCreateNestedManyWithoutOrganizationInput
    Documents?: DocumentsCreateNestedManyWithoutOrganizationInput
    entity?: EntityCreateNestedManyWithoutOrganizationInput
    entityType?: EntityTypeCreateNestedManyWithoutOrganizationInput
    location?: LocationCreateNestedManyWithoutOrganizationInput
    role?: RoleCreateNestedManyWithoutOrganizationInput
    section?: SectionCreateNestedManyWithoutOrganizationInput
    systemType?: SystemTypeCreateNestedManyWithoutOrganizationInput
    user?: UserCreateNestedManyWithoutOrganizationInput
    userPersonalisation?: userPersonalisationCreateNestedManyWithoutOrganizationInput
    ConnectedApps?: ConnectedAppsCreateNestedManyWithoutOrganizationInput
    unitOfMeasurement?: unitTypeCreateNestedManyWithoutOrganizationInput
    kpi?: kpiCreateNestedManyWithoutOrganizationInput
    businessType?: businessTypeCreateNestedManyWithoutOrganizationInput
    prefixSuffix?: prefixSuffixCreateNestedManyWithoutOrganizationInput
    serialNumber?: serialNumberCreateNestedManyWithoutOrganizationInput
    function?: FunctionsCreateNestedManyWithoutOrganizationInput
    rolesTable?: rolesTableCreateNestedManyWithoutOrganizationInput
    problem?: ProblemCreateNestedManyWithoutOrganizationInput
    parts?: PartsCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutModelsInput = {
    id?: string
    kcId?: string | null
    organizationName?: string | null
    realmName?: string | null
    instanceUrl?: string | null
    principalGeography?: string | null
    loginUrl?: string | null
    logoutUrl?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    activeModules?: OrganizationCreateactiveModulesInput | string[]
    clientID?: string | null
    clientSecret?: string | null
    fiscalYearQuarters?: string | null
    fiscalYearFormat?: string | null
    auditYear?: string | null
    logoUrl?: string | null
    deleted?: boolean | null
    business?: BusinessUncheckedCreateNestedManyWithoutOrganizationInput
    Doctype?: DoctypeUncheckedCreateNestedManyWithoutOrganizationInput
    Documents?: DocumentsUncheckedCreateNestedManyWithoutOrganizationInput
    entity?: EntityUncheckedCreateNestedManyWithoutOrganizationInput
    entityType?: EntityTypeUncheckedCreateNestedManyWithoutOrganizationInput
    location?: LocationUncheckedCreateNestedManyWithoutOrganizationInput
    role?: RoleUncheckedCreateNestedManyWithoutOrganizationInput
    section?: SectionUncheckedCreateNestedManyWithoutOrganizationInput
    systemType?: SystemTypeUncheckedCreateNestedManyWithoutOrganizationInput
    user?: UserUncheckedCreateNestedManyWithoutOrganizationInput
    userPersonalisation?: userPersonalisationUncheckedCreateNestedManyWithoutOrganizationInput
    ConnectedApps?: ConnectedAppsUncheckedCreateNestedManyWithoutOrganizationInput
    unitOfMeasurement?: unitTypeUncheckedCreateNestedManyWithoutOrganizationInput
    kpi?: kpiUncheckedCreateNestedManyWithoutOrganizationInput
    businessType?: businessTypeUncheckedCreateNestedManyWithoutOrganizationInput
    prefixSuffix?: prefixSuffixUncheckedCreateNestedManyWithoutOrganizationInput
    serialNumber?: serialNumberUncheckedCreateNestedManyWithoutOrganizationInput
    function?: FunctionsUncheckedCreateNestedManyWithoutOrganizationInput
    rolesTable?: rolesTableUncheckedCreateNestedManyWithoutOrganizationInput
    problem?: ProblemUncheckedCreateNestedManyWithoutOrganizationInput
    parts?: PartsUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutModelsInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutModelsInput, OrganizationUncheckedCreateWithoutModelsInput>
  }

  export type PartsCreateWithoutModelsInput = {
    id?: string
    partNo: string
    partName: string
    description?: string | null
    claimId?: PartsCreateclaimIdInput | string[]
    claims?: ClaimCreateNestedManyWithoutPartsInput
    entity?: EntityCreateNestedOneWithoutPartsInput
    organization?: OrganizationCreateNestedOneWithoutPartsInput
  }

  export type PartsUncheckedCreateWithoutModelsInput = {
    id?: string
    partNo: string
    partName: string
    description?: string | null
    organizationId?: string | null
    entityId?: string | null
    claimId?: PartsCreateclaimIdInput | string[]
    modelsId?: PartsCreatemodelsIdInput | string[]
    claims?: ClaimUncheckedCreateNestedManyWithoutPartsInput
  }

  export type PartsCreateOrConnectWithoutModelsInput = {
    where: PartsWhereUniqueInput
    create: XOR<PartsCreateWithoutModelsInput, PartsUncheckedCreateWithoutModelsInput>
  }

  export type ClaimUpsertWithWhereUniqueWithoutModelsInput = {
    where: ClaimWhereUniqueInput
    update: XOR<ClaimUpdateWithoutModelsInput, ClaimUncheckedUpdateWithoutModelsInput>
    create: XOR<ClaimCreateWithoutModelsInput, ClaimUncheckedCreateWithoutModelsInput>
  }

  export type ClaimUpdateWithWhereUniqueWithoutModelsInput = {
    where: ClaimWhereUniqueInput
    data: XOR<ClaimUpdateWithoutModelsInput, ClaimUncheckedUpdateWithoutModelsInput>
  }

  export type ClaimUpdateManyWithWhereWithoutModelsInput = {
    where: ClaimScalarWhereInput
    data: XOR<ClaimUpdateManyMutationInput, ClaimUncheckedUpdateManyWithoutModelsInput>
  }

  export type ClaimScalarWhereInput = {
    AND?: ClaimScalarWhereInput | ClaimScalarWhereInput[]
    OR?: ClaimScalarWhereInput[]
    NOT?: ClaimScalarWhereInput | ClaimScalarWhereInput[]
    id?: StringFilter<"Claim"> | string
    partId?: StringNullableFilter<"Claim"> | string | null
    modelId?: StringNullableFilter<"Claim"> | string | null
    partRecieptDate?: StringFilter<"Claim"> | string
    vehicleType?: StringFilter<"Claim"> | string
    FrameNo?: StringFilter<"Claim"> | string
    prNo?: StringFilter<"Claim"> | string
    lineOffDate?: StringFilter<"Claim"> | string
    saleDate?: StringFilter<"Claim"> | string
    repairDate?: StringFilter<"Claim"> | string
    shipmentId?: StringNullableFilter<"Claim"> | string | null
    investigationId?: StringNullableFilter<"Claim"> | string | null
    settleMonth?: StringNullableFilter<"Claim"> | string | null
    kms?: IntFilter<"Claim"> | number
    problemId?: StringNullableFilter<"Claim"> | string | null
    mis?: IntFilter<"Claim"> | number
    claimNo?: IntFilter<"Claim"> | number
  }

  export type OrganizationUpsertWithoutModelsInput = {
    update: XOR<OrganizationUpdateWithoutModelsInput, OrganizationUncheckedUpdateWithoutModelsInput>
    create: XOR<OrganizationCreateWithoutModelsInput, OrganizationUncheckedCreateWithoutModelsInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutModelsInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutModelsInput, OrganizationUncheckedUpdateWithoutModelsInput>
  }

  export type OrganizationUpdateWithoutModelsInput = {
    kcId?: NullableStringFieldUpdateOperationsInput | string | null
    organizationName?: NullableStringFieldUpdateOperationsInput | string | null
    realmName?: NullableStringFieldUpdateOperationsInput | string | null
    instanceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    principalGeography?: NullableStringFieldUpdateOperationsInput | string | null
    loginUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoutUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    activeModules?: OrganizationUpdateactiveModulesInput | string[]
    clientID?: NullableStringFieldUpdateOperationsInput | string | null
    clientSecret?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearQuarters?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearFormat?: NullableStringFieldUpdateOperationsInput | string | null
    auditYear?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    business?: BusinessUpdateManyWithoutOrganizationNestedInput
    Doctype?: DoctypeUpdateManyWithoutOrganizationNestedInput
    Documents?: DocumentsUpdateManyWithoutOrganizationNestedInput
    entity?: EntityUpdateManyWithoutOrganizationNestedInput
    entityType?: EntityTypeUpdateManyWithoutOrganizationNestedInput
    location?: LocationUpdateManyWithoutOrganizationNestedInput
    role?: RoleUpdateManyWithoutOrganizationNestedInput
    section?: SectionUpdateManyWithoutOrganizationNestedInput
    systemType?: SystemTypeUpdateManyWithoutOrganizationNestedInput
    user?: UserUpdateManyWithoutOrganizationNestedInput
    userPersonalisation?: userPersonalisationUpdateManyWithoutOrganizationNestedInput
    ConnectedApps?: ConnectedAppsUpdateManyWithoutOrganizationNestedInput
    unitOfMeasurement?: unitTypeUpdateManyWithoutOrganizationNestedInput
    kpi?: kpiUpdateManyWithoutOrganizationNestedInput
    businessType?: businessTypeUpdateManyWithoutOrganizationNestedInput
    prefixSuffix?: prefixSuffixUpdateManyWithoutOrganizationNestedInput
    serialNumber?: serialNumberUpdateManyWithoutOrganizationNestedInput
    function?: FunctionsUpdateManyWithoutOrganizationNestedInput
    rolesTable?: rolesTableUpdateManyWithoutOrganizationNestedInput
    problem?: ProblemUpdateManyWithoutOrganizationNestedInput
    parts?: PartsUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutModelsInput = {
    kcId?: NullableStringFieldUpdateOperationsInput | string | null
    organizationName?: NullableStringFieldUpdateOperationsInput | string | null
    realmName?: NullableStringFieldUpdateOperationsInput | string | null
    instanceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    principalGeography?: NullableStringFieldUpdateOperationsInput | string | null
    loginUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoutUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    activeModules?: OrganizationUpdateactiveModulesInput | string[]
    clientID?: NullableStringFieldUpdateOperationsInput | string | null
    clientSecret?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearQuarters?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearFormat?: NullableStringFieldUpdateOperationsInput | string | null
    auditYear?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    business?: BusinessUncheckedUpdateManyWithoutOrganizationNestedInput
    Doctype?: DoctypeUncheckedUpdateManyWithoutOrganizationNestedInput
    Documents?: DocumentsUncheckedUpdateManyWithoutOrganizationNestedInput
    entity?: EntityUncheckedUpdateManyWithoutOrganizationNestedInput
    entityType?: EntityTypeUncheckedUpdateManyWithoutOrganizationNestedInput
    location?: LocationUncheckedUpdateManyWithoutOrganizationNestedInput
    role?: RoleUncheckedUpdateManyWithoutOrganizationNestedInput
    section?: SectionUncheckedUpdateManyWithoutOrganizationNestedInput
    systemType?: SystemTypeUncheckedUpdateManyWithoutOrganizationNestedInput
    user?: UserUncheckedUpdateManyWithoutOrganizationNestedInput
    userPersonalisation?: userPersonalisationUncheckedUpdateManyWithoutOrganizationNestedInput
    ConnectedApps?: ConnectedAppsUncheckedUpdateManyWithoutOrganizationNestedInput
    unitOfMeasurement?: unitTypeUncheckedUpdateManyWithoutOrganizationNestedInput
    kpi?: kpiUncheckedUpdateManyWithoutOrganizationNestedInput
    businessType?: businessTypeUncheckedUpdateManyWithoutOrganizationNestedInput
    prefixSuffix?: prefixSuffixUncheckedUpdateManyWithoutOrganizationNestedInput
    serialNumber?: serialNumberUncheckedUpdateManyWithoutOrganizationNestedInput
    function?: FunctionsUncheckedUpdateManyWithoutOrganizationNestedInput
    rolesTable?: rolesTableUncheckedUpdateManyWithoutOrganizationNestedInput
    problem?: ProblemUncheckedUpdateManyWithoutOrganizationNestedInput
    parts?: PartsUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type PartsUpsertWithWhereUniqueWithoutModelsInput = {
    where: PartsWhereUniqueInput
    update: XOR<PartsUpdateWithoutModelsInput, PartsUncheckedUpdateWithoutModelsInput>
    create: XOR<PartsCreateWithoutModelsInput, PartsUncheckedCreateWithoutModelsInput>
  }

  export type PartsUpdateWithWhereUniqueWithoutModelsInput = {
    where: PartsWhereUniqueInput
    data: XOR<PartsUpdateWithoutModelsInput, PartsUncheckedUpdateWithoutModelsInput>
  }

  export type PartsUpdateManyWithWhereWithoutModelsInput = {
    where: PartsScalarWhereInput
    data: XOR<PartsUpdateManyMutationInput, PartsUncheckedUpdateManyWithoutModelsInput>
  }

  export type PartsScalarWhereInput = {
    AND?: PartsScalarWhereInput | PartsScalarWhereInput[]
    OR?: PartsScalarWhereInput[]
    NOT?: PartsScalarWhereInput | PartsScalarWhereInput[]
    id?: StringFilter<"Parts"> | string
    partNo?: StringFilter<"Parts"> | string
    partName?: StringFilter<"Parts"> | string
    description?: StringNullableFilter<"Parts"> | string | null
    organizationId?: StringNullableFilter<"Parts"> | string | null
    entityId?: StringNullableFilter<"Parts"> | string | null
    claimId?: StringNullableListFilter<"Parts">
    modelsId?: StringNullableListFilter<"Parts">
  }

  export type ClaimCreateWithoutPartsInput = {
    id?: string
    partRecieptDate: string
    vehicleType: string
    FrameNo: string
    prNo: string
    lineOffDate: string
    saleDate: string
    repairDate: string
    settleMonth?: string | null
    kms: number
    mis: number
    claimNo: number
    problem?: ProblemCreateNestedOneWithoutClaimInput
    investigations?: InvestigationCreateNestedOneWithoutClaimsInput
    models?: ModelsCreateNestedOneWithoutClaimsInput
    shipments?: ShipmentCreateNestedOneWithoutClaimsInput
    claimToEntity?: ClaimToEntityCreateNestedManyWithoutClaimInput
  }

  export type ClaimUncheckedCreateWithoutPartsInput = {
    id?: string
    modelId?: string | null
    partRecieptDate: string
    vehicleType: string
    FrameNo: string
    prNo: string
    lineOffDate: string
    saleDate: string
    repairDate: string
    shipmentId?: string | null
    investigationId?: string | null
    settleMonth?: string | null
    kms: number
    problemId?: string | null
    mis: number
    claimNo: number
    claimToEntity?: ClaimToEntityUncheckedCreateNestedManyWithoutClaimInput
  }

  export type ClaimCreateOrConnectWithoutPartsInput = {
    where: ClaimWhereUniqueInput
    create: XOR<ClaimCreateWithoutPartsInput, ClaimUncheckedCreateWithoutPartsInput>
  }

  export type ClaimCreateManyPartsInputEnvelope = {
    data: ClaimCreateManyPartsInput | ClaimCreateManyPartsInput[]
  }

  export type EntityCreateWithoutPartsInput = {
    id?: string
    entityName?: string | null
    description?: string | null
    createdBy?: string | null
    entityId?: string | null
    deleted?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedBy?: string | null
    users?: EntityCreateusersInput | string[]
    sections?: EntityCreatesectionsInput | string[]
    entityType?: EntityTypeCreateNestedOneWithoutEntityInput
    location?: LocationCreateNestedOneWithoutEntityInput
    organization?: OrganizationCreateNestedOneWithoutEntityInput
    Doctype?: DoctypeCreateNestedManyWithoutEntityInput
    Documents?: DocumentsCreateNestedManyWithoutCreatorEntityInput
    user?: UserCreateNestedManyWithoutEntityInput
    claimToEntity?: ClaimToEntityCreateNestedManyWithoutEntityInput
    function?: FunctionsCreateNestedOneWithoutEntityInput
  }

  export type EntityUncheckedCreateWithoutPartsInput = {
    id?: string
    entityName?: string | null
    description?: string | null
    entityTypeId?: string | null
    organizationId?: string | null
    locationId?: string | null
    createdBy?: string | null
    entityId?: string | null
    deleted?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedBy?: string | null
    users?: EntityCreateusersInput | string[]
    sections?: EntityCreatesectionsInput | string[]
    functionId?: string | null
    Doctype?: DoctypeUncheckedCreateNestedManyWithoutEntityInput
    Documents?: DocumentsUncheckedCreateNestedManyWithoutCreatorEntityInput
    user?: UserUncheckedCreateNestedManyWithoutEntityInput
    claimToEntity?: ClaimToEntityUncheckedCreateNestedManyWithoutEntityInput
  }

  export type EntityCreateOrConnectWithoutPartsInput = {
    where: EntityWhereUniqueInput
    create: XOR<EntityCreateWithoutPartsInput, EntityUncheckedCreateWithoutPartsInput>
  }

  export type OrganizationCreateWithoutPartsInput = {
    id?: string
    kcId?: string | null
    organizationName?: string | null
    realmName?: string | null
    instanceUrl?: string | null
    principalGeography?: string | null
    loginUrl?: string | null
    logoutUrl?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    activeModules?: OrganizationCreateactiveModulesInput | string[]
    clientID?: string | null
    clientSecret?: string | null
    fiscalYearQuarters?: string | null
    fiscalYearFormat?: string | null
    auditYear?: string | null
    logoUrl?: string | null
    deleted?: boolean | null
    business?: BusinessCreateNestedManyWithoutOrganizationInput
    Doctype?: DoctypeCreateNestedManyWithoutOrganizationInput
    Documents?: DocumentsCreateNestedManyWithoutOrganizationInput
    entity?: EntityCreateNestedManyWithoutOrganizationInput
    entityType?: EntityTypeCreateNestedManyWithoutOrganizationInput
    location?: LocationCreateNestedManyWithoutOrganizationInput
    role?: RoleCreateNestedManyWithoutOrganizationInput
    section?: SectionCreateNestedManyWithoutOrganizationInput
    systemType?: SystemTypeCreateNestedManyWithoutOrganizationInput
    user?: UserCreateNestedManyWithoutOrganizationInput
    userPersonalisation?: userPersonalisationCreateNestedManyWithoutOrganizationInput
    ConnectedApps?: ConnectedAppsCreateNestedManyWithoutOrganizationInput
    unitOfMeasurement?: unitTypeCreateNestedManyWithoutOrganizationInput
    kpi?: kpiCreateNestedManyWithoutOrganizationInput
    businessType?: businessTypeCreateNestedManyWithoutOrganizationInput
    prefixSuffix?: prefixSuffixCreateNestedManyWithoutOrganizationInput
    serialNumber?: serialNumberCreateNestedManyWithoutOrganizationInput
    function?: FunctionsCreateNestedManyWithoutOrganizationInput
    rolesTable?: rolesTableCreateNestedManyWithoutOrganizationInput
    problem?: ProblemCreateNestedManyWithoutOrganizationInput
    Models?: ModelsCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutPartsInput = {
    id?: string
    kcId?: string | null
    organizationName?: string | null
    realmName?: string | null
    instanceUrl?: string | null
    principalGeography?: string | null
    loginUrl?: string | null
    logoutUrl?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    activeModules?: OrganizationCreateactiveModulesInput | string[]
    clientID?: string | null
    clientSecret?: string | null
    fiscalYearQuarters?: string | null
    fiscalYearFormat?: string | null
    auditYear?: string | null
    logoUrl?: string | null
    deleted?: boolean | null
    business?: BusinessUncheckedCreateNestedManyWithoutOrganizationInput
    Doctype?: DoctypeUncheckedCreateNestedManyWithoutOrganizationInput
    Documents?: DocumentsUncheckedCreateNestedManyWithoutOrganizationInput
    entity?: EntityUncheckedCreateNestedManyWithoutOrganizationInput
    entityType?: EntityTypeUncheckedCreateNestedManyWithoutOrganizationInput
    location?: LocationUncheckedCreateNestedManyWithoutOrganizationInput
    role?: RoleUncheckedCreateNestedManyWithoutOrganizationInput
    section?: SectionUncheckedCreateNestedManyWithoutOrganizationInput
    systemType?: SystemTypeUncheckedCreateNestedManyWithoutOrganizationInput
    user?: UserUncheckedCreateNestedManyWithoutOrganizationInput
    userPersonalisation?: userPersonalisationUncheckedCreateNestedManyWithoutOrganizationInput
    ConnectedApps?: ConnectedAppsUncheckedCreateNestedManyWithoutOrganizationInput
    unitOfMeasurement?: unitTypeUncheckedCreateNestedManyWithoutOrganizationInput
    kpi?: kpiUncheckedCreateNestedManyWithoutOrganizationInput
    businessType?: businessTypeUncheckedCreateNestedManyWithoutOrganizationInput
    prefixSuffix?: prefixSuffixUncheckedCreateNestedManyWithoutOrganizationInput
    serialNumber?: serialNumberUncheckedCreateNestedManyWithoutOrganizationInput
    function?: FunctionsUncheckedCreateNestedManyWithoutOrganizationInput
    rolesTable?: rolesTableUncheckedCreateNestedManyWithoutOrganizationInput
    problem?: ProblemUncheckedCreateNestedManyWithoutOrganizationInput
    Models?: ModelsUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutPartsInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutPartsInput, OrganizationUncheckedCreateWithoutPartsInput>
  }

  export type ModelsCreateWithoutPartsInput = {
    id?: string
    modelNo: string
    modelName: string
    description?: string | null
    claimId?: ModelsCreateclaimIdInput | string[]
    claims?: ClaimCreateNestedManyWithoutModelsInput
    organization: OrganizationCreateNestedOneWithoutModelsInput
  }

  export type ModelsUncheckedCreateWithoutPartsInput = {
    id?: string
    modelNo: string
    modelName: string
    description?: string | null
    organizationId: string
    partsId?: ModelsCreatepartsIdInput | string[]
    claimId?: ModelsCreateclaimIdInput | string[]
    claims?: ClaimUncheckedCreateNestedManyWithoutModelsInput
  }

  export type ModelsCreateOrConnectWithoutPartsInput = {
    where: ModelsWhereUniqueInput
    create: XOR<ModelsCreateWithoutPartsInput, ModelsUncheckedCreateWithoutPartsInput>
  }

  export type ClaimUpsertWithWhereUniqueWithoutPartsInput = {
    where: ClaimWhereUniqueInput
    update: XOR<ClaimUpdateWithoutPartsInput, ClaimUncheckedUpdateWithoutPartsInput>
    create: XOR<ClaimCreateWithoutPartsInput, ClaimUncheckedCreateWithoutPartsInput>
  }

  export type ClaimUpdateWithWhereUniqueWithoutPartsInput = {
    where: ClaimWhereUniqueInput
    data: XOR<ClaimUpdateWithoutPartsInput, ClaimUncheckedUpdateWithoutPartsInput>
  }

  export type ClaimUpdateManyWithWhereWithoutPartsInput = {
    where: ClaimScalarWhereInput
    data: XOR<ClaimUpdateManyMutationInput, ClaimUncheckedUpdateManyWithoutPartsInput>
  }

  export type EntityUpsertWithoutPartsInput = {
    update: XOR<EntityUpdateWithoutPartsInput, EntityUncheckedUpdateWithoutPartsInput>
    create: XOR<EntityCreateWithoutPartsInput, EntityUncheckedCreateWithoutPartsInput>
    where?: EntityWhereInput
  }

  export type EntityUpdateToOneWithWhereWithoutPartsInput = {
    where?: EntityWhereInput
    data: XOR<EntityUpdateWithoutPartsInput, EntityUncheckedUpdateWithoutPartsInput>
  }

  export type EntityUpdateWithoutPartsInput = {
    entityName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    users?: EntityUpdateusersInput | string[]
    sections?: EntityUpdatesectionsInput | string[]
    entityType?: EntityTypeUpdateOneWithoutEntityNestedInput
    location?: LocationUpdateOneWithoutEntityNestedInput
    organization?: OrganizationUpdateOneWithoutEntityNestedInput
    Doctype?: DoctypeUpdateManyWithoutEntityNestedInput
    Documents?: DocumentsUpdateManyWithoutCreatorEntityNestedInput
    user?: UserUpdateManyWithoutEntityNestedInput
    claimToEntity?: ClaimToEntityUpdateManyWithoutEntityNestedInput
    function?: FunctionsUpdateOneWithoutEntityNestedInput
  }

  export type EntityUncheckedUpdateWithoutPartsInput = {
    entityName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    entityTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    users?: EntityUpdateusersInput | string[]
    sections?: EntityUpdatesectionsInput | string[]
    functionId?: NullableStringFieldUpdateOperationsInput | string | null
    Doctype?: DoctypeUncheckedUpdateManyWithoutEntityNestedInput
    Documents?: DocumentsUncheckedUpdateManyWithoutCreatorEntityNestedInput
    user?: UserUncheckedUpdateManyWithoutEntityNestedInput
    claimToEntity?: ClaimToEntityUncheckedUpdateManyWithoutEntityNestedInput
  }

  export type OrganizationUpsertWithoutPartsInput = {
    update: XOR<OrganizationUpdateWithoutPartsInput, OrganizationUncheckedUpdateWithoutPartsInput>
    create: XOR<OrganizationCreateWithoutPartsInput, OrganizationUncheckedCreateWithoutPartsInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutPartsInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutPartsInput, OrganizationUncheckedUpdateWithoutPartsInput>
  }

  export type OrganizationUpdateWithoutPartsInput = {
    kcId?: NullableStringFieldUpdateOperationsInput | string | null
    organizationName?: NullableStringFieldUpdateOperationsInput | string | null
    realmName?: NullableStringFieldUpdateOperationsInput | string | null
    instanceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    principalGeography?: NullableStringFieldUpdateOperationsInput | string | null
    loginUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoutUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    activeModules?: OrganizationUpdateactiveModulesInput | string[]
    clientID?: NullableStringFieldUpdateOperationsInput | string | null
    clientSecret?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearQuarters?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearFormat?: NullableStringFieldUpdateOperationsInput | string | null
    auditYear?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    business?: BusinessUpdateManyWithoutOrganizationNestedInput
    Doctype?: DoctypeUpdateManyWithoutOrganizationNestedInput
    Documents?: DocumentsUpdateManyWithoutOrganizationNestedInput
    entity?: EntityUpdateManyWithoutOrganizationNestedInput
    entityType?: EntityTypeUpdateManyWithoutOrganizationNestedInput
    location?: LocationUpdateManyWithoutOrganizationNestedInput
    role?: RoleUpdateManyWithoutOrganizationNestedInput
    section?: SectionUpdateManyWithoutOrganizationNestedInput
    systemType?: SystemTypeUpdateManyWithoutOrganizationNestedInput
    user?: UserUpdateManyWithoutOrganizationNestedInput
    userPersonalisation?: userPersonalisationUpdateManyWithoutOrganizationNestedInput
    ConnectedApps?: ConnectedAppsUpdateManyWithoutOrganizationNestedInput
    unitOfMeasurement?: unitTypeUpdateManyWithoutOrganizationNestedInput
    kpi?: kpiUpdateManyWithoutOrganizationNestedInput
    businessType?: businessTypeUpdateManyWithoutOrganizationNestedInput
    prefixSuffix?: prefixSuffixUpdateManyWithoutOrganizationNestedInput
    serialNumber?: serialNumberUpdateManyWithoutOrganizationNestedInput
    function?: FunctionsUpdateManyWithoutOrganizationNestedInput
    rolesTable?: rolesTableUpdateManyWithoutOrganizationNestedInput
    problem?: ProblemUpdateManyWithoutOrganizationNestedInput
    Models?: ModelsUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutPartsInput = {
    kcId?: NullableStringFieldUpdateOperationsInput | string | null
    organizationName?: NullableStringFieldUpdateOperationsInput | string | null
    realmName?: NullableStringFieldUpdateOperationsInput | string | null
    instanceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    principalGeography?: NullableStringFieldUpdateOperationsInput | string | null
    loginUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoutUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    activeModules?: OrganizationUpdateactiveModulesInput | string[]
    clientID?: NullableStringFieldUpdateOperationsInput | string | null
    clientSecret?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearQuarters?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearFormat?: NullableStringFieldUpdateOperationsInput | string | null
    auditYear?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    business?: BusinessUncheckedUpdateManyWithoutOrganizationNestedInput
    Doctype?: DoctypeUncheckedUpdateManyWithoutOrganizationNestedInput
    Documents?: DocumentsUncheckedUpdateManyWithoutOrganizationNestedInput
    entity?: EntityUncheckedUpdateManyWithoutOrganizationNestedInput
    entityType?: EntityTypeUncheckedUpdateManyWithoutOrganizationNestedInput
    location?: LocationUncheckedUpdateManyWithoutOrganizationNestedInput
    role?: RoleUncheckedUpdateManyWithoutOrganizationNestedInput
    section?: SectionUncheckedUpdateManyWithoutOrganizationNestedInput
    systemType?: SystemTypeUncheckedUpdateManyWithoutOrganizationNestedInput
    user?: UserUncheckedUpdateManyWithoutOrganizationNestedInput
    userPersonalisation?: userPersonalisationUncheckedUpdateManyWithoutOrganizationNestedInput
    ConnectedApps?: ConnectedAppsUncheckedUpdateManyWithoutOrganizationNestedInput
    unitOfMeasurement?: unitTypeUncheckedUpdateManyWithoutOrganizationNestedInput
    kpi?: kpiUncheckedUpdateManyWithoutOrganizationNestedInput
    businessType?: businessTypeUncheckedUpdateManyWithoutOrganizationNestedInput
    prefixSuffix?: prefixSuffixUncheckedUpdateManyWithoutOrganizationNestedInput
    serialNumber?: serialNumberUncheckedUpdateManyWithoutOrganizationNestedInput
    function?: FunctionsUncheckedUpdateManyWithoutOrganizationNestedInput
    rolesTable?: rolesTableUncheckedUpdateManyWithoutOrganizationNestedInput
    problem?: ProblemUncheckedUpdateManyWithoutOrganizationNestedInput
    Models?: ModelsUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type ModelsUpsertWithWhereUniqueWithoutPartsInput = {
    where: ModelsWhereUniqueInput
    update: XOR<ModelsUpdateWithoutPartsInput, ModelsUncheckedUpdateWithoutPartsInput>
    create: XOR<ModelsCreateWithoutPartsInput, ModelsUncheckedCreateWithoutPartsInput>
  }

  export type ModelsUpdateWithWhereUniqueWithoutPartsInput = {
    where: ModelsWhereUniqueInput
    data: XOR<ModelsUpdateWithoutPartsInput, ModelsUncheckedUpdateWithoutPartsInput>
  }

  export type ModelsUpdateManyWithWhereWithoutPartsInput = {
    where: ModelsScalarWhereInput
    data: XOR<ModelsUpdateManyMutationInput, ModelsUncheckedUpdateManyWithoutPartsInput>
  }

  export type ModelsScalarWhereInput = {
    AND?: ModelsScalarWhereInput | ModelsScalarWhereInput[]
    OR?: ModelsScalarWhereInput[]
    NOT?: ModelsScalarWhereInput | ModelsScalarWhereInput[]
    id?: StringFilter<"Models"> | string
    modelNo?: StringFilter<"Models"> | string
    modelName?: StringFilter<"Models"> | string
    description?: StringNullableFilter<"Models"> | string | null
    organizationId?: StringFilter<"Models"> | string
    partsId?: StringNullableListFilter<"Models">
    claimId?: StringNullableListFilter<"Models">
  }

  export type ProblemCreateWithoutClaimInput = {
    id?: string
    problem: string
    createdAt: string
    investigations?: InvestigationCreateNestedManyWithoutProblemInput
    organization: OrganizationCreateNestedOneWithoutProblemInput
  }

  export type ProblemUncheckedCreateWithoutClaimInput = {
    id?: string
    problem: string
    createdAt: string
    organizationId: string
    investigations?: InvestigationUncheckedCreateNestedManyWithoutProblemInput
  }

  export type ProblemCreateOrConnectWithoutClaimInput = {
    where: ProblemWhereUniqueInput
    create: XOR<ProblemCreateWithoutClaimInput, ProblemUncheckedCreateWithoutClaimInput>
  }

  export type InvestigationCreateWithoutClaimsInput = {
    id?: string
    rootCause: string
    counterMeasure: string
    leadTime: string
    claimType: string
    implementDate: string
    attachment?: InvestigationCreateattachmentInput | InputJsonValue[]
    claimNo: number
    Problem?: ProblemCreateNestedOneWithoutInvestigationsInput
  }

  export type InvestigationUncheckedCreateWithoutClaimsInput = {
    id?: string
    rootCause: string
    counterMeasure: string
    leadTime: string
    claimType: string
    implementDate: string
    attachment?: InvestigationCreateattachmentInput | InputJsonValue[]
    claimNo: number
    problemId?: string | null
  }

  export type InvestigationCreateOrConnectWithoutClaimsInput = {
    where: InvestigationWhereUniqueInput
    create: XOR<InvestigationCreateWithoutClaimsInput, InvestigationUncheckedCreateWithoutClaimsInput>
  }

  export type ModelsCreateWithoutClaimsInput = {
    id?: string
    modelNo: string
    modelName: string
    description?: string | null
    claimId?: ModelsCreateclaimIdInput | string[]
    organization: OrganizationCreateNestedOneWithoutModelsInput
    Parts?: PartsCreateNestedManyWithoutModelsInput
  }

  export type ModelsUncheckedCreateWithoutClaimsInput = {
    id?: string
    modelNo: string
    modelName: string
    description?: string | null
    organizationId: string
    partsId?: ModelsCreatepartsIdInput | string[]
    claimId?: ModelsCreateclaimIdInput | string[]
    Parts?: PartsUncheckedCreateNestedManyWithoutModelsInput
  }

  export type ModelsCreateOrConnectWithoutClaimsInput = {
    where: ModelsWhereUniqueInput
    create: XOR<ModelsCreateWithoutClaimsInput, ModelsUncheckedCreateWithoutClaimsInput>
  }

  export type PartsCreateWithoutClaimsInput = {
    id?: string
    partNo: string
    partName: string
    description?: string | null
    claimId?: PartsCreateclaimIdInput | string[]
    entity?: EntityCreateNestedOneWithoutPartsInput
    organization?: OrganizationCreateNestedOneWithoutPartsInput
    models?: ModelsCreateNestedManyWithoutPartsInput
  }

  export type PartsUncheckedCreateWithoutClaimsInput = {
    id?: string
    partNo: string
    partName: string
    description?: string | null
    organizationId?: string | null
    entityId?: string | null
    claimId?: PartsCreateclaimIdInput | string[]
    modelsId?: PartsCreatemodelsIdInput | string[]
    models?: ModelsUncheckedCreateNestedManyWithoutPartsInput
  }

  export type PartsCreateOrConnectWithoutClaimsInput = {
    where: PartsWhereUniqueInput
    create: XOR<PartsCreateWithoutClaimsInput, PartsUncheckedCreateWithoutClaimsInput>
  }

  export type ShipmentCreateWithoutClaimsInput = {
    id?: string
    shipmentDate?: string | null
    quantity?: number | null
    location?: string | null
    InvoiceNumber?: string | null
    dueDate?: string | null
    shipmentCost?: number | null
    createdBy?: string | null
    awb?: string | null
    supplierName?: string | null
    supplierReport?: ShipmentCreatesupplierReportInput | InputJsonValue[]
  }

  export type ShipmentUncheckedCreateWithoutClaimsInput = {
    id?: string
    shipmentDate?: string | null
    quantity?: number | null
    location?: string | null
    InvoiceNumber?: string | null
    dueDate?: string | null
    shipmentCost?: number | null
    createdBy?: string | null
    awb?: string | null
    supplierName?: string | null
    supplierReport?: ShipmentCreatesupplierReportInput | InputJsonValue[]
  }

  export type ShipmentCreateOrConnectWithoutClaimsInput = {
    where: ShipmentWhereUniqueInput
    create: XOR<ShipmentCreateWithoutClaimsInput, ShipmentUncheckedCreateWithoutClaimsInput>
  }

  export type ClaimToEntityCreateWithoutClaimInput = {
    id?: string
    entity: EntityCreateNestedOneWithoutClaimToEntityInput
  }

  export type ClaimToEntityUncheckedCreateWithoutClaimInput = {
    id?: string
    entityId: string
  }

  export type ClaimToEntityCreateOrConnectWithoutClaimInput = {
    where: ClaimToEntityWhereUniqueInput
    create: XOR<ClaimToEntityCreateWithoutClaimInput, ClaimToEntityUncheckedCreateWithoutClaimInput>
  }

  export type ClaimToEntityCreateManyClaimInputEnvelope = {
    data: ClaimToEntityCreateManyClaimInput | ClaimToEntityCreateManyClaimInput[]
  }

  export type ProblemUpsertWithoutClaimInput = {
    update: XOR<ProblemUpdateWithoutClaimInput, ProblemUncheckedUpdateWithoutClaimInput>
    create: XOR<ProblemCreateWithoutClaimInput, ProblemUncheckedCreateWithoutClaimInput>
    where?: ProblemWhereInput
  }

  export type ProblemUpdateToOneWithWhereWithoutClaimInput = {
    where?: ProblemWhereInput
    data: XOR<ProblemUpdateWithoutClaimInput, ProblemUncheckedUpdateWithoutClaimInput>
  }

  export type ProblemUpdateWithoutClaimInput = {
    problem?: StringFieldUpdateOperationsInput | string
    createdAt?: StringFieldUpdateOperationsInput | string
    investigations?: InvestigationUpdateManyWithoutProblemNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutProblemNestedInput
  }

  export type ProblemUncheckedUpdateWithoutClaimInput = {
    problem?: StringFieldUpdateOperationsInput | string
    createdAt?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    investigations?: InvestigationUncheckedUpdateManyWithoutProblemNestedInput
  }

  export type InvestigationUpsertWithoutClaimsInput = {
    update: XOR<InvestigationUpdateWithoutClaimsInput, InvestigationUncheckedUpdateWithoutClaimsInput>
    create: XOR<InvestigationCreateWithoutClaimsInput, InvestigationUncheckedCreateWithoutClaimsInput>
    where?: InvestigationWhereInput
  }

  export type InvestigationUpdateToOneWithWhereWithoutClaimsInput = {
    where?: InvestigationWhereInput
    data: XOR<InvestigationUpdateWithoutClaimsInput, InvestigationUncheckedUpdateWithoutClaimsInput>
  }

  export type InvestigationUpdateWithoutClaimsInput = {
    rootCause?: StringFieldUpdateOperationsInput | string
    counterMeasure?: StringFieldUpdateOperationsInput | string
    leadTime?: StringFieldUpdateOperationsInput | string
    claimType?: StringFieldUpdateOperationsInput | string
    implementDate?: StringFieldUpdateOperationsInput | string
    attachment?: InvestigationUpdateattachmentInput | InputJsonValue[]
    claimNo?: IntFieldUpdateOperationsInput | number
    Problem?: ProblemUpdateOneWithoutInvestigationsNestedInput
  }

  export type InvestigationUncheckedUpdateWithoutClaimsInput = {
    rootCause?: StringFieldUpdateOperationsInput | string
    counterMeasure?: StringFieldUpdateOperationsInput | string
    leadTime?: StringFieldUpdateOperationsInput | string
    claimType?: StringFieldUpdateOperationsInput | string
    implementDate?: StringFieldUpdateOperationsInput | string
    attachment?: InvestigationUpdateattachmentInput | InputJsonValue[]
    claimNo?: IntFieldUpdateOperationsInput | number
    problemId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ModelsUpsertWithoutClaimsInput = {
    update: XOR<ModelsUpdateWithoutClaimsInput, ModelsUncheckedUpdateWithoutClaimsInput>
    create: XOR<ModelsCreateWithoutClaimsInput, ModelsUncheckedCreateWithoutClaimsInput>
    where?: ModelsWhereInput
  }

  export type ModelsUpdateToOneWithWhereWithoutClaimsInput = {
    where?: ModelsWhereInput
    data: XOR<ModelsUpdateWithoutClaimsInput, ModelsUncheckedUpdateWithoutClaimsInput>
  }

  export type ModelsUpdateWithoutClaimsInput = {
    modelNo?: StringFieldUpdateOperationsInput | string
    modelName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    claimId?: ModelsUpdateclaimIdInput | string[]
    organization?: OrganizationUpdateOneRequiredWithoutModelsNestedInput
    Parts?: PartsUpdateManyWithoutModelsNestedInput
  }

  export type ModelsUncheckedUpdateWithoutClaimsInput = {
    modelNo?: StringFieldUpdateOperationsInput | string
    modelName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: StringFieldUpdateOperationsInput | string
    partsId?: ModelsUpdatepartsIdInput | string[]
    claimId?: ModelsUpdateclaimIdInput | string[]
    Parts?: PartsUncheckedUpdateManyWithoutModelsNestedInput
  }

  export type PartsUpsertWithoutClaimsInput = {
    update: XOR<PartsUpdateWithoutClaimsInput, PartsUncheckedUpdateWithoutClaimsInput>
    create: XOR<PartsCreateWithoutClaimsInput, PartsUncheckedCreateWithoutClaimsInput>
    where?: PartsWhereInput
  }

  export type PartsUpdateToOneWithWhereWithoutClaimsInput = {
    where?: PartsWhereInput
    data: XOR<PartsUpdateWithoutClaimsInput, PartsUncheckedUpdateWithoutClaimsInput>
  }

  export type PartsUpdateWithoutClaimsInput = {
    partNo?: StringFieldUpdateOperationsInput | string
    partName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    claimId?: PartsUpdateclaimIdInput | string[]
    entity?: EntityUpdateOneWithoutPartsNestedInput
    organization?: OrganizationUpdateOneWithoutPartsNestedInput
    models?: ModelsUpdateManyWithoutPartsNestedInput
  }

  export type PartsUncheckedUpdateWithoutClaimsInput = {
    partNo?: StringFieldUpdateOperationsInput | string
    partName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    claimId?: PartsUpdateclaimIdInput | string[]
    modelsId?: PartsUpdatemodelsIdInput | string[]
    models?: ModelsUncheckedUpdateManyWithoutPartsNestedInput
  }

  export type ShipmentUpsertWithoutClaimsInput = {
    update: XOR<ShipmentUpdateWithoutClaimsInput, ShipmentUncheckedUpdateWithoutClaimsInput>
    create: XOR<ShipmentCreateWithoutClaimsInput, ShipmentUncheckedCreateWithoutClaimsInput>
    where?: ShipmentWhereInput
  }

  export type ShipmentUpdateToOneWithWhereWithoutClaimsInput = {
    where?: ShipmentWhereInput
    data: XOR<ShipmentUpdateWithoutClaimsInput, ShipmentUncheckedUpdateWithoutClaimsInput>
  }

  export type ShipmentUpdateWithoutClaimsInput = {
    shipmentDate?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    InvoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableStringFieldUpdateOperationsInput | string | null
    shipmentCost?: NullableIntFieldUpdateOperationsInput | number | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    awb?: NullableStringFieldUpdateOperationsInput | string | null
    supplierName?: NullableStringFieldUpdateOperationsInput | string | null
    supplierReport?: ShipmentUpdatesupplierReportInput | InputJsonValue[]
  }

  export type ShipmentUncheckedUpdateWithoutClaimsInput = {
    shipmentDate?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    InvoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableStringFieldUpdateOperationsInput | string | null
    shipmentCost?: NullableIntFieldUpdateOperationsInput | number | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    awb?: NullableStringFieldUpdateOperationsInput | string | null
    supplierName?: NullableStringFieldUpdateOperationsInput | string | null
    supplierReport?: ShipmentUpdatesupplierReportInput | InputJsonValue[]
  }

  export type ClaimToEntityUpsertWithWhereUniqueWithoutClaimInput = {
    where: ClaimToEntityWhereUniqueInput
    update: XOR<ClaimToEntityUpdateWithoutClaimInput, ClaimToEntityUncheckedUpdateWithoutClaimInput>
    create: XOR<ClaimToEntityCreateWithoutClaimInput, ClaimToEntityUncheckedCreateWithoutClaimInput>
  }

  export type ClaimToEntityUpdateWithWhereUniqueWithoutClaimInput = {
    where: ClaimToEntityWhereUniqueInput
    data: XOR<ClaimToEntityUpdateWithoutClaimInput, ClaimToEntityUncheckedUpdateWithoutClaimInput>
  }

  export type ClaimToEntityUpdateManyWithWhereWithoutClaimInput = {
    where: ClaimToEntityScalarWhereInput
    data: XOR<ClaimToEntityUpdateManyMutationInput, ClaimToEntityUncheckedUpdateManyWithoutClaimInput>
  }

  export type ClaimToEntityScalarWhereInput = {
    AND?: ClaimToEntityScalarWhereInput | ClaimToEntityScalarWhereInput[]
    OR?: ClaimToEntityScalarWhereInput[]
    NOT?: ClaimToEntityScalarWhereInput | ClaimToEntityScalarWhereInput[]
    id?: StringFilter<"ClaimToEntity"> | string
    claimId?: StringFilter<"ClaimToEntity"> | string
    entityId?: StringFilter<"ClaimToEntity"> | string
  }

  export type InvestigationCreateWithoutProblemInput = {
    id?: string
    rootCause: string
    counterMeasure: string
    leadTime: string
    claimType: string
    implementDate: string
    attachment?: InvestigationCreateattachmentInput | InputJsonValue[]
    claimNo: number
    claims?: ClaimCreateNestedManyWithoutInvestigationsInput
  }

  export type InvestigationUncheckedCreateWithoutProblemInput = {
    id?: string
    rootCause: string
    counterMeasure: string
    leadTime: string
    claimType: string
    implementDate: string
    attachment?: InvestigationCreateattachmentInput | InputJsonValue[]
    claimNo: number
    claims?: ClaimUncheckedCreateNestedManyWithoutInvestigationsInput
  }

  export type InvestigationCreateOrConnectWithoutProblemInput = {
    where: InvestigationWhereUniqueInput
    create: XOR<InvestigationCreateWithoutProblemInput, InvestigationUncheckedCreateWithoutProblemInput>
  }

  export type InvestigationCreateManyProblemInputEnvelope = {
    data: InvestigationCreateManyProblemInput | InvestigationCreateManyProblemInput[]
  }

  export type ClaimCreateWithoutProblemInput = {
    id?: string
    partRecieptDate: string
    vehicleType: string
    FrameNo: string
    prNo: string
    lineOffDate: string
    saleDate: string
    repairDate: string
    settleMonth?: string | null
    kms: number
    mis: number
    claimNo: number
    investigations?: InvestigationCreateNestedOneWithoutClaimsInput
    models?: ModelsCreateNestedOneWithoutClaimsInput
    parts?: PartsCreateNestedOneWithoutClaimsInput
    shipments?: ShipmentCreateNestedOneWithoutClaimsInput
    claimToEntity?: ClaimToEntityCreateNestedManyWithoutClaimInput
  }

  export type ClaimUncheckedCreateWithoutProblemInput = {
    id?: string
    partId?: string | null
    modelId?: string | null
    partRecieptDate: string
    vehicleType: string
    FrameNo: string
    prNo: string
    lineOffDate: string
    saleDate: string
    repairDate: string
    shipmentId?: string | null
    investigationId?: string | null
    settleMonth?: string | null
    kms: number
    mis: number
    claimNo: number
    claimToEntity?: ClaimToEntityUncheckedCreateNestedManyWithoutClaimInput
  }

  export type ClaimCreateOrConnectWithoutProblemInput = {
    where: ClaimWhereUniqueInput
    create: XOR<ClaimCreateWithoutProblemInput, ClaimUncheckedCreateWithoutProblemInput>
  }

  export type ClaimCreateManyProblemInputEnvelope = {
    data: ClaimCreateManyProblemInput | ClaimCreateManyProblemInput[]
  }

  export type OrganizationCreateWithoutProblemInput = {
    id?: string
    kcId?: string | null
    organizationName?: string | null
    realmName?: string | null
    instanceUrl?: string | null
    principalGeography?: string | null
    loginUrl?: string | null
    logoutUrl?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    activeModules?: OrganizationCreateactiveModulesInput | string[]
    clientID?: string | null
    clientSecret?: string | null
    fiscalYearQuarters?: string | null
    fiscalYearFormat?: string | null
    auditYear?: string | null
    logoUrl?: string | null
    deleted?: boolean | null
    business?: BusinessCreateNestedManyWithoutOrganizationInput
    Doctype?: DoctypeCreateNestedManyWithoutOrganizationInput
    Documents?: DocumentsCreateNestedManyWithoutOrganizationInput
    entity?: EntityCreateNestedManyWithoutOrganizationInput
    entityType?: EntityTypeCreateNestedManyWithoutOrganizationInput
    location?: LocationCreateNestedManyWithoutOrganizationInput
    role?: RoleCreateNestedManyWithoutOrganizationInput
    section?: SectionCreateNestedManyWithoutOrganizationInput
    systemType?: SystemTypeCreateNestedManyWithoutOrganizationInput
    user?: UserCreateNestedManyWithoutOrganizationInput
    userPersonalisation?: userPersonalisationCreateNestedManyWithoutOrganizationInput
    ConnectedApps?: ConnectedAppsCreateNestedManyWithoutOrganizationInput
    unitOfMeasurement?: unitTypeCreateNestedManyWithoutOrganizationInput
    kpi?: kpiCreateNestedManyWithoutOrganizationInput
    businessType?: businessTypeCreateNestedManyWithoutOrganizationInput
    prefixSuffix?: prefixSuffixCreateNestedManyWithoutOrganizationInput
    serialNumber?: serialNumberCreateNestedManyWithoutOrganizationInput
    function?: FunctionsCreateNestedManyWithoutOrganizationInput
    rolesTable?: rolesTableCreateNestedManyWithoutOrganizationInput
    parts?: PartsCreateNestedManyWithoutOrganizationInput
    Models?: ModelsCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutProblemInput = {
    id?: string
    kcId?: string | null
    organizationName?: string | null
    realmName?: string | null
    instanceUrl?: string | null
    principalGeography?: string | null
    loginUrl?: string | null
    logoutUrl?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    activeModules?: OrganizationCreateactiveModulesInput | string[]
    clientID?: string | null
    clientSecret?: string | null
    fiscalYearQuarters?: string | null
    fiscalYearFormat?: string | null
    auditYear?: string | null
    logoUrl?: string | null
    deleted?: boolean | null
    business?: BusinessUncheckedCreateNestedManyWithoutOrganizationInput
    Doctype?: DoctypeUncheckedCreateNestedManyWithoutOrganizationInput
    Documents?: DocumentsUncheckedCreateNestedManyWithoutOrganizationInput
    entity?: EntityUncheckedCreateNestedManyWithoutOrganizationInput
    entityType?: EntityTypeUncheckedCreateNestedManyWithoutOrganizationInput
    location?: LocationUncheckedCreateNestedManyWithoutOrganizationInput
    role?: RoleUncheckedCreateNestedManyWithoutOrganizationInput
    section?: SectionUncheckedCreateNestedManyWithoutOrganizationInput
    systemType?: SystemTypeUncheckedCreateNestedManyWithoutOrganizationInput
    user?: UserUncheckedCreateNestedManyWithoutOrganizationInput
    userPersonalisation?: userPersonalisationUncheckedCreateNestedManyWithoutOrganizationInput
    ConnectedApps?: ConnectedAppsUncheckedCreateNestedManyWithoutOrganizationInput
    unitOfMeasurement?: unitTypeUncheckedCreateNestedManyWithoutOrganizationInput
    kpi?: kpiUncheckedCreateNestedManyWithoutOrganizationInput
    businessType?: businessTypeUncheckedCreateNestedManyWithoutOrganizationInput
    prefixSuffix?: prefixSuffixUncheckedCreateNestedManyWithoutOrganizationInput
    serialNumber?: serialNumberUncheckedCreateNestedManyWithoutOrganizationInput
    function?: FunctionsUncheckedCreateNestedManyWithoutOrganizationInput
    rolesTable?: rolesTableUncheckedCreateNestedManyWithoutOrganizationInput
    parts?: PartsUncheckedCreateNestedManyWithoutOrganizationInput
    Models?: ModelsUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutProblemInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutProblemInput, OrganizationUncheckedCreateWithoutProblemInput>
  }

  export type InvestigationUpsertWithWhereUniqueWithoutProblemInput = {
    where: InvestigationWhereUniqueInput
    update: XOR<InvestigationUpdateWithoutProblemInput, InvestigationUncheckedUpdateWithoutProblemInput>
    create: XOR<InvestigationCreateWithoutProblemInput, InvestigationUncheckedCreateWithoutProblemInput>
  }

  export type InvestigationUpdateWithWhereUniqueWithoutProblemInput = {
    where: InvestigationWhereUniqueInput
    data: XOR<InvestigationUpdateWithoutProblemInput, InvestigationUncheckedUpdateWithoutProblemInput>
  }

  export type InvestigationUpdateManyWithWhereWithoutProblemInput = {
    where: InvestigationScalarWhereInput
    data: XOR<InvestigationUpdateManyMutationInput, InvestigationUncheckedUpdateManyWithoutProblemInput>
  }

  export type InvestigationScalarWhereInput = {
    AND?: InvestigationScalarWhereInput | InvestigationScalarWhereInput[]
    OR?: InvestigationScalarWhereInput[]
    NOT?: InvestigationScalarWhereInput | InvestigationScalarWhereInput[]
    id?: StringFilter<"Investigation"> | string
    rootCause?: StringFilter<"Investigation"> | string
    counterMeasure?: StringFilter<"Investigation"> | string
    leadTime?: StringFilter<"Investigation"> | string
    claimType?: StringFilter<"Investigation"> | string
    implementDate?: StringFilter<"Investigation"> | string
    attachment?: JsonNullableListFilter<"Investigation">
    claimNo?: IntFilter<"Investigation"> | number
    problemId?: StringNullableFilter<"Investigation"> | string | null
  }

  export type ClaimUpsertWithWhereUniqueWithoutProblemInput = {
    where: ClaimWhereUniqueInput
    update: XOR<ClaimUpdateWithoutProblemInput, ClaimUncheckedUpdateWithoutProblemInput>
    create: XOR<ClaimCreateWithoutProblemInput, ClaimUncheckedCreateWithoutProblemInput>
  }

  export type ClaimUpdateWithWhereUniqueWithoutProblemInput = {
    where: ClaimWhereUniqueInput
    data: XOR<ClaimUpdateWithoutProblemInput, ClaimUncheckedUpdateWithoutProblemInput>
  }

  export type ClaimUpdateManyWithWhereWithoutProblemInput = {
    where: ClaimScalarWhereInput
    data: XOR<ClaimUpdateManyMutationInput, ClaimUncheckedUpdateManyWithoutProblemInput>
  }

  export type OrganizationUpsertWithoutProblemInput = {
    update: XOR<OrganizationUpdateWithoutProblemInput, OrganizationUncheckedUpdateWithoutProblemInput>
    create: XOR<OrganizationCreateWithoutProblemInput, OrganizationUncheckedCreateWithoutProblemInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutProblemInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutProblemInput, OrganizationUncheckedUpdateWithoutProblemInput>
  }

  export type OrganizationUpdateWithoutProblemInput = {
    kcId?: NullableStringFieldUpdateOperationsInput | string | null
    organizationName?: NullableStringFieldUpdateOperationsInput | string | null
    realmName?: NullableStringFieldUpdateOperationsInput | string | null
    instanceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    principalGeography?: NullableStringFieldUpdateOperationsInput | string | null
    loginUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoutUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    activeModules?: OrganizationUpdateactiveModulesInput | string[]
    clientID?: NullableStringFieldUpdateOperationsInput | string | null
    clientSecret?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearQuarters?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearFormat?: NullableStringFieldUpdateOperationsInput | string | null
    auditYear?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    business?: BusinessUpdateManyWithoutOrganizationNestedInput
    Doctype?: DoctypeUpdateManyWithoutOrganizationNestedInput
    Documents?: DocumentsUpdateManyWithoutOrganizationNestedInput
    entity?: EntityUpdateManyWithoutOrganizationNestedInput
    entityType?: EntityTypeUpdateManyWithoutOrganizationNestedInput
    location?: LocationUpdateManyWithoutOrganizationNestedInput
    role?: RoleUpdateManyWithoutOrganizationNestedInput
    section?: SectionUpdateManyWithoutOrganizationNestedInput
    systemType?: SystemTypeUpdateManyWithoutOrganizationNestedInput
    user?: UserUpdateManyWithoutOrganizationNestedInput
    userPersonalisation?: userPersonalisationUpdateManyWithoutOrganizationNestedInput
    ConnectedApps?: ConnectedAppsUpdateManyWithoutOrganizationNestedInput
    unitOfMeasurement?: unitTypeUpdateManyWithoutOrganizationNestedInput
    kpi?: kpiUpdateManyWithoutOrganizationNestedInput
    businessType?: businessTypeUpdateManyWithoutOrganizationNestedInput
    prefixSuffix?: prefixSuffixUpdateManyWithoutOrganizationNestedInput
    serialNumber?: serialNumberUpdateManyWithoutOrganizationNestedInput
    function?: FunctionsUpdateManyWithoutOrganizationNestedInput
    rolesTable?: rolesTableUpdateManyWithoutOrganizationNestedInput
    parts?: PartsUpdateManyWithoutOrganizationNestedInput
    Models?: ModelsUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutProblemInput = {
    kcId?: NullableStringFieldUpdateOperationsInput | string | null
    organizationName?: NullableStringFieldUpdateOperationsInput | string | null
    realmName?: NullableStringFieldUpdateOperationsInput | string | null
    instanceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    principalGeography?: NullableStringFieldUpdateOperationsInput | string | null
    loginUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoutUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    activeModules?: OrganizationUpdateactiveModulesInput | string[]
    clientID?: NullableStringFieldUpdateOperationsInput | string | null
    clientSecret?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearQuarters?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearFormat?: NullableStringFieldUpdateOperationsInput | string | null
    auditYear?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    business?: BusinessUncheckedUpdateManyWithoutOrganizationNestedInput
    Doctype?: DoctypeUncheckedUpdateManyWithoutOrganizationNestedInput
    Documents?: DocumentsUncheckedUpdateManyWithoutOrganizationNestedInput
    entity?: EntityUncheckedUpdateManyWithoutOrganizationNestedInput
    entityType?: EntityTypeUncheckedUpdateManyWithoutOrganizationNestedInput
    location?: LocationUncheckedUpdateManyWithoutOrganizationNestedInput
    role?: RoleUncheckedUpdateManyWithoutOrganizationNestedInput
    section?: SectionUncheckedUpdateManyWithoutOrganizationNestedInput
    systemType?: SystemTypeUncheckedUpdateManyWithoutOrganizationNestedInput
    user?: UserUncheckedUpdateManyWithoutOrganizationNestedInput
    userPersonalisation?: userPersonalisationUncheckedUpdateManyWithoutOrganizationNestedInput
    ConnectedApps?: ConnectedAppsUncheckedUpdateManyWithoutOrganizationNestedInput
    unitOfMeasurement?: unitTypeUncheckedUpdateManyWithoutOrganizationNestedInput
    kpi?: kpiUncheckedUpdateManyWithoutOrganizationNestedInput
    businessType?: businessTypeUncheckedUpdateManyWithoutOrganizationNestedInput
    prefixSuffix?: prefixSuffixUncheckedUpdateManyWithoutOrganizationNestedInput
    serialNumber?: serialNumberUncheckedUpdateManyWithoutOrganizationNestedInput
    function?: FunctionsUncheckedUpdateManyWithoutOrganizationNestedInput
    rolesTable?: rolesTableUncheckedUpdateManyWithoutOrganizationNestedInput
    parts?: PartsUncheckedUpdateManyWithoutOrganizationNestedInput
    Models?: ModelsUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type ClaimCreateWithoutClaimToEntityInput = {
    id?: string
    partRecieptDate: string
    vehicleType: string
    FrameNo: string
    prNo: string
    lineOffDate: string
    saleDate: string
    repairDate: string
    settleMonth?: string | null
    kms: number
    mis: number
    claimNo: number
    problem?: ProblemCreateNestedOneWithoutClaimInput
    investigations?: InvestigationCreateNestedOneWithoutClaimsInput
    models?: ModelsCreateNestedOneWithoutClaimsInput
    parts?: PartsCreateNestedOneWithoutClaimsInput
    shipments?: ShipmentCreateNestedOneWithoutClaimsInput
  }

  export type ClaimUncheckedCreateWithoutClaimToEntityInput = {
    id?: string
    partId?: string | null
    modelId?: string | null
    partRecieptDate: string
    vehicleType: string
    FrameNo: string
    prNo: string
    lineOffDate: string
    saleDate: string
    repairDate: string
    shipmentId?: string | null
    investigationId?: string | null
    settleMonth?: string | null
    kms: number
    problemId?: string | null
    mis: number
    claimNo: number
  }

  export type ClaimCreateOrConnectWithoutClaimToEntityInput = {
    where: ClaimWhereUniqueInput
    create: XOR<ClaimCreateWithoutClaimToEntityInput, ClaimUncheckedCreateWithoutClaimToEntityInput>
  }

  export type EntityCreateWithoutClaimToEntityInput = {
    id?: string
    entityName?: string | null
    description?: string | null
    createdBy?: string | null
    entityId?: string | null
    deleted?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedBy?: string | null
    users?: EntityCreateusersInput | string[]
    sections?: EntityCreatesectionsInput | string[]
    entityType?: EntityTypeCreateNestedOneWithoutEntityInput
    location?: LocationCreateNestedOneWithoutEntityInput
    organization?: OrganizationCreateNestedOneWithoutEntityInput
    Doctype?: DoctypeCreateNestedManyWithoutEntityInput
    Documents?: DocumentsCreateNestedManyWithoutCreatorEntityInput
    user?: UserCreateNestedManyWithoutEntityInput
    parts?: PartsCreateNestedManyWithoutEntityInput
    function?: FunctionsCreateNestedOneWithoutEntityInput
  }

  export type EntityUncheckedCreateWithoutClaimToEntityInput = {
    id?: string
    entityName?: string | null
    description?: string | null
    entityTypeId?: string | null
    organizationId?: string | null
    locationId?: string | null
    createdBy?: string | null
    entityId?: string | null
    deleted?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedBy?: string | null
    users?: EntityCreateusersInput | string[]
    sections?: EntityCreatesectionsInput | string[]
    functionId?: string | null
    Doctype?: DoctypeUncheckedCreateNestedManyWithoutEntityInput
    Documents?: DocumentsUncheckedCreateNestedManyWithoutCreatorEntityInput
    user?: UserUncheckedCreateNestedManyWithoutEntityInput
    parts?: PartsUncheckedCreateNestedManyWithoutEntityInput
  }

  export type EntityCreateOrConnectWithoutClaimToEntityInput = {
    where: EntityWhereUniqueInput
    create: XOR<EntityCreateWithoutClaimToEntityInput, EntityUncheckedCreateWithoutClaimToEntityInput>
  }

  export type ClaimUpsertWithoutClaimToEntityInput = {
    update: XOR<ClaimUpdateWithoutClaimToEntityInput, ClaimUncheckedUpdateWithoutClaimToEntityInput>
    create: XOR<ClaimCreateWithoutClaimToEntityInput, ClaimUncheckedCreateWithoutClaimToEntityInput>
    where?: ClaimWhereInput
  }

  export type ClaimUpdateToOneWithWhereWithoutClaimToEntityInput = {
    where?: ClaimWhereInput
    data: XOR<ClaimUpdateWithoutClaimToEntityInput, ClaimUncheckedUpdateWithoutClaimToEntityInput>
  }

  export type ClaimUpdateWithoutClaimToEntityInput = {
    partRecieptDate?: StringFieldUpdateOperationsInput | string
    vehicleType?: StringFieldUpdateOperationsInput | string
    FrameNo?: StringFieldUpdateOperationsInput | string
    prNo?: StringFieldUpdateOperationsInput | string
    lineOffDate?: StringFieldUpdateOperationsInput | string
    saleDate?: StringFieldUpdateOperationsInput | string
    repairDate?: StringFieldUpdateOperationsInput | string
    settleMonth?: NullableStringFieldUpdateOperationsInput | string | null
    kms?: IntFieldUpdateOperationsInput | number
    mis?: IntFieldUpdateOperationsInput | number
    claimNo?: IntFieldUpdateOperationsInput | number
    problem?: ProblemUpdateOneWithoutClaimNestedInput
    investigations?: InvestigationUpdateOneWithoutClaimsNestedInput
    models?: ModelsUpdateOneWithoutClaimsNestedInput
    parts?: PartsUpdateOneWithoutClaimsNestedInput
    shipments?: ShipmentUpdateOneWithoutClaimsNestedInput
  }

  export type ClaimUncheckedUpdateWithoutClaimToEntityInput = {
    partId?: NullableStringFieldUpdateOperationsInput | string | null
    modelId?: NullableStringFieldUpdateOperationsInput | string | null
    partRecieptDate?: StringFieldUpdateOperationsInput | string
    vehicleType?: StringFieldUpdateOperationsInput | string
    FrameNo?: StringFieldUpdateOperationsInput | string
    prNo?: StringFieldUpdateOperationsInput | string
    lineOffDate?: StringFieldUpdateOperationsInput | string
    saleDate?: StringFieldUpdateOperationsInput | string
    repairDate?: StringFieldUpdateOperationsInput | string
    shipmentId?: NullableStringFieldUpdateOperationsInput | string | null
    investigationId?: NullableStringFieldUpdateOperationsInput | string | null
    settleMonth?: NullableStringFieldUpdateOperationsInput | string | null
    kms?: IntFieldUpdateOperationsInput | number
    problemId?: NullableStringFieldUpdateOperationsInput | string | null
    mis?: IntFieldUpdateOperationsInput | number
    claimNo?: IntFieldUpdateOperationsInput | number
  }

  export type EntityUpsertWithoutClaimToEntityInput = {
    update: XOR<EntityUpdateWithoutClaimToEntityInput, EntityUncheckedUpdateWithoutClaimToEntityInput>
    create: XOR<EntityCreateWithoutClaimToEntityInput, EntityUncheckedCreateWithoutClaimToEntityInput>
    where?: EntityWhereInput
  }

  export type EntityUpdateToOneWithWhereWithoutClaimToEntityInput = {
    where?: EntityWhereInput
    data: XOR<EntityUpdateWithoutClaimToEntityInput, EntityUncheckedUpdateWithoutClaimToEntityInput>
  }

  export type EntityUpdateWithoutClaimToEntityInput = {
    entityName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    users?: EntityUpdateusersInput | string[]
    sections?: EntityUpdatesectionsInput | string[]
    entityType?: EntityTypeUpdateOneWithoutEntityNestedInput
    location?: LocationUpdateOneWithoutEntityNestedInput
    organization?: OrganizationUpdateOneWithoutEntityNestedInput
    Doctype?: DoctypeUpdateManyWithoutEntityNestedInput
    Documents?: DocumentsUpdateManyWithoutCreatorEntityNestedInput
    user?: UserUpdateManyWithoutEntityNestedInput
    parts?: PartsUpdateManyWithoutEntityNestedInput
    function?: FunctionsUpdateOneWithoutEntityNestedInput
  }

  export type EntityUncheckedUpdateWithoutClaimToEntityInput = {
    entityName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    entityTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    users?: EntityUpdateusersInput | string[]
    sections?: EntityUpdatesectionsInput | string[]
    functionId?: NullableStringFieldUpdateOperationsInput | string | null
    Doctype?: DoctypeUncheckedUpdateManyWithoutEntityNestedInput
    Documents?: DocumentsUncheckedUpdateManyWithoutCreatorEntityNestedInput
    user?: UserUncheckedUpdateManyWithoutEntityNestedInput
    parts?: PartsUncheckedUpdateManyWithoutEntityNestedInput
  }

  export type ClaimCreateWithoutInvestigationsInput = {
    id?: string
    partRecieptDate: string
    vehicleType: string
    FrameNo: string
    prNo: string
    lineOffDate: string
    saleDate: string
    repairDate: string
    settleMonth?: string | null
    kms: number
    mis: number
    claimNo: number
    problem?: ProblemCreateNestedOneWithoutClaimInput
    models?: ModelsCreateNestedOneWithoutClaimsInput
    parts?: PartsCreateNestedOneWithoutClaimsInput
    shipments?: ShipmentCreateNestedOneWithoutClaimsInput
    claimToEntity?: ClaimToEntityCreateNestedManyWithoutClaimInput
  }

  export type ClaimUncheckedCreateWithoutInvestigationsInput = {
    id?: string
    partId?: string | null
    modelId?: string | null
    partRecieptDate: string
    vehicleType: string
    FrameNo: string
    prNo: string
    lineOffDate: string
    saleDate: string
    repairDate: string
    shipmentId?: string | null
    settleMonth?: string | null
    kms: number
    problemId?: string | null
    mis: number
    claimNo: number
    claimToEntity?: ClaimToEntityUncheckedCreateNestedManyWithoutClaimInput
  }

  export type ClaimCreateOrConnectWithoutInvestigationsInput = {
    where: ClaimWhereUniqueInput
    create: XOR<ClaimCreateWithoutInvestigationsInput, ClaimUncheckedCreateWithoutInvestigationsInput>
  }

  export type ClaimCreateManyInvestigationsInputEnvelope = {
    data: ClaimCreateManyInvestigationsInput | ClaimCreateManyInvestigationsInput[]
  }

  export type ProblemCreateWithoutInvestigationsInput = {
    id?: string
    problem: string
    createdAt: string
    claim?: ClaimCreateNestedManyWithoutProblemInput
    organization: OrganizationCreateNestedOneWithoutProblemInput
  }

  export type ProblemUncheckedCreateWithoutInvestigationsInput = {
    id?: string
    problem: string
    createdAt: string
    organizationId: string
    claim?: ClaimUncheckedCreateNestedManyWithoutProblemInput
  }

  export type ProblemCreateOrConnectWithoutInvestigationsInput = {
    where: ProblemWhereUniqueInput
    create: XOR<ProblemCreateWithoutInvestigationsInput, ProblemUncheckedCreateWithoutInvestigationsInput>
  }

  export type ClaimUpsertWithWhereUniqueWithoutInvestigationsInput = {
    where: ClaimWhereUniqueInput
    update: XOR<ClaimUpdateWithoutInvestigationsInput, ClaimUncheckedUpdateWithoutInvestigationsInput>
    create: XOR<ClaimCreateWithoutInvestigationsInput, ClaimUncheckedCreateWithoutInvestigationsInput>
  }

  export type ClaimUpdateWithWhereUniqueWithoutInvestigationsInput = {
    where: ClaimWhereUniqueInput
    data: XOR<ClaimUpdateWithoutInvestigationsInput, ClaimUncheckedUpdateWithoutInvestigationsInput>
  }

  export type ClaimUpdateManyWithWhereWithoutInvestigationsInput = {
    where: ClaimScalarWhereInput
    data: XOR<ClaimUpdateManyMutationInput, ClaimUncheckedUpdateManyWithoutInvestigationsInput>
  }

  export type ProblemUpsertWithoutInvestigationsInput = {
    update: XOR<ProblemUpdateWithoutInvestigationsInput, ProblemUncheckedUpdateWithoutInvestigationsInput>
    create: XOR<ProblemCreateWithoutInvestigationsInput, ProblemUncheckedCreateWithoutInvestigationsInput>
    where?: ProblemWhereInput
  }

  export type ProblemUpdateToOneWithWhereWithoutInvestigationsInput = {
    where?: ProblemWhereInput
    data: XOR<ProblemUpdateWithoutInvestigationsInput, ProblemUncheckedUpdateWithoutInvestigationsInput>
  }

  export type ProblemUpdateWithoutInvestigationsInput = {
    problem?: StringFieldUpdateOperationsInput | string
    createdAt?: StringFieldUpdateOperationsInput | string
    claim?: ClaimUpdateManyWithoutProblemNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutProblemNestedInput
  }

  export type ProblemUncheckedUpdateWithoutInvestigationsInput = {
    problem?: StringFieldUpdateOperationsInput | string
    createdAt?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    claim?: ClaimUncheckedUpdateManyWithoutProblemNestedInput
  }

  export type ClaimCreateWithoutShipmentsInput = {
    id?: string
    partRecieptDate: string
    vehicleType: string
    FrameNo: string
    prNo: string
    lineOffDate: string
    saleDate: string
    repairDate: string
    settleMonth?: string | null
    kms: number
    mis: number
    claimNo: number
    problem?: ProblemCreateNestedOneWithoutClaimInput
    investigations?: InvestigationCreateNestedOneWithoutClaimsInput
    models?: ModelsCreateNestedOneWithoutClaimsInput
    parts?: PartsCreateNestedOneWithoutClaimsInput
    claimToEntity?: ClaimToEntityCreateNestedManyWithoutClaimInput
  }

  export type ClaimUncheckedCreateWithoutShipmentsInput = {
    id?: string
    partId?: string | null
    modelId?: string | null
    partRecieptDate: string
    vehicleType: string
    FrameNo: string
    prNo: string
    lineOffDate: string
    saleDate: string
    repairDate: string
    investigationId?: string | null
    settleMonth?: string | null
    kms: number
    problemId?: string | null
    mis: number
    claimNo: number
    claimToEntity?: ClaimToEntityUncheckedCreateNestedManyWithoutClaimInput
  }

  export type ClaimCreateOrConnectWithoutShipmentsInput = {
    where: ClaimWhereUniqueInput
    create: XOR<ClaimCreateWithoutShipmentsInput, ClaimUncheckedCreateWithoutShipmentsInput>
  }

  export type ClaimCreateManyShipmentsInputEnvelope = {
    data: ClaimCreateManyShipmentsInput | ClaimCreateManyShipmentsInput[]
  }

  export type ClaimUpsertWithWhereUniqueWithoutShipmentsInput = {
    where: ClaimWhereUniqueInput
    update: XOR<ClaimUpdateWithoutShipmentsInput, ClaimUncheckedUpdateWithoutShipmentsInput>
    create: XOR<ClaimCreateWithoutShipmentsInput, ClaimUncheckedCreateWithoutShipmentsInput>
  }

  export type ClaimUpdateWithWhereUniqueWithoutShipmentsInput = {
    where: ClaimWhereUniqueInput
    data: XOR<ClaimUpdateWithoutShipmentsInput, ClaimUncheckedUpdateWithoutShipmentsInput>
  }

  export type ClaimUpdateManyWithWhereWithoutShipmentsInput = {
    where: ClaimScalarWhereInput
    data: XOR<ClaimUpdateManyMutationInput, ClaimUncheckedUpdateManyWithoutShipmentsInput>
  }

  export type BusinessCreateWithoutOrganizationInput = {
    id?: string
    name?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    deleted?: boolean | null
    location?: LocationBusinessCreateNestedManyWithoutBusinessInput
  }

  export type BusinessUncheckedCreateWithoutOrganizationInput = {
    id?: string
    name?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    deleted?: boolean | null
    location?: LocationBusinessUncheckedCreateNestedManyWithoutBusinessInput
  }

  export type BusinessCreateOrConnectWithoutOrganizationInput = {
    where: BusinessWhereUniqueInput
    create: XOR<BusinessCreateWithoutOrganizationInput, BusinessUncheckedCreateWithoutOrganizationInput>
  }

  export type BusinessCreateManyOrganizationInputEnvelope = {
    data: BusinessCreateManyOrganizationInput | BusinessCreateManyOrganizationInput[]
  }

  export type DoctypeCreateWithoutOrganizationInput = {
    id?: string
    locationId?: DoctypeCreatelocationIdInput | string[]
    documentTypeName?: string | null
    documentNumbering?: string | null
    reviewFrequency?: number | null
    revisionRemind?: number | null
    prefix?: string | null
    suffix?: string | null
    readAccess?: string | null
    readAccessUsers?: DoctypeCreatereadAccessUsersInput | InputJsonValue[]
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedBy?: string | null
    createdBy?: string | null
    applicable_systems?: DoctypeCreateapplicable_systemsInput | InputJsonValue[]
    users?: DoctypeCreateusersInput | InputJsonValue[]
    document_classification?: string | null
    distributionUsers?: DoctypeCreatedistributionUsersInput | InputJsonValue[]
    currentVersion: string
    distributionList?: string | null
    Entity?: EntityCreateNestedOneWithoutDoctypeInput
    Documents?: DocumentsCreateNestedManyWithoutDoctypeInput
    documentAdmins?: documentAdminsCreateNestedManyWithoutDoctypeInput
  }

  export type DoctypeUncheckedCreateWithoutOrganizationInput = {
    id?: string
    locationId?: DoctypeCreatelocationIdInput | string[]
    documentTypeName?: string | null
    documentNumbering?: string | null
    reviewFrequency?: number | null
    revisionRemind?: number | null
    prefix?: string | null
    suffix?: string | null
    readAccess?: string | null
    readAccessUsers?: DoctypeCreatereadAccessUsersInput | InputJsonValue[]
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedBy?: string | null
    createdBy?: string | null
    applicable_systems?: DoctypeCreateapplicable_systemsInput | InputJsonValue[]
    users?: DoctypeCreateusersInput | InputJsonValue[]
    document_classification?: string | null
    entityId?: string | null
    distributionUsers?: DoctypeCreatedistributionUsersInput | InputJsonValue[]
    currentVersion: string
    distributionList?: string | null
    Documents?: DocumentsUncheckedCreateNestedManyWithoutDoctypeInput
    documentAdmins?: documentAdminsUncheckedCreateNestedManyWithoutDoctypeInput
  }

  export type DoctypeCreateOrConnectWithoutOrganizationInput = {
    where: DoctypeWhereUniqueInput
    create: XOR<DoctypeCreateWithoutOrganizationInput, DoctypeUncheckedCreateWithoutOrganizationInput>
  }

  export type DoctypeCreateManyOrganizationInputEnvelope = {
    data: DoctypeCreateManyOrganizationInput | DoctypeCreateManyOrganizationInput[]
  }

  export type DocumentsCreateWithoutOrganizationInput = {
    id?: string
    documentName?: string | null
    documentNumbering?: string | null
    reasonOfCreation?: string | null
    effectiveDate?: Date | string | null
    nextRevisionDate?: Date | string | null
    currentVersion?: string | null
    documentLink?: string | null
    description?: string | null
    tags?: DocumentsCreatetagsInput | string[]
    documentState?: string | null
    system?: DocumentsCreatesystemInput | string[]
    section?: string | null
    revertComment?: string | null
    docType?: string | null
    documentClassification?: string | null
    issueNumber?: string | null
    retireComment?: string | null
    revisionReminderFlag?: boolean | null
    isVersion?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedDate?: Date | string | null
    countNumber?: number | null
    createdBy?: string | null
    distributionList?: string | null
    documentId?: string | null
    reviewers?: DocumentsCreatereviewersInput | string[]
    approvers?: DocumentsCreateapproversInput | string[]
    creators?: DocumentsCreatecreatorsInput | string[]
    distributionUsers?: DocumentsCreatedistributionUsersInput | InputJsonValue[]
    readAccess?: string | null
    readAccessUsers?: DocumentsCreatereadAccessUsersInput | InputJsonValue[]
    versionInfo?: DocumentsCreateversionInfoInput | InputJsonValue[]
    doctype?: DoctypeCreateNestedOneWithoutDocumentsInput
    creatorLocation?: LocationCreateNestedOneWithoutDocumentsInput
    creatorEntity?: EntityCreateNestedOneWithoutDocumentsInput
    ReferenceDocuments?: ReferenceDocumentsCreateNestedManyWithoutDocumentInput
    DocumentVersions?: DocumentVersionsCreateNestedManyWithoutDocumentInput
    DocumentComments?: DocumentCommentsCreateNestedManyWithoutDocumentInput
    DocumentWorkFlowHistory?: DocumentWorkFlowHistoryCreateNestedManyWithoutDocumentInput
    AdditionalDocumentAdmins?: AdditionalDocumentAdminsCreateNestedManyWithoutDocumentInput
    VersionReferenceDocuments?: VersionReferenceDocumentsCreateNestedManyWithoutDocumentsInput
  }

  export type DocumentsUncheckedCreateWithoutOrganizationInput = {
    id?: string
    doctypeId?: string | null
    documentName?: string | null
    documentNumbering?: string | null
    reasonOfCreation?: string | null
    effectiveDate?: Date | string | null
    nextRevisionDate?: Date | string | null
    currentVersion?: string | null
    documentLink?: string | null
    description?: string | null
    tags?: DocumentsCreatetagsInput | string[]
    documentState?: string | null
    locationId: string
    entityId?: string | null
    system?: DocumentsCreatesystemInput | string[]
    section?: string | null
    revertComment?: string | null
    docType?: string | null
    documentClassification?: string | null
    issueNumber?: string | null
    retireComment?: string | null
    revisionReminderFlag?: boolean | null
    isVersion?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedDate?: Date | string | null
    countNumber?: number | null
    createdBy?: string | null
    distributionList?: string | null
    documentId?: string | null
    reviewers?: DocumentsCreatereviewersInput | string[]
    approvers?: DocumentsCreateapproversInput | string[]
    creators?: DocumentsCreatecreatorsInput | string[]
    distributionUsers?: DocumentsCreatedistributionUsersInput | InputJsonValue[]
    readAccess?: string | null
    readAccessUsers?: DocumentsCreatereadAccessUsersInput | InputJsonValue[]
    versionInfo?: DocumentsCreateversionInfoInput | InputJsonValue[]
    ReferenceDocuments?: ReferenceDocumentsUncheckedCreateNestedManyWithoutDocumentInput
    DocumentVersions?: DocumentVersionsUncheckedCreateNestedManyWithoutDocumentInput
    DocumentComments?: DocumentCommentsUncheckedCreateNestedManyWithoutDocumentInput
    DocumentWorkFlowHistory?: DocumentWorkFlowHistoryUncheckedCreateNestedManyWithoutDocumentInput
    AdditionalDocumentAdmins?: AdditionalDocumentAdminsUncheckedCreateNestedManyWithoutDocumentInput
    VersionReferenceDocuments?: VersionReferenceDocumentsUncheckedCreateNestedManyWithoutDocumentsInput
  }

  export type DocumentsCreateOrConnectWithoutOrganizationInput = {
    where: DocumentsWhereUniqueInput
    create: XOR<DocumentsCreateWithoutOrganizationInput, DocumentsUncheckedCreateWithoutOrganizationInput>
  }

  export type DocumentsCreateManyOrganizationInputEnvelope = {
    data: DocumentsCreateManyOrganizationInput | DocumentsCreateManyOrganizationInput[]
  }

  export type EntityCreateWithoutOrganizationInput = {
    id?: string
    entityName?: string | null
    description?: string | null
    createdBy?: string | null
    entityId?: string | null
    deleted?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedBy?: string | null
    users?: EntityCreateusersInput | string[]
    sections?: EntityCreatesectionsInput | string[]
    entityType?: EntityTypeCreateNestedOneWithoutEntityInput
    location?: LocationCreateNestedOneWithoutEntityInput
    Doctype?: DoctypeCreateNestedManyWithoutEntityInput
    Documents?: DocumentsCreateNestedManyWithoutCreatorEntityInput
    user?: UserCreateNestedManyWithoutEntityInput
    parts?: PartsCreateNestedManyWithoutEntityInput
    claimToEntity?: ClaimToEntityCreateNestedManyWithoutEntityInput
    function?: FunctionsCreateNestedOneWithoutEntityInput
  }

  export type EntityUncheckedCreateWithoutOrganizationInput = {
    id?: string
    entityName?: string | null
    description?: string | null
    entityTypeId?: string | null
    locationId?: string | null
    createdBy?: string | null
    entityId?: string | null
    deleted?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedBy?: string | null
    users?: EntityCreateusersInput | string[]
    sections?: EntityCreatesectionsInput | string[]
    functionId?: string | null
    Doctype?: DoctypeUncheckedCreateNestedManyWithoutEntityInput
    Documents?: DocumentsUncheckedCreateNestedManyWithoutCreatorEntityInput
    user?: UserUncheckedCreateNestedManyWithoutEntityInput
    parts?: PartsUncheckedCreateNestedManyWithoutEntityInput
    claimToEntity?: ClaimToEntityUncheckedCreateNestedManyWithoutEntityInput
  }

  export type EntityCreateOrConnectWithoutOrganizationInput = {
    where: EntityWhereUniqueInput
    create: XOR<EntityCreateWithoutOrganizationInput, EntityUncheckedCreateWithoutOrganizationInput>
  }

  export type EntityCreateManyOrganizationInputEnvelope = {
    data: EntityCreateManyOrganizationInput | EntityCreateManyOrganizationInput[]
  }

  export type EntityTypeCreateWithoutOrganizationInput = {
    id?: string
    name?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    deleted?: boolean | null
    entity?: EntityCreateNestedManyWithoutEntityTypeInput
  }

  export type EntityTypeUncheckedCreateWithoutOrganizationInput = {
    id?: string
    name?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    deleted?: boolean | null
    entity?: EntityUncheckedCreateNestedManyWithoutEntityTypeInput
  }

  export type EntityTypeCreateOrConnectWithoutOrganizationInput = {
    where: EntityTypeWhereUniqueInput
    create: XOR<EntityTypeCreateWithoutOrganizationInput, EntityTypeUncheckedCreateWithoutOrganizationInput>
  }

  export type EntityTypeCreateManyOrganizationInputEnvelope = {
    data: EntityTypeCreateManyOrganizationInput | EntityTypeCreateManyOrganizationInput[]
  }

  export type LocationCreateWithoutOrganizationInput = {
    id?: string
    locationName?: string | null
    locationType?: string | null
    locationId?: string | null
    description?: string | null
    status?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedBy?: string | null
    functionId?: LocationCreatefunctionIdInput | string[]
    deleted?: boolean | null
    users?: LocationCreateusersInput | InputJsonValue[]
    businessTypeId?: string | null
    type?: string | null
    Documents?: DocumentsCreateNestedManyWithoutCreatorLocationInput
    entity?: EntityCreateNestedManyWithoutLocationInput
    business?: LocationBusinessCreateNestedManyWithoutLocationInput
    user?: UserCreateNestedManyWithoutLocationInput
    uom?: unitTypeCreateNestedManyWithoutLocationInput
    rolesTable?: rolesTableCreateNestedManyWithoutLocationInput
    Role?: RoleCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateWithoutOrganizationInput = {
    id?: string
    locationName?: string | null
    locationType?: string | null
    locationId?: string | null
    description?: string | null
    status?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedBy?: string | null
    functionId?: LocationCreatefunctionIdInput | string[]
    deleted?: boolean | null
    users?: LocationCreateusersInput | InputJsonValue[]
    businessTypeId?: string | null
    type?: string | null
    Documents?: DocumentsUncheckedCreateNestedManyWithoutCreatorLocationInput
    entity?: EntityUncheckedCreateNestedManyWithoutLocationInput
    business?: LocationBusinessUncheckedCreateNestedManyWithoutLocationInput
    user?: UserUncheckedCreateNestedManyWithoutLocationInput
    uom?: unitTypeUncheckedCreateNestedManyWithoutLocationInput
    rolesTable?: rolesTableUncheckedCreateNestedManyWithoutLocationInput
    Role?: RoleUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationCreateOrConnectWithoutOrganizationInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutOrganizationInput, LocationUncheckedCreateWithoutOrganizationInput>
  }

  export type LocationCreateManyOrganizationInputEnvelope = {
    data: LocationCreateManyOrganizationInput | LocationCreateManyOrganizationInput[]
  }

  export type RoleCreateWithoutOrganizationInput = {
    id?: string
    kcId?: string | null
    roleName?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    deleted?: boolean | null
    Location?: LocationCreateNestedOneWithoutRoleInput
  }

  export type RoleUncheckedCreateWithoutOrganizationInput = {
    id?: string
    kcId?: string | null
    roleName?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    deleted?: boolean | null
    locationId?: string | null
  }

  export type RoleCreateOrConnectWithoutOrganizationInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutOrganizationInput, RoleUncheckedCreateWithoutOrganizationInput>
  }

  export type RoleCreateManyOrganizationInputEnvelope = {
    data: RoleCreateManyOrganizationInput | RoleCreateManyOrganizationInput[]
  }

  export type SectionCreateWithoutOrganizationInput = {
    id?: string
    name?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    deleted?: boolean | null
  }

  export type SectionUncheckedCreateWithoutOrganizationInput = {
    id?: string
    name?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    deleted?: boolean | null
  }

  export type SectionCreateOrConnectWithoutOrganizationInput = {
    where: SectionWhereUniqueInput
    create: XOR<SectionCreateWithoutOrganizationInput, SectionUncheckedCreateWithoutOrganizationInput>
  }

  export type SectionCreateManyOrganizationInputEnvelope = {
    data: SectionCreateManyOrganizationInput | SectionCreateManyOrganizationInput[]
  }

  export type SystemTypeCreateWithoutOrganizationInput = {
    id?: string
    name?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    color?: string | null
    updatedBy?: string | null
    deleted?: boolean | null
  }

  export type SystemTypeUncheckedCreateWithoutOrganizationInput = {
    id?: string
    name?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    color?: string | null
    updatedBy?: string | null
    deleted?: boolean | null
  }

  export type SystemTypeCreateOrConnectWithoutOrganizationInput = {
    where: SystemTypeWhereUniqueInput
    create: XOR<SystemTypeCreateWithoutOrganizationInput, SystemTypeUncheckedCreateWithoutOrganizationInput>
  }

  export type SystemTypeCreateManyOrganizationInputEnvelope = {
    data: SystemTypeCreateManyOrganizationInput | SystemTypeCreateManyOrganizationInput[]
  }

  export type UserCreateWithoutOrganizationInput = {
    id?: string
    kcId?: string | null
    email?: string | null
    username?: string | null
    firstname?: string | null
    lastname?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    enabled?: boolean | null
    userType?: string | null
    status?: boolean | null
    avatar?: string | null
    deleted?: boolean | null
    roleId?: UserCreateroleIdInput | string[]
    functionId?: InputJsonValue | null
    additionalUnits?: UserCreateadditionalUnitsInput | string[]
    entity?: EntityCreateNestedOneWithoutUserInput
    location?: LocationCreateNestedOneWithoutUserInput
    AdditionalDocumentAdmins?: AdditionalDocumentAdminsCreateNestedManyWithoutUserInput
    DocumentComments?: DocumentCommentsCreateNestedManyWithoutUserInput
    DocumentVersions?: DocumentVersionsCreateNestedManyWithoutUserInput
    DocumentWorkFlowHistory?: DocumentWorkFlowHistoryCreateNestedManyWithoutUserInput
    Logs?: LogsCreateNestedManyWithoutUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
    documentAdmins?: documentAdminsCreateNestedManyWithoutUserInput
    userPersonalisation?: userPersonalisationCreateNestedManyWithoutUserInput
    auditTrial?: auditTrialCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOrganizationInput = {
    id?: string
    kcId?: string | null
    email?: string | null
    username?: string | null
    firstname?: string | null
    lastname?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    enabled?: boolean | null
    locationId?: string | null
    entityId?: string | null
    userType?: string | null
    status?: boolean | null
    avatar?: string | null
    deleted?: boolean | null
    roleId?: UserCreateroleIdInput | string[]
    functionId?: InputJsonValue | null
    additionalUnits?: UserCreateadditionalUnitsInput | string[]
    AdditionalDocumentAdmins?: AdditionalDocumentAdminsUncheckedCreateNestedManyWithoutUserInput
    DocumentComments?: DocumentCommentsUncheckedCreateNestedManyWithoutUserInput
    DocumentVersions?: DocumentVersionsUncheckedCreateNestedManyWithoutUserInput
    DocumentWorkFlowHistory?: DocumentWorkFlowHistoryUncheckedCreateNestedManyWithoutUserInput
    Logs?: LogsUncheckedCreateNestedManyWithoutUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    documentAdmins?: documentAdminsUncheckedCreateNestedManyWithoutUserInput
    userPersonalisation?: userPersonalisationUncheckedCreateNestedManyWithoutUserInput
    auditTrial?: auditTrialUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOrganizationInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOrganizationInput, UserUncheckedCreateWithoutOrganizationInput>
  }

  export type UserCreateManyOrganizationInputEnvelope = {
    data: UserCreateManyOrganizationInput | UserCreateManyOrganizationInput[]
  }

  export type userPersonalisationCreateWithoutOrganizationInput = {
    id?: string
    targetObject: string
    targetObjectId?: userPersonalisationCreatetargetObjectIdInput | string[]
    user: UserCreateNestedOneWithoutUserPersonalisationInput
  }

  export type userPersonalisationUncheckedCreateWithoutOrganizationInput = {
    id?: string
    userId: string
    targetObject: string
    targetObjectId?: userPersonalisationCreatetargetObjectIdInput | string[]
  }

  export type userPersonalisationCreateOrConnectWithoutOrganizationInput = {
    where: userPersonalisationWhereUniqueInput
    create: XOR<userPersonalisationCreateWithoutOrganizationInput, userPersonalisationUncheckedCreateWithoutOrganizationInput>
  }

  export type userPersonalisationCreateManyOrganizationInputEnvelope = {
    data: userPersonalisationCreateManyOrganizationInput | userPersonalisationCreateManyOrganizationInput[]
  }

  export type ConnectedAppsCreateWithoutOrganizationInput = {
    id?: string
    sourceName: string
    clientId: string
    clientSecret: string
    baseURL: string
    user?: string | null
    password?: string | null
    redirectURL?: string | null
    grantType?: string | null
    description: string
    deleted?: boolean | null
    createdModifiedBy: string
    createdModifiedAt?: Date | string
    locationId?: ConnectedAppsCreatelocationIdInput | string[]
    Status: boolean
    uom?: unitTypeCreateNestedManyWithoutConnectedAppsInput
    kpi?: kpiCreateNestedManyWithoutConnectedAppsInput
  }

  export type ConnectedAppsUncheckedCreateWithoutOrganizationInput = {
    id?: string
    sourceName: string
    clientId: string
    clientSecret: string
    baseURL: string
    user?: string | null
    password?: string | null
    redirectURL?: string | null
    grantType?: string | null
    description: string
    deleted?: boolean | null
    createdModifiedBy: string
    createdModifiedAt?: Date | string
    locationId?: ConnectedAppsCreatelocationIdInput | string[]
    Status: boolean
    uom?: unitTypeUncheckedCreateNestedManyWithoutConnectedAppsInput
    kpi?: kpiUncheckedCreateNestedManyWithoutConnectedAppsInput
  }

  export type ConnectedAppsCreateOrConnectWithoutOrganizationInput = {
    where: ConnectedAppsWhereUniqueInput
    create: XOR<ConnectedAppsCreateWithoutOrganizationInput, ConnectedAppsUncheckedCreateWithoutOrganizationInput>
  }

  export type ConnectedAppsCreateManyOrganizationInputEnvelope = {
    data: ConnectedAppsCreateManyOrganizationInput | ConnectedAppsCreateManyOrganizationInput[]
  }

  export type unitTypeCreateWithoutOrganizationInput = {
    id?: string
    unitType: string
    unitOfMeasurement?: unitTypeCreateunitOfMeasurementInput | string[]
    deleted?: boolean | null
    createdModifiedBy: string
    createdModifiedAt?: Date | string
    kpi?: kpiCreateNestedManyWithoutUnitTypeInput
    location?: LocationCreateNestedOneWithoutUomInput
    ConnectedApps?: ConnectedAppsCreateNestedOneWithoutUomInput
  }

  export type unitTypeUncheckedCreateWithoutOrganizationInput = {
    id?: string
    unitType: string
    unitOfMeasurement?: unitTypeCreateunitOfMeasurementInput | string[]
    locationId?: string | null
    deleted?: boolean | null
    createdModifiedBy: string
    createdModifiedAt?: Date | string
    connectedAppsId?: string | null
    kpi?: kpiUncheckedCreateNestedManyWithoutUnitTypeInput
  }

  export type unitTypeCreateOrConnectWithoutOrganizationInput = {
    where: unitTypeWhereUniqueInput
    create: XOR<unitTypeCreateWithoutOrganizationInput, unitTypeUncheckedCreateWithoutOrganizationInput>
  }

  export type unitTypeCreateManyOrganizationInputEnvelope = {
    data: unitTypeCreateManyOrganizationInput | unitTypeCreateManyOrganizationInput[]
  }

  export type kpiCreateWithoutOrganizationInput = {
    id?: string
    kpiName: string
    kpiType?: string | null
    keyFields?: kpiCreatekeyFieldsInput | string[]
    uom: string
    status: boolean
    apiEndPoint?: string | null
    kpiDescription?: string | null
    kpiTargetType?: boolean | null
    locationId?: kpiCreatelocationIdInput | string[]
    createdModifiedBy: string
    createdModifiedAt?: Date | string
    unitType?: unitTypeCreateNestedOneWithoutKpiInput
    ConnectedApps?: ConnectedAppsCreateNestedOneWithoutKpiInput
  }

  export type kpiUncheckedCreateWithoutOrganizationInput = {
    id?: string
    kpiName: string
    kpiType?: string | null
    keyFields?: kpiCreatekeyFieldsInput | string[]
    unitTypeId?: string | null
    uom: string
    sourceId?: string | null
    status: boolean
    apiEndPoint?: string | null
    kpiDescription?: string | null
    kpiTargetType?: boolean | null
    locationId?: kpiCreatelocationIdInput | string[]
    createdModifiedBy: string
    createdModifiedAt?: Date | string
  }

  export type kpiCreateOrConnectWithoutOrganizationInput = {
    where: kpiWhereUniqueInput
    create: XOR<kpiCreateWithoutOrganizationInput, kpiUncheckedCreateWithoutOrganizationInput>
  }

  export type kpiCreateManyOrganizationInputEnvelope = {
    data: kpiCreateManyOrganizationInput | kpiCreateManyOrganizationInput[]
  }

  export type businessTypeCreateWithoutOrganizationInput = {
    id?: string
    name?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    deleted?: boolean | null
  }

  export type businessTypeUncheckedCreateWithoutOrganizationInput = {
    id?: string
    name?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    deleted?: boolean | null
  }

  export type businessTypeCreateOrConnectWithoutOrganizationInput = {
    where: businessTypeWhereUniqueInput
    create: XOR<businessTypeCreateWithoutOrganizationInput, businessTypeUncheckedCreateWithoutOrganizationInput>
  }

  export type businessTypeCreateManyOrganizationInputEnvelope = {
    data: businessTypeCreateManyOrganizationInput | businessTypeCreateManyOrganizationInput[]
  }

  export type prefixSuffixCreateWithoutOrganizationInput = {
    id?: string
    prefix?: string | null
    suffix?: string | null
    moduleType?: string | null
    location?: string | null
    createdBy?: string | null
    createdAt?: Date | string
  }

  export type prefixSuffixUncheckedCreateWithoutOrganizationInput = {
    id?: string
    prefix?: string | null
    suffix?: string | null
    moduleType?: string | null
    location?: string | null
    createdBy?: string | null
    createdAt?: Date | string
  }

  export type prefixSuffixCreateOrConnectWithoutOrganizationInput = {
    where: prefixSuffixWhereUniqueInput
    create: XOR<prefixSuffixCreateWithoutOrganizationInput, prefixSuffixUncheckedCreateWithoutOrganizationInput>
  }

  export type prefixSuffixCreateManyOrganizationInputEnvelope = {
    data: prefixSuffixCreateManyOrganizationInput | prefixSuffixCreateManyOrganizationInput[]
  }

  export type serialNumberCreateWithoutOrganizationInput = {
    id?: string
    moduleType?: string | null
    location?: string | null
    entity?: string | null
    year?: string | null
    tid?: string | null
    serialNumber?: number
    createdBy?: string | null
    createdAt?: Date | string
  }

  export type serialNumberUncheckedCreateWithoutOrganizationInput = {
    id?: string
    moduleType?: string | null
    location?: string | null
    entity?: string | null
    year?: string | null
    tid?: string | null
    serialNumber?: number
    createdBy?: string | null
    createdAt?: Date | string
  }

  export type serialNumberCreateOrConnectWithoutOrganizationInput = {
    where: serialNumberWhereUniqueInput
    create: XOR<serialNumberCreateWithoutOrganizationInput, serialNumberUncheckedCreateWithoutOrganizationInput>
  }

  export type serialNumberCreateManyOrganizationInputEnvelope = {
    data: serialNumberCreateManyOrganizationInput | serialNumberCreateManyOrganizationInput[]
  }

  export type FunctionsCreateWithoutOrganizationInput = {
    id?: string
    name?: string | null
    functionId?: string | null
    description?: string | null
    functionHead?: FunctionsCreatefunctionHeadInput | string[]
    functionSpoc?: FunctionsCreatefunctionSpocInput | string[]
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    deleted?: boolean | null
    type?: boolean
    locationId?: FunctionsCreatelocationIdInput | string[]
    businessId?: FunctionsCreatebusinessIdInput | string[]
    unitId?: string | null
    entity?: EntityCreateNestedManyWithoutFunctionInput
  }

  export type FunctionsUncheckedCreateWithoutOrganizationInput = {
    id?: string
    name?: string | null
    functionId?: string | null
    description?: string | null
    functionHead?: FunctionsCreatefunctionHeadInput | string[]
    functionSpoc?: FunctionsCreatefunctionSpocInput | string[]
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    deleted?: boolean | null
    type?: boolean
    locationId?: FunctionsCreatelocationIdInput | string[]
    businessId?: FunctionsCreatebusinessIdInput | string[]
    unitId?: string | null
    entity?: EntityUncheckedCreateNestedManyWithoutFunctionInput
  }

  export type FunctionsCreateOrConnectWithoutOrganizationInput = {
    where: FunctionsWhereUniqueInput
    create: XOR<FunctionsCreateWithoutOrganizationInput, FunctionsUncheckedCreateWithoutOrganizationInput>
  }

  export type FunctionsCreateManyOrganizationInputEnvelope = {
    data: FunctionsCreateManyOrganizationInput | FunctionsCreateManyOrganizationInput[]
  }

  export type rolesTableCreateWithoutOrganizationInput = {
    id?: string
    users?: rolesTableCreateusersInput | string[]
    roleId?: rolesTableCreateroleIdInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    location: LocationCreateNestedOneWithoutRolesTableInput
  }

  export type rolesTableUncheckedCreateWithoutOrganizationInput = {
    id?: string
    unitId: string
    users?: rolesTableCreateusersInput | string[]
    roleId?: rolesTableCreateroleIdInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type rolesTableCreateOrConnectWithoutOrganizationInput = {
    where: rolesTableWhereUniqueInput
    create: XOR<rolesTableCreateWithoutOrganizationInput, rolesTableUncheckedCreateWithoutOrganizationInput>
  }

  export type rolesTableCreateManyOrganizationInputEnvelope = {
    data: rolesTableCreateManyOrganizationInput | rolesTableCreateManyOrganizationInput[]
  }

  export type ProblemCreateWithoutOrganizationInput = {
    id?: string
    problem: string
    createdAt: string
    investigations?: InvestigationCreateNestedManyWithoutProblemInput
    claim?: ClaimCreateNestedManyWithoutProblemInput
  }

  export type ProblemUncheckedCreateWithoutOrganizationInput = {
    id?: string
    problem: string
    createdAt: string
    investigations?: InvestigationUncheckedCreateNestedManyWithoutProblemInput
    claim?: ClaimUncheckedCreateNestedManyWithoutProblemInput
  }

  export type ProblemCreateOrConnectWithoutOrganizationInput = {
    where: ProblemWhereUniqueInput
    create: XOR<ProblemCreateWithoutOrganizationInput, ProblemUncheckedCreateWithoutOrganizationInput>
  }

  export type ProblemCreateManyOrganizationInputEnvelope = {
    data: ProblemCreateManyOrganizationInput | ProblemCreateManyOrganizationInput[]
  }

  export type PartsCreateWithoutOrganizationInput = {
    id?: string
    partNo: string
    partName: string
    description?: string | null
    claimId?: PartsCreateclaimIdInput | string[]
    claims?: ClaimCreateNestedManyWithoutPartsInput
    entity?: EntityCreateNestedOneWithoutPartsInput
    models?: ModelsCreateNestedManyWithoutPartsInput
  }

  export type PartsUncheckedCreateWithoutOrganizationInput = {
    id?: string
    partNo: string
    partName: string
    description?: string | null
    entityId?: string | null
    claimId?: PartsCreateclaimIdInput | string[]
    modelsId?: PartsCreatemodelsIdInput | string[]
    claims?: ClaimUncheckedCreateNestedManyWithoutPartsInput
    models?: ModelsUncheckedCreateNestedManyWithoutPartsInput
  }

  export type PartsCreateOrConnectWithoutOrganizationInput = {
    where: PartsWhereUniqueInput
    create: XOR<PartsCreateWithoutOrganizationInput, PartsUncheckedCreateWithoutOrganizationInput>
  }

  export type PartsCreateManyOrganizationInputEnvelope = {
    data: PartsCreateManyOrganizationInput | PartsCreateManyOrganizationInput[]
  }

  export type ModelsCreateWithoutOrganizationInput = {
    id?: string
    modelNo: string
    modelName: string
    description?: string | null
    claimId?: ModelsCreateclaimIdInput | string[]
    claims?: ClaimCreateNestedManyWithoutModelsInput
    Parts?: PartsCreateNestedManyWithoutModelsInput
  }

  export type ModelsUncheckedCreateWithoutOrganizationInput = {
    id?: string
    modelNo: string
    modelName: string
    description?: string | null
    partsId?: ModelsCreatepartsIdInput | string[]
    claimId?: ModelsCreateclaimIdInput | string[]
    claims?: ClaimUncheckedCreateNestedManyWithoutModelsInput
    Parts?: PartsUncheckedCreateNestedManyWithoutModelsInput
  }

  export type ModelsCreateOrConnectWithoutOrganizationInput = {
    where: ModelsWhereUniqueInput
    create: XOR<ModelsCreateWithoutOrganizationInput, ModelsUncheckedCreateWithoutOrganizationInput>
  }

  export type ModelsCreateManyOrganizationInputEnvelope = {
    data: ModelsCreateManyOrganizationInput | ModelsCreateManyOrganizationInput[]
  }

  export type BusinessUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: BusinessWhereUniqueInput
    update: XOR<BusinessUpdateWithoutOrganizationInput, BusinessUncheckedUpdateWithoutOrganizationInput>
    create: XOR<BusinessCreateWithoutOrganizationInput, BusinessUncheckedCreateWithoutOrganizationInput>
  }

  export type BusinessUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: BusinessWhereUniqueInput
    data: XOR<BusinessUpdateWithoutOrganizationInput, BusinessUncheckedUpdateWithoutOrganizationInput>
  }

  export type BusinessUpdateManyWithWhereWithoutOrganizationInput = {
    where: BusinessScalarWhereInput
    data: XOR<BusinessUpdateManyMutationInput, BusinessUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type BusinessScalarWhereInput = {
    AND?: BusinessScalarWhereInput | BusinessScalarWhereInput[]
    OR?: BusinessScalarWhereInput[]
    NOT?: BusinessScalarWhereInput | BusinessScalarWhereInput[]
    id?: StringFilter<"Business"> | string
    name?: StringNullableFilter<"Business"> | string | null
    createdAt?: DateTimeFilter<"Business"> | Date | string
    createdBy?: StringNullableFilter<"Business"> | string | null
    updatedAt?: DateTimeFilter<"Business"> | Date | string
    updatedBy?: StringNullableFilter<"Business"> | string | null
    organizationId?: StringNullableFilter<"Business"> | string | null
    deleted?: BoolNullableFilter<"Business"> | boolean | null
  }

  export type DoctypeUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: DoctypeWhereUniqueInput
    update: XOR<DoctypeUpdateWithoutOrganizationInput, DoctypeUncheckedUpdateWithoutOrganizationInput>
    create: XOR<DoctypeCreateWithoutOrganizationInput, DoctypeUncheckedCreateWithoutOrganizationInput>
  }

  export type DoctypeUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: DoctypeWhereUniqueInput
    data: XOR<DoctypeUpdateWithoutOrganizationInput, DoctypeUncheckedUpdateWithoutOrganizationInput>
  }

  export type DoctypeUpdateManyWithWhereWithoutOrganizationInput = {
    where: DoctypeScalarWhereInput
    data: XOR<DoctypeUpdateManyMutationInput, DoctypeUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type DoctypeScalarWhereInput = {
    AND?: DoctypeScalarWhereInput | DoctypeScalarWhereInput[]
    OR?: DoctypeScalarWhereInput[]
    NOT?: DoctypeScalarWhereInput | DoctypeScalarWhereInput[]
    id?: StringFilter<"Doctype"> | string
    locationId?: StringNullableListFilter<"Doctype">
    documentTypeName?: StringNullableFilter<"Doctype"> | string | null
    documentNumbering?: StringNullableFilter<"Doctype"> | string | null
    reviewFrequency?: IntNullableFilter<"Doctype"> | number | null
    revisionRemind?: IntNullableFilter<"Doctype"> | number | null
    prefix?: StringNullableFilter<"Doctype"> | string | null
    suffix?: StringNullableFilter<"Doctype"> | string | null
    organizationId?: StringNullableFilter<"Doctype"> | string | null
    readAccess?: StringNullableFilter<"Doctype"> | string | null
    readAccessUsers?: JsonNullableListFilter<"Doctype">
    createdAt?: DateTimeFilter<"Doctype"> | Date | string
    updatedAt?: DateTimeFilter<"Doctype"> | Date | string
    updatedBy?: StringNullableFilter<"Doctype"> | string | null
    createdBy?: StringNullableFilter<"Doctype"> | string | null
    applicable_systems?: JsonNullableListFilter<"Doctype">
    users?: JsonNullableListFilter<"Doctype">
    document_classification?: StringNullableFilter<"Doctype"> | string | null
    entityId?: StringNullableFilter<"Doctype"> | string | null
    distributionUsers?: JsonNullableListFilter<"Doctype">
    currentVersion?: StringFilter<"Doctype"> | string
    distributionList?: StringNullableFilter<"Doctype"> | string | null
  }

  export type DocumentsUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: DocumentsWhereUniqueInput
    update: XOR<DocumentsUpdateWithoutOrganizationInput, DocumentsUncheckedUpdateWithoutOrganizationInput>
    create: XOR<DocumentsCreateWithoutOrganizationInput, DocumentsUncheckedCreateWithoutOrganizationInput>
  }

  export type DocumentsUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: DocumentsWhereUniqueInput
    data: XOR<DocumentsUpdateWithoutOrganizationInput, DocumentsUncheckedUpdateWithoutOrganizationInput>
  }

  export type DocumentsUpdateManyWithWhereWithoutOrganizationInput = {
    where: DocumentsScalarWhereInput
    data: XOR<DocumentsUpdateManyMutationInput, DocumentsUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type DocumentsScalarWhereInput = {
    AND?: DocumentsScalarWhereInput | DocumentsScalarWhereInput[]
    OR?: DocumentsScalarWhereInput[]
    NOT?: DocumentsScalarWhereInput | DocumentsScalarWhereInput[]
    id?: StringFilter<"Documents"> | string
    doctypeId?: StringNullableFilter<"Documents"> | string | null
    organizationId?: StringNullableFilter<"Documents"> | string | null
    documentName?: StringNullableFilter<"Documents"> | string | null
    documentNumbering?: StringNullableFilter<"Documents"> | string | null
    reasonOfCreation?: StringNullableFilter<"Documents"> | string | null
    effectiveDate?: DateTimeNullableFilter<"Documents"> | Date | string | null
    nextRevisionDate?: DateTimeNullableFilter<"Documents"> | Date | string | null
    currentVersion?: StringNullableFilter<"Documents"> | string | null
    documentLink?: StringNullableFilter<"Documents"> | string | null
    description?: StringNullableFilter<"Documents"> | string | null
    tags?: StringNullableListFilter<"Documents">
    documentState?: StringNullableFilter<"Documents"> | string | null
    locationId?: StringFilter<"Documents"> | string
    entityId?: StringNullableFilter<"Documents"> | string | null
    system?: StringNullableListFilter<"Documents">
    section?: StringNullableFilter<"Documents"> | string | null
    revertComment?: StringNullableFilter<"Documents"> | string | null
    docType?: StringNullableFilter<"Documents"> | string | null
    documentClassification?: StringNullableFilter<"Documents"> | string | null
    issueNumber?: StringNullableFilter<"Documents"> | string | null
    retireComment?: StringNullableFilter<"Documents"> | string | null
    revisionReminderFlag?: BoolNullableFilter<"Documents"> | boolean | null
    isVersion?: BoolNullableFilter<"Documents"> | boolean | null
    createdAt?: DateTimeFilter<"Documents"> | Date | string
    updatedAt?: DateTimeFilter<"Documents"> | Date | string
    approvedDate?: DateTimeNullableFilter<"Documents"> | Date | string | null
    countNumber?: IntNullableFilter<"Documents"> | number | null
    createdBy?: StringNullableFilter<"Documents"> | string | null
    distributionList?: StringNullableFilter<"Documents"> | string | null
    documentId?: StringNullableFilter<"Documents"> | string | null
    reviewers?: StringNullableListFilter<"Documents">
    approvers?: StringNullableListFilter<"Documents">
    creators?: StringNullableListFilter<"Documents">
    distributionUsers?: JsonNullableListFilter<"Documents">
    readAccess?: StringNullableFilter<"Documents"> | string | null
    readAccessUsers?: JsonNullableListFilter<"Documents">
    versionInfo?: JsonNullableListFilter<"Documents">
  }

  export type EntityUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: EntityWhereUniqueInput
    update: XOR<EntityUpdateWithoutOrganizationInput, EntityUncheckedUpdateWithoutOrganizationInput>
    create: XOR<EntityCreateWithoutOrganizationInput, EntityUncheckedCreateWithoutOrganizationInput>
  }

  export type EntityUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: EntityWhereUniqueInput
    data: XOR<EntityUpdateWithoutOrganizationInput, EntityUncheckedUpdateWithoutOrganizationInput>
  }

  export type EntityUpdateManyWithWhereWithoutOrganizationInput = {
    where: EntityScalarWhereInput
    data: XOR<EntityUpdateManyMutationInput, EntityUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type EntityScalarWhereInput = {
    AND?: EntityScalarWhereInput | EntityScalarWhereInput[]
    OR?: EntityScalarWhereInput[]
    NOT?: EntityScalarWhereInput | EntityScalarWhereInput[]
    id?: StringFilter<"Entity"> | string
    entityName?: StringNullableFilter<"Entity"> | string | null
    description?: StringNullableFilter<"Entity"> | string | null
    entityTypeId?: StringNullableFilter<"Entity"> | string | null
    organizationId?: StringNullableFilter<"Entity"> | string | null
    locationId?: StringNullableFilter<"Entity"> | string | null
    createdBy?: StringNullableFilter<"Entity"> | string | null
    entityId?: StringNullableFilter<"Entity"> | string | null
    deleted?: BoolNullableFilter<"Entity"> | boolean | null
    createdAt?: DateTimeFilter<"Entity"> | Date | string
    updatedAt?: DateTimeFilter<"Entity"> | Date | string
    updatedBy?: StringNullableFilter<"Entity"> | string | null
    users?: StringNullableListFilter<"Entity">
    sections?: StringNullableListFilter<"Entity">
    functionId?: StringNullableFilter<"Entity"> | string | null
  }

  export type EntityTypeUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: EntityTypeWhereUniqueInput
    update: XOR<EntityTypeUpdateWithoutOrganizationInput, EntityTypeUncheckedUpdateWithoutOrganizationInput>
    create: XOR<EntityTypeCreateWithoutOrganizationInput, EntityTypeUncheckedCreateWithoutOrganizationInput>
  }

  export type EntityTypeUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: EntityTypeWhereUniqueInput
    data: XOR<EntityTypeUpdateWithoutOrganizationInput, EntityTypeUncheckedUpdateWithoutOrganizationInput>
  }

  export type EntityTypeUpdateManyWithWhereWithoutOrganizationInput = {
    where: EntityTypeScalarWhereInput
    data: XOR<EntityTypeUpdateManyMutationInput, EntityTypeUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type EntityTypeScalarWhereInput = {
    AND?: EntityTypeScalarWhereInput | EntityTypeScalarWhereInput[]
    OR?: EntityTypeScalarWhereInput[]
    NOT?: EntityTypeScalarWhereInput | EntityTypeScalarWhereInput[]
    id?: StringFilter<"EntityType"> | string
    name?: StringNullableFilter<"EntityType"> | string | null
    createdAt?: DateTimeFilter<"EntityType"> | Date | string
    createdBy?: StringNullableFilter<"EntityType"> | string | null
    updatedAt?: DateTimeFilter<"EntityType"> | Date | string
    updatedBy?: StringNullableFilter<"EntityType"> | string | null
    organizationId?: StringNullableFilter<"EntityType"> | string | null
    deleted?: BoolNullableFilter<"EntityType"> | boolean | null
  }

  export type LocationUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: LocationWhereUniqueInput
    update: XOR<LocationUpdateWithoutOrganizationInput, LocationUncheckedUpdateWithoutOrganizationInput>
    create: XOR<LocationCreateWithoutOrganizationInput, LocationUncheckedCreateWithoutOrganizationInput>
  }

  export type LocationUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: LocationWhereUniqueInput
    data: XOR<LocationUpdateWithoutOrganizationInput, LocationUncheckedUpdateWithoutOrganizationInput>
  }

  export type LocationUpdateManyWithWhereWithoutOrganizationInput = {
    where: LocationScalarWhereInput
    data: XOR<LocationUpdateManyMutationInput, LocationUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type LocationScalarWhereInput = {
    AND?: LocationScalarWhereInput | LocationScalarWhereInput[]
    OR?: LocationScalarWhereInput[]
    NOT?: LocationScalarWhereInput | LocationScalarWhereInput[]
    id?: StringFilter<"Location"> | string
    locationName?: StringNullableFilter<"Location"> | string | null
    locationType?: StringNullableFilter<"Location"> | string | null
    locationId?: StringNullableFilter<"Location"> | string | null
    description?: StringNullableFilter<"Location"> | string | null
    status?: StringNullableFilter<"Location"> | string | null
    createdBy?: StringNullableFilter<"Location"> | string | null
    createdAt?: DateTimeFilter<"Location"> | Date | string
    updatedAt?: DateTimeFilter<"Location"> | Date | string
    updatedBy?: StringNullableFilter<"Location"> | string | null
    functionId?: StringNullableListFilter<"Location">
    deleted?: BoolNullableFilter<"Location"> | boolean | null
    organizationId?: StringNullableFilter<"Location"> | string | null
    users?: JsonNullableListFilter<"Location">
    businessTypeId?: StringNullableFilter<"Location"> | string | null
    type?: StringNullableFilter<"Location"> | string | null
  }

  export type RoleUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: RoleWhereUniqueInput
    update: XOR<RoleUpdateWithoutOrganizationInput, RoleUncheckedUpdateWithoutOrganizationInput>
    create: XOR<RoleCreateWithoutOrganizationInput, RoleUncheckedCreateWithoutOrganizationInput>
  }

  export type RoleUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: RoleWhereUniqueInput
    data: XOR<RoleUpdateWithoutOrganizationInput, RoleUncheckedUpdateWithoutOrganizationInput>
  }

  export type RoleUpdateManyWithWhereWithoutOrganizationInput = {
    where: RoleScalarWhereInput
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type RoleScalarWhereInput = {
    AND?: RoleScalarWhereInput | RoleScalarWhereInput[]
    OR?: RoleScalarWhereInput[]
    NOT?: RoleScalarWhereInput | RoleScalarWhereInput[]
    id?: StringFilter<"Role"> | string
    kcId?: StringNullableFilter<"Role"> | string | null
    roleName?: StringNullableFilter<"Role"> | string | null
    createdAt?: DateTimeFilter<"Role"> | Date | string
    createdBy?: StringNullableFilter<"Role"> | string | null
    updatedAt?: DateTimeFilter<"Role"> | Date | string
    updatedBy?: StringNullableFilter<"Role"> | string | null
    deleted?: BoolNullableFilter<"Role"> | boolean | null
    organizationId?: StringNullableFilter<"Role"> | string | null
    locationId?: StringNullableFilter<"Role"> | string | null
  }

  export type SectionUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: SectionWhereUniqueInput
    update: XOR<SectionUpdateWithoutOrganizationInput, SectionUncheckedUpdateWithoutOrganizationInput>
    create: XOR<SectionCreateWithoutOrganizationInput, SectionUncheckedCreateWithoutOrganizationInput>
  }

  export type SectionUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: SectionWhereUniqueInput
    data: XOR<SectionUpdateWithoutOrganizationInput, SectionUncheckedUpdateWithoutOrganizationInput>
  }

  export type SectionUpdateManyWithWhereWithoutOrganizationInput = {
    where: SectionScalarWhereInput
    data: XOR<SectionUpdateManyMutationInput, SectionUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type SectionScalarWhereInput = {
    AND?: SectionScalarWhereInput | SectionScalarWhereInput[]
    OR?: SectionScalarWhereInput[]
    NOT?: SectionScalarWhereInput | SectionScalarWhereInput[]
    id?: StringFilter<"Section"> | string
    name?: StringNullableFilter<"Section"> | string | null
    createdAt?: DateTimeFilter<"Section"> | Date | string
    createdBy?: StringNullableFilter<"Section"> | string | null
    updatedAt?: DateTimeFilter<"Section"> | Date | string
    updatedBy?: StringNullableFilter<"Section"> | string | null
    organizationId?: StringNullableFilter<"Section"> | string | null
    deleted?: BoolNullableFilter<"Section"> | boolean | null
  }

  export type SystemTypeUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: SystemTypeWhereUniqueInput
    update: XOR<SystemTypeUpdateWithoutOrganizationInput, SystemTypeUncheckedUpdateWithoutOrganizationInput>
    create: XOR<SystemTypeCreateWithoutOrganizationInput, SystemTypeUncheckedCreateWithoutOrganizationInput>
  }

  export type SystemTypeUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: SystemTypeWhereUniqueInput
    data: XOR<SystemTypeUpdateWithoutOrganizationInput, SystemTypeUncheckedUpdateWithoutOrganizationInput>
  }

  export type SystemTypeUpdateManyWithWhereWithoutOrganizationInput = {
    where: SystemTypeScalarWhereInput
    data: XOR<SystemTypeUpdateManyMutationInput, SystemTypeUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type SystemTypeScalarWhereInput = {
    AND?: SystemTypeScalarWhereInput | SystemTypeScalarWhereInput[]
    OR?: SystemTypeScalarWhereInput[]
    NOT?: SystemTypeScalarWhereInput | SystemTypeScalarWhereInput[]
    id?: StringFilter<"SystemType"> | string
    name?: StringNullableFilter<"SystemType"> | string | null
    createdAt?: DateTimeFilter<"SystemType"> | Date | string
    createdBy?: StringNullableFilter<"SystemType"> | string | null
    updatedAt?: DateTimeFilter<"SystemType"> | Date | string
    color?: StringNullableFilter<"SystemType"> | string | null
    updatedBy?: StringNullableFilter<"SystemType"> | string | null
    deleted?: BoolNullableFilter<"SystemType"> | boolean | null
    organizationId?: StringNullableFilter<"SystemType"> | string | null
  }

  export type UserUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutOrganizationInput, UserUncheckedUpdateWithoutOrganizationInput>
    create: XOR<UserCreateWithoutOrganizationInput, UserUncheckedCreateWithoutOrganizationInput>
  }

  export type UserUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutOrganizationInput, UserUncheckedUpdateWithoutOrganizationInput>
  }

  export type UserUpdateManyWithWhereWithoutOrganizationInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    kcId?: StringNullableFilter<"User"> | string | null
    email?: StringNullableFilter<"User"> | string | null
    username?: StringNullableFilter<"User"> | string | null
    firstname?: StringNullableFilter<"User"> | string | null
    lastname?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    createdBy?: StringNullableFilter<"User"> | string | null
    updatedAt?: DateTimeFilter<"User"> | Date | string
    updatedBy?: StringNullableFilter<"User"> | string | null
    enabled?: BoolNullableFilter<"User"> | boolean | null
    organizationId?: StringNullableFilter<"User"> | string | null
    locationId?: StringNullableFilter<"User"> | string | null
    entityId?: StringNullableFilter<"User"> | string | null
    userType?: StringNullableFilter<"User"> | string | null
    status?: BoolNullableFilter<"User"> | boolean | null
    avatar?: StringNullableFilter<"User"> | string | null
    deleted?: BoolNullableFilter<"User"> | boolean | null
    roleId?: StringNullableListFilter<"User">
    functionId?: JsonNullableFilter<"User">
    additionalUnits?: StringNullableListFilter<"User">
  }

  export type userPersonalisationUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: userPersonalisationWhereUniqueInput
    update: XOR<userPersonalisationUpdateWithoutOrganizationInput, userPersonalisationUncheckedUpdateWithoutOrganizationInput>
    create: XOR<userPersonalisationCreateWithoutOrganizationInput, userPersonalisationUncheckedCreateWithoutOrganizationInput>
  }

  export type userPersonalisationUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: userPersonalisationWhereUniqueInput
    data: XOR<userPersonalisationUpdateWithoutOrganizationInput, userPersonalisationUncheckedUpdateWithoutOrganizationInput>
  }

  export type userPersonalisationUpdateManyWithWhereWithoutOrganizationInput = {
    where: userPersonalisationScalarWhereInput
    data: XOR<userPersonalisationUpdateManyMutationInput, userPersonalisationUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type ConnectedAppsUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: ConnectedAppsWhereUniqueInput
    update: XOR<ConnectedAppsUpdateWithoutOrganizationInput, ConnectedAppsUncheckedUpdateWithoutOrganizationInput>
    create: XOR<ConnectedAppsCreateWithoutOrganizationInput, ConnectedAppsUncheckedCreateWithoutOrganizationInput>
  }

  export type ConnectedAppsUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: ConnectedAppsWhereUniqueInput
    data: XOR<ConnectedAppsUpdateWithoutOrganizationInput, ConnectedAppsUncheckedUpdateWithoutOrganizationInput>
  }

  export type ConnectedAppsUpdateManyWithWhereWithoutOrganizationInput = {
    where: ConnectedAppsScalarWhereInput
    data: XOR<ConnectedAppsUpdateManyMutationInput, ConnectedAppsUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type ConnectedAppsScalarWhereInput = {
    AND?: ConnectedAppsScalarWhereInput | ConnectedAppsScalarWhereInput[]
    OR?: ConnectedAppsScalarWhereInput[]
    NOT?: ConnectedAppsScalarWhereInput | ConnectedAppsScalarWhereInput[]
    id?: StringFilter<"ConnectedApps"> | string
    sourceName?: StringFilter<"ConnectedApps"> | string
    clientId?: StringFilter<"ConnectedApps"> | string
    clientSecret?: StringFilter<"ConnectedApps"> | string
    baseURL?: StringFilter<"ConnectedApps"> | string
    user?: StringNullableFilter<"ConnectedApps"> | string | null
    password?: StringNullableFilter<"ConnectedApps"> | string | null
    redirectURL?: StringNullableFilter<"ConnectedApps"> | string | null
    grantType?: StringNullableFilter<"ConnectedApps"> | string | null
    description?: StringFilter<"ConnectedApps"> | string
    deleted?: BoolNullableFilter<"ConnectedApps"> | boolean | null
    organizationId?: StringNullableFilter<"ConnectedApps"> | string | null
    createdModifiedBy?: StringFilter<"ConnectedApps"> | string
    createdModifiedAt?: DateTimeFilter<"ConnectedApps"> | Date | string
    locationId?: StringNullableListFilter<"ConnectedApps">
    Status?: BoolFilter<"ConnectedApps"> | boolean
  }

  export type unitTypeUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: unitTypeWhereUniqueInput
    update: XOR<unitTypeUpdateWithoutOrganizationInput, unitTypeUncheckedUpdateWithoutOrganizationInput>
    create: XOR<unitTypeCreateWithoutOrganizationInput, unitTypeUncheckedCreateWithoutOrganizationInput>
  }

  export type unitTypeUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: unitTypeWhereUniqueInput
    data: XOR<unitTypeUpdateWithoutOrganizationInput, unitTypeUncheckedUpdateWithoutOrganizationInput>
  }

  export type unitTypeUpdateManyWithWhereWithoutOrganizationInput = {
    where: unitTypeScalarWhereInput
    data: XOR<unitTypeUpdateManyMutationInput, unitTypeUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type unitTypeScalarWhereInput = {
    AND?: unitTypeScalarWhereInput | unitTypeScalarWhereInput[]
    OR?: unitTypeScalarWhereInput[]
    NOT?: unitTypeScalarWhereInput | unitTypeScalarWhereInput[]
    id?: StringFilter<"unitType"> | string
    unitType?: StringFilter<"unitType"> | string
    unitOfMeasurement?: StringNullableListFilter<"unitType">
    organizationId?: StringNullableFilter<"unitType"> | string | null
    locationId?: StringNullableFilter<"unitType"> | string | null
    deleted?: BoolNullableFilter<"unitType"> | boolean | null
    createdModifiedBy?: StringFilter<"unitType"> | string
    createdModifiedAt?: DateTimeFilter<"unitType"> | Date | string
    connectedAppsId?: StringNullableFilter<"unitType"> | string | null
  }

  export type kpiUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: kpiWhereUniqueInput
    update: XOR<kpiUpdateWithoutOrganizationInput, kpiUncheckedUpdateWithoutOrganizationInput>
    create: XOR<kpiCreateWithoutOrganizationInput, kpiUncheckedCreateWithoutOrganizationInput>
  }

  export type kpiUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: kpiWhereUniqueInput
    data: XOR<kpiUpdateWithoutOrganizationInput, kpiUncheckedUpdateWithoutOrganizationInput>
  }

  export type kpiUpdateManyWithWhereWithoutOrganizationInput = {
    where: kpiScalarWhereInput
    data: XOR<kpiUpdateManyMutationInput, kpiUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type kpiScalarWhereInput = {
    AND?: kpiScalarWhereInput | kpiScalarWhereInput[]
    OR?: kpiScalarWhereInput[]
    NOT?: kpiScalarWhereInput | kpiScalarWhereInput[]
    id?: StringFilter<"kpi"> | string
    kpiName?: StringFilter<"kpi"> | string
    kpiType?: StringNullableFilter<"kpi"> | string | null
    keyFields?: StringNullableListFilter<"kpi">
    unitTypeId?: StringNullableFilter<"kpi"> | string | null
    uom?: StringFilter<"kpi"> | string
    sourceId?: StringNullableFilter<"kpi"> | string | null
    status?: BoolFilter<"kpi"> | boolean
    apiEndPoint?: StringNullableFilter<"kpi"> | string | null
    kpiDescription?: StringNullableFilter<"kpi"> | string | null
    kpiTargetType?: BoolNullableFilter<"kpi"> | boolean | null
    organizationId?: StringNullableFilter<"kpi"> | string | null
    locationId?: StringNullableListFilter<"kpi">
    createdModifiedBy?: StringFilter<"kpi"> | string
    createdModifiedAt?: DateTimeFilter<"kpi"> | Date | string
  }

  export type businessTypeUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: businessTypeWhereUniqueInput
    update: XOR<businessTypeUpdateWithoutOrganizationInput, businessTypeUncheckedUpdateWithoutOrganizationInput>
    create: XOR<businessTypeCreateWithoutOrganizationInput, businessTypeUncheckedCreateWithoutOrganizationInput>
  }

  export type businessTypeUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: businessTypeWhereUniqueInput
    data: XOR<businessTypeUpdateWithoutOrganizationInput, businessTypeUncheckedUpdateWithoutOrganizationInput>
  }

  export type businessTypeUpdateManyWithWhereWithoutOrganizationInput = {
    where: businessTypeScalarWhereInput
    data: XOR<businessTypeUpdateManyMutationInput, businessTypeUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type businessTypeScalarWhereInput = {
    AND?: businessTypeScalarWhereInput | businessTypeScalarWhereInput[]
    OR?: businessTypeScalarWhereInput[]
    NOT?: businessTypeScalarWhereInput | businessTypeScalarWhereInput[]
    id?: StringFilter<"businessType"> | string
    name?: StringNullableFilter<"businessType"> | string | null
    createdAt?: DateTimeFilter<"businessType"> | Date | string
    createdBy?: StringNullableFilter<"businessType"> | string | null
    deleted?: BoolNullableFilter<"businessType"> | boolean | null
    organizationId?: StringNullableFilter<"businessType"> | string | null
  }

  export type prefixSuffixUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: prefixSuffixWhereUniqueInput
    update: XOR<prefixSuffixUpdateWithoutOrganizationInput, prefixSuffixUncheckedUpdateWithoutOrganizationInput>
    create: XOR<prefixSuffixCreateWithoutOrganizationInput, prefixSuffixUncheckedCreateWithoutOrganizationInput>
  }

  export type prefixSuffixUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: prefixSuffixWhereUniqueInput
    data: XOR<prefixSuffixUpdateWithoutOrganizationInput, prefixSuffixUncheckedUpdateWithoutOrganizationInput>
  }

  export type prefixSuffixUpdateManyWithWhereWithoutOrganizationInput = {
    where: prefixSuffixScalarWhereInput
    data: XOR<prefixSuffixUpdateManyMutationInput, prefixSuffixUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type prefixSuffixScalarWhereInput = {
    AND?: prefixSuffixScalarWhereInput | prefixSuffixScalarWhereInput[]
    OR?: prefixSuffixScalarWhereInput[]
    NOT?: prefixSuffixScalarWhereInput | prefixSuffixScalarWhereInput[]
    id?: StringFilter<"prefixSuffix"> | string
    prefix?: StringNullableFilter<"prefixSuffix"> | string | null
    suffix?: StringNullableFilter<"prefixSuffix"> | string | null
    moduleType?: StringNullableFilter<"prefixSuffix"> | string | null
    location?: StringNullableFilter<"prefixSuffix"> | string | null
    organizationId?: StringNullableFilter<"prefixSuffix"> | string | null
    createdBy?: StringNullableFilter<"prefixSuffix"> | string | null
    createdAt?: DateTimeFilter<"prefixSuffix"> | Date | string
  }

  export type serialNumberUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: serialNumberWhereUniqueInput
    update: XOR<serialNumberUpdateWithoutOrganizationInput, serialNumberUncheckedUpdateWithoutOrganizationInput>
    create: XOR<serialNumberCreateWithoutOrganizationInput, serialNumberUncheckedCreateWithoutOrganizationInput>
  }

  export type serialNumberUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: serialNumberWhereUniqueInput
    data: XOR<serialNumberUpdateWithoutOrganizationInput, serialNumberUncheckedUpdateWithoutOrganizationInput>
  }

  export type serialNumberUpdateManyWithWhereWithoutOrganizationInput = {
    where: serialNumberScalarWhereInput
    data: XOR<serialNumberUpdateManyMutationInput, serialNumberUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type serialNumberScalarWhereInput = {
    AND?: serialNumberScalarWhereInput | serialNumberScalarWhereInput[]
    OR?: serialNumberScalarWhereInput[]
    NOT?: serialNumberScalarWhereInput | serialNumberScalarWhereInput[]
    id?: StringFilter<"serialNumber"> | string
    moduleType?: StringNullableFilter<"serialNumber"> | string | null
    location?: StringNullableFilter<"serialNumber"> | string | null
    entity?: StringNullableFilter<"serialNumber"> | string | null
    year?: StringNullableFilter<"serialNumber"> | string | null
    tid?: StringNullableFilter<"serialNumber"> | string | null
    serialNumber?: IntFilter<"serialNumber"> | number
    createdBy?: StringNullableFilter<"serialNumber"> | string | null
    createdAt?: DateTimeFilter<"serialNumber"> | Date | string
    organizationId?: StringNullableFilter<"serialNumber"> | string | null
  }

  export type FunctionsUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: FunctionsWhereUniqueInput
    update: XOR<FunctionsUpdateWithoutOrganizationInput, FunctionsUncheckedUpdateWithoutOrganizationInput>
    create: XOR<FunctionsCreateWithoutOrganizationInput, FunctionsUncheckedCreateWithoutOrganizationInput>
  }

  export type FunctionsUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: FunctionsWhereUniqueInput
    data: XOR<FunctionsUpdateWithoutOrganizationInput, FunctionsUncheckedUpdateWithoutOrganizationInput>
  }

  export type FunctionsUpdateManyWithWhereWithoutOrganizationInput = {
    where: FunctionsScalarWhereInput
    data: XOR<FunctionsUpdateManyMutationInput, FunctionsUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type FunctionsScalarWhereInput = {
    AND?: FunctionsScalarWhereInput | FunctionsScalarWhereInput[]
    OR?: FunctionsScalarWhereInput[]
    NOT?: FunctionsScalarWhereInput | FunctionsScalarWhereInput[]
    id?: StringFilter<"Functions"> | string
    name?: StringNullableFilter<"Functions"> | string | null
    functionId?: StringNullableFilter<"Functions"> | string | null
    description?: StringNullableFilter<"Functions"> | string | null
    functionHead?: StringNullableListFilter<"Functions">
    functionSpoc?: StringNullableListFilter<"Functions">
    createdAt?: DateTimeFilter<"Functions"> | Date | string
    createdBy?: StringNullableFilter<"Functions"> | string | null
    updatedAt?: DateTimeFilter<"Functions"> | Date | string
    updatedBy?: StringNullableFilter<"Functions"> | string | null
    deleted?: BoolNullableFilter<"Functions"> | boolean | null
    organizationId?: StringNullableFilter<"Functions"> | string | null
    type?: BoolFilter<"Functions"> | boolean
    locationId?: StringNullableListFilter<"Functions">
    businessId?: StringNullableListFilter<"Functions">
    unitId?: StringNullableFilter<"Functions"> | string | null
  }

  export type rolesTableUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: rolesTableWhereUniqueInput
    update: XOR<rolesTableUpdateWithoutOrganizationInput, rolesTableUncheckedUpdateWithoutOrganizationInput>
    create: XOR<rolesTableCreateWithoutOrganizationInput, rolesTableUncheckedCreateWithoutOrganizationInput>
  }

  export type rolesTableUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: rolesTableWhereUniqueInput
    data: XOR<rolesTableUpdateWithoutOrganizationInput, rolesTableUncheckedUpdateWithoutOrganizationInput>
  }

  export type rolesTableUpdateManyWithWhereWithoutOrganizationInput = {
    where: rolesTableScalarWhereInput
    data: XOR<rolesTableUpdateManyMutationInput, rolesTableUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type rolesTableScalarWhereInput = {
    AND?: rolesTableScalarWhereInput | rolesTableScalarWhereInput[]
    OR?: rolesTableScalarWhereInput[]
    NOT?: rolesTableScalarWhereInput | rolesTableScalarWhereInput[]
    id?: StringFilter<"rolesTable"> | string
    orgId?: StringFilter<"rolesTable"> | string
    unitId?: StringFilter<"rolesTable"> | string
    users?: StringNullableListFilter<"rolesTable">
    roleId?: StringNullableListFilter<"rolesTable">
    createdAt?: DateTimeFilter<"rolesTable"> | Date | string
    updatedAt?: DateTimeFilter<"rolesTable"> | Date | string
  }

  export type ProblemUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: ProblemWhereUniqueInput
    update: XOR<ProblemUpdateWithoutOrganizationInput, ProblemUncheckedUpdateWithoutOrganizationInput>
    create: XOR<ProblemCreateWithoutOrganizationInput, ProblemUncheckedCreateWithoutOrganizationInput>
  }

  export type ProblemUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: ProblemWhereUniqueInput
    data: XOR<ProblemUpdateWithoutOrganizationInput, ProblemUncheckedUpdateWithoutOrganizationInput>
  }

  export type ProblemUpdateManyWithWhereWithoutOrganizationInput = {
    where: ProblemScalarWhereInput
    data: XOR<ProblemUpdateManyMutationInput, ProblemUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type ProblemScalarWhereInput = {
    AND?: ProblemScalarWhereInput | ProblemScalarWhereInput[]
    OR?: ProblemScalarWhereInput[]
    NOT?: ProblemScalarWhereInput | ProblemScalarWhereInput[]
    id?: StringFilter<"Problem"> | string
    problem?: StringFilter<"Problem"> | string
    createdAt?: StringFilter<"Problem"> | string
    organizationId?: StringFilter<"Problem"> | string
  }

  export type PartsUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: PartsWhereUniqueInput
    update: XOR<PartsUpdateWithoutOrganizationInput, PartsUncheckedUpdateWithoutOrganizationInput>
    create: XOR<PartsCreateWithoutOrganizationInput, PartsUncheckedCreateWithoutOrganizationInput>
  }

  export type PartsUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: PartsWhereUniqueInput
    data: XOR<PartsUpdateWithoutOrganizationInput, PartsUncheckedUpdateWithoutOrganizationInput>
  }

  export type PartsUpdateManyWithWhereWithoutOrganizationInput = {
    where: PartsScalarWhereInput
    data: XOR<PartsUpdateManyMutationInput, PartsUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type ModelsUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: ModelsWhereUniqueInput
    update: XOR<ModelsUpdateWithoutOrganizationInput, ModelsUncheckedUpdateWithoutOrganizationInput>
    create: XOR<ModelsCreateWithoutOrganizationInput, ModelsUncheckedCreateWithoutOrganizationInput>
  }

  export type ModelsUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: ModelsWhereUniqueInput
    data: XOR<ModelsUpdateWithoutOrganizationInput, ModelsUncheckedUpdateWithoutOrganizationInput>
  }

  export type ModelsUpdateManyWithWhereWithoutOrganizationInput = {
    where: ModelsScalarWhereInput
    data: XOR<ModelsUpdateManyMutationInput, ModelsUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type OrganizationCreateWithoutRoleInput = {
    id?: string
    kcId?: string | null
    organizationName?: string | null
    realmName?: string | null
    instanceUrl?: string | null
    principalGeography?: string | null
    loginUrl?: string | null
    logoutUrl?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    activeModules?: OrganizationCreateactiveModulesInput | string[]
    clientID?: string | null
    clientSecret?: string | null
    fiscalYearQuarters?: string | null
    fiscalYearFormat?: string | null
    auditYear?: string | null
    logoUrl?: string | null
    deleted?: boolean | null
    business?: BusinessCreateNestedManyWithoutOrganizationInput
    Doctype?: DoctypeCreateNestedManyWithoutOrganizationInput
    Documents?: DocumentsCreateNestedManyWithoutOrganizationInput
    entity?: EntityCreateNestedManyWithoutOrganizationInput
    entityType?: EntityTypeCreateNestedManyWithoutOrganizationInput
    location?: LocationCreateNestedManyWithoutOrganizationInput
    section?: SectionCreateNestedManyWithoutOrganizationInput
    systemType?: SystemTypeCreateNestedManyWithoutOrganizationInput
    user?: UserCreateNestedManyWithoutOrganizationInput
    userPersonalisation?: userPersonalisationCreateNestedManyWithoutOrganizationInput
    ConnectedApps?: ConnectedAppsCreateNestedManyWithoutOrganizationInput
    unitOfMeasurement?: unitTypeCreateNestedManyWithoutOrganizationInput
    kpi?: kpiCreateNestedManyWithoutOrganizationInput
    businessType?: businessTypeCreateNestedManyWithoutOrganizationInput
    prefixSuffix?: prefixSuffixCreateNestedManyWithoutOrganizationInput
    serialNumber?: serialNumberCreateNestedManyWithoutOrganizationInput
    function?: FunctionsCreateNestedManyWithoutOrganizationInput
    rolesTable?: rolesTableCreateNestedManyWithoutOrganizationInput
    problem?: ProblemCreateNestedManyWithoutOrganizationInput
    parts?: PartsCreateNestedManyWithoutOrganizationInput
    Models?: ModelsCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutRoleInput = {
    id?: string
    kcId?: string | null
    organizationName?: string | null
    realmName?: string | null
    instanceUrl?: string | null
    principalGeography?: string | null
    loginUrl?: string | null
    logoutUrl?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    activeModules?: OrganizationCreateactiveModulesInput | string[]
    clientID?: string | null
    clientSecret?: string | null
    fiscalYearQuarters?: string | null
    fiscalYearFormat?: string | null
    auditYear?: string | null
    logoUrl?: string | null
    deleted?: boolean | null
    business?: BusinessUncheckedCreateNestedManyWithoutOrganizationInput
    Doctype?: DoctypeUncheckedCreateNestedManyWithoutOrganizationInput
    Documents?: DocumentsUncheckedCreateNestedManyWithoutOrganizationInput
    entity?: EntityUncheckedCreateNestedManyWithoutOrganizationInput
    entityType?: EntityTypeUncheckedCreateNestedManyWithoutOrganizationInput
    location?: LocationUncheckedCreateNestedManyWithoutOrganizationInput
    section?: SectionUncheckedCreateNestedManyWithoutOrganizationInput
    systemType?: SystemTypeUncheckedCreateNestedManyWithoutOrganizationInput
    user?: UserUncheckedCreateNestedManyWithoutOrganizationInput
    userPersonalisation?: userPersonalisationUncheckedCreateNestedManyWithoutOrganizationInput
    ConnectedApps?: ConnectedAppsUncheckedCreateNestedManyWithoutOrganizationInput
    unitOfMeasurement?: unitTypeUncheckedCreateNestedManyWithoutOrganizationInput
    kpi?: kpiUncheckedCreateNestedManyWithoutOrganizationInput
    businessType?: businessTypeUncheckedCreateNestedManyWithoutOrganizationInput
    prefixSuffix?: prefixSuffixUncheckedCreateNestedManyWithoutOrganizationInput
    serialNumber?: serialNumberUncheckedCreateNestedManyWithoutOrganizationInput
    function?: FunctionsUncheckedCreateNestedManyWithoutOrganizationInput
    rolesTable?: rolesTableUncheckedCreateNestedManyWithoutOrganizationInput
    problem?: ProblemUncheckedCreateNestedManyWithoutOrganizationInput
    parts?: PartsUncheckedCreateNestedManyWithoutOrganizationInput
    Models?: ModelsUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutRoleInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutRoleInput, OrganizationUncheckedCreateWithoutRoleInput>
  }

  export type LocationCreateWithoutRoleInput = {
    id?: string
    locationName?: string | null
    locationType?: string | null
    locationId?: string | null
    description?: string | null
    status?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedBy?: string | null
    functionId?: LocationCreatefunctionIdInput | string[]
    deleted?: boolean | null
    users?: LocationCreateusersInput | InputJsonValue[]
    businessTypeId?: string | null
    type?: string | null
    organization?: OrganizationCreateNestedOneWithoutLocationInput
    Documents?: DocumentsCreateNestedManyWithoutCreatorLocationInput
    entity?: EntityCreateNestedManyWithoutLocationInput
    business?: LocationBusinessCreateNestedManyWithoutLocationInput
    user?: UserCreateNestedManyWithoutLocationInput
    uom?: unitTypeCreateNestedManyWithoutLocationInput
    rolesTable?: rolesTableCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateWithoutRoleInput = {
    id?: string
    locationName?: string | null
    locationType?: string | null
    locationId?: string | null
    description?: string | null
    status?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedBy?: string | null
    functionId?: LocationCreatefunctionIdInput | string[]
    deleted?: boolean | null
    organizationId?: string | null
    users?: LocationCreateusersInput | InputJsonValue[]
    businessTypeId?: string | null
    type?: string | null
    Documents?: DocumentsUncheckedCreateNestedManyWithoutCreatorLocationInput
    entity?: EntityUncheckedCreateNestedManyWithoutLocationInput
    business?: LocationBusinessUncheckedCreateNestedManyWithoutLocationInput
    user?: UserUncheckedCreateNestedManyWithoutLocationInput
    uom?: unitTypeUncheckedCreateNestedManyWithoutLocationInput
    rolesTable?: rolesTableUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationCreateOrConnectWithoutRoleInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutRoleInput, LocationUncheckedCreateWithoutRoleInput>
  }

  export type OrganizationUpsertWithoutRoleInput = {
    update: XOR<OrganizationUpdateWithoutRoleInput, OrganizationUncheckedUpdateWithoutRoleInput>
    create: XOR<OrganizationCreateWithoutRoleInput, OrganizationUncheckedCreateWithoutRoleInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutRoleInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutRoleInput, OrganizationUncheckedUpdateWithoutRoleInput>
  }

  export type OrganizationUpdateWithoutRoleInput = {
    kcId?: NullableStringFieldUpdateOperationsInput | string | null
    organizationName?: NullableStringFieldUpdateOperationsInput | string | null
    realmName?: NullableStringFieldUpdateOperationsInput | string | null
    instanceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    principalGeography?: NullableStringFieldUpdateOperationsInput | string | null
    loginUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoutUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    activeModules?: OrganizationUpdateactiveModulesInput | string[]
    clientID?: NullableStringFieldUpdateOperationsInput | string | null
    clientSecret?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearQuarters?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearFormat?: NullableStringFieldUpdateOperationsInput | string | null
    auditYear?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    business?: BusinessUpdateManyWithoutOrganizationNestedInput
    Doctype?: DoctypeUpdateManyWithoutOrganizationNestedInput
    Documents?: DocumentsUpdateManyWithoutOrganizationNestedInput
    entity?: EntityUpdateManyWithoutOrganizationNestedInput
    entityType?: EntityTypeUpdateManyWithoutOrganizationNestedInput
    location?: LocationUpdateManyWithoutOrganizationNestedInput
    section?: SectionUpdateManyWithoutOrganizationNestedInput
    systemType?: SystemTypeUpdateManyWithoutOrganizationNestedInput
    user?: UserUpdateManyWithoutOrganizationNestedInput
    userPersonalisation?: userPersonalisationUpdateManyWithoutOrganizationNestedInput
    ConnectedApps?: ConnectedAppsUpdateManyWithoutOrganizationNestedInput
    unitOfMeasurement?: unitTypeUpdateManyWithoutOrganizationNestedInput
    kpi?: kpiUpdateManyWithoutOrganizationNestedInput
    businessType?: businessTypeUpdateManyWithoutOrganizationNestedInput
    prefixSuffix?: prefixSuffixUpdateManyWithoutOrganizationNestedInput
    serialNumber?: serialNumberUpdateManyWithoutOrganizationNestedInput
    function?: FunctionsUpdateManyWithoutOrganizationNestedInput
    rolesTable?: rolesTableUpdateManyWithoutOrganizationNestedInput
    problem?: ProblemUpdateManyWithoutOrganizationNestedInput
    parts?: PartsUpdateManyWithoutOrganizationNestedInput
    Models?: ModelsUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutRoleInput = {
    kcId?: NullableStringFieldUpdateOperationsInput | string | null
    organizationName?: NullableStringFieldUpdateOperationsInput | string | null
    realmName?: NullableStringFieldUpdateOperationsInput | string | null
    instanceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    principalGeography?: NullableStringFieldUpdateOperationsInput | string | null
    loginUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoutUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    activeModules?: OrganizationUpdateactiveModulesInput | string[]
    clientID?: NullableStringFieldUpdateOperationsInput | string | null
    clientSecret?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearQuarters?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearFormat?: NullableStringFieldUpdateOperationsInput | string | null
    auditYear?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    business?: BusinessUncheckedUpdateManyWithoutOrganizationNestedInput
    Doctype?: DoctypeUncheckedUpdateManyWithoutOrganizationNestedInput
    Documents?: DocumentsUncheckedUpdateManyWithoutOrganizationNestedInput
    entity?: EntityUncheckedUpdateManyWithoutOrganizationNestedInput
    entityType?: EntityTypeUncheckedUpdateManyWithoutOrganizationNestedInput
    location?: LocationUncheckedUpdateManyWithoutOrganizationNestedInput
    section?: SectionUncheckedUpdateManyWithoutOrganizationNestedInput
    systemType?: SystemTypeUncheckedUpdateManyWithoutOrganizationNestedInput
    user?: UserUncheckedUpdateManyWithoutOrganizationNestedInput
    userPersonalisation?: userPersonalisationUncheckedUpdateManyWithoutOrganizationNestedInput
    ConnectedApps?: ConnectedAppsUncheckedUpdateManyWithoutOrganizationNestedInput
    unitOfMeasurement?: unitTypeUncheckedUpdateManyWithoutOrganizationNestedInput
    kpi?: kpiUncheckedUpdateManyWithoutOrganizationNestedInput
    businessType?: businessTypeUncheckedUpdateManyWithoutOrganizationNestedInput
    prefixSuffix?: prefixSuffixUncheckedUpdateManyWithoutOrganizationNestedInput
    serialNumber?: serialNumberUncheckedUpdateManyWithoutOrganizationNestedInput
    function?: FunctionsUncheckedUpdateManyWithoutOrganizationNestedInput
    rolesTable?: rolesTableUncheckedUpdateManyWithoutOrganizationNestedInput
    problem?: ProblemUncheckedUpdateManyWithoutOrganizationNestedInput
    parts?: PartsUncheckedUpdateManyWithoutOrganizationNestedInput
    Models?: ModelsUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type LocationUpsertWithoutRoleInput = {
    update: XOR<LocationUpdateWithoutRoleInput, LocationUncheckedUpdateWithoutRoleInput>
    create: XOR<LocationCreateWithoutRoleInput, LocationUncheckedCreateWithoutRoleInput>
    where?: LocationWhereInput
  }

  export type LocationUpdateToOneWithWhereWithoutRoleInput = {
    where?: LocationWhereInput
    data: XOR<LocationUpdateWithoutRoleInput, LocationUncheckedUpdateWithoutRoleInput>
  }

  export type LocationUpdateWithoutRoleInput = {
    locationName?: NullableStringFieldUpdateOperationsInput | string | null
    locationType?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    functionId?: LocationUpdatefunctionIdInput | string[]
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    users?: LocationUpdateusersInput | InputJsonValue[]
    businessTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: OrganizationUpdateOneWithoutLocationNestedInput
    Documents?: DocumentsUpdateManyWithoutCreatorLocationNestedInput
    entity?: EntityUpdateManyWithoutLocationNestedInput
    business?: LocationBusinessUpdateManyWithoutLocationNestedInput
    user?: UserUpdateManyWithoutLocationNestedInput
    uom?: unitTypeUpdateManyWithoutLocationNestedInput
    rolesTable?: rolesTableUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateWithoutRoleInput = {
    locationName?: NullableStringFieldUpdateOperationsInput | string | null
    locationType?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    functionId?: LocationUpdatefunctionIdInput | string[]
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    users?: LocationUpdateusersInput | InputJsonValue[]
    businessTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    Documents?: DocumentsUncheckedUpdateManyWithoutCreatorLocationNestedInput
    entity?: EntityUncheckedUpdateManyWithoutLocationNestedInput
    business?: LocationBusinessUncheckedUpdateManyWithoutLocationNestedInput
    user?: UserUncheckedUpdateManyWithoutLocationNestedInput
    uom?: unitTypeUncheckedUpdateManyWithoutLocationNestedInput
    rolesTable?: rolesTableUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type OrganizationCreateWithoutSystemTypeInput = {
    id?: string
    kcId?: string | null
    organizationName?: string | null
    realmName?: string | null
    instanceUrl?: string | null
    principalGeography?: string | null
    loginUrl?: string | null
    logoutUrl?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    activeModules?: OrganizationCreateactiveModulesInput | string[]
    clientID?: string | null
    clientSecret?: string | null
    fiscalYearQuarters?: string | null
    fiscalYearFormat?: string | null
    auditYear?: string | null
    logoUrl?: string | null
    deleted?: boolean | null
    business?: BusinessCreateNestedManyWithoutOrganizationInput
    Doctype?: DoctypeCreateNestedManyWithoutOrganizationInput
    Documents?: DocumentsCreateNestedManyWithoutOrganizationInput
    entity?: EntityCreateNestedManyWithoutOrganizationInput
    entityType?: EntityTypeCreateNestedManyWithoutOrganizationInput
    location?: LocationCreateNestedManyWithoutOrganizationInput
    role?: RoleCreateNestedManyWithoutOrganizationInput
    section?: SectionCreateNestedManyWithoutOrganizationInput
    user?: UserCreateNestedManyWithoutOrganizationInput
    userPersonalisation?: userPersonalisationCreateNestedManyWithoutOrganizationInput
    ConnectedApps?: ConnectedAppsCreateNestedManyWithoutOrganizationInput
    unitOfMeasurement?: unitTypeCreateNestedManyWithoutOrganizationInput
    kpi?: kpiCreateNestedManyWithoutOrganizationInput
    businessType?: businessTypeCreateNestedManyWithoutOrganizationInput
    prefixSuffix?: prefixSuffixCreateNestedManyWithoutOrganizationInput
    serialNumber?: serialNumberCreateNestedManyWithoutOrganizationInput
    function?: FunctionsCreateNestedManyWithoutOrganizationInput
    rolesTable?: rolesTableCreateNestedManyWithoutOrganizationInput
    problem?: ProblemCreateNestedManyWithoutOrganizationInput
    parts?: PartsCreateNestedManyWithoutOrganizationInput
    Models?: ModelsCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutSystemTypeInput = {
    id?: string
    kcId?: string | null
    organizationName?: string | null
    realmName?: string | null
    instanceUrl?: string | null
    principalGeography?: string | null
    loginUrl?: string | null
    logoutUrl?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    activeModules?: OrganizationCreateactiveModulesInput | string[]
    clientID?: string | null
    clientSecret?: string | null
    fiscalYearQuarters?: string | null
    fiscalYearFormat?: string | null
    auditYear?: string | null
    logoUrl?: string | null
    deleted?: boolean | null
    business?: BusinessUncheckedCreateNestedManyWithoutOrganizationInput
    Doctype?: DoctypeUncheckedCreateNestedManyWithoutOrganizationInput
    Documents?: DocumentsUncheckedCreateNestedManyWithoutOrganizationInput
    entity?: EntityUncheckedCreateNestedManyWithoutOrganizationInput
    entityType?: EntityTypeUncheckedCreateNestedManyWithoutOrganizationInput
    location?: LocationUncheckedCreateNestedManyWithoutOrganizationInput
    role?: RoleUncheckedCreateNestedManyWithoutOrganizationInput
    section?: SectionUncheckedCreateNestedManyWithoutOrganizationInput
    user?: UserUncheckedCreateNestedManyWithoutOrganizationInput
    userPersonalisation?: userPersonalisationUncheckedCreateNestedManyWithoutOrganizationInput
    ConnectedApps?: ConnectedAppsUncheckedCreateNestedManyWithoutOrganizationInput
    unitOfMeasurement?: unitTypeUncheckedCreateNestedManyWithoutOrganizationInput
    kpi?: kpiUncheckedCreateNestedManyWithoutOrganizationInput
    businessType?: businessTypeUncheckedCreateNestedManyWithoutOrganizationInput
    prefixSuffix?: prefixSuffixUncheckedCreateNestedManyWithoutOrganizationInput
    serialNumber?: serialNumberUncheckedCreateNestedManyWithoutOrganizationInput
    function?: FunctionsUncheckedCreateNestedManyWithoutOrganizationInput
    rolesTable?: rolesTableUncheckedCreateNestedManyWithoutOrganizationInput
    problem?: ProblemUncheckedCreateNestedManyWithoutOrganizationInput
    parts?: PartsUncheckedCreateNestedManyWithoutOrganizationInput
    Models?: ModelsUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutSystemTypeInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutSystemTypeInput, OrganizationUncheckedCreateWithoutSystemTypeInput>
  }

  export type OrganizationUpsertWithoutSystemTypeInput = {
    update: XOR<OrganizationUpdateWithoutSystemTypeInput, OrganizationUncheckedUpdateWithoutSystemTypeInput>
    create: XOR<OrganizationCreateWithoutSystemTypeInput, OrganizationUncheckedCreateWithoutSystemTypeInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutSystemTypeInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutSystemTypeInput, OrganizationUncheckedUpdateWithoutSystemTypeInput>
  }

  export type OrganizationUpdateWithoutSystemTypeInput = {
    kcId?: NullableStringFieldUpdateOperationsInput | string | null
    organizationName?: NullableStringFieldUpdateOperationsInput | string | null
    realmName?: NullableStringFieldUpdateOperationsInput | string | null
    instanceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    principalGeography?: NullableStringFieldUpdateOperationsInput | string | null
    loginUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoutUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    activeModules?: OrganizationUpdateactiveModulesInput | string[]
    clientID?: NullableStringFieldUpdateOperationsInput | string | null
    clientSecret?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearQuarters?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearFormat?: NullableStringFieldUpdateOperationsInput | string | null
    auditYear?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    business?: BusinessUpdateManyWithoutOrganizationNestedInput
    Doctype?: DoctypeUpdateManyWithoutOrganizationNestedInput
    Documents?: DocumentsUpdateManyWithoutOrganizationNestedInput
    entity?: EntityUpdateManyWithoutOrganizationNestedInput
    entityType?: EntityTypeUpdateManyWithoutOrganizationNestedInput
    location?: LocationUpdateManyWithoutOrganizationNestedInput
    role?: RoleUpdateManyWithoutOrganizationNestedInput
    section?: SectionUpdateManyWithoutOrganizationNestedInput
    user?: UserUpdateManyWithoutOrganizationNestedInput
    userPersonalisation?: userPersonalisationUpdateManyWithoutOrganizationNestedInput
    ConnectedApps?: ConnectedAppsUpdateManyWithoutOrganizationNestedInput
    unitOfMeasurement?: unitTypeUpdateManyWithoutOrganizationNestedInput
    kpi?: kpiUpdateManyWithoutOrganizationNestedInput
    businessType?: businessTypeUpdateManyWithoutOrganizationNestedInput
    prefixSuffix?: prefixSuffixUpdateManyWithoutOrganizationNestedInput
    serialNumber?: serialNumberUpdateManyWithoutOrganizationNestedInput
    function?: FunctionsUpdateManyWithoutOrganizationNestedInput
    rolesTable?: rolesTableUpdateManyWithoutOrganizationNestedInput
    problem?: ProblemUpdateManyWithoutOrganizationNestedInput
    parts?: PartsUpdateManyWithoutOrganizationNestedInput
    Models?: ModelsUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutSystemTypeInput = {
    kcId?: NullableStringFieldUpdateOperationsInput | string | null
    organizationName?: NullableStringFieldUpdateOperationsInput | string | null
    realmName?: NullableStringFieldUpdateOperationsInput | string | null
    instanceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    principalGeography?: NullableStringFieldUpdateOperationsInput | string | null
    loginUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoutUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    activeModules?: OrganizationUpdateactiveModulesInput | string[]
    clientID?: NullableStringFieldUpdateOperationsInput | string | null
    clientSecret?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearQuarters?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearFormat?: NullableStringFieldUpdateOperationsInput | string | null
    auditYear?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    business?: BusinessUncheckedUpdateManyWithoutOrganizationNestedInput
    Doctype?: DoctypeUncheckedUpdateManyWithoutOrganizationNestedInput
    Documents?: DocumentsUncheckedUpdateManyWithoutOrganizationNestedInput
    entity?: EntityUncheckedUpdateManyWithoutOrganizationNestedInput
    entityType?: EntityTypeUncheckedUpdateManyWithoutOrganizationNestedInput
    location?: LocationUncheckedUpdateManyWithoutOrganizationNestedInput
    role?: RoleUncheckedUpdateManyWithoutOrganizationNestedInput
    section?: SectionUncheckedUpdateManyWithoutOrganizationNestedInput
    user?: UserUncheckedUpdateManyWithoutOrganizationNestedInput
    userPersonalisation?: userPersonalisationUncheckedUpdateManyWithoutOrganizationNestedInput
    ConnectedApps?: ConnectedAppsUncheckedUpdateManyWithoutOrganizationNestedInput
    unitOfMeasurement?: unitTypeUncheckedUpdateManyWithoutOrganizationNestedInput
    kpi?: kpiUncheckedUpdateManyWithoutOrganizationNestedInput
    businessType?: businessTypeUncheckedUpdateManyWithoutOrganizationNestedInput
    prefixSuffix?: prefixSuffixUncheckedUpdateManyWithoutOrganizationNestedInput
    serialNumber?: serialNumberUncheckedUpdateManyWithoutOrganizationNestedInput
    function?: FunctionsUncheckedUpdateManyWithoutOrganizationNestedInput
    rolesTable?: rolesTableUncheckedUpdateManyWithoutOrganizationNestedInput
    problem?: ProblemUncheckedUpdateManyWithoutOrganizationNestedInput
    parts?: PartsUncheckedUpdateManyWithoutOrganizationNestedInput
    Models?: ModelsUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationCreateWithoutEntityTypeInput = {
    id?: string
    kcId?: string | null
    organizationName?: string | null
    realmName?: string | null
    instanceUrl?: string | null
    principalGeography?: string | null
    loginUrl?: string | null
    logoutUrl?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    activeModules?: OrganizationCreateactiveModulesInput | string[]
    clientID?: string | null
    clientSecret?: string | null
    fiscalYearQuarters?: string | null
    fiscalYearFormat?: string | null
    auditYear?: string | null
    logoUrl?: string | null
    deleted?: boolean | null
    business?: BusinessCreateNestedManyWithoutOrganizationInput
    Doctype?: DoctypeCreateNestedManyWithoutOrganizationInput
    Documents?: DocumentsCreateNestedManyWithoutOrganizationInput
    entity?: EntityCreateNestedManyWithoutOrganizationInput
    location?: LocationCreateNestedManyWithoutOrganizationInput
    role?: RoleCreateNestedManyWithoutOrganizationInput
    section?: SectionCreateNestedManyWithoutOrganizationInput
    systemType?: SystemTypeCreateNestedManyWithoutOrganizationInput
    user?: UserCreateNestedManyWithoutOrganizationInput
    userPersonalisation?: userPersonalisationCreateNestedManyWithoutOrganizationInput
    ConnectedApps?: ConnectedAppsCreateNestedManyWithoutOrganizationInput
    unitOfMeasurement?: unitTypeCreateNestedManyWithoutOrganizationInput
    kpi?: kpiCreateNestedManyWithoutOrganizationInput
    businessType?: businessTypeCreateNestedManyWithoutOrganizationInput
    prefixSuffix?: prefixSuffixCreateNestedManyWithoutOrganizationInput
    serialNumber?: serialNumberCreateNestedManyWithoutOrganizationInput
    function?: FunctionsCreateNestedManyWithoutOrganizationInput
    rolesTable?: rolesTableCreateNestedManyWithoutOrganizationInput
    problem?: ProblemCreateNestedManyWithoutOrganizationInput
    parts?: PartsCreateNestedManyWithoutOrganizationInput
    Models?: ModelsCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutEntityTypeInput = {
    id?: string
    kcId?: string | null
    organizationName?: string | null
    realmName?: string | null
    instanceUrl?: string | null
    principalGeography?: string | null
    loginUrl?: string | null
    logoutUrl?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    activeModules?: OrganizationCreateactiveModulesInput | string[]
    clientID?: string | null
    clientSecret?: string | null
    fiscalYearQuarters?: string | null
    fiscalYearFormat?: string | null
    auditYear?: string | null
    logoUrl?: string | null
    deleted?: boolean | null
    business?: BusinessUncheckedCreateNestedManyWithoutOrganizationInput
    Doctype?: DoctypeUncheckedCreateNestedManyWithoutOrganizationInput
    Documents?: DocumentsUncheckedCreateNestedManyWithoutOrganizationInput
    entity?: EntityUncheckedCreateNestedManyWithoutOrganizationInput
    location?: LocationUncheckedCreateNestedManyWithoutOrganizationInput
    role?: RoleUncheckedCreateNestedManyWithoutOrganizationInput
    section?: SectionUncheckedCreateNestedManyWithoutOrganizationInput
    systemType?: SystemTypeUncheckedCreateNestedManyWithoutOrganizationInput
    user?: UserUncheckedCreateNestedManyWithoutOrganizationInput
    userPersonalisation?: userPersonalisationUncheckedCreateNestedManyWithoutOrganizationInput
    ConnectedApps?: ConnectedAppsUncheckedCreateNestedManyWithoutOrganizationInput
    unitOfMeasurement?: unitTypeUncheckedCreateNestedManyWithoutOrganizationInput
    kpi?: kpiUncheckedCreateNestedManyWithoutOrganizationInput
    businessType?: businessTypeUncheckedCreateNestedManyWithoutOrganizationInput
    prefixSuffix?: prefixSuffixUncheckedCreateNestedManyWithoutOrganizationInput
    serialNumber?: serialNumberUncheckedCreateNestedManyWithoutOrganizationInput
    function?: FunctionsUncheckedCreateNestedManyWithoutOrganizationInput
    rolesTable?: rolesTableUncheckedCreateNestedManyWithoutOrganizationInput
    problem?: ProblemUncheckedCreateNestedManyWithoutOrganizationInput
    parts?: PartsUncheckedCreateNestedManyWithoutOrganizationInput
    Models?: ModelsUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutEntityTypeInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutEntityTypeInput, OrganizationUncheckedCreateWithoutEntityTypeInput>
  }

  export type EntityCreateWithoutEntityTypeInput = {
    id?: string
    entityName?: string | null
    description?: string | null
    createdBy?: string | null
    entityId?: string | null
    deleted?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedBy?: string | null
    users?: EntityCreateusersInput | string[]
    sections?: EntityCreatesectionsInput | string[]
    location?: LocationCreateNestedOneWithoutEntityInput
    organization?: OrganizationCreateNestedOneWithoutEntityInput
    Doctype?: DoctypeCreateNestedManyWithoutEntityInput
    Documents?: DocumentsCreateNestedManyWithoutCreatorEntityInput
    user?: UserCreateNestedManyWithoutEntityInput
    parts?: PartsCreateNestedManyWithoutEntityInput
    claimToEntity?: ClaimToEntityCreateNestedManyWithoutEntityInput
    function?: FunctionsCreateNestedOneWithoutEntityInput
  }

  export type EntityUncheckedCreateWithoutEntityTypeInput = {
    id?: string
    entityName?: string | null
    description?: string | null
    organizationId?: string | null
    locationId?: string | null
    createdBy?: string | null
    entityId?: string | null
    deleted?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedBy?: string | null
    users?: EntityCreateusersInput | string[]
    sections?: EntityCreatesectionsInput | string[]
    functionId?: string | null
    Doctype?: DoctypeUncheckedCreateNestedManyWithoutEntityInput
    Documents?: DocumentsUncheckedCreateNestedManyWithoutCreatorEntityInput
    user?: UserUncheckedCreateNestedManyWithoutEntityInput
    parts?: PartsUncheckedCreateNestedManyWithoutEntityInput
    claimToEntity?: ClaimToEntityUncheckedCreateNestedManyWithoutEntityInput
  }

  export type EntityCreateOrConnectWithoutEntityTypeInput = {
    where: EntityWhereUniqueInput
    create: XOR<EntityCreateWithoutEntityTypeInput, EntityUncheckedCreateWithoutEntityTypeInput>
  }

  export type EntityCreateManyEntityTypeInputEnvelope = {
    data: EntityCreateManyEntityTypeInput | EntityCreateManyEntityTypeInput[]
  }

  export type OrganizationUpsertWithoutEntityTypeInput = {
    update: XOR<OrganizationUpdateWithoutEntityTypeInput, OrganizationUncheckedUpdateWithoutEntityTypeInput>
    create: XOR<OrganizationCreateWithoutEntityTypeInput, OrganizationUncheckedCreateWithoutEntityTypeInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutEntityTypeInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutEntityTypeInput, OrganizationUncheckedUpdateWithoutEntityTypeInput>
  }

  export type OrganizationUpdateWithoutEntityTypeInput = {
    kcId?: NullableStringFieldUpdateOperationsInput | string | null
    organizationName?: NullableStringFieldUpdateOperationsInput | string | null
    realmName?: NullableStringFieldUpdateOperationsInput | string | null
    instanceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    principalGeography?: NullableStringFieldUpdateOperationsInput | string | null
    loginUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoutUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    activeModules?: OrganizationUpdateactiveModulesInput | string[]
    clientID?: NullableStringFieldUpdateOperationsInput | string | null
    clientSecret?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearQuarters?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearFormat?: NullableStringFieldUpdateOperationsInput | string | null
    auditYear?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    business?: BusinessUpdateManyWithoutOrganizationNestedInput
    Doctype?: DoctypeUpdateManyWithoutOrganizationNestedInput
    Documents?: DocumentsUpdateManyWithoutOrganizationNestedInput
    entity?: EntityUpdateManyWithoutOrganizationNestedInput
    location?: LocationUpdateManyWithoutOrganizationNestedInput
    role?: RoleUpdateManyWithoutOrganizationNestedInput
    section?: SectionUpdateManyWithoutOrganizationNestedInput
    systemType?: SystemTypeUpdateManyWithoutOrganizationNestedInput
    user?: UserUpdateManyWithoutOrganizationNestedInput
    userPersonalisation?: userPersonalisationUpdateManyWithoutOrganizationNestedInput
    ConnectedApps?: ConnectedAppsUpdateManyWithoutOrganizationNestedInput
    unitOfMeasurement?: unitTypeUpdateManyWithoutOrganizationNestedInput
    kpi?: kpiUpdateManyWithoutOrganizationNestedInput
    businessType?: businessTypeUpdateManyWithoutOrganizationNestedInput
    prefixSuffix?: prefixSuffixUpdateManyWithoutOrganizationNestedInput
    serialNumber?: serialNumberUpdateManyWithoutOrganizationNestedInput
    function?: FunctionsUpdateManyWithoutOrganizationNestedInput
    rolesTable?: rolesTableUpdateManyWithoutOrganizationNestedInput
    problem?: ProblemUpdateManyWithoutOrganizationNestedInput
    parts?: PartsUpdateManyWithoutOrganizationNestedInput
    Models?: ModelsUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutEntityTypeInput = {
    kcId?: NullableStringFieldUpdateOperationsInput | string | null
    organizationName?: NullableStringFieldUpdateOperationsInput | string | null
    realmName?: NullableStringFieldUpdateOperationsInput | string | null
    instanceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    principalGeography?: NullableStringFieldUpdateOperationsInput | string | null
    loginUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoutUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    activeModules?: OrganizationUpdateactiveModulesInput | string[]
    clientID?: NullableStringFieldUpdateOperationsInput | string | null
    clientSecret?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearQuarters?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearFormat?: NullableStringFieldUpdateOperationsInput | string | null
    auditYear?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    business?: BusinessUncheckedUpdateManyWithoutOrganizationNestedInput
    Doctype?: DoctypeUncheckedUpdateManyWithoutOrganizationNestedInput
    Documents?: DocumentsUncheckedUpdateManyWithoutOrganizationNestedInput
    entity?: EntityUncheckedUpdateManyWithoutOrganizationNestedInput
    location?: LocationUncheckedUpdateManyWithoutOrganizationNestedInput
    role?: RoleUncheckedUpdateManyWithoutOrganizationNestedInput
    section?: SectionUncheckedUpdateManyWithoutOrganizationNestedInput
    systemType?: SystemTypeUncheckedUpdateManyWithoutOrganizationNestedInput
    user?: UserUncheckedUpdateManyWithoutOrganizationNestedInput
    userPersonalisation?: userPersonalisationUncheckedUpdateManyWithoutOrganizationNestedInput
    ConnectedApps?: ConnectedAppsUncheckedUpdateManyWithoutOrganizationNestedInput
    unitOfMeasurement?: unitTypeUncheckedUpdateManyWithoutOrganizationNestedInput
    kpi?: kpiUncheckedUpdateManyWithoutOrganizationNestedInput
    businessType?: businessTypeUncheckedUpdateManyWithoutOrganizationNestedInput
    prefixSuffix?: prefixSuffixUncheckedUpdateManyWithoutOrganizationNestedInput
    serialNumber?: serialNumberUncheckedUpdateManyWithoutOrganizationNestedInput
    function?: FunctionsUncheckedUpdateManyWithoutOrganizationNestedInput
    rolesTable?: rolesTableUncheckedUpdateManyWithoutOrganizationNestedInput
    problem?: ProblemUncheckedUpdateManyWithoutOrganizationNestedInput
    parts?: PartsUncheckedUpdateManyWithoutOrganizationNestedInput
    Models?: ModelsUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type EntityUpsertWithWhereUniqueWithoutEntityTypeInput = {
    where: EntityWhereUniqueInput
    update: XOR<EntityUpdateWithoutEntityTypeInput, EntityUncheckedUpdateWithoutEntityTypeInput>
    create: XOR<EntityCreateWithoutEntityTypeInput, EntityUncheckedCreateWithoutEntityTypeInput>
  }

  export type EntityUpdateWithWhereUniqueWithoutEntityTypeInput = {
    where: EntityWhereUniqueInput
    data: XOR<EntityUpdateWithoutEntityTypeInput, EntityUncheckedUpdateWithoutEntityTypeInput>
  }

  export type EntityUpdateManyWithWhereWithoutEntityTypeInput = {
    where: EntityScalarWhereInput
    data: XOR<EntityUpdateManyMutationInput, EntityUncheckedUpdateManyWithoutEntityTypeInput>
  }

  export type OrganizationCreateWithoutBusinessTypeInput = {
    id?: string
    kcId?: string | null
    organizationName?: string | null
    realmName?: string | null
    instanceUrl?: string | null
    principalGeography?: string | null
    loginUrl?: string | null
    logoutUrl?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    activeModules?: OrganizationCreateactiveModulesInput | string[]
    clientID?: string | null
    clientSecret?: string | null
    fiscalYearQuarters?: string | null
    fiscalYearFormat?: string | null
    auditYear?: string | null
    logoUrl?: string | null
    deleted?: boolean | null
    business?: BusinessCreateNestedManyWithoutOrganizationInput
    Doctype?: DoctypeCreateNestedManyWithoutOrganizationInput
    Documents?: DocumentsCreateNestedManyWithoutOrganizationInput
    entity?: EntityCreateNestedManyWithoutOrganizationInput
    entityType?: EntityTypeCreateNestedManyWithoutOrganizationInput
    location?: LocationCreateNestedManyWithoutOrganizationInput
    role?: RoleCreateNestedManyWithoutOrganizationInput
    section?: SectionCreateNestedManyWithoutOrganizationInput
    systemType?: SystemTypeCreateNestedManyWithoutOrganizationInput
    user?: UserCreateNestedManyWithoutOrganizationInput
    userPersonalisation?: userPersonalisationCreateNestedManyWithoutOrganizationInput
    ConnectedApps?: ConnectedAppsCreateNestedManyWithoutOrganizationInput
    unitOfMeasurement?: unitTypeCreateNestedManyWithoutOrganizationInput
    kpi?: kpiCreateNestedManyWithoutOrganizationInput
    prefixSuffix?: prefixSuffixCreateNestedManyWithoutOrganizationInput
    serialNumber?: serialNumberCreateNestedManyWithoutOrganizationInput
    function?: FunctionsCreateNestedManyWithoutOrganizationInput
    rolesTable?: rolesTableCreateNestedManyWithoutOrganizationInput
    problem?: ProblemCreateNestedManyWithoutOrganizationInput
    parts?: PartsCreateNestedManyWithoutOrganizationInput
    Models?: ModelsCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutBusinessTypeInput = {
    id?: string
    kcId?: string | null
    organizationName?: string | null
    realmName?: string | null
    instanceUrl?: string | null
    principalGeography?: string | null
    loginUrl?: string | null
    logoutUrl?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    activeModules?: OrganizationCreateactiveModulesInput | string[]
    clientID?: string | null
    clientSecret?: string | null
    fiscalYearQuarters?: string | null
    fiscalYearFormat?: string | null
    auditYear?: string | null
    logoUrl?: string | null
    deleted?: boolean | null
    business?: BusinessUncheckedCreateNestedManyWithoutOrganizationInput
    Doctype?: DoctypeUncheckedCreateNestedManyWithoutOrganizationInput
    Documents?: DocumentsUncheckedCreateNestedManyWithoutOrganizationInput
    entity?: EntityUncheckedCreateNestedManyWithoutOrganizationInput
    entityType?: EntityTypeUncheckedCreateNestedManyWithoutOrganizationInput
    location?: LocationUncheckedCreateNestedManyWithoutOrganizationInput
    role?: RoleUncheckedCreateNestedManyWithoutOrganizationInput
    section?: SectionUncheckedCreateNestedManyWithoutOrganizationInput
    systemType?: SystemTypeUncheckedCreateNestedManyWithoutOrganizationInput
    user?: UserUncheckedCreateNestedManyWithoutOrganizationInput
    userPersonalisation?: userPersonalisationUncheckedCreateNestedManyWithoutOrganizationInput
    ConnectedApps?: ConnectedAppsUncheckedCreateNestedManyWithoutOrganizationInput
    unitOfMeasurement?: unitTypeUncheckedCreateNestedManyWithoutOrganizationInput
    kpi?: kpiUncheckedCreateNestedManyWithoutOrganizationInput
    prefixSuffix?: prefixSuffixUncheckedCreateNestedManyWithoutOrganizationInput
    serialNumber?: serialNumberUncheckedCreateNestedManyWithoutOrganizationInput
    function?: FunctionsUncheckedCreateNestedManyWithoutOrganizationInput
    rolesTable?: rolesTableUncheckedCreateNestedManyWithoutOrganizationInput
    problem?: ProblemUncheckedCreateNestedManyWithoutOrganizationInput
    parts?: PartsUncheckedCreateNestedManyWithoutOrganizationInput
    Models?: ModelsUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutBusinessTypeInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutBusinessTypeInput, OrganizationUncheckedCreateWithoutBusinessTypeInput>
  }

  export type OrganizationUpsertWithoutBusinessTypeInput = {
    update: XOR<OrganizationUpdateWithoutBusinessTypeInput, OrganizationUncheckedUpdateWithoutBusinessTypeInput>
    create: XOR<OrganizationCreateWithoutBusinessTypeInput, OrganizationUncheckedCreateWithoutBusinessTypeInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutBusinessTypeInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutBusinessTypeInput, OrganizationUncheckedUpdateWithoutBusinessTypeInput>
  }

  export type OrganizationUpdateWithoutBusinessTypeInput = {
    kcId?: NullableStringFieldUpdateOperationsInput | string | null
    organizationName?: NullableStringFieldUpdateOperationsInput | string | null
    realmName?: NullableStringFieldUpdateOperationsInput | string | null
    instanceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    principalGeography?: NullableStringFieldUpdateOperationsInput | string | null
    loginUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoutUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    activeModules?: OrganizationUpdateactiveModulesInput | string[]
    clientID?: NullableStringFieldUpdateOperationsInput | string | null
    clientSecret?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearQuarters?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearFormat?: NullableStringFieldUpdateOperationsInput | string | null
    auditYear?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    business?: BusinessUpdateManyWithoutOrganizationNestedInput
    Doctype?: DoctypeUpdateManyWithoutOrganizationNestedInput
    Documents?: DocumentsUpdateManyWithoutOrganizationNestedInput
    entity?: EntityUpdateManyWithoutOrganizationNestedInput
    entityType?: EntityTypeUpdateManyWithoutOrganizationNestedInput
    location?: LocationUpdateManyWithoutOrganizationNestedInput
    role?: RoleUpdateManyWithoutOrganizationNestedInput
    section?: SectionUpdateManyWithoutOrganizationNestedInput
    systemType?: SystemTypeUpdateManyWithoutOrganizationNestedInput
    user?: UserUpdateManyWithoutOrganizationNestedInput
    userPersonalisation?: userPersonalisationUpdateManyWithoutOrganizationNestedInput
    ConnectedApps?: ConnectedAppsUpdateManyWithoutOrganizationNestedInput
    unitOfMeasurement?: unitTypeUpdateManyWithoutOrganizationNestedInput
    kpi?: kpiUpdateManyWithoutOrganizationNestedInput
    prefixSuffix?: prefixSuffixUpdateManyWithoutOrganizationNestedInput
    serialNumber?: serialNumberUpdateManyWithoutOrganizationNestedInput
    function?: FunctionsUpdateManyWithoutOrganizationNestedInput
    rolesTable?: rolesTableUpdateManyWithoutOrganizationNestedInput
    problem?: ProblemUpdateManyWithoutOrganizationNestedInput
    parts?: PartsUpdateManyWithoutOrganizationNestedInput
    Models?: ModelsUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutBusinessTypeInput = {
    kcId?: NullableStringFieldUpdateOperationsInput | string | null
    organizationName?: NullableStringFieldUpdateOperationsInput | string | null
    realmName?: NullableStringFieldUpdateOperationsInput | string | null
    instanceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    principalGeography?: NullableStringFieldUpdateOperationsInput | string | null
    loginUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoutUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    activeModules?: OrganizationUpdateactiveModulesInput | string[]
    clientID?: NullableStringFieldUpdateOperationsInput | string | null
    clientSecret?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearQuarters?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearFormat?: NullableStringFieldUpdateOperationsInput | string | null
    auditYear?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    business?: BusinessUncheckedUpdateManyWithoutOrganizationNestedInput
    Doctype?: DoctypeUncheckedUpdateManyWithoutOrganizationNestedInput
    Documents?: DocumentsUncheckedUpdateManyWithoutOrganizationNestedInput
    entity?: EntityUncheckedUpdateManyWithoutOrganizationNestedInput
    entityType?: EntityTypeUncheckedUpdateManyWithoutOrganizationNestedInput
    location?: LocationUncheckedUpdateManyWithoutOrganizationNestedInput
    role?: RoleUncheckedUpdateManyWithoutOrganizationNestedInput
    section?: SectionUncheckedUpdateManyWithoutOrganizationNestedInput
    systemType?: SystemTypeUncheckedUpdateManyWithoutOrganizationNestedInput
    user?: UserUncheckedUpdateManyWithoutOrganizationNestedInput
    userPersonalisation?: userPersonalisationUncheckedUpdateManyWithoutOrganizationNestedInput
    ConnectedApps?: ConnectedAppsUncheckedUpdateManyWithoutOrganizationNestedInput
    unitOfMeasurement?: unitTypeUncheckedUpdateManyWithoutOrganizationNestedInput
    kpi?: kpiUncheckedUpdateManyWithoutOrganizationNestedInput
    prefixSuffix?: prefixSuffixUncheckedUpdateManyWithoutOrganizationNestedInput
    serialNumber?: serialNumberUncheckedUpdateManyWithoutOrganizationNestedInput
    function?: FunctionsUncheckedUpdateManyWithoutOrganizationNestedInput
    rolesTable?: rolesTableUncheckedUpdateManyWithoutOrganizationNestedInput
    problem?: ProblemUncheckedUpdateManyWithoutOrganizationNestedInput
    parts?: PartsUncheckedUpdateManyWithoutOrganizationNestedInput
    Models?: ModelsUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationCreateWithoutBusinessInput = {
    id?: string
    kcId?: string | null
    organizationName?: string | null
    realmName?: string | null
    instanceUrl?: string | null
    principalGeography?: string | null
    loginUrl?: string | null
    logoutUrl?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    activeModules?: OrganizationCreateactiveModulesInput | string[]
    clientID?: string | null
    clientSecret?: string | null
    fiscalYearQuarters?: string | null
    fiscalYearFormat?: string | null
    auditYear?: string | null
    logoUrl?: string | null
    deleted?: boolean | null
    Doctype?: DoctypeCreateNestedManyWithoutOrganizationInput
    Documents?: DocumentsCreateNestedManyWithoutOrganizationInput
    entity?: EntityCreateNestedManyWithoutOrganizationInput
    entityType?: EntityTypeCreateNestedManyWithoutOrganizationInput
    location?: LocationCreateNestedManyWithoutOrganizationInput
    role?: RoleCreateNestedManyWithoutOrganizationInput
    section?: SectionCreateNestedManyWithoutOrganizationInput
    systemType?: SystemTypeCreateNestedManyWithoutOrganizationInput
    user?: UserCreateNestedManyWithoutOrganizationInput
    userPersonalisation?: userPersonalisationCreateNestedManyWithoutOrganizationInput
    ConnectedApps?: ConnectedAppsCreateNestedManyWithoutOrganizationInput
    unitOfMeasurement?: unitTypeCreateNestedManyWithoutOrganizationInput
    kpi?: kpiCreateNestedManyWithoutOrganizationInput
    businessType?: businessTypeCreateNestedManyWithoutOrganizationInput
    prefixSuffix?: prefixSuffixCreateNestedManyWithoutOrganizationInput
    serialNumber?: serialNumberCreateNestedManyWithoutOrganizationInput
    function?: FunctionsCreateNestedManyWithoutOrganizationInput
    rolesTable?: rolesTableCreateNestedManyWithoutOrganizationInput
    problem?: ProblemCreateNestedManyWithoutOrganizationInput
    parts?: PartsCreateNestedManyWithoutOrganizationInput
    Models?: ModelsCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutBusinessInput = {
    id?: string
    kcId?: string | null
    organizationName?: string | null
    realmName?: string | null
    instanceUrl?: string | null
    principalGeography?: string | null
    loginUrl?: string | null
    logoutUrl?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    activeModules?: OrganizationCreateactiveModulesInput | string[]
    clientID?: string | null
    clientSecret?: string | null
    fiscalYearQuarters?: string | null
    fiscalYearFormat?: string | null
    auditYear?: string | null
    logoUrl?: string | null
    deleted?: boolean | null
    Doctype?: DoctypeUncheckedCreateNestedManyWithoutOrganizationInput
    Documents?: DocumentsUncheckedCreateNestedManyWithoutOrganizationInput
    entity?: EntityUncheckedCreateNestedManyWithoutOrganizationInput
    entityType?: EntityTypeUncheckedCreateNestedManyWithoutOrganizationInput
    location?: LocationUncheckedCreateNestedManyWithoutOrganizationInput
    role?: RoleUncheckedCreateNestedManyWithoutOrganizationInput
    section?: SectionUncheckedCreateNestedManyWithoutOrganizationInput
    systemType?: SystemTypeUncheckedCreateNestedManyWithoutOrganizationInput
    user?: UserUncheckedCreateNestedManyWithoutOrganizationInput
    userPersonalisation?: userPersonalisationUncheckedCreateNestedManyWithoutOrganizationInput
    ConnectedApps?: ConnectedAppsUncheckedCreateNestedManyWithoutOrganizationInput
    unitOfMeasurement?: unitTypeUncheckedCreateNestedManyWithoutOrganizationInput
    kpi?: kpiUncheckedCreateNestedManyWithoutOrganizationInput
    businessType?: businessTypeUncheckedCreateNestedManyWithoutOrganizationInput
    prefixSuffix?: prefixSuffixUncheckedCreateNestedManyWithoutOrganizationInput
    serialNumber?: serialNumberUncheckedCreateNestedManyWithoutOrganizationInput
    function?: FunctionsUncheckedCreateNestedManyWithoutOrganizationInput
    rolesTable?: rolesTableUncheckedCreateNestedManyWithoutOrganizationInput
    problem?: ProblemUncheckedCreateNestedManyWithoutOrganizationInput
    parts?: PartsUncheckedCreateNestedManyWithoutOrganizationInput
    Models?: ModelsUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutBusinessInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutBusinessInput, OrganizationUncheckedCreateWithoutBusinessInput>
  }

  export type LocationBusinessCreateWithoutBusinessInput = {
    id?: string
    location?: LocationCreateNestedOneWithoutBusinessInput
  }

  export type LocationBusinessUncheckedCreateWithoutBusinessInput = {
    id?: string
    locationId?: string | null
  }

  export type LocationBusinessCreateOrConnectWithoutBusinessInput = {
    where: LocationBusinessWhereUniqueInput
    create: XOR<LocationBusinessCreateWithoutBusinessInput, LocationBusinessUncheckedCreateWithoutBusinessInput>
  }

  export type LocationBusinessCreateManyBusinessInputEnvelope = {
    data: LocationBusinessCreateManyBusinessInput | LocationBusinessCreateManyBusinessInput[]
  }

  export type OrganizationUpsertWithoutBusinessInput = {
    update: XOR<OrganizationUpdateWithoutBusinessInput, OrganizationUncheckedUpdateWithoutBusinessInput>
    create: XOR<OrganizationCreateWithoutBusinessInput, OrganizationUncheckedCreateWithoutBusinessInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutBusinessInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutBusinessInput, OrganizationUncheckedUpdateWithoutBusinessInput>
  }

  export type OrganizationUpdateWithoutBusinessInput = {
    kcId?: NullableStringFieldUpdateOperationsInput | string | null
    organizationName?: NullableStringFieldUpdateOperationsInput | string | null
    realmName?: NullableStringFieldUpdateOperationsInput | string | null
    instanceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    principalGeography?: NullableStringFieldUpdateOperationsInput | string | null
    loginUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoutUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    activeModules?: OrganizationUpdateactiveModulesInput | string[]
    clientID?: NullableStringFieldUpdateOperationsInput | string | null
    clientSecret?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearQuarters?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearFormat?: NullableStringFieldUpdateOperationsInput | string | null
    auditYear?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Doctype?: DoctypeUpdateManyWithoutOrganizationNestedInput
    Documents?: DocumentsUpdateManyWithoutOrganizationNestedInput
    entity?: EntityUpdateManyWithoutOrganizationNestedInput
    entityType?: EntityTypeUpdateManyWithoutOrganizationNestedInput
    location?: LocationUpdateManyWithoutOrganizationNestedInput
    role?: RoleUpdateManyWithoutOrganizationNestedInput
    section?: SectionUpdateManyWithoutOrganizationNestedInput
    systemType?: SystemTypeUpdateManyWithoutOrganizationNestedInput
    user?: UserUpdateManyWithoutOrganizationNestedInput
    userPersonalisation?: userPersonalisationUpdateManyWithoutOrganizationNestedInput
    ConnectedApps?: ConnectedAppsUpdateManyWithoutOrganizationNestedInput
    unitOfMeasurement?: unitTypeUpdateManyWithoutOrganizationNestedInput
    kpi?: kpiUpdateManyWithoutOrganizationNestedInput
    businessType?: businessTypeUpdateManyWithoutOrganizationNestedInput
    prefixSuffix?: prefixSuffixUpdateManyWithoutOrganizationNestedInput
    serialNumber?: serialNumberUpdateManyWithoutOrganizationNestedInput
    function?: FunctionsUpdateManyWithoutOrganizationNestedInput
    rolesTable?: rolesTableUpdateManyWithoutOrganizationNestedInput
    problem?: ProblemUpdateManyWithoutOrganizationNestedInput
    parts?: PartsUpdateManyWithoutOrganizationNestedInput
    Models?: ModelsUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutBusinessInput = {
    kcId?: NullableStringFieldUpdateOperationsInput | string | null
    organizationName?: NullableStringFieldUpdateOperationsInput | string | null
    realmName?: NullableStringFieldUpdateOperationsInput | string | null
    instanceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    principalGeography?: NullableStringFieldUpdateOperationsInput | string | null
    loginUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoutUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    activeModules?: OrganizationUpdateactiveModulesInput | string[]
    clientID?: NullableStringFieldUpdateOperationsInput | string | null
    clientSecret?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearQuarters?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearFormat?: NullableStringFieldUpdateOperationsInput | string | null
    auditYear?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Doctype?: DoctypeUncheckedUpdateManyWithoutOrganizationNestedInput
    Documents?: DocumentsUncheckedUpdateManyWithoutOrganizationNestedInput
    entity?: EntityUncheckedUpdateManyWithoutOrganizationNestedInput
    entityType?: EntityTypeUncheckedUpdateManyWithoutOrganizationNestedInput
    location?: LocationUncheckedUpdateManyWithoutOrganizationNestedInput
    role?: RoleUncheckedUpdateManyWithoutOrganizationNestedInput
    section?: SectionUncheckedUpdateManyWithoutOrganizationNestedInput
    systemType?: SystemTypeUncheckedUpdateManyWithoutOrganizationNestedInput
    user?: UserUncheckedUpdateManyWithoutOrganizationNestedInput
    userPersonalisation?: userPersonalisationUncheckedUpdateManyWithoutOrganizationNestedInput
    ConnectedApps?: ConnectedAppsUncheckedUpdateManyWithoutOrganizationNestedInput
    unitOfMeasurement?: unitTypeUncheckedUpdateManyWithoutOrganizationNestedInput
    kpi?: kpiUncheckedUpdateManyWithoutOrganizationNestedInput
    businessType?: businessTypeUncheckedUpdateManyWithoutOrganizationNestedInput
    prefixSuffix?: prefixSuffixUncheckedUpdateManyWithoutOrganizationNestedInput
    serialNumber?: serialNumberUncheckedUpdateManyWithoutOrganizationNestedInput
    function?: FunctionsUncheckedUpdateManyWithoutOrganizationNestedInput
    rolesTable?: rolesTableUncheckedUpdateManyWithoutOrganizationNestedInput
    problem?: ProblemUncheckedUpdateManyWithoutOrganizationNestedInput
    parts?: PartsUncheckedUpdateManyWithoutOrganizationNestedInput
    Models?: ModelsUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type LocationBusinessUpsertWithWhereUniqueWithoutBusinessInput = {
    where: LocationBusinessWhereUniqueInput
    update: XOR<LocationBusinessUpdateWithoutBusinessInput, LocationBusinessUncheckedUpdateWithoutBusinessInput>
    create: XOR<LocationBusinessCreateWithoutBusinessInput, LocationBusinessUncheckedCreateWithoutBusinessInput>
  }

  export type LocationBusinessUpdateWithWhereUniqueWithoutBusinessInput = {
    where: LocationBusinessWhereUniqueInput
    data: XOR<LocationBusinessUpdateWithoutBusinessInput, LocationBusinessUncheckedUpdateWithoutBusinessInput>
  }

  export type LocationBusinessUpdateManyWithWhereWithoutBusinessInput = {
    where: LocationBusinessScalarWhereInput
    data: XOR<LocationBusinessUpdateManyMutationInput, LocationBusinessUncheckedUpdateManyWithoutBusinessInput>
  }

  export type LocationBusinessScalarWhereInput = {
    AND?: LocationBusinessScalarWhereInput | LocationBusinessScalarWhereInput[]
    OR?: LocationBusinessScalarWhereInput[]
    NOT?: LocationBusinessScalarWhereInput | LocationBusinessScalarWhereInput[]
    id?: StringFilter<"LocationBusiness"> | string
    locationId?: StringNullableFilter<"LocationBusiness"> | string | null
    businessId?: StringNullableFilter<"LocationBusiness"> | string | null
  }

  export type OrganizationCreateWithoutFunctionInput = {
    id?: string
    kcId?: string | null
    organizationName?: string | null
    realmName?: string | null
    instanceUrl?: string | null
    principalGeography?: string | null
    loginUrl?: string | null
    logoutUrl?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    activeModules?: OrganizationCreateactiveModulesInput | string[]
    clientID?: string | null
    clientSecret?: string | null
    fiscalYearQuarters?: string | null
    fiscalYearFormat?: string | null
    auditYear?: string | null
    logoUrl?: string | null
    deleted?: boolean | null
    business?: BusinessCreateNestedManyWithoutOrganizationInput
    Doctype?: DoctypeCreateNestedManyWithoutOrganizationInput
    Documents?: DocumentsCreateNestedManyWithoutOrganizationInput
    entity?: EntityCreateNestedManyWithoutOrganizationInput
    entityType?: EntityTypeCreateNestedManyWithoutOrganizationInput
    location?: LocationCreateNestedManyWithoutOrganizationInput
    role?: RoleCreateNestedManyWithoutOrganizationInput
    section?: SectionCreateNestedManyWithoutOrganizationInput
    systemType?: SystemTypeCreateNestedManyWithoutOrganizationInput
    user?: UserCreateNestedManyWithoutOrganizationInput
    userPersonalisation?: userPersonalisationCreateNestedManyWithoutOrganizationInput
    ConnectedApps?: ConnectedAppsCreateNestedManyWithoutOrganizationInput
    unitOfMeasurement?: unitTypeCreateNestedManyWithoutOrganizationInput
    kpi?: kpiCreateNestedManyWithoutOrganizationInput
    businessType?: businessTypeCreateNestedManyWithoutOrganizationInput
    prefixSuffix?: prefixSuffixCreateNestedManyWithoutOrganizationInput
    serialNumber?: serialNumberCreateNestedManyWithoutOrganizationInput
    rolesTable?: rolesTableCreateNestedManyWithoutOrganizationInput
    problem?: ProblemCreateNestedManyWithoutOrganizationInput
    parts?: PartsCreateNestedManyWithoutOrganizationInput
    Models?: ModelsCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutFunctionInput = {
    id?: string
    kcId?: string | null
    organizationName?: string | null
    realmName?: string | null
    instanceUrl?: string | null
    principalGeography?: string | null
    loginUrl?: string | null
    logoutUrl?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    activeModules?: OrganizationCreateactiveModulesInput | string[]
    clientID?: string | null
    clientSecret?: string | null
    fiscalYearQuarters?: string | null
    fiscalYearFormat?: string | null
    auditYear?: string | null
    logoUrl?: string | null
    deleted?: boolean | null
    business?: BusinessUncheckedCreateNestedManyWithoutOrganizationInput
    Doctype?: DoctypeUncheckedCreateNestedManyWithoutOrganizationInput
    Documents?: DocumentsUncheckedCreateNestedManyWithoutOrganizationInput
    entity?: EntityUncheckedCreateNestedManyWithoutOrganizationInput
    entityType?: EntityTypeUncheckedCreateNestedManyWithoutOrganizationInput
    location?: LocationUncheckedCreateNestedManyWithoutOrganizationInput
    role?: RoleUncheckedCreateNestedManyWithoutOrganizationInput
    section?: SectionUncheckedCreateNestedManyWithoutOrganizationInput
    systemType?: SystemTypeUncheckedCreateNestedManyWithoutOrganizationInput
    user?: UserUncheckedCreateNestedManyWithoutOrganizationInput
    userPersonalisation?: userPersonalisationUncheckedCreateNestedManyWithoutOrganizationInput
    ConnectedApps?: ConnectedAppsUncheckedCreateNestedManyWithoutOrganizationInput
    unitOfMeasurement?: unitTypeUncheckedCreateNestedManyWithoutOrganizationInput
    kpi?: kpiUncheckedCreateNestedManyWithoutOrganizationInput
    businessType?: businessTypeUncheckedCreateNestedManyWithoutOrganizationInput
    prefixSuffix?: prefixSuffixUncheckedCreateNestedManyWithoutOrganizationInput
    serialNumber?: serialNumberUncheckedCreateNestedManyWithoutOrganizationInput
    rolesTable?: rolesTableUncheckedCreateNestedManyWithoutOrganizationInput
    problem?: ProblemUncheckedCreateNestedManyWithoutOrganizationInput
    parts?: PartsUncheckedCreateNestedManyWithoutOrganizationInput
    Models?: ModelsUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutFunctionInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutFunctionInput, OrganizationUncheckedCreateWithoutFunctionInput>
  }

  export type EntityCreateWithoutFunctionInput = {
    id?: string
    entityName?: string | null
    description?: string | null
    createdBy?: string | null
    entityId?: string | null
    deleted?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedBy?: string | null
    users?: EntityCreateusersInput | string[]
    sections?: EntityCreatesectionsInput | string[]
    entityType?: EntityTypeCreateNestedOneWithoutEntityInput
    location?: LocationCreateNestedOneWithoutEntityInput
    organization?: OrganizationCreateNestedOneWithoutEntityInput
    Doctype?: DoctypeCreateNestedManyWithoutEntityInput
    Documents?: DocumentsCreateNestedManyWithoutCreatorEntityInput
    user?: UserCreateNestedManyWithoutEntityInput
    parts?: PartsCreateNestedManyWithoutEntityInput
    claimToEntity?: ClaimToEntityCreateNestedManyWithoutEntityInput
  }

  export type EntityUncheckedCreateWithoutFunctionInput = {
    id?: string
    entityName?: string | null
    description?: string | null
    entityTypeId?: string | null
    organizationId?: string | null
    locationId?: string | null
    createdBy?: string | null
    entityId?: string | null
    deleted?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedBy?: string | null
    users?: EntityCreateusersInput | string[]
    sections?: EntityCreatesectionsInput | string[]
    Doctype?: DoctypeUncheckedCreateNestedManyWithoutEntityInput
    Documents?: DocumentsUncheckedCreateNestedManyWithoutCreatorEntityInput
    user?: UserUncheckedCreateNestedManyWithoutEntityInput
    parts?: PartsUncheckedCreateNestedManyWithoutEntityInput
    claimToEntity?: ClaimToEntityUncheckedCreateNestedManyWithoutEntityInput
  }

  export type EntityCreateOrConnectWithoutFunctionInput = {
    where: EntityWhereUniqueInput
    create: XOR<EntityCreateWithoutFunctionInput, EntityUncheckedCreateWithoutFunctionInput>
  }

  export type EntityCreateManyFunctionInputEnvelope = {
    data: EntityCreateManyFunctionInput | EntityCreateManyFunctionInput[]
  }

  export type OrganizationUpsertWithoutFunctionInput = {
    update: XOR<OrganizationUpdateWithoutFunctionInput, OrganizationUncheckedUpdateWithoutFunctionInput>
    create: XOR<OrganizationCreateWithoutFunctionInput, OrganizationUncheckedCreateWithoutFunctionInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutFunctionInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutFunctionInput, OrganizationUncheckedUpdateWithoutFunctionInput>
  }

  export type OrganizationUpdateWithoutFunctionInput = {
    kcId?: NullableStringFieldUpdateOperationsInput | string | null
    organizationName?: NullableStringFieldUpdateOperationsInput | string | null
    realmName?: NullableStringFieldUpdateOperationsInput | string | null
    instanceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    principalGeography?: NullableStringFieldUpdateOperationsInput | string | null
    loginUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoutUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    activeModules?: OrganizationUpdateactiveModulesInput | string[]
    clientID?: NullableStringFieldUpdateOperationsInput | string | null
    clientSecret?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearQuarters?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearFormat?: NullableStringFieldUpdateOperationsInput | string | null
    auditYear?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    business?: BusinessUpdateManyWithoutOrganizationNestedInput
    Doctype?: DoctypeUpdateManyWithoutOrganizationNestedInput
    Documents?: DocumentsUpdateManyWithoutOrganizationNestedInput
    entity?: EntityUpdateManyWithoutOrganizationNestedInput
    entityType?: EntityTypeUpdateManyWithoutOrganizationNestedInput
    location?: LocationUpdateManyWithoutOrganizationNestedInput
    role?: RoleUpdateManyWithoutOrganizationNestedInput
    section?: SectionUpdateManyWithoutOrganizationNestedInput
    systemType?: SystemTypeUpdateManyWithoutOrganizationNestedInput
    user?: UserUpdateManyWithoutOrganizationNestedInput
    userPersonalisation?: userPersonalisationUpdateManyWithoutOrganizationNestedInput
    ConnectedApps?: ConnectedAppsUpdateManyWithoutOrganizationNestedInput
    unitOfMeasurement?: unitTypeUpdateManyWithoutOrganizationNestedInput
    kpi?: kpiUpdateManyWithoutOrganizationNestedInput
    businessType?: businessTypeUpdateManyWithoutOrganizationNestedInput
    prefixSuffix?: prefixSuffixUpdateManyWithoutOrganizationNestedInput
    serialNumber?: serialNumberUpdateManyWithoutOrganizationNestedInput
    rolesTable?: rolesTableUpdateManyWithoutOrganizationNestedInput
    problem?: ProblemUpdateManyWithoutOrganizationNestedInput
    parts?: PartsUpdateManyWithoutOrganizationNestedInput
    Models?: ModelsUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutFunctionInput = {
    kcId?: NullableStringFieldUpdateOperationsInput | string | null
    organizationName?: NullableStringFieldUpdateOperationsInput | string | null
    realmName?: NullableStringFieldUpdateOperationsInput | string | null
    instanceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    principalGeography?: NullableStringFieldUpdateOperationsInput | string | null
    loginUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoutUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    activeModules?: OrganizationUpdateactiveModulesInput | string[]
    clientID?: NullableStringFieldUpdateOperationsInput | string | null
    clientSecret?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearQuarters?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearFormat?: NullableStringFieldUpdateOperationsInput | string | null
    auditYear?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    business?: BusinessUncheckedUpdateManyWithoutOrganizationNestedInput
    Doctype?: DoctypeUncheckedUpdateManyWithoutOrganizationNestedInput
    Documents?: DocumentsUncheckedUpdateManyWithoutOrganizationNestedInput
    entity?: EntityUncheckedUpdateManyWithoutOrganizationNestedInput
    entityType?: EntityTypeUncheckedUpdateManyWithoutOrganizationNestedInput
    location?: LocationUncheckedUpdateManyWithoutOrganizationNestedInput
    role?: RoleUncheckedUpdateManyWithoutOrganizationNestedInput
    section?: SectionUncheckedUpdateManyWithoutOrganizationNestedInput
    systemType?: SystemTypeUncheckedUpdateManyWithoutOrganizationNestedInput
    user?: UserUncheckedUpdateManyWithoutOrganizationNestedInput
    userPersonalisation?: userPersonalisationUncheckedUpdateManyWithoutOrganizationNestedInput
    ConnectedApps?: ConnectedAppsUncheckedUpdateManyWithoutOrganizationNestedInput
    unitOfMeasurement?: unitTypeUncheckedUpdateManyWithoutOrganizationNestedInput
    kpi?: kpiUncheckedUpdateManyWithoutOrganizationNestedInput
    businessType?: businessTypeUncheckedUpdateManyWithoutOrganizationNestedInput
    prefixSuffix?: prefixSuffixUncheckedUpdateManyWithoutOrganizationNestedInput
    serialNumber?: serialNumberUncheckedUpdateManyWithoutOrganizationNestedInput
    rolesTable?: rolesTableUncheckedUpdateManyWithoutOrganizationNestedInput
    problem?: ProblemUncheckedUpdateManyWithoutOrganizationNestedInput
    parts?: PartsUncheckedUpdateManyWithoutOrganizationNestedInput
    Models?: ModelsUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type EntityUpsertWithWhereUniqueWithoutFunctionInput = {
    where: EntityWhereUniqueInput
    update: XOR<EntityUpdateWithoutFunctionInput, EntityUncheckedUpdateWithoutFunctionInput>
    create: XOR<EntityCreateWithoutFunctionInput, EntityUncheckedCreateWithoutFunctionInput>
  }

  export type EntityUpdateWithWhereUniqueWithoutFunctionInput = {
    where: EntityWhereUniqueInput
    data: XOR<EntityUpdateWithoutFunctionInput, EntityUncheckedUpdateWithoutFunctionInput>
  }

  export type EntityUpdateManyWithWhereWithoutFunctionInput = {
    where: EntityScalarWhereInput
    data: XOR<EntityUpdateManyMutationInput, EntityUncheckedUpdateManyWithoutFunctionInput>
  }

  export type OrganizationCreateWithoutSectionInput = {
    id?: string
    kcId?: string | null
    organizationName?: string | null
    realmName?: string | null
    instanceUrl?: string | null
    principalGeography?: string | null
    loginUrl?: string | null
    logoutUrl?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    activeModules?: OrganizationCreateactiveModulesInput | string[]
    clientID?: string | null
    clientSecret?: string | null
    fiscalYearQuarters?: string | null
    fiscalYearFormat?: string | null
    auditYear?: string | null
    logoUrl?: string | null
    deleted?: boolean | null
    business?: BusinessCreateNestedManyWithoutOrganizationInput
    Doctype?: DoctypeCreateNestedManyWithoutOrganizationInput
    Documents?: DocumentsCreateNestedManyWithoutOrganizationInput
    entity?: EntityCreateNestedManyWithoutOrganizationInput
    entityType?: EntityTypeCreateNestedManyWithoutOrganizationInput
    location?: LocationCreateNestedManyWithoutOrganizationInput
    role?: RoleCreateNestedManyWithoutOrganizationInput
    systemType?: SystemTypeCreateNestedManyWithoutOrganizationInput
    user?: UserCreateNestedManyWithoutOrganizationInput
    userPersonalisation?: userPersonalisationCreateNestedManyWithoutOrganizationInput
    ConnectedApps?: ConnectedAppsCreateNestedManyWithoutOrganizationInput
    unitOfMeasurement?: unitTypeCreateNestedManyWithoutOrganizationInput
    kpi?: kpiCreateNestedManyWithoutOrganizationInput
    businessType?: businessTypeCreateNestedManyWithoutOrganizationInput
    prefixSuffix?: prefixSuffixCreateNestedManyWithoutOrganizationInput
    serialNumber?: serialNumberCreateNestedManyWithoutOrganizationInput
    function?: FunctionsCreateNestedManyWithoutOrganizationInput
    rolesTable?: rolesTableCreateNestedManyWithoutOrganizationInput
    problem?: ProblemCreateNestedManyWithoutOrganizationInput
    parts?: PartsCreateNestedManyWithoutOrganizationInput
    Models?: ModelsCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutSectionInput = {
    id?: string
    kcId?: string | null
    organizationName?: string | null
    realmName?: string | null
    instanceUrl?: string | null
    principalGeography?: string | null
    loginUrl?: string | null
    logoutUrl?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    activeModules?: OrganizationCreateactiveModulesInput | string[]
    clientID?: string | null
    clientSecret?: string | null
    fiscalYearQuarters?: string | null
    fiscalYearFormat?: string | null
    auditYear?: string | null
    logoUrl?: string | null
    deleted?: boolean | null
    business?: BusinessUncheckedCreateNestedManyWithoutOrganizationInput
    Doctype?: DoctypeUncheckedCreateNestedManyWithoutOrganizationInput
    Documents?: DocumentsUncheckedCreateNestedManyWithoutOrganizationInput
    entity?: EntityUncheckedCreateNestedManyWithoutOrganizationInput
    entityType?: EntityTypeUncheckedCreateNestedManyWithoutOrganizationInput
    location?: LocationUncheckedCreateNestedManyWithoutOrganizationInput
    role?: RoleUncheckedCreateNestedManyWithoutOrganizationInput
    systemType?: SystemTypeUncheckedCreateNestedManyWithoutOrganizationInput
    user?: UserUncheckedCreateNestedManyWithoutOrganizationInput
    userPersonalisation?: userPersonalisationUncheckedCreateNestedManyWithoutOrganizationInput
    ConnectedApps?: ConnectedAppsUncheckedCreateNestedManyWithoutOrganizationInput
    unitOfMeasurement?: unitTypeUncheckedCreateNestedManyWithoutOrganizationInput
    kpi?: kpiUncheckedCreateNestedManyWithoutOrganizationInput
    businessType?: businessTypeUncheckedCreateNestedManyWithoutOrganizationInput
    prefixSuffix?: prefixSuffixUncheckedCreateNestedManyWithoutOrganizationInput
    serialNumber?: serialNumberUncheckedCreateNestedManyWithoutOrganizationInput
    function?: FunctionsUncheckedCreateNestedManyWithoutOrganizationInput
    rolesTable?: rolesTableUncheckedCreateNestedManyWithoutOrganizationInput
    problem?: ProblemUncheckedCreateNestedManyWithoutOrganizationInput
    parts?: PartsUncheckedCreateNestedManyWithoutOrganizationInput
    Models?: ModelsUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutSectionInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutSectionInput, OrganizationUncheckedCreateWithoutSectionInput>
  }

  export type OrganizationUpsertWithoutSectionInput = {
    update: XOR<OrganizationUpdateWithoutSectionInput, OrganizationUncheckedUpdateWithoutSectionInput>
    create: XOR<OrganizationCreateWithoutSectionInput, OrganizationUncheckedCreateWithoutSectionInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutSectionInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutSectionInput, OrganizationUncheckedUpdateWithoutSectionInput>
  }

  export type OrganizationUpdateWithoutSectionInput = {
    kcId?: NullableStringFieldUpdateOperationsInput | string | null
    organizationName?: NullableStringFieldUpdateOperationsInput | string | null
    realmName?: NullableStringFieldUpdateOperationsInput | string | null
    instanceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    principalGeography?: NullableStringFieldUpdateOperationsInput | string | null
    loginUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoutUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    activeModules?: OrganizationUpdateactiveModulesInput | string[]
    clientID?: NullableStringFieldUpdateOperationsInput | string | null
    clientSecret?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearQuarters?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearFormat?: NullableStringFieldUpdateOperationsInput | string | null
    auditYear?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    business?: BusinessUpdateManyWithoutOrganizationNestedInput
    Doctype?: DoctypeUpdateManyWithoutOrganizationNestedInput
    Documents?: DocumentsUpdateManyWithoutOrganizationNestedInput
    entity?: EntityUpdateManyWithoutOrganizationNestedInput
    entityType?: EntityTypeUpdateManyWithoutOrganizationNestedInput
    location?: LocationUpdateManyWithoutOrganizationNestedInput
    role?: RoleUpdateManyWithoutOrganizationNestedInput
    systemType?: SystemTypeUpdateManyWithoutOrganizationNestedInput
    user?: UserUpdateManyWithoutOrganizationNestedInput
    userPersonalisation?: userPersonalisationUpdateManyWithoutOrganizationNestedInput
    ConnectedApps?: ConnectedAppsUpdateManyWithoutOrganizationNestedInput
    unitOfMeasurement?: unitTypeUpdateManyWithoutOrganizationNestedInput
    kpi?: kpiUpdateManyWithoutOrganizationNestedInput
    businessType?: businessTypeUpdateManyWithoutOrganizationNestedInput
    prefixSuffix?: prefixSuffixUpdateManyWithoutOrganizationNestedInput
    serialNumber?: serialNumberUpdateManyWithoutOrganizationNestedInput
    function?: FunctionsUpdateManyWithoutOrganizationNestedInput
    rolesTable?: rolesTableUpdateManyWithoutOrganizationNestedInput
    problem?: ProblemUpdateManyWithoutOrganizationNestedInput
    parts?: PartsUpdateManyWithoutOrganizationNestedInput
    Models?: ModelsUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutSectionInput = {
    kcId?: NullableStringFieldUpdateOperationsInput | string | null
    organizationName?: NullableStringFieldUpdateOperationsInput | string | null
    realmName?: NullableStringFieldUpdateOperationsInput | string | null
    instanceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    principalGeography?: NullableStringFieldUpdateOperationsInput | string | null
    loginUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoutUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    activeModules?: OrganizationUpdateactiveModulesInput | string[]
    clientID?: NullableStringFieldUpdateOperationsInput | string | null
    clientSecret?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearQuarters?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearFormat?: NullableStringFieldUpdateOperationsInput | string | null
    auditYear?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    business?: BusinessUncheckedUpdateManyWithoutOrganizationNestedInput
    Doctype?: DoctypeUncheckedUpdateManyWithoutOrganizationNestedInput
    Documents?: DocumentsUncheckedUpdateManyWithoutOrganizationNestedInput
    entity?: EntityUncheckedUpdateManyWithoutOrganizationNestedInput
    entityType?: EntityTypeUncheckedUpdateManyWithoutOrganizationNestedInput
    location?: LocationUncheckedUpdateManyWithoutOrganizationNestedInput
    role?: RoleUncheckedUpdateManyWithoutOrganizationNestedInput
    systemType?: SystemTypeUncheckedUpdateManyWithoutOrganizationNestedInput
    user?: UserUncheckedUpdateManyWithoutOrganizationNestedInput
    userPersonalisation?: userPersonalisationUncheckedUpdateManyWithoutOrganizationNestedInput
    ConnectedApps?: ConnectedAppsUncheckedUpdateManyWithoutOrganizationNestedInput
    unitOfMeasurement?: unitTypeUncheckedUpdateManyWithoutOrganizationNestedInput
    kpi?: kpiUncheckedUpdateManyWithoutOrganizationNestedInput
    businessType?: businessTypeUncheckedUpdateManyWithoutOrganizationNestedInput
    prefixSuffix?: prefixSuffixUncheckedUpdateManyWithoutOrganizationNestedInput
    serialNumber?: serialNumberUncheckedUpdateManyWithoutOrganizationNestedInput
    function?: FunctionsUncheckedUpdateManyWithoutOrganizationNestedInput
    rolesTable?: rolesTableUncheckedUpdateManyWithoutOrganizationNestedInput
    problem?: ProblemUncheckedUpdateManyWithoutOrganizationNestedInput
    parts?: PartsUncheckedUpdateManyWithoutOrganizationNestedInput
    Models?: ModelsUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationCreateWithoutLocationInput = {
    id?: string
    kcId?: string | null
    organizationName?: string | null
    realmName?: string | null
    instanceUrl?: string | null
    principalGeography?: string | null
    loginUrl?: string | null
    logoutUrl?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    activeModules?: OrganizationCreateactiveModulesInput | string[]
    clientID?: string | null
    clientSecret?: string | null
    fiscalYearQuarters?: string | null
    fiscalYearFormat?: string | null
    auditYear?: string | null
    logoUrl?: string | null
    deleted?: boolean | null
    business?: BusinessCreateNestedManyWithoutOrganizationInput
    Doctype?: DoctypeCreateNestedManyWithoutOrganizationInput
    Documents?: DocumentsCreateNestedManyWithoutOrganizationInput
    entity?: EntityCreateNestedManyWithoutOrganizationInput
    entityType?: EntityTypeCreateNestedManyWithoutOrganizationInput
    role?: RoleCreateNestedManyWithoutOrganizationInput
    section?: SectionCreateNestedManyWithoutOrganizationInput
    systemType?: SystemTypeCreateNestedManyWithoutOrganizationInput
    user?: UserCreateNestedManyWithoutOrganizationInput
    userPersonalisation?: userPersonalisationCreateNestedManyWithoutOrganizationInput
    ConnectedApps?: ConnectedAppsCreateNestedManyWithoutOrganizationInput
    unitOfMeasurement?: unitTypeCreateNestedManyWithoutOrganizationInput
    kpi?: kpiCreateNestedManyWithoutOrganizationInput
    businessType?: businessTypeCreateNestedManyWithoutOrganizationInput
    prefixSuffix?: prefixSuffixCreateNestedManyWithoutOrganizationInput
    serialNumber?: serialNumberCreateNestedManyWithoutOrganizationInput
    function?: FunctionsCreateNestedManyWithoutOrganizationInput
    rolesTable?: rolesTableCreateNestedManyWithoutOrganizationInput
    problem?: ProblemCreateNestedManyWithoutOrganizationInput
    parts?: PartsCreateNestedManyWithoutOrganizationInput
    Models?: ModelsCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutLocationInput = {
    id?: string
    kcId?: string | null
    organizationName?: string | null
    realmName?: string | null
    instanceUrl?: string | null
    principalGeography?: string | null
    loginUrl?: string | null
    logoutUrl?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    activeModules?: OrganizationCreateactiveModulesInput | string[]
    clientID?: string | null
    clientSecret?: string | null
    fiscalYearQuarters?: string | null
    fiscalYearFormat?: string | null
    auditYear?: string | null
    logoUrl?: string | null
    deleted?: boolean | null
    business?: BusinessUncheckedCreateNestedManyWithoutOrganizationInput
    Doctype?: DoctypeUncheckedCreateNestedManyWithoutOrganizationInput
    Documents?: DocumentsUncheckedCreateNestedManyWithoutOrganizationInput
    entity?: EntityUncheckedCreateNestedManyWithoutOrganizationInput
    entityType?: EntityTypeUncheckedCreateNestedManyWithoutOrganizationInput
    role?: RoleUncheckedCreateNestedManyWithoutOrganizationInput
    section?: SectionUncheckedCreateNestedManyWithoutOrganizationInput
    systemType?: SystemTypeUncheckedCreateNestedManyWithoutOrganizationInput
    user?: UserUncheckedCreateNestedManyWithoutOrganizationInput
    userPersonalisation?: userPersonalisationUncheckedCreateNestedManyWithoutOrganizationInput
    ConnectedApps?: ConnectedAppsUncheckedCreateNestedManyWithoutOrganizationInput
    unitOfMeasurement?: unitTypeUncheckedCreateNestedManyWithoutOrganizationInput
    kpi?: kpiUncheckedCreateNestedManyWithoutOrganizationInput
    businessType?: businessTypeUncheckedCreateNestedManyWithoutOrganizationInput
    prefixSuffix?: prefixSuffixUncheckedCreateNestedManyWithoutOrganizationInput
    serialNumber?: serialNumberUncheckedCreateNestedManyWithoutOrganizationInput
    function?: FunctionsUncheckedCreateNestedManyWithoutOrganizationInput
    rolesTable?: rolesTableUncheckedCreateNestedManyWithoutOrganizationInput
    problem?: ProblemUncheckedCreateNestedManyWithoutOrganizationInput
    parts?: PartsUncheckedCreateNestedManyWithoutOrganizationInput
    Models?: ModelsUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutLocationInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutLocationInput, OrganizationUncheckedCreateWithoutLocationInput>
  }

  export type DocumentsCreateWithoutCreatorLocationInput = {
    id?: string
    documentName?: string | null
    documentNumbering?: string | null
    reasonOfCreation?: string | null
    effectiveDate?: Date | string | null
    nextRevisionDate?: Date | string | null
    currentVersion?: string | null
    documentLink?: string | null
    description?: string | null
    tags?: DocumentsCreatetagsInput | string[]
    documentState?: string | null
    system?: DocumentsCreatesystemInput | string[]
    section?: string | null
    revertComment?: string | null
    docType?: string | null
    documentClassification?: string | null
    issueNumber?: string | null
    retireComment?: string | null
    revisionReminderFlag?: boolean | null
    isVersion?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedDate?: Date | string | null
    countNumber?: number | null
    createdBy?: string | null
    distributionList?: string | null
    documentId?: string | null
    reviewers?: DocumentsCreatereviewersInput | string[]
    approvers?: DocumentsCreateapproversInput | string[]
    creators?: DocumentsCreatecreatorsInput | string[]
    distributionUsers?: DocumentsCreatedistributionUsersInput | InputJsonValue[]
    readAccess?: string | null
    readAccessUsers?: DocumentsCreatereadAccessUsersInput | InputJsonValue[]
    versionInfo?: DocumentsCreateversionInfoInput | InputJsonValue[]
    doctype?: DoctypeCreateNestedOneWithoutDocumentsInput
    organization?: OrganizationCreateNestedOneWithoutDocumentsInput
    creatorEntity?: EntityCreateNestedOneWithoutDocumentsInput
    ReferenceDocuments?: ReferenceDocumentsCreateNestedManyWithoutDocumentInput
    DocumentVersions?: DocumentVersionsCreateNestedManyWithoutDocumentInput
    DocumentComments?: DocumentCommentsCreateNestedManyWithoutDocumentInput
    DocumentWorkFlowHistory?: DocumentWorkFlowHistoryCreateNestedManyWithoutDocumentInput
    AdditionalDocumentAdmins?: AdditionalDocumentAdminsCreateNestedManyWithoutDocumentInput
    VersionReferenceDocuments?: VersionReferenceDocumentsCreateNestedManyWithoutDocumentsInput
  }

  export type DocumentsUncheckedCreateWithoutCreatorLocationInput = {
    id?: string
    doctypeId?: string | null
    organizationId?: string | null
    documentName?: string | null
    documentNumbering?: string | null
    reasonOfCreation?: string | null
    effectiveDate?: Date | string | null
    nextRevisionDate?: Date | string | null
    currentVersion?: string | null
    documentLink?: string | null
    description?: string | null
    tags?: DocumentsCreatetagsInput | string[]
    documentState?: string | null
    entityId?: string | null
    system?: DocumentsCreatesystemInput | string[]
    section?: string | null
    revertComment?: string | null
    docType?: string | null
    documentClassification?: string | null
    issueNumber?: string | null
    retireComment?: string | null
    revisionReminderFlag?: boolean | null
    isVersion?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedDate?: Date | string | null
    countNumber?: number | null
    createdBy?: string | null
    distributionList?: string | null
    documentId?: string | null
    reviewers?: DocumentsCreatereviewersInput | string[]
    approvers?: DocumentsCreateapproversInput | string[]
    creators?: DocumentsCreatecreatorsInput | string[]
    distributionUsers?: DocumentsCreatedistributionUsersInput | InputJsonValue[]
    readAccess?: string | null
    readAccessUsers?: DocumentsCreatereadAccessUsersInput | InputJsonValue[]
    versionInfo?: DocumentsCreateversionInfoInput | InputJsonValue[]
    ReferenceDocuments?: ReferenceDocumentsUncheckedCreateNestedManyWithoutDocumentInput
    DocumentVersions?: DocumentVersionsUncheckedCreateNestedManyWithoutDocumentInput
    DocumentComments?: DocumentCommentsUncheckedCreateNestedManyWithoutDocumentInput
    DocumentWorkFlowHistory?: DocumentWorkFlowHistoryUncheckedCreateNestedManyWithoutDocumentInput
    AdditionalDocumentAdmins?: AdditionalDocumentAdminsUncheckedCreateNestedManyWithoutDocumentInput
    VersionReferenceDocuments?: VersionReferenceDocumentsUncheckedCreateNestedManyWithoutDocumentsInput
  }

  export type DocumentsCreateOrConnectWithoutCreatorLocationInput = {
    where: DocumentsWhereUniqueInput
    create: XOR<DocumentsCreateWithoutCreatorLocationInput, DocumentsUncheckedCreateWithoutCreatorLocationInput>
  }

  export type DocumentsCreateManyCreatorLocationInputEnvelope = {
    data: DocumentsCreateManyCreatorLocationInput | DocumentsCreateManyCreatorLocationInput[]
  }

  export type EntityCreateWithoutLocationInput = {
    id?: string
    entityName?: string | null
    description?: string | null
    createdBy?: string | null
    entityId?: string | null
    deleted?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedBy?: string | null
    users?: EntityCreateusersInput | string[]
    sections?: EntityCreatesectionsInput | string[]
    entityType?: EntityTypeCreateNestedOneWithoutEntityInput
    organization?: OrganizationCreateNestedOneWithoutEntityInput
    Doctype?: DoctypeCreateNestedManyWithoutEntityInput
    Documents?: DocumentsCreateNestedManyWithoutCreatorEntityInput
    user?: UserCreateNestedManyWithoutEntityInput
    parts?: PartsCreateNestedManyWithoutEntityInput
    claimToEntity?: ClaimToEntityCreateNestedManyWithoutEntityInput
    function?: FunctionsCreateNestedOneWithoutEntityInput
  }

  export type EntityUncheckedCreateWithoutLocationInput = {
    id?: string
    entityName?: string | null
    description?: string | null
    entityTypeId?: string | null
    organizationId?: string | null
    createdBy?: string | null
    entityId?: string | null
    deleted?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedBy?: string | null
    users?: EntityCreateusersInput | string[]
    sections?: EntityCreatesectionsInput | string[]
    functionId?: string | null
    Doctype?: DoctypeUncheckedCreateNestedManyWithoutEntityInput
    Documents?: DocumentsUncheckedCreateNestedManyWithoutCreatorEntityInput
    user?: UserUncheckedCreateNestedManyWithoutEntityInput
    parts?: PartsUncheckedCreateNestedManyWithoutEntityInput
    claimToEntity?: ClaimToEntityUncheckedCreateNestedManyWithoutEntityInput
  }

  export type EntityCreateOrConnectWithoutLocationInput = {
    where: EntityWhereUniqueInput
    create: XOR<EntityCreateWithoutLocationInput, EntityUncheckedCreateWithoutLocationInput>
  }

  export type EntityCreateManyLocationInputEnvelope = {
    data: EntityCreateManyLocationInput | EntityCreateManyLocationInput[]
  }

  export type LocationBusinessCreateWithoutLocationInput = {
    id?: string
    business?: BusinessCreateNestedOneWithoutLocationInput
  }

  export type LocationBusinessUncheckedCreateWithoutLocationInput = {
    id?: string
    businessId?: string | null
  }

  export type LocationBusinessCreateOrConnectWithoutLocationInput = {
    where: LocationBusinessWhereUniqueInput
    create: XOR<LocationBusinessCreateWithoutLocationInput, LocationBusinessUncheckedCreateWithoutLocationInput>
  }

  export type LocationBusinessCreateManyLocationInputEnvelope = {
    data: LocationBusinessCreateManyLocationInput | LocationBusinessCreateManyLocationInput[]
  }

  export type UserCreateWithoutLocationInput = {
    id?: string
    kcId?: string | null
    email?: string | null
    username?: string | null
    firstname?: string | null
    lastname?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    enabled?: boolean | null
    userType?: string | null
    status?: boolean | null
    avatar?: string | null
    deleted?: boolean | null
    roleId?: UserCreateroleIdInput | string[]
    functionId?: InputJsonValue | null
    additionalUnits?: UserCreateadditionalUnitsInput | string[]
    entity?: EntityCreateNestedOneWithoutUserInput
    organization?: OrganizationCreateNestedOneWithoutUserInput
    AdditionalDocumentAdmins?: AdditionalDocumentAdminsCreateNestedManyWithoutUserInput
    DocumentComments?: DocumentCommentsCreateNestedManyWithoutUserInput
    DocumentVersions?: DocumentVersionsCreateNestedManyWithoutUserInput
    DocumentWorkFlowHistory?: DocumentWorkFlowHistoryCreateNestedManyWithoutUserInput
    Logs?: LogsCreateNestedManyWithoutUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
    documentAdmins?: documentAdminsCreateNestedManyWithoutUserInput
    userPersonalisation?: userPersonalisationCreateNestedManyWithoutUserInput
    auditTrial?: auditTrialCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutLocationInput = {
    id?: string
    kcId?: string | null
    email?: string | null
    username?: string | null
    firstname?: string | null
    lastname?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    enabled?: boolean | null
    organizationId?: string | null
    entityId?: string | null
    userType?: string | null
    status?: boolean | null
    avatar?: string | null
    deleted?: boolean | null
    roleId?: UserCreateroleIdInput | string[]
    functionId?: InputJsonValue | null
    additionalUnits?: UserCreateadditionalUnitsInput | string[]
    AdditionalDocumentAdmins?: AdditionalDocumentAdminsUncheckedCreateNestedManyWithoutUserInput
    DocumentComments?: DocumentCommentsUncheckedCreateNestedManyWithoutUserInput
    DocumentVersions?: DocumentVersionsUncheckedCreateNestedManyWithoutUserInput
    DocumentWorkFlowHistory?: DocumentWorkFlowHistoryUncheckedCreateNestedManyWithoutUserInput
    Logs?: LogsUncheckedCreateNestedManyWithoutUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    documentAdmins?: documentAdminsUncheckedCreateNestedManyWithoutUserInput
    userPersonalisation?: userPersonalisationUncheckedCreateNestedManyWithoutUserInput
    auditTrial?: auditTrialUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutLocationInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLocationInput, UserUncheckedCreateWithoutLocationInput>
  }

  export type UserCreateManyLocationInputEnvelope = {
    data: UserCreateManyLocationInput | UserCreateManyLocationInput[]
  }

  export type unitTypeCreateWithoutLocationInput = {
    id?: string
    unitType: string
    unitOfMeasurement?: unitTypeCreateunitOfMeasurementInput | string[]
    deleted?: boolean | null
    createdModifiedBy: string
    createdModifiedAt?: Date | string
    kpi?: kpiCreateNestedManyWithoutUnitTypeInput
    organization?: OrganizationCreateNestedOneWithoutUnitOfMeasurementInput
    ConnectedApps?: ConnectedAppsCreateNestedOneWithoutUomInput
  }

  export type unitTypeUncheckedCreateWithoutLocationInput = {
    id?: string
    unitType: string
    unitOfMeasurement?: unitTypeCreateunitOfMeasurementInput | string[]
    organizationId?: string | null
    deleted?: boolean | null
    createdModifiedBy: string
    createdModifiedAt?: Date | string
    connectedAppsId?: string | null
    kpi?: kpiUncheckedCreateNestedManyWithoutUnitTypeInput
  }

  export type unitTypeCreateOrConnectWithoutLocationInput = {
    where: unitTypeWhereUniqueInput
    create: XOR<unitTypeCreateWithoutLocationInput, unitTypeUncheckedCreateWithoutLocationInput>
  }

  export type unitTypeCreateManyLocationInputEnvelope = {
    data: unitTypeCreateManyLocationInput | unitTypeCreateManyLocationInput[]
  }

  export type rolesTableCreateWithoutLocationInput = {
    id?: string
    users?: rolesTableCreateusersInput | string[]
    roleId?: rolesTableCreateroleIdInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutRolesTableInput
  }

  export type rolesTableUncheckedCreateWithoutLocationInput = {
    id?: string
    orgId: string
    users?: rolesTableCreateusersInput | string[]
    roleId?: rolesTableCreateroleIdInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type rolesTableCreateOrConnectWithoutLocationInput = {
    where: rolesTableWhereUniqueInput
    create: XOR<rolesTableCreateWithoutLocationInput, rolesTableUncheckedCreateWithoutLocationInput>
  }

  export type rolesTableCreateManyLocationInputEnvelope = {
    data: rolesTableCreateManyLocationInput | rolesTableCreateManyLocationInput[]
  }

  export type RoleCreateWithoutLocationInput = {
    id?: string
    kcId?: string | null
    roleName?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    deleted?: boolean | null
    organization?: OrganizationCreateNestedOneWithoutRoleInput
  }

  export type RoleUncheckedCreateWithoutLocationInput = {
    id?: string
    kcId?: string | null
    roleName?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    deleted?: boolean | null
    organizationId?: string | null
  }

  export type RoleCreateOrConnectWithoutLocationInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutLocationInput, RoleUncheckedCreateWithoutLocationInput>
  }

  export type RoleCreateManyLocationInputEnvelope = {
    data: RoleCreateManyLocationInput | RoleCreateManyLocationInput[]
  }

  export type OrganizationUpsertWithoutLocationInput = {
    update: XOR<OrganizationUpdateWithoutLocationInput, OrganizationUncheckedUpdateWithoutLocationInput>
    create: XOR<OrganizationCreateWithoutLocationInput, OrganizationUncheckedCreateWithoutLocationInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutLocationInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutLocationInput, OrganizationUncheckedUpdateWithoutLocationInput>
  }

  export type OrganizationUpdateWithoutLocationInput = {
    kcId?: NullableStringFieldUpdateOperationsInput | string | null
    organizationName?: NullableStringFieldUpdateOperationsInput | string | null
    realmName?: NullableStringFieldUpdateOperationsInput | string | null
    instanceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    principalGeography?: NullableStringFieldUpdateOperationsInput | string | null
    loginUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoutUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    activeModules?: OrganizationUpdateactiveModulesInput | string[]
    clientID?: NullableStringFieldUpdateOperationsInput | string | null
    clientSecret?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearQuarters?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearFormat?: NullableStringFieldUpdateOperationsInput | string | null
    auditYear?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    business?: BusinessUpdateManyWithoutOrganizationNestedInput
    Doctype?: DoctypeUpdateManyWithoutOrganizationNestedInput
    Documents?: DocumentsUpdateManyWithoutOrganizationNestedInput
    entity?: EntityUpdateManyWithoutOrganizationNestedInput
    entityType?: EntityTypeUpdateManyWithoutOrganizationNestedInput
    role?: RoleUpdateManyWithoutOrganizationNestedInput
    section?: SectionUpdateManyWithoutOrganizationNestedInput
    systemType?: SystemTypeUpdateManyWithoutOrganizationNestedInput
    user?: UserUpdateManyWithoutOrganizationNestedInput
    userPersonalisation?: userPersonalisationUpdateManyWithoutOrganizationNestedInput
    ConnectedApps?: ConnectedAppsUpdateManyWithoutOrganizationNestedInput
    unitOfMeasurement?: unitTypeUpdateManyWithoutOrganizationNestedInput
    kpi?: kpiUpdateManyWithoutOrganizationNestedInput
    businessType?: businessTypeUpdateManyWithoutOrganizationNestedInput
    prefixSuffix?: prefixSuffixUpdateManyWithoutOrganizationNestedInput
    serialNumber?: serialNumberUpdateManyWithoutOrganizationNestedInput
    function?: FunctionsUpdateManyWithoutOrganizationNestedInput
    rolesTable?: rolesTableUpdateManyWithoutOrganizationNestedInput
    problem?: ProblemUpdateManyWithoutOrganizationNestedInput
    parts?: PartsUpdateManyWithoutOrganizationNestedInput
    Models?: ModelsUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutLocationInput = {
    kcId?: NullableStringFieldUpdateOperationsInput | string | null
    organizationName?: NullableStringFieldUpdateOperationsInput | string | null
    realmName?: NullableStringFieldUpdateOperationsInput | string | null
    instanceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    principalGeography?: NullableStringFieldUpdateOperationsInput | string | null
    loginUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoutUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    activeModules?: OrganizationUpdateactiveModulesInput | string[]
    clientID?: NullableStringFieldUpdateOperationsInput | string | null
    clientSecret?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearQuarters?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearFormat?: NullableStringFieldUpdateOperationsInput | string | null
    auditYear?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    business?: BusinessUncheckedUpdateManyWithoutOrganizationNestedInput
    Doctype?: DoctypeUncheckedUpdateManyWithoutOrganizationNestedInput
    Documents?: DocumentsUncheckedUpdateManyWithoutOrganizationNestedInput
    entity?: EntityUncheckedUpdateManyWithoutOrganizationNestedInput
    entityType?: EntityTypeUncheckedUpdateManyWithoutOrganizationNestedInput
    role?: RoleUncheckedUpdateManyWithoutOrganizationNestedInput
    section?: SectionUncheckedUpdateManyWithoutOrganizationNestedInput
    systemType?: SystemTypeUncheckedUpdateManyWithoutOrganizationNestedInput
    user?: UserUncheckedUpdateManyWithoutOrganizationNestedInput
    userPersonalisation?: userPersonalisationUncheckedUpdateManyWithoutOrganizationNestedInput
    ConnectedApps?: ConnectedAppsUncheckedUpdateManyWithoutOrganizationNestedInput
    unitOfMeasurement?: unitTypeUncheckedUpdateManyWithoutOrganizationNestedInput
    kpi?: kpiUncheckedUpdateManyWithoutOrganizationNestedInput
    businessType?: businessTypeUncheckedUpdateManyWithoutOrganizationNestedInput
    prefixSuffix?: prefixSuffixUncheckedUpdateManyWithoutOrganizationNestedInput
    serialNumber?: serialNumberUncheckedUpdateManyWithoutOrganizationNestedInput
    function?: FunctionsUncheckedUpdateManyWithoutOrganizationNestedInput
    rolesTable?: rolesTableUncheckedUpdateManyWithoutOrganizationNestedInput
    problem?: ProblemUncheckedUpdateManyWithoutOrganizationNestedInput
    parts?: PartsUncheckedUpdateManyWithoutOrganizationNestedInput
    Models?: ModelsUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type DocumentsUpsertWithWhereUniqueWithoutCreatorLocationInput = {
    where: DocumentsWhereUniqueInput
    update: XOR<DocumentsUpdateWithoutCreatorLocationInput, DocumentsUncheckedUpdateWithoutCreatorLocationInput>
    create: XOR<DocumentsCreateWithoutCreatorLocationInput, DocumentsUncheckedCreateWithoutCreatorLocationInput>
  }

  export type DocumentsUpdateWithWhereUniqueWithoutCreatorLocationInput = {
    where: DocumentsWhereUniqueInput
    data: XOR<DocumentsUpdateWithoutCreatorLocationInput, DocumentsUncheckedUpdateWithoutCreatorLocationInput>
  }

  export type DocumentsUpdateManyWithWhereWithoutCreatorLocationInput = {
    where: DocumentsScalarWhereInput
    data: XOR<DocumentsUpdateManyMutationInput, DocumentsUncheckedUpdateManyWithoutCreatorLocationInput>
  }

  export type EntityUpsertWithWhereUniqueWithoutLocationInput = {
    where: EntityWhereUniqueInput
    update: XOR<EntityUpdateWithoutLocationInput, EntityUncheckedUpdateWithoutLocationInput>
    create: XOR<EntityCreateWithoutLocationInput, EntityUncheckedCreateWithoutLocationInput>
  }

  export type EntityUpdateWithWhereUniqueWithoutLocationInput = {
    where: EntityWhereUniqueInput
    data: XOR<EntityUpdateWithoutLocationInput, EntityUncheckedUpdateWithoutLocationInput>
  }

  export type EntityUpdateManyWithWhereWithoutLocationInput = {
    where: EntityScalarWhereInput
    data: XOR<EntityUpdateManyMutationInput, EntityUncheckedUpdateManyWithoutLocationInput>
  }

  export type LocationBusinessUpsertWithWhereUniqueWithoutLocationInput = {
    where: LocationBusinessWhereUniqueInput
    update: XOR<LocationBusinessUpdateWithoutLocationInput, LocationBusinessUncheckedUpdateWithoutLocationInput>
    create: XOR<LocationBusinessCreateWithoutLocationInput, LocationBusinessUncheckedCreateWithoutLocationInput>
  }

  export type LocationBusinessUpdateWithWhereUniqueWithoutLocationInput = {
    where: LocationBusinessWhereUniqueInput
    data: XOR<LocationBusinessUpdateWithoutLocationInput, LocationBusinessUncheckedUpdateWithoutLocationInput>
  }

  export type LocationBusinessUpdateManyWithWhereWithoutLocationInput = {
    where: LocationBusinessScalarWhereInput
    data: XOR<LocationBusinessUpdateManyMutationInput, LocationBusinessUncheckedUpdateManyWithoutLocationInput>
  }

  export type UserUpsertWithWhereUniqueWithoutLocationInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutLocationInput, UserUncheckedUpdateWithoutLocationInput>
    create: XOR<UserCreateWithoutLocationInput, UserUncheckedCreateWithoutLocationInput>
  }

  export type UserUpdateWithWhereUniqueWithoutLocationInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutLocationInput, UserUncheckedUpdateWithoutLocationInput>
  }

  export type UserUpdateManyWithWhereWithoutLocationInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutLocationInput>
  }

  export type unitTypeUpsertWithWhereUniqueWithoutLocationInput = {
    where: unitTypeWhereUniqueInput
    update: XOR<unitTypeUpdateWithoutLocationInput, unitTypeUncheckedUpdateWithoutLocationInput>
    create: XOR<unitTypeCreateWithoutLocationInput, unitTypeUncheckedCreateWithoutLocationInput>
  }

  export type unitTypeUpdateWithWhereUniqueWithoutLocationInput = {
    where: unitTypeWhereUniqueInput
    data: XOR<unitTypeUpdateWithoutLocationInput, unitTypeUncheckedUpdateWithoutLocationInput>
  }

  export type unitTypeUpdateManyWithWhereWithoutLocationInput = {
    where: unitTypeScalarWhereInput
    data: XOR<unitTypeUpdateManyMutationInput, unitTypeUncheckedUpdateManyWithoutLocationInput>
  }

  export type rolesTableUpsertWithWhereUniqueWithoutLocationInput = {
    where: rolesTableWhereUniqueInput
    update: XOR<rolesTableUpdateWithoutLocationInput, rolesTableUncheckedUpdateWithoutLocationInput>
    create: XOR<rolesTableCreateWithoutLocationInput, rolesTableUncheckedCreateWithoutLocationInput>
  }

  export type rolesTableUpdateWithWhereUniqueWithoutLocationInput = {
    where: rolesTableWhereUniqueInput
    data: XOR<rolesTableUpdateWithoutLocationInput, rolesTableUncheckedUpdateWithoutLocationInput>
  }

  export type rolesTableUpdateManyWithWhereWithoutLocationInput = {
    where: rolesTableScalarWhereInput
    data: XOR<rolesTableUpdateManyMutationInput, rolesTableUncheckedUpdateManyWithoutLocationInput>
  }

  export type RoleUpsertWithWhereUniqueWithoutLocationInput = {
    where: RoleWhereUniqueInput
    update: XOR<RoleUpdateWithoutLocationInput, RoleUncheckedUpdateWithoutLocationInput>
    create: XOR<RoleCreateWithoutLocationInput, RoleUncheckedCreateWithoutLocationInput>
  }

  export type RoleUpdateWithWhereUniqueWithoutLocationInput = {
    where: RoleWhereUniqueInput
    data: XOR<RoleUpdateWithoutLocationInput, RoleUncheckedUpdateWithoutLocationInput>
  }

  export type RoleUpdateManyWithWhereWithoutLocationInput = {
    where: RoleScalarWhereInput
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyWithoutLocationInput>
  }

  export type EntityTypeCreateWithoutEntityInput = {
    id?: string
    name?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    deleted?: boolean | null
    organization?: OrganizationCreateNestedOneWithoutEntityTypeInput
  }

  export type EntityTypeUncheckedCreateWithoutEntityInput = {
    id?: string
    name?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    organizationId?: string | null
    deleted?: boolean | null
  }

  export type EntityTypeCreateOrConnectWithoutEntityInput = {
    where: EntityTypeWhereUniqueInput
    create: XOR<EntityTypeCreateWithoutEntityInput, EntityTypeUncheckedCreateWithoutEntityInput>
  }

  export type LocationCreateWithoutEntityInput = {
    id?: string
    locationName?: string | null
    locationType?: string | null
    locationId?: string | null
    description?: string | null
    status?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedBy?: string | null
    functionId?: LocationCreatefunctionIdInput | string[]
    deleted?: boolean | null
    users?: LocationCreateusersInput | InputJsonValue[]
    businessTypeId?: string | null
    type?: string | null
    organization?: OrganizationCreateNestedOneWithoutLocationInput
    Documents?: DocumentsCreateNestedManyWithoutCreatorLocationInput
    business?: LocationBusinessCreateNestedManyWithoutLocationInput
    user?: UserCreateNestedManyWithoutLocationInput
    uom?: unitTypeCreateNestedManyWithoutLocationInput
    rolesTable?: rolesTableCreateNestedManyWithoutLocationInput
    Role?: RoleCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateWithoutEntityInput = {
    id?: string
    locationName?: string | null
    locationType?: string | null
    locationId?: string | null
    description?: string | null
    status?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedBy?: string | null
    functionId?: LocationCreatefunctionIdInput | string[]
    deleted?: boolean | null
    organizationId?: string | null
    users?: LocationCreateusersInput | InputJsonValue[]
    businessTypeId?: string | null
    type?: string | null
    Documents?: DocumentsUncheckedCreateNestedManyWithoutCreatorLocationInput
    business?: LocationBusinessUncheckedCreateNestedManyWithoutLocationInput
    user?: UserUncheckedCreateNestedManyWithoutLocationInput
    uom?: unitTypeUncheckedCreateNestedManyWithoutLocationInput
    rolesTable?: rolesTableUncheckedCreateNestedManyWithoutLocationInput
    Role?: RoleUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationCreateOrConnectWithoutEntityInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutEntityInput, LocationUncheckedCreateWithoutEntityInput>
  }

  export type OrganizationCreateWithoutEntityInput = {
    id?: string
    kcId?: string | null
    organizationName?: string | null
    realmName?: string | null
    instanceUrl?: string | null
    principalGeography?: string | null
    loginUrl?: string | null
    logoutUrl?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    activeModules?: OrganizationCreateactiveModulesInput | string[]
    clientID?: string | null
    clientSecret?: string | null
    fiscalYearQuarters?: string | null
    fiscalYearFormat?: string | null
    auditYear?: string | null
    logoUrl?: string | null
    deleted?: boolean | null
    business?: BusinessCreateNestedManyWithoutOrganizationInput
    Doctype?: DoctypeCreateNestedManyWithoutOrganizationInput
    Documents?: DocumentsCreateNestedManyWithoutOrganizationInput
    entityType?: EntityTypeCreateNestedManyWithoutOrganizationInput
    location?: LocationCreateNestedManyWithoutOrganizationInput
    role?: RoleCreateNestedManyWithoutOrganizationInput
    section?: SectionCreateNestedManyWithoutOrganizationInput
    systemType?: SystemTypeCreateNestedManyWithoutOrganizationInput
    user?: UserCreateNestedManyWithoutOrganizationInput
    userPersonalisation?: userPersonalisationCreateNestedManyWithoutOrganizationInput
    ConnectedApps?: ConnectedAppsCreateNestedManyWithoutOrganizationInput
    unitOfMeasurement?: unitTypeCreateNestedManyWithoutOrganizationInput
    kpi?: kpiCreateNestedManyWithoutOrganizationInput
    businessType?: businessTypeCreateNestedManyWithoutOrganizationInput
    prefixSuffix?: prefixSuffixCreateNestedManyWithoutOrganizationInput
    serialNumber?: serialNumberCreateNestedManyWithoutOrganizationInput
    function?: FunctionsCreateNestedManyWithoutOrganizationInput
    rolesTable?: rolesTableCreateNestedManyWithoutOrganizationInput
    problem?: ProblemCreateNestedManyWithoutOrganizationInput
    parts?: PartsCreateNestedManyWithoutOrganizationInput
    Models?: ModelsCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutEntityInput = {
    id?: string
    kcId?: string | null
    organizationName?: string | null
    realmName?: string | null
    instanceUrl?: string | null
    principalGeography?: string | null
    loginUrl?: string | null
    logoutUrl?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    activeModules?: OrganizationCreateactiveModulesInput | string[]
    clientID?: string | null
    clientSecret?: string | null
    fiscalYearQuarters?: string | null
    fiscalYearFormat?: string | null
    auditYear?: string | null
    logoUrl?: string | null
    deleted?: boolean | null
    business?: BusinessUncheckedCreateNestedManyWithoutOrganizationInput
    Doctype?: DoctypeUncheckedCreateNestedManyWithoutOrganizationInput
    Documents?: DocumentsUncheckedCreateNestedManyWithoutOrganizationInput
    entityType?: EntityTypeUncheckedCreateNestedManyWithoutOrganizationInput
    location?: LocationUncheckedCreateNestedManyWithoutOrganizationInput
    role?: RoleUncheckedCreateNestedManyWithoutOrganizationInput
    section?: SectionUncheckedCreateNestedManyWithoutOrganizationInput
    systemType?: SystemTypeUncheckedCreateNestedManyWithoutOrganizationInput
    user?: UserUncheckedCreateNestedManyWithoutOrganizationInput
    userPersonalisation?: userPersonalisationUncheckedCreateNestedManyWithoutOrganizationInput
    ConnectedApps?: ConnectedAppsUncheckedCreateNestedManyWithoutOrganizationInput
    unitOfMeasurement?: unitTypeUncheckedCreateNestedManyWithoutOrganizationInput
    kpi?: kpiUncheckedCreateNestedManyWithoutOrganizationInput
    businessType?: businessTypeUncheckedCreateNestedManyWithoutOrganizationInput
    prefixSuffix?: prefixSuffixUncheckedCreateNestedManyWithoutOrganizationInput
    serialNumber?: serialNumberUncheckedCreateNestedManyWithoutOrganizationInput
    function?: FunctionsUncheckedCreateNestedManyWithoutOrganizationInput
    rolesTable?: rolesTableUncheckedCreateNestedManyWithoutOrganizationInput
    problem?: ProblemUncheckedCreateNestedManyWithoutOrganizationInput
    parts?: PartsUncheckedCreateNestedManyWithoutOrganizationInput
    Models?: ModelsUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutEntityInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutEntityInput, OrganizationUncheckedCreateWithoutEntityInput>
  }

  export type DoctypeCreateWithoutEntityInput = {
    id?: string
    locationId?: DoctypeCreatelocationIdInput | string[]
    documentTypeName?: string | null
    documentNumbering?: string | null
    reviewFrequency?: number | null
    revisionRemind?: number | null
    prefix?: string | null
    suffix?: string | null
    readAccess?: string | null
    readAccessUsers?: DoctypeCreatereadAccessUsersInput | InputJsonValue[]
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedBy?: string | null
    createdBy?: string | null
    applicable_systems?: DoctypeCreateapplicable_systemsInput | InputJsonValue[]
    users?: DoctypeCreateusersInput | InputJsonValue[]
    document_classification?: string | null
    distributionUsers?: DoctypeCreatedistributionUsersInput | InputJsonValue[]
    currentVersion: string
    distributionList?: string | null
    organization?: OrganizationCreateNestedOneWithoutDoctypeInput
    Documents?: DocumentsCreateNestedManyWithoutDoctypeInput
    documentAdmins?: documentAdminsCreateNestedManyWithoutDoctypeInput
  }

  export type DoctypeUncheckedCreateWithoutEntityInput = {
    id?: string
    locationId?: DoctypeCreatelocationIdInput | string[]
    documentTypeName?: string | null
    documentNumbering?: string | null
    reviewFrequency?: number | null
    revisionRemind?: number | null
    prefix?: string | null
    suffix?: string | null
    organizationId?: string | null
    readAccess?: string | null
    readAccessUsers?: DoctypeCreatereadAccessUsersInput | InputJsonValue[]
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedBy?: string | null
    createdBy?: string | null
    applicable_systems?: DoctypeCreateapplicable_systemsInput | InputJsonValue[]
    users?: DoctypeCreateusersInput | InputJsonValue[]
    document_classification?: string | null
    distributionUsers?: DoctypeCreatedistributionUsersInput | InputJsonValue[]
    currentVersion: string
    distributionList?: string | null
    Documents?: DocumentsUncheckedCreateNestedManyWithoutDoctypeInput
    documentAdmins?: documentAdminsUncheckedCreateNestedManyWithoutDoctypeInput
  }

  export type DoctypeCreateOrConnectWithoutEntityInput = {
    where: DoctypeWhereUniqueInput
    create: XOR<DoctypeCreateWithoutEntityInput, DoctypeUncheckedCreateWithoutEntityInput>
  }

  export type DoctypeCreateManyEntityInputEnvelope = {
    data: DoctypeCreateManyEntityInput | DoctypeCreateManyEntityInput[]
  }

  export type DocumentsCreateWithoutCreatorEntityInput = {
    id?: string
    documentName?: string | null
    documentNumbering?: string | null
    reasonOfCreation?: string | null
    effectiveDate?: Date | string | null
    nextRevisionDate?: Date | string | null
    currentVersion?: string | null
    documentLink?: string | null
    description?: string | null
    tags?: DocumentsCreatetagsInput | string[]
    documentState?: string | null
    system?: DocumentsCreatesystemInput | string[]
    section?: string | null
    revertComment?: string | null
    docType?: string | null
    documentClassification?: string | null
    issueNumber?: string | null
    retireComment?: string | null
    revisionReminderFlag?: boolean | null
    isVersion?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedDate?: Date | string | null
    countNumber?: number | null
    createdBy?: string | null
    distributionList?: string | null
    documentId?: string | null
    reviewers?: DocumentsCreatereviewersInput | string[]
    approvers?: DocumentsCreateapproversInput | string[]
    creators?: DocumentsCreatecreatorsInput | string[]
    distributionUsers?: DocumentsCreatedistributionUsersInput | InputJsonValue[]
    readAccess?: string | null
    readAccessUsers?: DocumentsCreatereadAccessUsersInput | InputJsonValue[]
    versionInfo?: DocumentsCreateversionInfoInput | InputJsonValue[]
    doctype?: DoctypeCreateNestedOneWithoutDocumentsInput
    organization?: OrganizationCreateNestedOneWithoutDocumentsInput
    creatorLocation?: LocationCreateNestedOneWithoutDocumentsInput
    ReferenceDocuments?: ReferenceDocumentsCreateNestedManyWithoutDocumentInput
    DocumentVersions?: DocumentVersionsCreateNestedManyWithoutDocumentInput
    DocumentComments?: DocumentCommentsCreateNestedManyWithoutDocumentInput
    DocumentWorkFlowHistory?: DocumentWorkFlowHistoryCreateNestedManyWithoutDocumentInput
    AdditionalDocumentAdmins?: AdditionalDocumentAdminsCreateNestedManyWithoutDocumentInput
    VersionReferenceDocuments?: VersionReferenceDocumentsCreateNestedManyWithoutDocumentsInput
  }

  export type DocumentsUncheckedCreateWithoutCreatorEntityInput = {
    id?: string
    doctypeId?: string | null
    organizationId?: string | null
    documentName?: string | null
    documentNumbering?: string | null
    reasonOfCreation?: string | null
    effectiveDate?: Date | string | null
    nextRevisionDate?: Date | string | null
    currentVersion?: string | null
    documentLink?: string | null
    description?: string | null
    tags?: DocumentsCreatetagsInput | string[]
    documentState?: string | null
    locationId: string
    system?: DocumentsCreatesystemInput | string[]
    section?: string | null
    revertComment?: string | null
    docType?: string | null
    documentClassification?: string | null
    issueNumber?: string | null
    retireComment?: string | null
    revisionReminderFlag?: boolean | null
    isVersion?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedDate?: Date | string | null
    countNumber?: number | null
    createdBy?: string | null
    distributionList?: string | null
    documentId?: string | null
    reviewers?: DocumentsCreatereviewersInput | string[]
    approvers?: DocumentsCreateapproversInput | string[]
    creators?: DocumentsCreatecreatorsInput | string[]
    distributionUsers?: DocumentsCreatedistributionUsersInput | InputJsonValue[]
    readAccess?: string | null
    readAccessUsers?: DocumentsCreatereadAccessUsersInput | InputJsonValue[]
    versionInfo?: DocumentsCreateversionInfoInput | InputJsonValue[]
    ReferenceDocuments?: ReferenceDocumentsUncheckedCreateNestedManyWithoutDocumentInput
    DocumentVersions?: DocumentVersionsUncheckedCreateNestedManyWithoutDocumentInput
    DocumentComments?: DocumentCommentsUncheckedCreateNestedManyWithoutDocumentInput
    DocumentWorkFlowHistory?: DocumentWorkFlowHistoryUncheckedCreateNestedManyWithoutDocumentInput
    AdditionalDocumentAdmins?: AdditionalDocumentAdminsUncheckedCreateNestedManyWithoutDocumentInput
    VersionReferenceDocuments?: VersionReferenceDocumentsUncheckedCreateNestedManyWithoutDocumentsInput
  }

  export type DocumentsCreateOrConnectWithoutCreatorEntityInput = {
    where: DocumentsWhereUniqueInput
    create: XOR<DocumentsCreateWithoutCreatorEntityInput, DocumentsUncheckedCreateWithoutCreatorEntityInput>
  }

  export type DocumentsCreateManyCreatorEntityInputEnvelope = {
    data: DocumentsCreateManyCreatorEntityInput | DocumentsCreateManyCreatorEntityInput[]
  }

  export type UserCreateWithoutEntityInput = {
    id?: string
    kcId?: string | null
    email?: string | null
    username?: string | null
    firstname?: string | null
    lastname?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    enabled?: boolean | null
    userType?: string | null
    status?: boolean | null
    avatar?: string | null
    deleted?: boolean | null
    roleId?: UserCreateroleIdInput | string[]
    functionId?: InputJsonValue | null
    additionalUnits?: UserCreateadditionalUnitsInput | string[]
    location?: LocationCreateNestedOneWithoutUserInput
    organization?: OrganizationCreateNestedOneWithoutUserInput
    AdditionalDocumentAdmins?: AdditionalDocumentAdminsCreateNestedManyWithoutUserInput
    DocumentComments?: DocumentCommentsCreateNestedManyWithoutUserInput
    DocumentVersions?: DocumentVersionsCreateNestedManyWithoutUserInput
    DocumentWorkFlowHistory?: DocumentWorkFlowHistoryCreateNestedManyWithoutUserInput
    Logs?: LogsCreateNestedManyWithoutUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
    documentAdmins?: documentAdminsCreateNestedManyWithoutUserInput
    userPersonalisation?: userPersonalisationCreateNestedManyWithoutUserInput
    auditTrial?: auditTrialCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutEntityInput = {
    id?: string
    kcId?: string | null
    email?: string | null
    username?: string | null
    firstname?: string | null
    lastname?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    enabled?: boolean | null
    organizationId?: string | null
    locationId?: string | null
    userType?: string | null
    status?: boolean | null
    avatar?: string | null
    deleted?: boolean | null
    roleId?: UserCreateroleIdInput | string[]
    functionId?: InputJsonValue | null
    additionalUnits?: UserCreateadditionalUnitsInput | string[]
    AdditionalDocumentAdmins?: AdditionalDocumentAdminsUncheckedCreateNestedManyWithoutUserInput
    DocumentComments?: DocumentCommentsUncheckedCreateNestedManyWithoutUserInput
    DocumentVersions?: DocumentVersionsUncheckedCreateNestedManyWithoutUserInput
    DocumentWorkFlowHistory?: DocumentWorkFlowHistoryUncheckedCreateNestedManyWithoutUserInput
    Logs?: LogsUncheckedCreateNestedManyWithoutUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    documentAdmins?: documentAdminsUncheckedCreateNestedManyWithoutUserInput
    userPersonalisation?: userPersonalisationUncheckedCreateNestedManyWithoutUserInput
    auditTrial?: auditTrialUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutEntityInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEntityInput, UserUncheckedCreateWithoutEntityInput>
  }

  export type UserCreateManyEntityInputEnvelope = {
    data: UserCreateManyEntityInput | UserCreateManyEntityInput[]
  }

  export type PartsCreateWithoutEntityInput = {
    id?: string
    partNo: string
    partName: string
    description?: string | null
    claimId?: PartsCreateclaimIdInput | string[]
    claims?: ClaimCreateNestedManyWithoutPartsInput
    organization?: OrganizationCreateNestedOneWithoutPartsInput
    models?: ModelsCreateNestedManyWithoutPartsInput
  }

  export type PartsUncheckedCreateWithoutEntityInput = {
    id?: string
    partNo: string
    partName: string
    description?: string | null
    organizationId?: string | null
    claimId?: PartsCreateclaimIdInput | string[]
    modelsId?: PartsCreatemodelsIdInput | string[]
    claims?: ClaimUncheckedCreateNestedManyWithoutPartsInput
    models?: ModelsUncheckedCreateNestedManyWithoutPartsInput
  }

  export type PartsCreateOrConnectWithoutEntityInput = {
    where: PartsWhereUniqueInput
    create: XOR<PartsCreateWithoutEntityInput, PartsUncheckedCreateWithoutEntityInput>
  }

  export type PartsCreateManyEntityInputEnvelope = {
    data: PartsCreateManyEntityInput | PartsCreateManyEntityInput[]
  }

  export type ClaimToEntityCreateWithoutEntityInput = {
    id?: string
    claim: ClaimCreateNestedOneWithoutClaimToEntityInput
  }

  export type ClaimToEntityUncheckedCreateWithoutEntityInput = {
    id?: string
    claimId: string
  }

  export type ClaimToEntityCreateOrConnectWithoutEntityInput = {
    where: ClaimToEntityWhereUniqueInput
    create: XOR<ClaimToEntityCreateWithoutEntityInput, ClaimToEntityUncheckedCreateWithoutEntityInput>
  }

  export type ClaimToEntityCreateManyEntityInputEnvelope = {
    data: ClaimToEntityCreateManyEntityInput | ClaimToEntityCreateManyEntityInput[]
  }

  export type FunctionsCreateWithoutEntityInput = {
    id?: string
    name?: string | null
    functionId?: string | null
    description?: string | null
    functionHead?: FunctionsCreatefunctionHeadInput | string[]
    functionSpoc?: FunctionsCreatefunctionSpocInput | string[]
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    deleted?: boolean | null
    type?: boolean
    locationId?: FunctionsCreatelocationIdInput | string[]
    businessId?: FunctionsCreatebusinessIdInput | string[]
    unitId?: string | null
    organization?: OrganizationCreateNestedOneWithoutFunctionInput
  }

  export type FunctionsUncheckedCreateWithoutEntityInput = {
    id?: string
    name?: string | null
    functionId?: string | null
    description?: string | null
    functionHead?: FunctionsCreatefunctionHeadInput | string[]
    functionSpoc?: FunctionsCreatefunctionSpocInput | string[]
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    deleted?: boolean | null
    organizationId?: string | null
    type?: boolean
    locationId?: FunctionsCreatelocationIdInput | string[]
    businessId?: FunctionsCreatebusinessIdInput | string[]
    unitId?: string | null
  }

  export type FunctionsCreateOrConnectWithoutEntityInput = {
    where: FunctionsWhereUniqueInput
    create: XOR<FunctionsCreateWithoutEntityInput, FunctionsUncheckedCreateWithoutEntityInput>
  }

  export type EntityTypeUpsertWithoutEntityInput = {
    update: XOR<EntityTypeUpdateWithoutEntityInput, EntityTypeUncheckedUpdateWithoutEntityInput>
    create: XOR<EntityTypeCreateWithoutEntityInput, EntityTypeUncheckedCreateWithoutEntityInput>
    where?: EntityTypeWhereInput
  }

  export type EntityTypeUpdateToOneWithWhereWithoutEntityInput = {
    where?: EntityTypeWhereInput
    data: XOR<EntityTypeUpdateWithoutEntityInput, EntityTypeUncheckedUpdateWithoutEntityInput>
  }

  export type EntityTypeUpdateWithoutEntityInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    organization?: OrganizationUpdateOneWithoutEntityTypeNestedInput
  }

  export type EntityTypeUncheckedUpdateWithoutEntityInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type LocationUpsertWithoutEntityInput = {
    update: XOR<LocationUpdateWithoutEntityInput, LocationUncheckedUpdateWithoutEntityInput>
    create: XOR<LocationCreateWithoutEntityInput, LocationUncheckedCreateWithoutEntityInput>
    where?: LocationWhereInput
  }

  export type LocationUpdateToOneWithWhereWithoutEntityInput = {
    where?: LocationWhereInput
    data: XOR<LocationUpdateWithoutEntityInput, LocationUncheckedUpdateWithoutEntityInput>
  }

  export type LocationUpdateWithoutEntityInput = {
    locationName?: NullableStringFieldUpdateOperationsInput | string | null
    locationType?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    functionId?: LocationUpdatefunctionIdInput | string[]
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    users?: LocationUpdateusersInput | InputJsonValue[]
    businessTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: OrganizationUpdateOneWithoutLocationNestedInput
    Documents?: DocumentsUpdateManyWithoutCreatorLocationNestedInput
    business?: LocationBusinessUpdateManyWithoutLocationNestedInput
    user?: UserUpdateManyWithoutLocationNestedInput
    uom?: unitTypeUpdateManyWithoutLocationNestedInput
    rolesTable?: rolesTableUpdateManyWithoutLocationNestedInput
    Role?: RoleUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateWithoutEntityInput = {
    locationName?: NullableStringFieldUpdateOperationsInput | string | null
    locationType?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    functionId?: LocationUpdatefunctionIdInput | string[]
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    users?: LocationUpdateusersInput | InputJsonValue[]
    businessTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    Documents?: DocumentsUncheckedUpdateManyWithoutCreatorLocationNestedInput
    business?: LocationBusinessUncheckedUpdateManyWithoutLocationNestedInput
    user?: UserUncheckedUpdateManyWithoutLocationNestedInput
    uom?: unitTypeUncheckedUpdateManyWithoutLocationNestedInput
    rolesTable?: rolesTableUncheckedUpdateManyWithoutLocationNestedInput
    Role?: RoleUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type OrganizationUpsertWithoutEntityInput = {
    update: XOR<OrganizationUpdateWithoutEntityInput, OrganizationUncheckedUpdateWithoutEntityInput>
    create: XOR<OrganizationCreateWithoutEntityInput, OrganizationUncheckedCreateWithoutEntityInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutEntityInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutEntityInput, OrganizationUncheckedUpdateWithoutEntityInput>
  }

  export type OrganizationUpdateWithoutEntityInput = {
    kcId?: NullableStringFieldUpdateOperationsInput | string | null
    organizationName?: NullableStringFieldUpdateOperationsInput | string | null
    realmName?: NullableStringFieldUpdateOperationsInput | string | null
    instanceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    principalGeography?: NullableStringFieldUpdateOperationsInput | string | null
    loginUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoutUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    activeModules?: OrganizationUpdateactiveModulesInput | string[]
    clientID?: NullableStringFieldUpdateOperationsInput | string | null
    clientSecret?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearQuarters?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearFormat?: NullableStringFieldUpdateOperationsInput | string | null
    auditYear?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    business?: BusinessUpdateManyWithoutOrganizationNestedInput
    Doctype?: DoctypeUpdateManyWithoutOrganizationNestedInput
    Documents?: DocumentsUpdateManyWithoutOrganizationNestedInput
    entityType?: EntityTypeUpdateManyWithoutOrganizationNestedInput
    location?: LocationUpdateManyWithoutOrganizationNestedInput
    role?: RoleUpdateManyWithoutOrganizationNestedInput
    section?: SectionUpdateManyWithoutOrganizationNestedInput
    systemType?: SystemTypeUpdateManyWithoutOrganizationNestedInput
    user?: UserUpdateManyWithoutOrganizationNestedInput
    userPersonalisation?: userPersonalisationUpdateManyWithoutOrganizationNestedInput
    ConnectedApps?: ConnectedAppsUpdateManyWithoutOrganizationNestedInput
    unitOfMeasurement?: unitTypeUpdateManyWithoutOrganizationNestedInput
    kpi?: kpiUpdateManyWithoutOrganizationNestedInput
    businessType?: businessTypeUpdateManyWithoutOrganizationNestedInput
    prefixSuffix?: prefixSuffixUpdateManyWithoutOrganizationNestedInput
    serialNumber?: serialNumberUpdateManyWithoutOrganizationNestedInput
    function?: FunctionsUpdateManyWithoutOrganizationNestedInput
    rolesTable?: rolesTableUpdateManyWithoutOrganizationNestedInput
    problem?: ProblemUpdateManyWithoutOrganizationNestedInput
    parts?: PartsUpdateManyWithoutOrganizationNestedInput
    Models?: ModelsUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutEntityInput = {
    kcId?: NullableStringFieldUpdateOperationsInput | string | null
    organizationName?: NullableStringFieldUpdateOperationsInput | string | null
    realmName?: NullableStringFieldUpdateOperationsInput | string | null
    instanceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    principalGeography?: NullableStringFieldUpdateOperationsInput | string | null
    loginUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoutUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    activeModules?: OrganizationUpdateactiveModulesInput | string[]
    clientID?: NullableStringFieldUpdateOperationsInput | string | null
    clientSecret?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearQuarters?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearFormat?: NullableStringFieldUpdateOperationsInput | string | null
    auditYear?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    business?: BusinessUncheckedUpdateManyWithoutOrganizationNestedInput
    Doctype?: DoctypeUncheckedUpdateManyWithoutOrganizationNestedInput
    Documents?: DocumentsUncheckedUpdateManyWithoutOrganizationNestedInput
    entityType?: EntityTypeUncheckedUpdateManyWithoutOrganizationNestedInput
    location?: LocationUncheckedUpdateManyWithoutOrganizationNestedInput
    role?: RoleUncheckedUpdateManyWithoutOrganizationNestedInput
    section?: SectionUncheckedUpdateManyWithoutOrganizationNestedInput
    systemType?: SystemTypeUncheckedUpdateManyWithoutOrganizationNestedInput
    user?: UserUncheckedUpdateManyWithoutOrganizationNestedInput
    userPersonalisation?: userPersonalisationUncheckedUpdateManyWithoutOrganizationNestedInput
    ConnectedApps?: ConnectedAppsUncheckedUpdateManyWithoutOrganizationNestedInput
    unitOfMeasurement?: unitTypeUncheckedUpdateManyWithoutOrganizationNestedInput
    kpi?: kpiUncheckedUpdateManyWithoutOrganizationNestedInput
    businessType?: businessTypeUncheckedUpdateManyWithoutOrganizationNestedInput
    prefixSuffix?: prefixSuffixUncheckedUpdateManyWithoutOrganizationNestedInput
    serialNumber?: serialNumberUncheckedUpdateManyWithoutOrganizationNestedInput
    function?: FunctionsUncheckedUpdateManyWithoutOrganizationNestedInput
    rolesTable?: rolesTableUncheckedUpdateManyWithoutOrganizationNestedInput
    problem?: ProblemUncheckedUpdateManyWithoutOrganizationNestedInput
    parts?: PartsUncheckedUpdateManyWithoutOrganizationNestedInput
    Models?: ModelsUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type DoctypeUpsertWithWhereUniqueWithoutEntityInput = {
    where: DoctypeWhereUniqueInput
    update: XOR<DoctypeUpdateWithoutEntityInput, DoctypeUncheckedUpdateWithoutEntityInput>
    create: XOR<DoctypeCreateWithoutEntityInput, DoctypeUncheckedCreateWithoutEntityInput>
  }

  export type DoctypeUpdateWithWhereUniqueWithoutEntityInput = {
    where: DoctypeWhereUniqueInput
    data: XOR<DoctypeUpdateWithoutEntityInput, DoctypeUncheckedUpdateWithoutEntityInput>
  }

  export type DoctypeUpdateManyWithWhereWithoutEntityInput = {
    where: DoctypeScalarWhereInput
    data: XOR<DoctypeUpdateManyMutationInput, DoctypeUncheckedUpdateManyWithoutEntityInput>
  }

  export type DocumentsUpsertWithWhereUniqueWithoutCreatorEntityInput = {
    where: DocumentsWhereUniqueInput
    update: XOR<DocumentsUpdateWithoutCreatorEntityInput, DocumentsUncheckedUpdateWithoutCreatorEntityInput>
    create: XOR<DocumentsCreateWithoutCreatorEntityInput, DocumentsUncheckedCreateWithoutCreatorEntityInput>
  }

  export type DocumentsUpdateWithWhereUniqueWithoutCreatorEntityInput = {
    where: DocumentsWhereUniqueInput
    data: XOR<DocumentsUpdateWithoutCreatorEntityInput, DocumentsUncheckedUpdateWithoutCreatorEntityInput>
  }

  export type DocumentsUpdateManyWithWhereWithoutCreatorEntityInput = {
    where: DocumentsScalarWhereInput
    data: XOR<DocumentsUpdateManyMutationInput, DocumentsUncheckedUpdateManyWithoutCreatorEntityInput>
  }

  export type UserUpsertWithWhereUniqueWithoutEntityInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutEntityInput, UserUncheckedUpdateWithoutEntityInput>
    create: XOR<UserCreateWithoutEntityInput, UserUncheckedCreateWithoutEntityInput>
  }

  export type UserUpdateWithWhereUniqueWithoutEntityInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutEntityInput, UserUncheckedUpdateWithoutEntityInput>
  }

  export type UserUpdateManyWithWhereWithoutEntityInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutEntityInput>
  }

  export type PartsUpsertWithWhereUniqueWithoutEntityInput = {
    where: PartsWhereUniqueInput
    update: XOR<PartsUpdateWithoutEntityInput, PartsUncheckedUpdateWithoutEntityInput>
    create: XOR<PartsCreateWithoutEntityInput, PartsUncheckedCreateWithoutEntityInput>
  }

  export type PartsUpdateWithWhereUniqueWithoutEntityInput = {
    where: PartsWhereUniqueInput
    data: XOR<PartsUpdateWithoutEntityInput, PartsUncheckedUpdateWithoutEntityInput>
  }

  export type PartsUpdateManyWithWhereWithoutEntityInput = {
    where: PartsScalarWhereInput
    data: XOR<PartsUpdateManyMutationInput, PartsUncheckedUpdateManyWithoutEntityInput>
  }

  export type ClaimToEntityUpsertWithWhereUniqueWithoutEntityInput = {
    where: ClaimToEntityWhereUniqueInput
    update: XOR<ClaimToEntityUpdateWithoutEntityInput, ClaimToEntityUncheckedUpdateWithoutEntityInput>
    create: XOR<ClaimToEntityCreateWithoutEntityInput, ClaimToEntityUncheckedCreateWithoutEntityInput>
  }

  export type ClaimToEntityUpdateWithWhereUniqueWithoutEntityInput = {
    where: ClaimToEntityWhereUniqueInput
    data: XOR<ClaimToEntityUpdateWithoutEntityInput, ClaimToEntityUncheckedUpdateWithoutEntityInput>
  }

  export type ClaimToEntityUpdateManyWithWhereWithoutEntityInput = {
    where: ClaimToEntityScalarWhereInput
    data: XOR<ClaimToEntityUpdateManyMutationInput, ClaimToEntityUncheckedUpdateManyWithoutEntityInput>
  }

  export type FunctionsUpsertWithoutEntityInput = {
    update: XOR<FunctionsUpdateWithoutEntityInput, FunctionsUncheckedUpdateWithoutEntityInput>
    create: XOR<FunctionsCreateWithoutEntityInput, FunctionsUncheckedCreateWithoutEntityInput>
    where?: FunctionsWhereInput
  }

  export type FunctionsUpdateToOneWithWhereWithoutEntityInput = {
    where?: FunctionsWhereInput
    data: XOR<FunctionsUpdateWithoutEntityInput, FunctionsUncheckedUpdateWithoutEntityInput>
  }

  export type FunctionsUpdateWithoutEntityInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    functionId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    functionHead?: FunctionsUpdatefunctionHeadInput | string[]
    functionSpoc?: FunctionsUpdatefunctionSpocInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    type?: BoolFieldUpdateOperationsInput | boolean
    locationId?: FunctionsUpdatelocationIdInput | string[]
    businessId?: FunctionsUpdatebusinessIdInput | string[]
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: OrganizationUpdateOneWithoutFunctionNestedInput
  }

  export type FunctionsUncheckedUpdateWithoutEntityInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    functionId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    functionHead?: FunctionsUpdatefunctionHeadInput | string[]
    functionSpoc?: FunctionsUpdatefunctionSpocInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: BoolFieldUpdateOperationsInput | boolean
    locationId?: FunctionsUpdatelocationIdInput | string[]
    businessId?: FunctionsUpdatebusinessIdInput | string[]
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BusinessCreateWithoutLocationInput = {
    id?: string
    name?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    deleted?: boolean | null
    organization?: OrganizationCreateNestedOneWithoutBusinessInput
  }

  export type BusinessUncheckedCreateWithoutLocationInput = {
    id?: string
    name?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    organizationId?: string | null
    deleted?: boolean | null
  }

  export type BusinessCreateOrConnectWithoutLocationInput = {
    where: BusinessWhereUniqueInput
    create: XOR<BusinessCreateWithoutLocationInput, BusinessUncheckedCreateWithoutLocationInput>
  }

  export type LocationCreateWithoutBusinessInput = {
    id?: string
    locationName?: string | null
    locationType?: string | null
    locationId?: string | null
    description?: string | null
    status?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedBy?: string | null
    functionId?: LocationCreatefunctionIdInput | string[]
    deleted?: boolean | null
    users?: LocationCreateusersInput | InputJsonValue[]
    businessTypeId?: string | null
    type?: string | null
    organization?: OrganizationCreateNestedOneWithoutLocationInput
    Documents?: DocumentsCreateNestedManyWithoutCreatorLocationInput
    entity?: EntityCreateNestedManyWithoutLocationInput
    user?: UserCreateNestedManyWithoutLocationInput
    uom?: unitTypeCreateNestedManyWithoutLocationInput
    rolesTable?: rolesTableCreateNestedManyWithoutLocationInput
    Role?: RoleCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateWithoutBusinessInput = {
    id?: string
    locationName?: string | null
    locationType?: string | null
    locationId?: string | null
    description?: string | null
    status?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedBy?: string | null
    functionId?: LocationCreatefunctionIdInput | string[]
    deleted?: boolean | null
    organizationId?: string | null
    users?: LocationCreateusersInput | InputJsonValue[]
    businessTypeId?: string | null
    type?: string | null
    Documents?: DocumentsUncheckedCreateNestedManyWithoutCreatorLocationInput
    entity?: EntityUncheckedCreateNestedManyWithoutLocationInput
    user?: UserUncheckedCreateNestedManyWithoutLocationInput
    uom?: unitTypeUncheckedCreateNestedManyWithoutLocationInput
    rolesTable?: rolesTableUncheckedCreateNestedManyWithoutLocationInput
    Role?: RoleUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationCreateOrConnectWithoutBusinessInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutBusinessInput, LocationUncheckedCreateWithoutBusinessInput>
  }

  export type BusinessUpsertWithoutLocationInput = {
    update: XOR<BusinessUpdateWithoutLocationInput, BusinessUncheckedUpdateWithoutLocationInput>
    create: XOR<BusinessCreateWithoutLocationInput, BusinessUncheckedCreateWithoutLocationInput>
    where?: BusinessWhereInput
  }

  export type BusinessUpdateToOneWithWhereWithoutLocationInput = {
    where?: BusinessWhereInput
    data: XOR<BusinessUpdateWithoutLocationInput, BusinessUncheckedUpdateWithoutLocationInput>
  }

  export type BusinessUpdateWithoutLocationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    organization?: OrganizationUpdateOneWithoutBusinessNestedInput
  }

  export type BusinessUncheckedUpdateWithoutLocationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type LocationUpsertWithoutBusinessInput = {
    update: XOR<LocationUpdateWithoutBusinessInput, LocationUncheckedUpdateWithoutBusinessInput>
    create: XOR<LocationCreateWithoutBusinessInput, LocationUncheckedCreateWithoutBusinessInput>
    where?: LocationWhereInput
  }

  export type LocationUpdateToOneWithWhereWithoutBusinessInput = {
    where?: LocationWhereInput
    data: XOR<LocationUpdateWithoutBusinessInput, LocationUncheckedUpdateWithoutBusinessInput>
  }

  export type LocationUpdateWithoutBusinessInput = {
    locationName?: NullableStringFieldUpdateOperationsInput | string | null
    locationType?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    functionId?: LocationUpdatefunctionIdInput | string[]
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    users?: LocationUpdateusersInput | InputJsonValue[]
    businessTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: OrganizationUpdateOneWithoutLocationNestedInput
    Documents?: DocumentsUpdateManyWithoutCreatorLocationNestedInput
    entity?: EntityUpdateManyWithoutLocationNestedInput
    user?: UserUpdateManyWithoutLocationNestedInput
    uom?: unitTypeUpdateManyWithoutLocationNestedInput
    rolesTable?: rolesTableUpdateManyWithoutLocationNestedInput
    Role?: RoleUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateWithoutBusinessInput = {
    locationName?: NullableStringFieldUpdateOperationsInput | string | null
    locationType?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    functionId?: LocationUpdatefunctionIdInput | string[]
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    users?: LocationUpdateusersInput | InputJsonValue[]
    businessTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    Documents?: DocumentsUncheckedUpdateManyWithoutCreatorLocationNestedInput
    entity?: EntityUncheckedUpdateManyWithoutLocationNestedInput
    user?: UserUncheckedUpdateManyWithoutLocationNestedInput
    uom?: unitTypeUncheckedUpdateManyWithoutLocationNestedInput
    rolesTable?: rolesTableUncheckedUpdateManyWithoutLocationNestedInput
    Role?: RoleUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type UserCreateWithoutNotificationInput = {
    id?: string
    kcId?: string | null
    email?: string | null
    username?: string | null
    firstname?: string | null
    lastname?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    enabled?: boolean | null
    userType?: string | null
    status?: boolean | null
    avatar?: string | null
    deleted?: boolean | null
    roleId?: UserCreateroleIdInput | string[]
    functionId?: InputJsonValue | null
    additionalUnits?: UserCreateadditionalUnitsInput | string[]
    entity?: EntityCreateNestedOneWithoutUserInput
    location?: LocationCreateNestedOneWithoutUserInput
    organization?: OrganizationCreateNestedOneWithoutUserInput
    AdditionalDocumentAdmins?: AdditionalDocumentAdminsCreateNestedManyWithoutUserInput
    DocumentComments?: DocumentCommentsCreateNestedManyWithoutUserInput
    DocumentVersions?: DocumentVersionsCreateNestedManyWithoutUserInput
    DocumentWorkFlowHistory?: DocumentWorkFlowHistoryCreateNestedManyWithoutUserInput
    Logs?: LogsCreateNestedManyWithoutUserInput
    documentAdmins?: documentAdminsCreateNestedManyWithoutUserInput
    userPersonalisation?: userPersonalisationCreateNestedManyWithoutUserInput
    auditTrial?: auditTrialCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationInput = {
    id?: string
    kcId?: string | null
    email?: string | null
    username?: string | null
    firstname?: string | null
    lastname?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    enabled?: boolean | null
    organizationId?: string | null
    locationId?: string | null
    entityId?: string | null
    userType?: string | null
    status?: boolean | null
    avatar?: string | null
    deleted?: boolean | null
    roleId?: UserCreateroleIdInput | string[]
    functionId?: InputJsonValue | null
    additionalUnits?: UserCreateadditionalUnitsInput | string[]
    AdditionalDocumentAdmins?: AdditionalDocumentAdminsUncheckedCreateNestedManyWithoutUserInput
    DocumentComments?: DocumentCommentsUncheckedCreateNestedManyWithoutUserInput
    DocumentVersions?: DocumentVersionsUncheckedCreateNestedManyWithoutUserInput
    DocumentWorkFlowHistory?: DocumentWorkFlowHistoryUncheckedCreateNestedManyWithoutUserInput
    Logs?: LogsUncheckedCreateNestedManyWithoutUserInput
    documentAdmins?: documentAdminsUncheckedCreateNestedManyWithoutUserInput
    userPersonalisation?: userPersonalisationUncheckedCreateNestedManyWithoutUserInput
    auditTrial?: auditTrialUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationInput, UserUncheckedCreateWithoutNotificationInput>
  }

  export type UserUpsertWithoutNotificationInput = {
    update: XOR<UserUpdateWithoutNotificationInput, UserUncheckedUpdateWithoutNotificationInput>
    create: XOR<UserCreateWithoutNotificationInput, UserUncheckedCreateWithoutNotificationInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationInput, UserUncheckedUpdateWithoutNotificationInput>
  }

  export type UserUpdateWithoutNotificationInput = {
    kcId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    userType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    roleId?: UserUpdateroleIdInput | string[]
    functionId?: InputJsonValue | InputJsonValue | null
    additionalUnits?: UserUpdateadditionalUnitsInput | string[]
    entity?: EntityUpdateOneWithoutUserNestedInput
    location?: LocationUpdateOneWithoutUserNestedInput
    organization?: OrganizationUpdateOneWithoutUserNestedInput
    AdditionalDocumentAdmins?: AdditionalDocumentAdminsUpdateManyWithoutUserNestedInput
    DocumentComments?: DocumentCommentsUpdateManyWithoutUserNestedInput
    DocumentVersions?: DocumentVersionsUpdateManyWithoutUserNestedInput
    DocumentWorkFlowHistory?: DocumentWorkFlowHistoryUpdateManyWithoutUserNestedInput
    Logs?: LogsUpdateManyWithoutUserNestedInput
    documentAdmins?: documentAdminsUpdateManyWithoutUserNestedInput
    userPersonalisation?: userPersonalisationUpdateManyWithoutUserNestedInput
    auditTrial?: auditTrialUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationInput = {
    kcId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    roleId?: UserUpdateroleIdInput | string[]
    functionId?: InputJsonValue | InputJsonValue | null
    additionalUnits?: UserUpdateadditionalUnitsInput | string[]
    AdditionalDocumentAdmins?: AdditionalDocumentAdminsUncheckedUpdateManyWithoutUserNestedInput
    DocumentComments?: DocumentCommentsUncheckedUpdateManyWithoutUserNestedInput
    DocumentVersions?: DocumentVersionsUncheckedUpdateManyWithoutUserNestedInput
    DocumentWorkFlowHistory?: DocumentWorkFlowHistoryUncheckedUpdateManyWithoutUserNestedInput
    Logs?: LogsUncheckedUpdateManyWithoutUserNestedInput
    documentAdmins?: documentAdminsUncheckedUpdateManyWithoutUserNestedInput
    userPersonalisation?: userPersonalisationUncheckedUpdateManyWithoutUserNestedInput
    auditTrial?: auditTrialUncheckedUpdateManyWithoutUserNestedInput
  }

  export type OrganizationCreateWithoutDoctypeInput = {
    id?: string
    kcId?: string | null
    organizationName?: string | null
    realmName?: string | null
    instanceUrl?: string | null
    principalGeography?: string | null
    loginUrl?: string | null
    logoutUrl?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    activeModules?: OrganizationCreateactiveModulesInput | string[]
    clientID?: string | null
    clientSecret?: string | null
    fiscalYearQuarters?: string | null
    fiscalYearFormat?: string | null
    auditYear?: string | null
    logoUrl?: string | null
    deleted?: boolean | null
    business?: BusinessCreateNestedManyWithoutOrganizationInput
    Documents?: DocumentsCreateNestedManyWithoutOrganizationInput
    entity?: EntityCreateNestedManyWithoutOrganizationInput
    entityType?: EntityTypeCreateNestedManyWithoutOrganizationInput
    location?: LocationCreateNestedManyWithoutOrganizationInput
    role?: RoleCreateNestedManyWithoutOrganizationInput
    section?: SectionCreateNestedManyWithoutOrganizationInput
    systemType?: SystemTypeCreateNestedManyWithoutOrganizationInput
    user?: UserCreateNestedManyWithoutOrganizationInput
    userPersonalisation?: userPersonalisationCreateNestedManyWithoutOrganizationInput
    ConnectedApps?: ConnectedAppsCreateNestedManyWithoutOrganizationInput
    unitOfMeasurement?: unitTypeCreateNestedManyWithoutOrganizationInput
    kpi?: kpiCreateNestedManyWithoutOrganizationInput
    businessType?: businessTypeCreateNestedManyWithoutOrganizationInput
    prefixSuffix?: prefixSuffixCreateNestedManyWithoutOrganizationInput
    serialNumber?: serialNumberCreateNestedManyWithoutOrganizationInput
    function?: FunctionsCreateNestedManyWithoutOrganizationInput
    rolesTable?: rolesTableCreateNestedManyWithoutOrganizationInput
    problem?: ProblemCreateNestedManyWithoutOrganizationInput
    parts?: PartsCreateNestedManyWithoutOrganizationInput
    Models?: ModelsCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutDoctypeInput = {
    id?: string
    kcId?: string | null
    organizationName?: string | null
    realmName?: string | null
    instanceUrl?: string | null
    principalGeography?: string | null
    loginUrl?: string | null
    logoutUrl?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    activeModules?: OrganizationCreateactiveModulesInput | string[]
    clientID?: string | null
    clientSecret?: string | null
    fiscalYearQuarters?: string | null
    fiscalYearFormat?: string | null
    auditYear?: string | null
    logoUrl?: string | null
    deleted?: boolean | null
    business?: BusinessUncheckedCreateNestedManyWithoutOrganizationInput
    Documents?: DocumentsUncheckedCreateNestedManyWithoutOrganizationInput
    entity?: EntityUncheckedCreateNestedManyWithoutOrganizationInput
    entityType?: EntityTypeUncheckedCreateNestedManyWithoutOrganizationInput
    location?: LocationUncheckedCreateNestedManyWithoutOrganizationInput
    role?: RoleUncheckedCreateNestedManyWithoutOrganizationInput
    section?: SectionUncheckedCreateNestedManyWithoutOrganizationInput
    systemType?: SystemTypeUncheckedCreateNestedManyWithoutOrganizationInput
    user?: UserUncheckedCreateNestedManyWithoutOrganizationInput
    userPersonalisation?: userPersonalisationUncheckedCreateNestedManyWithoutOrganizationInput
    ConnectedApps?: ConnectedAppsUncheckedCreateNestedManyWithoutOrganizationInput
    unitOfMeasurement?: unitTypeUncheckedCreateNestedManyWithoutOrganizationInput
    kpi?: kpiUncheckedCreateNestedManyWithoutOrganizationInput
    businessType?: businessTypeUncheckedCreateNestedManyWithoutOrganizationInput
    prefixSuffix?: prefixSuffixUncheckedCreateNestedManyWithoutOrganizationInput
    serialNumber?: serialNumberUncheckedCreateNestedManyWithoutOrganizationInput
    function?: FunctionsUncheckedCreateNestedManyWithoutOrganizationInput
    rolesTable?: rolesTableUncheckedCreateNestedManyWithoutOrganizationInput
    problem?: ProblemUncheckedCreateNestedManyWithoutOrganizationInput
    parts?: PartsUncheckedCreateNestedManyWithoutOrganizationInput
    Models?: ModelsUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutDoctypeInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutDoctypeInput, OrganizationUncheckedCreateWithoutDoctypeInput>
  }

  export type EntityCreateWithoutDoctypeInput = {
    id?: string
    entityName?: string | null
    description?: string | null
    createdBy?: string | null
    entityId?: string | null
    deleted?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedBy?: string | null
    users?: EntityCreateusersInput | string[]
    sections?: EntityCreatesectionsInput | string[]
    entityType?: EntityTypeCreateNestedOneWithoutEntityInput
    location?: LocationCreateNestedOneWithoutEntityInput
    organization?: OrganizationCreateNestedOneWithoutEntityInput
    Documents?: DocumentsCreateNestedManyWithoutCreatorEntityInput
    user?: UserCreateNestedManyWithoutEntityInput
    parts?: PartsCreateNestedManyWithoutEntityInput
    claimToEntity?: ClaimToEntityCreateNestedManyWithoutEntityInput
    function?: FunctionsCreateNestedOneWithoutEntityInput
  }

  export type EntityUncheckedCreateWithoutDoctypeInput = {
    id?: string
    entityName?: string | null
    description?: string | null
    entityTypeId?: string | null
    organizationId?: string | null
    locationId?: string | null
    createdBy?: string | null
    entityId?: string | null
    deleted?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedBy?: string | null
    users?: EntityCreateusersInput | string[]
    sections?: EntityCreatesectionsInput | string[]
    functionId?: string | null
    Documents?: DocumentsUncheckedCreateNestedManyWithoutCreatorEntityInput
    user?: UserUncheckedCreateNestedManyWithoutEntityInput
    parts?: PartsUncheckedCreateNestedManyWithoutEntityInput
    claimToEntity?: ClaimToEntityUncheckedCreateNestedManyWithoutEntityInput
  }

  export type EntityCreateOrConnectWithoutDoctypeInput = {
    where: EntityWhereUniqueInput
    create: XOR<EntityCreateWithoutDoctypeInput, EntityUncheckedCreateWithoutDoctypeInput>
  }

  export type DocumentsCreateWithoutDoctypeInput = {
    id?: string
    documentName?: string | null
    documentNumbering?: string | null
    reasonOfCreation?: string | null
    effectiveDate?: Date | string | null
    nextRevisionDate?: Date | string | null
    currentVersion?: string | null
    documentLink?: string | null
    description?: string | null
    tags?: DocumentsCreatetagsInput | string[]
    documentState?: string | null
    system?: DocumentsCreatesystemInput | string[]
    section?: string | null
    revertComment?: string | null
    docType?: string | null
    documentClassification?: string | null
    issueNumber?: string | null
    retireComment?: string | null
    revisionReminderFlag?: boolean | null
    isVersion?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedDate?: Date | string | null
    countNumber?: number | null
    createdBy?: string | null
    distributionList?: string | null
    documentId?: string | null
    reviewers?: DocumentsCreatereviewersInput | string[]
    approvers?: DocumentsCreateapproversInput | string[]
    creators?: DocumentsCreatecreatorsInput | string[]
    distributionUsers?: DocumentsCreatedistributionUsersInput | InputJsonValue[]
    readAccess?: string | null
    readAccessUsers?: DocumentsCreatereadAccessUsersInput | InputJsonValue[]
    versionInfo?: DocumentsCreateversionInfoInput | InputJsonValue[]
    organization?: OrganizationCreateNestedOneWithoutDocumentsInput
    creatorLocation?: LocationCreateNestedOneWithoutDocumentsInput
    creatorEntity?: EntityCreateNestedOneWithoutDocumentsInput
    ReferenceDocuments?: ReferenceDocumentsCreateNestedManyWithoutDocumentInput
    DocumentVersions?: DocumentVersionsCreateNestedManyWithoutDocumentInput
    DocumentComments?: DocumentCommentsCreateNestedManyWithoutDocumentInput
    DocumentWorkFlowHistory?: DocumentWorkFlowHistoryCreateNestedManyWithoutDocumentInput
    AdditionalDocumentAdmins?: AdditionalDocumentAdminsCreateNestedManyWithoutDocumentInput
    VersionReferenceDocuments?: VersionReferenceDocumentsCreateNestedManyWithoutDocumentsInput
  }

  export type DocumentsUncheckedCreateWithoutDoctypeInput = {
    id?: string
    organizationId?: string | null
    documentName?: string | null
    documentNumbering?: string | null
    reasonOfCreation?: string | null
    effectiveDate?: Date | string | null
    nextRevisionDate?: Date | string | null
    currentVersion?: string | null
    documentLink?: string | null
    description?: string | null
    tags?: DocumentsCreatetagsInput | string[]
    documentState?: string | null
    locationId: string
    entityId?: string | null
    system?: DocumentsCreatesystemInput | string[]
    section?: string | null
    revertComment?: string | null
    docType?: string | null
    documentClassification?: string | null
    issueNumber?: string | null
    retireComment?: string | null
    revisionReminderFlag?: boolean | null
    isVersion?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedDate?: Date | string | null
    countNumber?: number | null
    createdBy?: string | null
    distributionList?: string | null
    documentId?: string | null
    reviewers?: DocumentsCreatereviewersInput | string[]
    approvers?: DocumentsCreateapproversInput | string[]
    creators?: DocumentsCreatecreatorsInput | string[]
    distributionUsers?: DocumentsCreatedistributionUsersInput | InputJsonValue[]
    readAccess?: string | null
    readAccessUsers?: DocumentsCreatereadAccessUsersInput | InputJsonValue[]
    versionInfo?: DocumentsCreateversionInfoInput | InputJsonValue[]
    ReferenceDocuments?: ReferenceDocumentsUncheckedCreateNestedManyWithoutDocumentInput
    DocumentVersions?: DocumentVersionsUncheckedCreateNestedManyWithoutDocumentInput
    DocumentComments?: DocumentCommentsUncheckedCreateNestedManyWithoutDocumentInput
    DocumentWorkFlowHistory?: DocumentWorkFlowHistoryUncheckedCreateNestedManyWithoutDocumentInput
    AdditionalDocumentAdmins?: AdditionalDocumentAdminsUncheckedCreateNestedManyWithoutDocumentInput
    VersionReferenceDocuments?: VersionReferenceDocumentsUncheckedCreateNestedManyWithoutDocumentsInput
  }

  export type DocumentsCreateOrConnectWithoutDoctypeInput = {
    where: DocumentsWhereUniqueInput
    create: XOR<DocumentsCreateWithoutDoctypeInput, DocumentsUncheckedCreateWithoutDoctypeInput>
  }

  export type DocumentsCreateManyDoctypeInputEnvelope = {
    data: DocumentsCreateManyDoctypeInput | DocumentsCreateManyDoctypeInput[]
  }

  export type documentAdminsCreateWithoutDoctypeInput = {
    id?: string
    type: string
    firstname: string
    lastname: string
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutDocumentAdminsInput
  }

  export type documentAdminsUncheckedCreateWithoutDoctypeInput = {
    id?: string
    type: string
    firstname: string
    lastname: string
    email: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type documentAdminsCreateOrConnectWithoutDoctypeInput = {
    where: documentAdminsWhereUniqueInput
    create: XOR<documentAdminsCreateWithoutDoctypeInput, documentAdminsUncheckedCreateWithoutDoctypeInput>
  }

  export type documentAdminsCreateManyDoctypeInputEnvelope = {
    data: documentAdminsCreateManyDoctypeInput | documentAdminsCreateManyDoctypeInput[]
  }

  export type OrganizationUpsertWithoutDoctypeInput = {
    update: XOR<OrganizationUpdateWithoutDoctypeInput, OrganizationUncheckedUpdateWithoutDoctypeInput>
    create: XOR<OrganizationCreateWithoutDoctypeInput, OrganizationUncheckedCreateWithoutDoctypeInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutDoctypeInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutDoctypeInput, OrganizationUncheckedUpdateWithoutDoctypeInput>
  }

  export type OrganizationUpdateWithoutDoctypeInput = {
    kcId?: NullableStringFieldUpdateOperationsInput | string | null
    organizationName?: NullableStringFieldUpdateOperationsInput | string | null
    realmName?: NullableStringFieldUpdateOperationsInput | string | null
    instanceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    principalGeography?: NullableStringFieldUpdateOperationsInput | string | null
    loginUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoutUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    activeModules?: OrganizationUpdateactiveModulesInput | string[]
    clientID?: NullableStringFieldUpdateOperationsInput | string | null
    clientSecret?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearQuarters?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearFormat?: NullableStringFieldUpdateOperationsInput | string | null
    auditYear?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    business?: BusinessUpdateManyWithoutOrganizationNestedInput
    Documents?: DocumentsUpdateManyWithoutOrganizationNestedInput
    entity?: EntityUpdateManyWithoutOrganizationNestedInput
    entityType?: EntityTypeUpdateManyWithoutOrganizationNestedInput
    location?: LocationUpdateManyWithoutOrganizationNestedInput
    role?: RoleUpdateManyWithoutOrganizationNestedInput
    section?: SectionUpdateManyWithoutOrganizationNestedInput
    systemType?: SystemTypeUpdateManyWithoutOrganizationNestedInput
    user?: UserUpdateManyWithoutOrganizationNestedInput
    userPersonalisation?: userPersonalisationUpdateManyWithoutOrganizationNestedInput
    ConnectedApps?: ConnectedAppsUpdateManyWithoutOrganizationNestedInput
    unitOfMeasurement?: unitTypeUpdateManyWithoutOrganizationNestedInput
    kpi?: kpiUpdateManyWithoutOrganizationNestedInput
    businessType?: businessTypeUpdateManyWithoutOrganizationNestedInput
    prefixSuffix?: prefixSuffixUpdateManyWithoutOrganizationNestedInput
    serialNumber?: serialNumberUpdateManyWithoutOrganizationNestedInput
    function?: FunctionsUpdateManyWithoutOrganizationNestedInput
    rolesTable?: rolesTableUpdateManyWithoutOrganizationNestedInput
    problem?: ProblemUpdateManyWithoutOrganizationNestedInput
    parts?: PartsUpdateManyWithoutOrganizationNestedInput
    Models?: ModelsUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutDoctypeInput = {
    kcId?: NullableStringFieldUpdateOperationsInput | string | null
    organizationName?: NullableStringFieldUpdateOperationsInput | string | null
    realmName?: NullableStringFieldUpdateOperationsInput | string | null
    instanceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    principalGeography?: NullableStringFieldUpdateOperationsInput | string | null
    loginUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoutUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    activeModules?: OrganizationUpdateactiveModulesInput | string[]
    clientID?: NullableStringFieldUpdateOperationsInput | string | null
    clientSecret?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearQuarters?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearFormat?: NullableStringFieldUpdateOperationsInput | string | null
    auditYear?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    business?: BusinessUncheckedUpdateManyWithoutOrganizationNestedInput
    Documents?: DocumentsUncheckedUpdateManyWithoutOrganizationNestedInput
    entity?: EntityUncheckedUpdateManyWithoutOrganizationNestedInput
    entityType?: EntityTypeUncheckedUpdateManyWithoutOrganizationNestedInput
    location?: LocationUncheckedUpdateManyWithoutOrganizationNestedInput
    role?: RoleUncheckedUpdateManyWithoutOrganizationNestedInput
    section?: SectionUncheckedUpdateManyWithoutOrganizationNestedInput
    systemType?: SystemTypeUncheckedUpdateManyWithoutOrganizationNestedInput
    user?: UserUncheckedUpdateManyWithoutOrganizationNestedInput
    userPersonalisation?: userPersonalisationUncheckedUpdateManyWithoutOrganizationNestedInput
    ConnectedApps?: ConnectedAppsUncheckedUpdateManyWithoutOrganizationNestedInput
    unitOfMeasurement?: unitTypeUncheckedUpdateManyWithoutOrganizationNestedInput
    kpi?: kpiUncheckedUpdateManyWithoutOrganizationNestedInput
    businessType?: businessTypeUncheckedUpdateManyWithoutOrganizationNestedInput
    prefixSuffix?: prefixSuffixUncheckedUpdateManyWithoutOrganizationNestedInput
    serialNumber?: serialNumberUncheckedUpdateManyWithoutOrganizationNestedInput
    function?: FunctionsUncheckedUpdateManyWithoutOrganizationNestedInput
    rolesTable?: rolesTableUncheckedUpdateManyWithoutOrganizationNestedInput
    problem?: ProblemUncheckedUpdateManyWithoutOrganizationNestedInput
    parts?: PartsUncheckedUpdateManyWithoutOrganizationNestedInput
    Models?: ModelsUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type EntityUpsertWithoutDoctypeInput = {
    update: XOR<EntityUpdateWithoutDoctypeInput, EntityUncheckedUpdateWithoutDoctypeInput>
    create: XOR<EntityCreateWithoutDoctypeInput, EntityUncheckedCreateWithoutDoctypeInput>
    where?: EntityWhereInput
  }

  export type EntityUpdateToOneWithWhereWithoutDoctypeInput = {
    where?: EntityWhereInput
    data: XOR<EntityUpdateWithoutDoctypeInput, EntityUncheckedUpdateWithoutDoctypeInput>
  }

  export type EntityUpdateWithoutDoctypeInput = {
    entityName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    users?: EntityUpdateusersInput | string[]
    sections?: EntityUpdatesectionsInput | string[]
    entityType?: EntityTypeUpdateOneWithoutEntityNestedInput
    location?: LocationUpdateOneWithoutEntityNestedInput
    organization?: OrganizationUpdateOneWithoutEntityNestedInput
    Documents?: DocumentsUpdateManyWithoutCreatorEntityNestedInput
    user?: UserUpdateManyWithoutEntityNestedInput
    parts?: PartsUpdateManyWithoutEntityNestedInput
    claimToEntity?: ClaimToEntityUpdateManyWithoutEntityNestedInput
    function?: FunctionsUpdateOneWithoutEntityNestedInput
  }

  export type EntityUncheckedUpdateWithoutDoctypeInput = {
    entityName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    entityTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    users?: EntityUpdateusersInput | string[]
    sections?: EntityUpdatesectionsInput | string[]
    functionId?: NullableStringFieldUpdateOperationsInput | string | null
    Documents?: DocumentsUncheckedUpdateManyWithoutCreatorEntityNestedInput
    user?: UserUncheckedUpdateManyWithoutEntityNestedInput
    parts?: PartsUncheckedUpdateManyWithoutEntityNestedInput
    claimToEntity?: ClaimToEntityUncheckedUpdateManyWithoutEntityNestedInput
  }

  export type DocumentsUpsertWithWhereUniqueWithoutDoctypeInput = {
    where: DocumentsWhereUniqueInput
    update: XOR<DocumentsUpdateWithoutDoctypeInput, DocumentsUncheckedUpdateWithoutDoctypeInput>
    create: XOR<DocumentsCreateWithoutDoctypeInput, DocumentsUncheckedCreateWithoutDoctypeInput>
  }

  export type DocumentsUpdateWithWhereUniqueWithoutDoctypeInput = {
    where: DocumentsWhereUniqueInput
    data: XOR<DocumentsUpdateWithoutDoctypeInput, DocumentsUncheckedUpdateWithoutDoctypeInput>
  }

  export type DocumentsUpdateManyWithWhereWithoutDoctypeInput = {
    where: DocumentsScalarWhereInput
    data: XOR<DocumentsUpdateManyMutationInput, DocumentsUncheckedUpdateManyWithoutDoctypeInput>
  }

  export type documentAdminsUpsertWithWhereUniqueWithoutDoctypeInput = {
    where: documentAdminsWhereUniqueInput
    update: XOR<documentAdminsUpdateWithoutDoctypeInput, documentAdminsUncheckedUpdateWithoutDoctypeInput>
    create: XOR<documentAdminsCreateWithoutDoctypeInput, documentAdminsUncheckedCreateWithoutDoctypeInput>
  }

  export type documentAdminsUpdateWithWhereUniqueWithoutDoctypeInput = {
    where: documentAdminsWhereUniqueInput
    data: XOR<documentAdminsUpdateWithoutDoctypeInput, documentAdminsUncheckedUpdateWithoutDoctypeInput>
  }

  export type documentAdminsUpdateManyWithWhereWithoutDoctypeInput = {
    where: documentAdminsScalarWhereInput
    data: XOR<documentAdminsUpdateManyMutationInput, documentAdminsUncheckedUpdateManyWithoutDoctypeInput>
  }

  export type DoctypeCreateWithoutDocumentsInput = {
    id?: string
    locationId?: DoctypeCreatelocationIdInput | string[]
    documentTypeName?: string | null
    documentNumbering?: string | null
    reviewFrequency?: number | null
    revisionRemind?: number | null
    prefix?: string | null
    suffix?: string | null
    readAccess?: string | null
    readAccessUsers?: DoctypeCreatereadAccessUsersInput | InputJsonValue[]
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedBy?: string | null
    createdBy?: string | null
    applicable_systems?: DoctypeCreateapplicable_systemsInput | InputJsonValue[]
    users?: DoctypeCreateusersInput | InputJsonValue[]
    document_classification?: string | null
    distributionUsers?: DoctypeCreatedistributionUsersInput | InputJsonValue[]
    currentVersion: string
    distributionList?: string | null
    organization?: OrganizationCreateNestedOneWithoutDoctypeInput
    Entity?: EntityCreateNestedOneWithoutDoctypeInput
    documentAdmins?: documentAdminsCreateNestedManyWithoutDoctypeInput
  }

  export type DoctypeUncheckedCreateWithoutDocumentsInput = {
    id?: string
    locationId?: DoctypeCreatelocationIdInput | string[]
    documentTypeName?: string | null
    documentNumbering?: string | null
    reviewFrequency?: number | null
    revisionRemind?: number | null
    prefix?: string | null
    suffix?: string | null
    organizationId?: string | null
    readAccess?: string | null
    readAccessUsers?: DoctypeCreatereadAccessUsersInput | InputJsonValue[]
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedBy?: string | null
    createdBy?: string | null
    applicable_systems?: DoctypeCreateapplicable_systemsInput | InputJsonValue[]
    users?: DoctypeCreateusersInput | InputJsonValue[]
    document_classification?: string | null
    entityId?: string | null
    distributionUsers?: DoctypeCreatedistributionUsersInput | InputJsonValue[]
    currentVersion: string
    distributionList?: string | null
    documentAdmins?: documentAdminsUncheckedCreateNestedManyWithoutDoctypeInput
  }

  export type DoctypeCreateOrConnectWithoutDocumentsInput = {
    where: DoctypeWhereUniqueInput
    create: XOR<DoctypeCreateWithoutDocumentsInput, DoctypeUncheckedCreateWithoutDocumentsInput>
  }

  export type OrganizationCreateWithoutDocumentsInput = {
    id?: string
    kcId?: string | null
    organizationName?: string | null
    realmName?: string | null
    instanceUrl?: string | null
    principalGeography?: string | null
    loginUrl?: string | null
    logoutUrl?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    activeModules?: OrganizationCreateactiveModulesInput | string[]
    clientID?: string | null
    clientSecret?: string | null
    fiscalYearQuarters?: string | null
    fiscalYearFormat?: string | null
    auditYear?: string | null
    logoUrl?: string | null
    deleted?: boolean | null
    business?: BusinessCreateNestedManyWithoutOrganizationInput
    Doctype?: DoctypeCreateNestedManyWithoutOrganizationInput
    entity?: EntityCreateNestedManyWithoutOrganizationInput
    entityType?: EntityTypeCreateNestedManyWithoutOrganizationInput
    location?: LocationCreateNestedManyWithoutOrganizationInput
    role?: RoleCreateNestedManyWithoutOrganizationInput
    section?: SectionCreateNestedManyWithoutOrganizationInput
    systemType?: SystemTypeCreateNestedManyWithoutOrganizationInput
    user?: UserCreateNestedManyWithoutOrganizationInput
    userPersonalisation?: userPersonalisationCreateNestedManyWithoutOrganizationInput
    ConnectedApps?: ConnectedAppsCreateNestedManyWithoutOrganizationInput
    unitOfMeasurement?: unitTypeCreateNestedManyWithoutOrganizationInput
    kpi?: kpiCreateNestedManyWithoutOrganizationInput
    businessType?: businessTypeCreateNestedManyWithoutOrganizationInput
    prefixSuffix?: prefixSuffixCreateNestedManyWithoutOrganizationInput
    serialNumber?: serialNumberCreateNestedManyWithoutOrganizationInput
    function?: FunctionsCreateNestedManyWithoutOrganizationInput
    rolesTable?: rolesTableCreateNestedManyWithoutOrganizationInput
    problem?: ProblemCreateNestedManyWithoutOrganizationInput
    parts?: PartsCreateNestedManyWithoutOrganizationInput
    Models?: ModelsCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutDocumentsInput = {
    id?: string
    kcId?: string | null
    organizationName?: string | null
    realmName?: string | null
    instanceUrl?: string | null
    principalGeography?: string | null
    loginUrl?: string | null
    logoutUrl?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    activeModules?: OrganizationCreateactiveModulesInput | string[]
    clientID?: string | null
    clientSecret?: string | null
    fiscalYearQuarters?: string | null
    fiscalYearFormat?: string | null
    auditYear?: string | null
    logoUrl?: string | null
    deleted?: boolean | null
    business?: BusinessUncheckedCreateNestedManyWithoutOrganizationInput
    Doctype?: DoctypeUncheckedCreateNestedManyWithoutOrganizationInput
    entity?: EntityUncheckedCreateNestedManyWithoutOrganizationInput
    entityType?: EntityTypeUncheckedCreateNestedManyWithoutOrganizationInput
    location?: LocationUncheckedCreateNestedManyWithoutOrganizationInput
    role?: RoleUncheckedCreateNestedManyWithoutOrganizationInput
    section?: SectionUncheckedCreateNestedManyWithoutOrganizationInput
    systemType?: SystemTypeUncheckedCreateNestedManyWithoutOrganizationInput
    user?: UserUncheckedCreateNestedManyWithoutOrganizationInput
    userPersonalisation?: userPersonalisationUncheckedCreateNestedManyWithoutOrganizationInput
    ConnectedApps?: ConnectedAppsUncheckedCreateNestedManyWithoutOrganizationInput
    unitOfMeasurement?: unitTypeUncheckedCreateNestedManyWithoutOrganizationInput
    kpi?: kpiUncheckedCreateNestedManyWithoutOrganizationInput
    businessType?: businessTypeUncheckedCreateNestedManyWithoutOrganizationInput
    prefixSuffix?: prefixSuffixUncheckedCreateNestedManyWithoutOrganizationInput
    serialNumber?: serialNumberUncheckedCreateNestedManyWithoutOrganizationInput
    function?: FunctionsUncheckedCreateNestedManyWithoutOrganizationInput
    rolesTable?: rolesTableUncheckedCreateNestedManyWithoutOrganizationInput
    problem?: ProblemUncheckedCreateNestedManyWithoutOrganizationInput
    parts?: PartsUncheckedCreateNestedManyWithoutOrganizationInput
    Models?: ModelsUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutDocumentsInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutDocumentsInput, OrganizationUncheckedCreateWithoutDocumentsInput>
  }

  export type LocationCreateWithoutDocumentsInput = {
    id?: string
    locationName?: string | null
    locationType?: string | null
    locationId?: string | null
    description?: string | null
    status?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedBy?: string | null
    functionId?: LocationCreatefunctionIdInput | string[]
    deleted?: boolean | null
    users?: LocationCreateusersInput | InputJsonValue[]
    businessTypeId?: string | null
    type?: string | null
    organization?: OrganizationCreateNestedOneWithoutLocationInput
    entity?: EntityCreateNestedManyWithoutLocationInput
    business?: LocationBusinessCreateNestedManyWithoutLocationInput
    user?: UserCreateNestedManyWithoutLocationInput
    uom?: unitTypeCreateNestedManyWithoutLocationInput
    rolesTable?: rolesTableCreateNestedManyWithoutLocationInput
    Role?: RoleCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateWithoutDocumentsInput = {
    id?: string
    locationName?: string | null
    locationType?: string | null
    locationId?: string | null
    description?: string | null
    status?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedBy?: string | null
    functionId?: LocationCreatefunctionIdInput | string[]
    deleted?: boolean | null
    organizationId?: string | null
    users?: LocationCreateusersInput | InputJsonValue[]
    businessTypeId?: string | null
    type?: string | null
    entity?: EntityUncheckedCreateNestedManyWithoutLocationInput
    business?: LocationBusinessUncheckedCreateNestedManyWithoutLocationInput
    user?: UserUncheckedCreateNestedManyWithoutLocationInput
    uom?: unitTypeUncheckedCreateNestedManyWithoutLocationInput
    rolesTable?: rolesTableUncheckedCreateNestedManyWithoutLocationInput
    Role?: RoleUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationCreateOrConnectWithoutDocumentsInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutDocumentsInput, LocationUncheckedCreateWithoutDocumentsInput>
  }

  export type EntityCreateWithoutDocumentsInput = {
    id?: string
    entityName?: string | null
    description?: string | null
    createdBy?: string | null
    entityId?: string | null
    deleted?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedBy?: string | null
    users?: EntityCreateusersInput | string[]
    sections?: EntityCreatesectionsInput | string[]
    entityType?: EntityTypeCreateNestedOneWithoutEntityInput
    location?: LocationCreateNestedOneWithoutEntityInput
    organization?: OrganizationCreateNestedOneWithoutEntityInput
    Doctype?: DoctypeCreateNestedManyWithoutEntityInput
    user?: UserCreateNestedManyWithoutEntityInput
    parts?: PartsCreateNestedManyWithoutEntityInput
    claimToEntity?: ClaimToEntityCreateNestedManyWithoutEntityInput
    function?: FunctionsCreateNestedOneWithoutEntityInput
  }

  export type EntityUncheckedCreateWithoutDocumentsInput = {
    id?: string
    entityName?: string | null
    description?: string | null
    entityTypeId?: string | null
    organizationId?: string | null
    locationId?: string | null
    createdBy?: string | null
    entityId?: string | null
    deleted?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedBy?: string | null
    users?: EntityCreateusersInput | string[]
    sections?: EntityCreatesectionsInput | string[]
    functionId?: string | null
    Doctype?: DoctypeUncheckedCreateNestedManyWithoutEntityInput
    user?: UserUncheckedCreateNestedManyWithoutEntityInput
    parts?: PartsUncheckedCreateNestedManyWithoutEntityInput
    claimToEntity?: ClaimToEntityUncheckedCreateNestedManyWithoutEntityInput
  }

  export type EntityCreateOrConnectWithoutDocumentsInput = {
    where: EntityWhereUniqueInput
    create: XOR<EntityCreateWithoutDocumentsInput, EntityUncheckedCreateWithoutDocumentsInput>
  }

  export type ReferenceDocumentsCreateWithoutDocumentInput = {
    id?: string
    documentLink?: string | null
    type?: string | null
    documentName?: string | null
    version?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    referenceDocId?: string | null
    versionsLinkedWith?: DocumentVersionsCreateNestedOneWithoutReferenceDocumentsInput
  }

  export type ReferenceDocumentsUncheckedCreateWithoutDocumentInput = {
    id?: string
    documentLink?: string | null
    type?: string | null
    documentName?: string | null
    version?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    referenceDocId?: string | null
    versionId?: string | null
  }

  export type ReferenceDocumentsCreateOrConnectWithoutDocumentInput = {
    where: ReferenceDocumentsWhereUniqueInput
    create: XOR<ReferenceDocumentsCreateWithoutDocumentInput, ReferenceDocumentsUncheckedCreateWithoutDocumentInput>
  }

  export type ReferenceDocumentsCreateManyDocumentInputEnvelope = {
    data: ReferenceDocumentsCreateManyDocumentInput | ReferenceDocumentsCreateManyDocumentInput[]
  }

  export type DocumentVersionsCreateWithoutDocumentInput = {
    id?: string
    versionName: string
    by?: string | null
    approvedDate?: Date | string | null
    versionLink: string
    createdAt?: Date | string
    updatedAt?: Date | string
    documentName?: string | null
    documentNumbering?: string | null
    reasonOfCreation?: string | null
    effectiveDate?: Date | string | null
    description?: string | null
    issueNumber?: string | null
    user?: UserCreateNestedOneWithoutDocumentVersionsInput
    ReferenceDocuments?: ReferenceDocumentsCreateNestedManyWithoutVersionsLinkedWithInput
    VersionReferenceDocuments?: VersionReferenceDocumentsCreateNestedManyWithoutVersionsLinkedWithInput
  }

  export type DocumentVersionsUncheckedCreateWithoutDocumentInput = {
    id?: string
    versionName: string
    userId?: string | null
    by?: string | null
    approvedDate?: Date | string | null
    versionLink: string
    createdAt?: Date | string
    updatedAt?: Date | string
    documentName?: string | null
    documentNumbering?: string | null
    reasonOfCreation?: string | null
    effectiveDate?: Date | string | null
    description?: string | null
    issueNumber?: string | null
    ReferenceDocuments?: ReferenceDocumentsUncheckedCreateNestedManyWithoutVersionsLinkedWithInput
    VersionReferenceDocuments?: VersionReferenceDocumentsUncheckedCreateNestedManyWithoutVersionsLinkedWithInput
  }

  export type DocumentVersionsCreateOrConnectWithoutDocumentInput = {
    where: DocumentVersionsWhereUniqueInput
    create: XOR<DocumentVersionsCreateWithoutDocumentInput, DocumentVersionsUncheckedCreateWithoutDocumentInput>
  }

  export type DocumentVersionsCreateManyDocumentInputEnvelope = {
    data: DocumentVersionsCreateManyDocumentInput | DocumentVersionsCreateManyDocumentInput[]
  }

  export type DocumentCommentsCreateWithoutDocumentInput = {
    id?: string
    commentBy?: string | null
    commentText: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutDocumentCommentsInput
  }

  export type DocumentCommentsUncheckedCreateWithoutDocumentInput = {
    id?: string
    userId?: string | null
    commentBy?: string | null
    commentText: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentCommentsCreateOrConnectWithoutDocumentInput = {
    where: DocumentCommentsWhereUniqueInput
    create: XOR<DocumentCommentsCreateWithoutDocumentInput, DocumentCommentsUncheckedCreateWithoutDocumentInput>
  }

  export type DocumentCommentsCreateManyDocumentInputEnvelope = {
    data: DocumentCommentsCreateManyDocumentInput | DocumentCommentsCreateManyDocumentInput[]
  }

  export type DocumentWorkFlowHistoryCreateWithoutDocumentInput = {
    id?: string
    actionName: string
    actionBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutDocumentWorkFlowHistoryInput
  }

  export type DocumentWorkFlowHistoryUncheckedCreateWithoutDocumentInput = {
    id?: string
    actionName: string
    userId?: string | null
    actionBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentWorkFlowHistoryCreateOrConnectWithoutDocumentInput = {
    where: DocumentWorkFlowHistoryWhereUniqueInput
    create: XOR<DocumentWorkFlowHistoryCreateWithoutDocumentInput, DocumentWorkFlowHistoryUncheckedCreateWithoutDocumentInput>
  }

  export type DocumentWorkFlowHistoryCreateManyDocumentInputEnvelope = {
    data: DocumentWorkFlowHistoryCreateManyDocumentInput | DocumentWorkFlowHistoryCreateManyDocumentInput[]
  }

  export type AdditionalDocumentAdminsCreateWithoutDocumentInput = {
    id?: string
    type: string
    firstname: string
    lastname: string
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAdditionalDocumentAdminsInput
  }

  export type AdditionalDocumentAdminsUncheckedCreateWithoutDocumentInput = {
    id?: string
    type: string
    firstname: string
    lastname: string
    email: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdditionalDocumentAdminsCreateOrConnectWithoutDocumentInput = {
    where: AdditionalDocumentAdminsWhereUniqueInput
    create: XOR<AdditionalDocumentAdminsCreateWithoutDocumentInput, AdditionalDocumentAdminsUncheckedCreateWithoutDocumentInput>
  }

  export type AdditionalDocumentAdminsCreateManyDocumentInputEnvelope = {
    data: AdditionalDocumentAdminsCreateManyDocumentInput | AdditionalDocumentAdminsCreateManyDocumentInput[]
  }

  export type VersionReferenceDocumentsCreateWithoutDocumentsInput = {
    id?: string
    documentLink?: string | null
    type?: string | null
    documentName?: string | null
    version?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    referenceDocId?: string | null
    versionsLinkedWith?: DocumentVersionsCreateNestedOneWithoutVersionReferenceDocumentsInput
  }

  export type VersionReferenceDocumentsUncheckedCreateWithoutDocumentsInput = {
    id?: string
    documentLink?: string | null
    type?: string | null
    documentName?: string | null
    version?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    referenceDocId?: string | null
    versionId?: string | null
  }

  export type VersionReferenceDocumentsCreateOrConnectWithoutDocumentsInput = {
    where: VersionReferenceDocumentsWhereUniqueInput
    create: XOR<VersionReferenceDocumentsCreateWithoutDocumentsInput, VersionReferenceDocumentsUncheckedCreateWithoutDocumentsInput>
  }

  export type VersionReferenceDocumentsCreateManyDocumentsInputEnvelope = {
    data: VersionReferenceDocumentsCreateManyDocumentsInput | VersionReferenceDocumentsCreateManyDocumentsInput[]
  }

  export type DoctypeUpsertWithoutDocumentsInput = {
    update: XOR<DoctypeUpdateWithoutDocumentsInput, DoctypeUncheckedUpdateWithoutDocumentsInput>
    create: XOR<DoctypeCreateWithoutDocumentsInput, DoctypeUncheckedCreateWithoutDocumentsInput>
    where?: DoctypeWhereInput
  }

  export type DoctypeUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: DoctypeWhereInput
    data: XOR<DoctypeUpdateWithoutDocumentsInput, DoctypeUncheckedUpdateWithoutDocumentsInput>
  }

  export type DoctypeUpdateWithoutDocumentsInput = {
    locationId?: DoctypeUpdatelocationIdInput | string[]
    documentTypeName?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumbering?: NullableStringFieldUpdateOperationsInput | string | null
    reviewFrequency?: NullableIntFieldUpdateOperationsInput | number | null
    revisionRemind?: NullableIntFieldUpdateOperationsInput | number | null
    prefix?: NullableStringFieldUpdateOperationsInput | string | null
    suffix?: NullableStringFieldUpdateOperationsInput | string | null
    readAccess?: NullableStringFieldUpdateOperationsInput | string | null
    readAccessUsers?: DoctypeUpdatereadAccessUsersInput | InputJsonValue[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    applicable_systems?: DoctypeUpdateapplicable_systemsInput | InputJsonValue[]
    users?: DoctypeUpdateusersInput | InputJsonValue[]
    document_classification?: NullableStringFieldUpdateOperationsInput | string | null
    distributionUsers?: DoctypeUpdatedistributionUsersInput | InputJsonValue[]
    currentVersion?: StringFieldUpdateOperationsInput | string
    distributionList?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: OrganizationUpdateOneWithoutDoctypeNestedInput
    Entity?: EntityUpdateOneWithoutDoctypeNestedInput
    documentAdmins?: documentAdminsUpdateManyWithoutDoctypeNestedInput
  }

  export type DoctypeUncheckedUpdateWithoutDocumentsInput = {
    locationId?: DoctypeUpdatelocationIdInput | string[]
    documentTypeName?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumbering?: NullableStringFieldUpdateOperationsInput | string | null
    reviewFrequency?: NullableIntFieldUpdateOperationsInput | number | null
    revisionRemind?: NullableIntFieldUpdateOperationsInput | number | null
    prefix?: NullableStringFieldUpdateOperationsInput | string | null
    suffix?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    readAccess?: NullableStringFieldUpdateOperationsInput | string | null
    readAccessUsers?: DoctypeUpdatereadAccessUsersInput | InputJsonValue[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    applicable_systems?: DoctypeUpdateapplicable_systemsInput | InputJsonValue[]
    users?: DoctypeUpdateusersInput | InputJsonValue[]
    document_classification?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    distributionUsers?: DoctypeUpdatedistributionUsersInput | InputJsonValue[]
    currentVersion?: StringFieldUpdateOperationsInput | string
    distributionList?: NullableStringFieldUpdateOperationsInput | string | null
    documentAdmins?: documentAdminsUncheckedUpdateManyWithoutDoctypeNestedInput
  }

  export type OrganizationUpsertWithoutDocumentsInput = {
    update: XOR<OrganizationUpdateWithoutDocumentsInput, OrganizationUncheckedUpdateWithoutDocumentsInput>
    create: XOR<OrganizationCreateWithoutDocumentsInput, OrganizationUncheckedCreateWithoutDocumentsInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutDocumentsInput, OrganizationUncheckedUpdateWithoutDocumentsInput>
  }

  export type OrganizationUpdateWithoutDocumentsInput = {
    kcId?: NullableStringFieldUpdateOperationsInput | string | null
    organizationName?: NullableStringFieldUpdateOperationsInput | string | null
    realmName?: NullableStringFieldUpdateOperationsInput | string | null
    instanceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    principalGeography?: NullableStringFieldUpdateOperationsInput | string | null
    loginUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoutUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    activeModules?: OrganizationUpdateactiveModulesInput | string[]
    clientID?: NullableStringFieldUpdateOperationsInput | string | null
    clientSecret?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearQuarters?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearFormat?: NullableStringFieldUpdateOperationsInput | string | null
    auditYear?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    business?: BusinessUpdateManyWithoutOrganizationNestedInput
    Doctype?: DoctypeUpdateManyWithoutOrganizationNestedInput
    entity?: EntityUpdateManyWithoutOrganizationNestedInput
    entityType?: EntityTypeUpdateManyWithoutOrganizationNestedInput
    location?: LocationUpdateManyWithoutOrganizationNestedInput
    role?: RoleUpdateManyWithoutOrganizationNestedInput
    section?: SectionUpdateManyWithoutOrganizationNestedInput
    systemType?: SystemTypeUpdateManyWithoutOrganizationNestedInput
    user?: UserUpdateManyWithoutOrganizationNestedInput
    userPersonalisation?: userPersonalisationUpdateManyWithoutOrganizationNestedInput
    ConnectedApps?: ConnectedAppsUpdateManyWithoutOrganizationNestedInput
    unitOfMeasurement?: unitTypeUpdateManyWithoutOrganizationNestedInput
    kpi?: kpiUpdateManyWithoutOrganizationNestedInput
    businessType?: businessTypeUpdateManyWithoutOrganizationNestedInput
    prefixSuffix?: prefixSuffixUpdateManyWithoutOrganizationNestedInput
    serialNumber?: serialNumberUpdateManyWithoutOrganizationNestedInput
    function?: FunctionsUpdateManyWithoutOrganizationNestedInput
    rolesTable?: rolesTableUpdateManyWithoutOrganizationNestedInput
    problem?: ProblemUpdateManyWithoutOrganizationNestedInput
    parts?: PartsUpdateManyWithoutOrganizationNestedInput
    Models?: ModelsUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutDocumentsInput = {
    kcId?: NullableStringFieldUpdateOperationsInput | string | null
    organizationName?: NullableStringFieldUpdateOperationsInput | string | null
    realmName?: NullableStringFieldUpdateOperationsInput | string | null
    instanceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    principalGeography?: NullableStringFieldUpdateOperationsInput | string | null
    loginUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoutUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    activeModules?: OrganizationUpdateactiveModulesInput | string[]
    clientID?: NullableStringFieldUpdateOperationsInput | string | null
    clientSecret?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearQuarters?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearFormat?: NullableStringFieldUpdateOperationsInput | string | null
    auditYear?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    business?: BusinessUncheckedUpdateManyWithoutOrganizationNestedInput
    Doctype?: DoctypeUncheckedUpdateManyWithoutOrganizationNestedInput
    entity?: EntityUncheckedUpdateManyWithoutOrganizationNestedInput
    entityType?: EntityTypeUncheckedUpdateManyWithoutOrganizationNestedInput
    location?: LocationUncheckedUpdateManyWithoutOrganizationNestedInput
    role?: RoleUncheckedUpdateManyWithoutOrganizationNestedInput
    section?: SectionUncheckedUpdateManyWithoutOrganizationNestedInput
    systemType?: SystemTypeUncheckedUpdateManyWithoutOrganizationNestedInput
    user?: UserUncheckedUpdateManyWithoutOrganizationNestedInput
    userPersonalisation?: userPersonalisationUncheckedUpdateManyWithoutOrganizationNestedInput
    ConnectedApps?: ConnectedAppsUncheckedUpdateManyWithoutOrganizationNestedInput
    unitOfMeasurement?: unitTypeUncheckedUpdateManyWithoutOrganizationNestedInput
    kpi?: kpiUncheckedUpdateManyWithoutOrganizationNestedInput
    businessType?: businessTypeUncheckedUpdateManyWithoutOrganizationNestedInput
    prefixSuffix?: prefixSuffixUncheckedUpdateManyWithoutOrganizationNestedInput
    serialNumber?: serialNumberUncheckedUpdateManyWithoutOrganizationNestedInput
    function?: FunctionsUncheckedUpdateManyWithoutOrganizationNestedInput
    rolesTable?: rolesTableUncheckedUpdateManyWithoutOrganizationNestedInput
    problem?: ProblemUncheckedUpdateManyWithoutOrganizationNestedInput
    parts?: PartsUncheckedUpdateManyWithoutOrganizationNestedInput
    Models?: ModelsUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type LocationUpsertWithoutDocumentsInput = {
    update: XOR<LocationUpdateWithoutDocumentsInput, LocationUncheckedUpdateWithoutDocumentsInput>
    create: XOR<LocationCreateWithoutDocumentsInput, LocationUncheckedCreateWithoutDocumentsInput>
    where?: LocationWhereInput
  }

  export type LocationUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: LocationWhereInput
    data: XOR<LocationUpdateWithoutDocumentsInput, LocationUncheckedUpdateWithoutDocumentsInput>
  }

  export type LocationUpdateWithoutDocumentsInput = {
    locationName?: NullableStringFieldUpdateOperationsInput | string | null
    locationType?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    functionId?: LocationUpdatefunctionIdInput | string[]
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    users?: LocationUpdateusersInput | InputJsonValue[]
    businessTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: OrganizationUpdateOneWithoutLocationNestedInput
    entity?: EntityUpdateManyWithoutLocationNestedInput
    business?: LocationBusinessUpdateManyWithoutLocationNestedInput
    user?: UserUpdateManyWithoutLocationNestedInput
    uom?: unitTypeUpdateManyWithoutLocationNestedInput
    rolesTable?: rolesTableUpdateManyWithoutLocationNestedInput
    Role?: RoleUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateWithoutDocumentsInput = {
    locationName?: NullableStringFieldUpdateOperationsInput | string | null
    locationType?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    functionId?: LocationUpdatefunctionIdInput | string[]
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    users?: LocationUpdateusersInput | InputJsonValue[]
    businessTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    entity?: EntityUncheckedUpdateManyWithoutLocationNestedInput
    business?: LocationBusinessUncheckedUpdateManyWithoutLocationNestedInput
    user?: UserUncheckedUpdateManyWithoutLocationNestedInput
    uom?: unitTypeUncheckedUpdateManyWithoutLocationNestedInput
    rolesTable?: rolesTableUncheckedUpdateManyWithoutLocationNestedInput
    Role?: RoleUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type EntityUpsertWithoutDocumentsInput = {
    update: XOR<EntityUpdateWithoutDocumentsInput, EntityUncheckedUpdateWithoutDocumentsInput>
    create: XOR<EntityCreateWithoutDocumentsInput, EntityUncheckedCreateWithoutDocumentsInput>
    where?: EntityWhereInput
  }

  export type EntityUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: EntityWhereInput
    data: XOR<EntityUpdateWithoutDocumentsInput, EntityUncheckedUpdateWithoutDocumentsInput>
  }

  export type EntityUpdateWithoutDocumentsInput = {
    entityName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    users?: EntityUpdateusersInput | string[]
    sections?: EntityUpdatesectionsInput | string[]
    entityType?: EntityTypeUpdateOneWithoutEntityNestedInput
    location?: LocationUpdateOneWithoutEntityNestedInput
    organization?: OrganizationUpdateOneWithoutEntityNestedInput
    Doctype?: DoctypeUpdateManyWithoutEntityNestedInput
    user?: UserUpdateManyWithoutEntityNestedInput
    parts?: PartsUpdateManyWithoutEntityNestedInput
    claimToEntity?: ClaimToEntityUpdateManyWithoutEntityNestedInput
    function?: FunctionsUpdateOneWithoutEntityNestedInput
  }

  export type EntityUncheckedUpdateWithoutDocumentsInput = {
    entityName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    entityTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    users?: EntityUpdateusersInput | string[]
    sections?: EntityUpdatesectionsInput | string[]
    functionId?: NullableStringFieldUpdateOperationsInput | string | null
    Doctype?: DoctypeUncheckedUpdateManyWithoutEntityNestedInput
    user?: UserUncheckedUpdateManyWithoutEntityNestedInput
    parts?: PartsUncheckedUpdateManyWithoutEntityNestedInput
    claimToEntity?: ClaimToEntityUncheckedUpdateManyWithoutEntityNestedInput
  }

  export type ReferenceDocumentsUpsertWithWhereUniqueWithoutDocumentInput = {
    where: ReferenceDocumentsWhereUniqueInput
    update: XOR<ReferenceDocumentsUpdateWithoutDocumentInput, ReferenceDocumentsUncheckedUpdateWithoutDocumentInput>
    create: XOR<ReferenceDocumentsCreateWithoutDocumentInput, ReferenceDocumentsUncheckedCreateWithoutDocumentInput>
  }

  export type ReferenceDocumentsUpdateWithWhereUniqueWithoutDocumentInput = {
    where: ReferenceDocumentsWhereUniqueInput
    data: XOR<ReferenceDocumentsUpdateWithoutDocumentInput, ReferenceDocumentsUncheckedUpdateWithoutDocumentInput>
  }

  export type ReferenceDocumentsUpdateManyWithWhereWithoutDocumentInput = {
    where: ReferenceDocumentsScalarWhereInput
    data: XOR<ReferenceDocumentsUpdateManyMutationInput, ReferenceDocumentsUncheckedUpdateManyWithoutDocumentInput>
  }

  export type ReferenceDocumentsScalarWhereInput = {
    AND?: ReferenceDocumentsScalarWhereInput | ReferenceDocumentsScalarWhereInput[]
    OR?: ReferenceDocumentsScalarWhereInput[]
    NOT?: ReferenceDocumentsScalarWhereInput | ReferenceDocumentsScalarWhereInput[]
    id?: StringFilter<"ReferenceDocuments"> | string
    documentLink?: StringNullableFilter<"ReferenceDocuments"> | string | null
    type?: StringNullableFilter<"ReferenceDocuments"> | string | null
    documentName?: StringNullableFilter<"ReferenceDocuments"> | string | null
    version?: StringNullableFilter<"ReferenceDocuments"> | string | null
    documentId?: StringNullableFilter<"ReferenceDocuments"> | string | null
    createdAt?: DateTimeFilter<"ReferenceDocuments"> | Date | string
    updatedAt?: DateTimeFilter<"ReferenceDocuments"> | Date | string
    referenceDocId?: StringNullableFilter<"ReferenceDocuments"> | string | null
    versionId?: StringNullableFilter<"ReferenceDocuments"> | string | null
  }

  export type DocumentVersionsUpsertWithWhereUniqueWithoutDocumentInput = {
    where: DocumentVersionsWhereUniqueInput
    update: XOR<DocumentVersionsUpdateWithoutDocumentInput, DocumentVersionsUncheckedUpdateWithoutDocumentInput>
    create: XOR<DocumentVersionsCreateWithoutDocumentInput, DocumentVersionsUncheckedCreateWithoutDocumentInput>
  }

  export type DocumentVersionsUpdateWithWhereUniqueWithoutDocumentInput = {
    where: DocumentVersionsWhereUniqueInput
    data: XOR<DocumentVersionsUpdateWithoutDocumentInput, DocumentVersionsUncheckedUpdateWithoutDocumentInput>
  }

  export type DocumentVersionsUpdateManyWithWhereWithoutDocumentInput = {
    where: DocumentVersionsScalarWhereInput
    data: XOR<DocumentVersionsUpdateManyMutationInput, DocumentVersionsUncheckedUpdateManyWithoutDocumentInput>
  }

  export type DocumentCommentsUpsertWithWhereUniqueWithoutDocumentInput = {
    where: DocumentCommentsWhereUniqueInput
    update: XOR<DocumentCommentsUpdateWithoutDocumentInput, DocumentCommentsUncheckedUpdateWithoutDocumentInput>
    create: XOR<DocumentCommentsCreateWithoutDocumentInput, DocumentCommentsUncheckedCreateWithoutDocumentInput>
  }

  export type DocumentCommentsUpdateWithWhereUniqueWithoutDocumentInput = {
    where: DocumentCommentsWhereUniqueInput
    data: XOR<DocumentCommentsUpdateWithoutDocumentInput, DocumentCommentsUncheckedUpdateWithoutDocumentInput>
  }

  export type DocumentCommentsUpdateManyWithWhereWithoutDocumentInput = {
    where: DocumentCommentsScalarWhereInput
    data: XOR<DocumentCommentsUpdateManyMutationInput, DocumentCommentsUncheckedUpdateManyWithoutDocumentInput>
  }

  export type DocumentWorkFlowHistoryUpsertWithWhereUniqueWithoutDocumentInput = {
    where: DocumentWorkFlowHistoryWhereUniqueInput
    update: XOR<DocumentWorkFlowHistoryUpdateWithoutDocumentInput, DocumentWorkFlowHistoryUncheckedUpdateWithoutDocumentInput>
    create: XOR<DocumentWorkFlowHistoryCreateWithoutDocumentInput, DocumentWorkFlowHistoryUncheckedCreateWithoutDocumentInput>
  }

  export type DocumentWorkFlowHistoryUpdateWithWhereUniqueWithoutDocumentInput = {
    where: DocumentWorkFlowHistoryWhereUniqueInput
    data: XOR<DocumentWorkFlowHistoryUpdateWithoutDocumentInput, DocumentWorkFlowHistoryUncheckedUpdateWithoutDocumentInput>
  }

  export type DocumentWorkFlowHistoryUpdateManyWithWhereWithoutDocumentInput = {
    where: DocumentWorkFlowHistoryScalarWhereInput
    data: XOR<DocumentWorkFlowHistoryUpdateManyMutationInput, DocumentWorkFlowHistoryUncheckedUpdateManyWithoutDocumentInput>
  }

  export type AdditionalDocumentAdminsUpsertWithWhereUniqueWithoutDocumentInput = {
    where: AdditionalDocumentAdminsWhereUniqueInput
    update: XOR<AdditionalDocumentAdminsUpdateWithoutDocumentInput, AdditionalDocumentAdminsUncheckedUpdateWithoutDocumentInput>
    create: XOR<AdditionalDocumentAdminsCreateWithoutDocumentInput, AdditionalDocumentAdminsUncheckedCreateWithoutDocumentInput>
  }

  export type AdditionalDocumentAdminsUpdateWithWhereUniqueWithoutDocumentInput = {
    where: AdditionalDocumentAdminsWhereUniqueInput
    data: XOR<AdditionalDocumentAdminsUpdateWithoutDocumentInput, AdditionalDocumentAdminsUncheckedUpdateWithoutDocumentInput>
  }

  export type AdditionalDocumentAdminsUpdateManyWithWhereWithoutDocumentInput = {
    where: AdditionalDocumentAdminsScalarWhereInput
    data: XOR<AdditionalDocumentAdminsUpdateManyMutationInput, AdditionalDocumentAdminsUncheckedUpdateManyWithoutDocumentInput>
  }

  export type VersionReferenceDocumentsUpsertWithWhereUniqueWithoutDocumentsInput = {
    where: VersionReferenceDocumentsWhereUniqueInput
    update: XOR<VersionReferenceDocumentsUpdateWithoutDocumentsInput, VersionReferenceDocumentsUncheckedUpdateWithoutDocumentsInput>
    create: XOR<VersionReferenceDocumentsCreateWithoutDocumentsInput, VersionReferenceDocumentsUncheckedCreateWithoutDocumentsInput>
  }

  export type VersionReferenceDocumentsUpdateWithWhereUniqueWithoutDocumentsInput = {
    where: VersionReferenceDocumentsWhereUniqueInput
    data: XOR<VersionReferenceDocumentsUpdateWithoutDocumentsInput, VersionReferenceDocumentsUncheckedUpdateWithoutDocumentsInput>
  }

  export type VersionReferenceDocumentsUpdateManyWithWhereWithoutDocumentsInput = {
    where: VersionReferenceDocumentsScalarWhereInput
    data: XOR<VersionReferenceDocumentsUpdateManyMutationInput, VersionReferenceDocumentsUncheckedUpdateManyWithoutDocumentsInput>
  }

  export type VersionReferenceDocumentsScalarWhereInput = {
    AND?: VersionReferenceDocumentsScalarWhereInput | VersionReferenceDocumentsScalarWhereInput[]
    OR?: VersionReferenceDocumentsScalarWhereInput[]
    NOT?: VersionReferenceDocumentsScalarWhereInput | VersionReferenceDocumentsScalarWhereInput[]
    id?: StringFilter<"VersionReferenceDocuments"> | string
    documentLink?: StringNullableFilter<"VersionReferenceDocuments"> | string | null
    type?: StringNullableFilter<"VersionReferenceDocuments"> | string | null
    documentName?: StringNullableFilter<"VersionReferenceDocuments"> | string | null
    version?: StringNullableFilter<"VersionReferenceDocuments"> | string | null
    createdAt?: DateTimeFilter<"VersionReferenceDocuments"> | Date | string
    updatedAt?: DateTimeFilter<"VersionReferenceDocuments"> | Date | string
    referenceDocId?: StringNullableFilter<"VersionReferenceDocuments"> | string | null
    versionId?: StringNullableFilter<"VersionReferenceDocuments"> | string | null
    documentsId?: StringNullableFilter<"VersionReferenceDocuments"> | string | null
  }

  export type DocumentsCreateWithoutReferenceDocumentsInput = {
    id?: string
    documentName?: string | null
    documentNumbering?: string | null
    reasonOfCreation?: string | null
    effectiveDate?: Date | string | null
    nextRevisionDate?: Date | string | null
    currentVersion?: string | null
    documentLink?: string | null
    description?: string | null
    tags?: DocumentsCreatetagsInput | string[]
    documentState?: string | null
    system?: DocumentsCreatesystemInput | string[]
    section?: string | null
    revertComment?: string | null
    docType?: string | null
    documentClassification?: string | null
    issueNumber?: string | null
    retireComment?: string | null
    revisionReminderFlag?: boolean | null
    isVersion?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedDate?: Date | string | null
    countNumber?: number | null
    createdBy?: string | null
    distributionList?: string | null
    documentId?: string | null
    reviewers?: DocumentsCreatereviewersInput | string[]
    approvers?: DocumentsCreateapproversInput | string[]
    creators?: DocumentsCreatecreatorsInput | string[]
    distributionUsers?: DocumentsCreatedistributionUsersInput | InputJsonValue[]
    readAccess?: string | null
    readAccessUsers?: DocumentsCreatereadAccessUsersInput | InputJsonValue[]
    versionInfo?: DocumentsCreateversionInfoInput | InputJsonValue[]
    doctype?: DoctypeCreateNestedOneWithoutDocumentsInput
    organization?: OrganizationCreateNestedOneWithoutDocumentsInput
    creatorLocation?: LocationCreateNestedOneWithoutDocumentsInput
    creatorEntity?: EntityCreateNestedOneWithoutDocumentsInput
    DocumentVersions?: DocumentVersionsCreateNestedManyWithoutDocumentInput
    DocumentComments?: DocumentCommentsCreateNestedManyWithoutDocumentInput
    DocumentWorkFlowHistory?: DocumentWorkFlowHistoryCreateNestedManyWithoutDocumentInput
    AdditionalDocumentAdmins?: AdditionalDocumentAdminsCreateNestedManyWithoutDocumentInput
    VersionReferenceDocuments?: VersionReferenceDocumentsCreateNestedManyWithoutDocumentsInput
  }

  export type DocumentsUncheckedCreateWithoutReferenceDocumentsInput = {
    id?: string
    doctypeId?: string | null
    organizationId?: string | null
    documentName?: string | null
    documentNumbering?: string | null
    reasonOfCreation?: string | null
    effectiveDate?: Date | string | null
    nextRevisionDate?: Date | string | null
    currentVersion?: string | null
    documentLink?: string | null
    description?: string | null
    tags?: DocumentsCreatetagsInput | string[]
    documentState?: string | null
    locationId: string
    entityId?: string | null
    system?: DocumentsCreatesystemInput | string[]
    section?: string | null
    revertComment?: string | null
    docType?: string | null
    documentClassification?: string | null
    issueNumber?: string | null
    retireComment?: string | null
    revisionReminderFlag?: boolean | null
    isVersion?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedDate?: Date | string | null
    countNumber?: number | null
    createdBy?: string | null
    distributionList?: string | null
    documentId?: string | null
    reviewers?: DocumentsCreatereviewersInput | string[]
    approvers?: DocumentsCreateapproversInput | string[]
    creators?: DocumentsCreatecreatorsInput | string[]
    distributionUsers?: DocumentsCreatedistributionUsersInput | InputJsonValue[]
    readAccess?: string | null
    readAccessUsers?: DocumentsCreatereadAccessUsersInput | InputJsonValue[]
    versionInfo?: DocumentsCreateversionInfoInput | InputJsonValue[]
    DocumentVersions?: DocumentVersionsUncheckedCreateNestedManyWithoutDocumentInput
    DocumentComments?: DocumentCommentsUncheckedCreateNestedManyWithoutDocumentInput
    DocumentWorkFlowHistory?: DocumentWorkFlowHistoryUncheckedCreateNestedManyWithoutDocumentInput
    AdditionalDocumentAdmins?: AdditionalDocumentAdminsUncheckedCreateNestedManyWithoutDocumentInput
    VersionReferenceDocuments?: VersionReferenceDocumentsUncheckedCreateNestedManyWithoutDocumentsInput
  }

  export type DocumentsCreateOrConnectWithoutReferenceDocumentsInput = {
    where: DocumentsWhereUniqueInput
    create: XOR<DocumentsCreateWithoutReferenceDocumentsInput, DocumentsUncheckedCreateWithoutReferenceDocumentsInput>
  }

  export type DocumentVersionsCreateWithoutReferenceDocumentsInput = {
    id?: string
    versionName: string
    by?: string | null
    approvedDate?: Date | string | null
    versionLink: string
    createdAt?: Date | string
    updatedAt?: Date | string
    documentName?: string | null
    documentNumbering?: string | null
    reasonOfCreation?: string | null
    effectiveDate?: Date | string | null
    description?: string | null
    issueNumber?: string | null
    document?: DocumentsCreateNestedOneWithoutDocumentVersionsInput
    user?: UserCreateNestedOneWithoutDocumentVersionsInput
    VersionReferenceDocuments?: VersionReferenceDocumentsCreateNestedManyWithoutVersionsLinkedWithInput
  }

  export type DocumentVersionsUncheckedCreateWithoutReferenceDocumentsInput = {
    id?: string
    versionName: string
    userId?: string | null
    by?: string | null
    approvedDate?: Date | string | null
    versionLink: string
    documentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    documentName?: string | null
    documentNumbering?: string | null
    reasonOfCreation?: string | null
    effectiveDate?: Date | string | null
    description?: string | null
    issueNumber?: string | null
    VersionReferenceDocuments?: VersionReferenceDocumentsUncheckedCreateNestedManyWithoutVersionsLinkedWithInput
  }

  export type DocumentVersionsCreateOrConnectWithoutReferenceDocumentsInput = {
    where: DocumentVersionsWhereUniqueInput
    create: XOR<DocumentVersionsCreateWithoutReferenceDocumentsInput, DocumentVersionsUncheckedCreateWithoutReferenceDocumentsInput>
  }

  export type DocumentsUpsertWithoutReferenceDocumentsInput = {
    update: XOR<DocumentsUpdateWithoutReferenceDocumentsInput, DocumentsUncheckedUpdateWithoutReferenceDocumentsInput>
    create: XOR<DocumentsCreateWithoutReferenceDocumentsInput, DocumentsUncheckedCreateWithoutReferenceDocumentsInput>
    where?: DocumentsWhereInput
  }

  export type DocumentsUpdateToOneWithWhereWithoutReferenceDocumentsInput = {
    where?: DocumentsWhereInput
    data: XOR<DocumentsUpdateWithoutReferenceDocumentsInput, DocumentsUncheckedUpdateWithoutReferenceDocumentsInput>
  }

  export type DocumentsUpdateWithoutReferenceDocumentsInput = {
    documentName?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumbering?: NullableStringFieldUpdateOperationsInput | string | null
    reasonOfCreation?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextRevisionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentVersion?: NullableStringFieldUpdateOperationsInput | string | null
    documentLink?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: DocumentsUpdatetagsInput | string[]
    documentState?: NullableStringFieldUpdateOperationsInput | string | null
    system?: DocumentsUpdatesystemInput | string[]
    section?: NullableStringFieldUpdateOperationsInput | string | null
    revertComment?: NullableStringFieldUpdateOperationsInput | string | null
    docType?: NullableStringFieldUpdateOperationsInput | string | null
    documentClassification?: NullableStringFieldUpdateOperationsInput | string | null
    issueNumber?: NullableStringFieldUpdateOperationsInput | string | null
    retireComment?: NullableStringFieldUpdateOperationsInput | string | null
    revisionReminderFlag?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isVersion?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    countNumber?: NullableIntFieldUpdateOperationsInput | number | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    distributionList?: NullableStringFieldUpdateOperationsInput | string | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    reviewers?: DocumentsUpdatereviewersInput | string[]
    approvers?: DocumentsUpdateapproversInput | string[]
    creators?: DocumentsUpdatecreatorsInput | string[]
    distributionUsers?: DocumentsUpdatedistributionUsersInput | InputJsonValue[]
    readAccess?: NullableStringFieldUpdateOperationsInput | string | null
    readAccessUsers?: DocumentsUpdatereadAccessUsersInput | InputJsonValue[]
    versionInfo?: DocumentsUpdateversionInfoInput | InputJsonValue[]
    doctype?: DoctypeUpdateOneWithoutDocumentsNestedInput
    organization?: OrganizationUpdateOneWithoutDocumentsNestedInput
    creatorLocation?: LocationUpdateOneWithoutDocumentsNestedInput
    creatorEntity?: EntityUpdateOneWithoutDocumentsNestedInput
    DocumentVersions?: DocumentVersionsUpdateManyWithoutDocumentNestedInput
    DocumentComments?: DocumentCommentsUpdateManyWithoutDocumentNestedInput
    DocumentWorkFlowHistory?: DocumentWorkFlowHistoryUpdateManyWithoutDocumentNestedInput
    AdditionalDocumentAdmins?: AdditionalDocumentAdminsUpdateManyWithoutDocumentNestedInput
    VersionReferenceDocuments?: VersionReferenceDocumentsUpdateManyWithoutDocumentsNestedInput
  }

  export type DocumentsUncheckedUpdateWithoutReferenceDocumentsInput = {
    doctypeId?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    documentName?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumbering?: NullableStringFieldUpdateOperationsInput | string | null
    reasonOfCreation?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextRevisionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentVersion?: NullableStringFieldUpdateOperationsInput | string | null
    documentLink?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: DocumentsUpdatetagsInput | string[]
    documentState?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    system?: DocumentsUpdatesystemInput | string[]
    section?: NullableStringFieldUpdateOperationsInput | string | null
    revertComment?: NullableStringFieldUpdateOperationsInput | string | null
    docType?: NullableStringFieldUpdateOperationsInput | string | null
    documentClassification?: NullableStringFieldUpdateOperationsInput | string | null
    issueNumber?: NullableStringFieldUpdateOperationsInput | string | null
    retireComment?: NullableStringFieldUpdateOperationsInput | string | null
    revisionReminderFlag?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isVersion?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    countNumber?: NullableIntFieldUpdateOperationsInput | number | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    distributionList?: NullableStringFieldUpdateOperationsInput | string | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    reviewers?: DocumentsUpdatereviewersInput | string[]
    approvers?: DocumentsUpdateapproversInput | string[]
    creators?: DocumentsUpdatecreatorsInput | string[]
    distributionUsers?: DocumentsUpdatedistributionUsersInput | InputJsonValue[]
    readAccess?: NullableStringFieldUpdateOperationsInput | string | null
    readAccessUsers?: DocumentsUpdatereadAccessUsersInput | InputJsonValue[]
    versionInfo?: DocumentsUpdateversionInfoInput | InputJsonValue[]
    DocumentVersions?: DocumentVersionsUncheckedUpdateManyWithoutDocumentNestedInput
    DocumentComments?: DocumentCommentsUncheckedUpdateManyWithoutDocumentNestedInput
    DocumentWorkFlowHistory?: DocumentWorkFlowHistoryUncheckedUpdateManyWithoutDocumentNestedInput
    AdditionalDocumentAdmins?: AdditionalDocumentAdminsUncheckedUpdateManyWithoutDocumentNestedInput
    VersionReferenceDocuments?: VersionReferenceDocumentsUncheckedUpdateManyWithoutDocumentsNestedInput
  }

  export type DocumentVersionsUpsertWithoutReferenceDocumentsInput = {
    update: XOR<DocumentVersionsUpdateWithoutReferenceDocumentsInput, DocumentVersionsUncheckedUpdateWithoutReferenceDocumentsInput>
    create: XOR<DocumentVersionsCreateWithoutReferenceDocumentsInput, DocumentVersionsUncheckedCreateWithoutReferenceDocumentsInput>
    where?: DocumentVersionsWhereInput
  }

  export type DocumentVersionsUpdateToOneWithWhereWithoutReferenceDocumentsInput = {
    where?: DocumentVersionsWhereInput
    data: XOR<DocumentVersionsUpdateWithoutReferenceDocumentsInput, DocumentVersionsUncheckedUpdateWithoutReferenceDocumentsInput>
  }

  export type DocumentVersionsUpdateWithoutReferenceDocumentsInput = {
    versionName?: StringFieldUpdateOperationsInput | string
    by?: NullableStringFieldUpdateOperationsInput | string | null
    approvedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    versionLink?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documentName?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumbering?: NullableStringFieldUpdateOperationsInput | string | null
    reasonOfCreation?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    issueNumber?: NullableStringFieldUpdateOperationsInput | string | null
    document?: DocumentsUpdateOneWithoutDocumentVersionsNestedInput
    user?: UserUpdateOneWithoutDocumentVersionsNestedInput
    VersionReferenceDocuments?: VersionReferenceDocumentsUpdateManyWithoutVersionsLinkedWithNestedInput
  }

  export type DocumentVersionsUncheckedUpdateWithoutReferenceDocumentsInput = {
    versionName?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    by?: NullableStringFieldUpdateOperationsInput | string | null
    approvedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    versionLink?: StringFieldUpdateOperationsInput | string
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documentName?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumbering?: NullableStringFieldUpdateOperationsInput | string | null
    reasonOfCreation?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    issueNumber?: NullableStringFieldUpdateOperationsInput | string | null
    VersionReferenceDocuments?: VersionReferenceDocumentsUncheckedUpdateManyWithoutVersionsLinkedWithNestedInput
  }

  export type DocumentsCreateWithoutVersionReferenceDocumentsInput = {
    id?: string
    documentName?: string | null
    documentNumbering?: string | null
    reasonOfCreation?: string | null
    effectiveDate?: Date | string | null
    nextRevisionDate?: Date | string | null
    currentVersion?: string | null
    documentLink?: string | null
    description?: string | null
    tags?: DocumentsCreatetagsInput | string[]
    documentState?: string | null
    system?: DocumentsCreatesystemInput | string[]
    section?: string | null
    revertComment?: string | null
    docType?: string | null
    documentClassification?: string | null
    issueNumber?: string | null
    retireComment?: string | null
    revisionReminderFlag?: boolean | null
    isVersion?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedDate?: Date | string | null
    countNumber?: number | null
    createdBy?: string | null
    distributionList?: string | null
    documentId?: string | null
    reviewers?: DocumentsCreatereviewersInput | string[]
    approvers?: DocumentsCreateapproversInput | string[]
    creators?: DocumentsCreatecreatorsInput | string[]
    distributionUsers?: DocumentsCreatedistributionUsersInput | InputJsonValue[]
    readAccess?: string | null
    readAccessUsers?: DocumentsCreatereadAccessUsersInput | InputJsonValue[]
    versionInfo?: DocumentsCreateversionInfoInput | InputJsonValue[]
    doctype?: DoctypeCreateNestedOneWithoutDocumentsInput
    organization?: OrganizationCreateNestedOneWithoutDocumentsInput
    creatorLocation?: LocationCreateNestedOneWithoutDocumentsInput
    creatorEntity?: EntityCreateNestedOneWithoutDocumentsInput
    ReferenceDocuments?: ReferenceDocumentsCreateNestedManyWithoutDocumentInput
    DocumentVersions?: DocumentVersionsCreateNestedManyWithoutDocumentInput
    DocumentComments?: DocumentCommentsCreateNestedManyWithoutDocumentInput
    DocumentWorkFlowHistory?: DocumentWorkFlowHistoryCreateNestedManyWithoutDocumentInput
    AdditionalDocumentAdmins?: AdditionalDocumentAdminsCreateNestedManyWithoutDocumentInput
  }

  export type DocumentsUncheckedCreateWithoutVersionReferenceDocumentsInput = {
    id?: string
    doctypeId?: string | null
    organizationId?: string | null
    documentName?: string | null
    documentNumbering?: string | null
    reasonOfCreation?: string | null
    effectiveDate?: Date | string | null
    nextRevisionDate?: Date | string | null
    currentVersion?: string | null
    documentLink?: string | null
    description?: string | null
    tags?: DocumentsCreatetagsInput | string[]
    documentState?: string | null
    locationId: string
    entityId?: string | null
    system?: DocumentsCreatesystemInput | string[]
    section?: string | null
    revertComment?: string | null
    docType?: string | null
    documentClassification?: string | null
    issueNumber?: string | null
    retireComment?: string | null
    revisionReminderFlag?: boolean | null
    isVersion?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedDate?: Date | string | null
    countNumber?: number | null
    createdBy?: string | null
    distributionList?: string | null
    documentId?: string | null
    reviewers?: DocumentsCreatereviewersInput | string[]
    approvers?: DocumentsCreateapproversInput | string[]
    creators?: DocumentsCreatecreatorsInput | string[]
    distributionUsers?: DocumentsCreatedistributionUsersInput | InputJsonValue[]
    readAccess?: string | null
    readAccessUsers?: DocumentsCreatereadAccessUsersInput | InputJsonValue[]
    versionInfo?: DocumentsCreateversionInfoInput | InputJsonValue[]
    ReferenceDocuments?: ReferenceDocumentsUncheckedCreateNestedManyWithoutDocumentInput
    DocumentVersions?: DocumentVersionsUncheckedCreateNestedManyWithoutDocumentInput
    DocumentComments?: DocumentCommentsUncheckedCreateNestedManyWithoutDocumentInput
    DocumentWorkFlowHistory?: DocumentWorkFlowHistoryUncheckedCreateNestedManyWithoutDocumentInput
    AdditionalDocumentAdmins?: AdditionalDocumentAdminsUncheckedCreateNestedManyWithoutDocumentInput
  }

  export type DocumentsCreateOrConnectWithoutVersionReferenceDocumentsInput = {
    where: DocumentsWhereUniqueInput
    create: XOR<DocumentsCreateWithoutVersionReferenceDocumentsInput, DocumentsUncheckedCreateWithoutVersionReferenceDocumentsInput>
  }

  export type DocumentVersionsCreateWithoutVersionReferenceDocumentsInput = {
    id?: string
    versionName: string
    by?: string | null
    approvedDate?: Date | string | null
    versionLink: string
    createdAt?: Date | string
    updatedAt?: Date | string
    documentName?: string | null
    documentNumbering?: string | null
    reasonOfCreation?: string | null
    effectiveDate?: Date | string | null
    description?: string | null
    issueNumber?: string | null
    document?: DocumentsCreateNestedOneWithoutDocumentVersionsInput
    user?: UserCreateNestedOneWithoutDocumentVersionsInput
    ReferenceDocuments?: ReferenceDocumentsCreateNestedManyWithoutVersionsLinkedWithInput
  }

  export type DocumentVersionsUncheckedCreateWithoutVersionReferenceDocumentsInput = {
    id?: string
    versionName: string
    userId?: string | null
    by?: string | null
    approvedDate?: Date | string | null
    versionLink: string
    documentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    documentName?: string | null
    documentNumbering?: string | null
    reasonOfCreation?: string | null
    effectiveDate?: Date | string | null
    description?: string | null
    issueNumber?: string | null
    ReferenceDocuments?: ReferenceDocumentsUncheckedCreateNestedManyWithoutVersionsLinkedWithInput
  }

  export type DocumentVersionsCreateOrConnectWithoutVersionReferenceDocumentsInput = {
    where: DocumentVersionsWhereUniqueInput
    create: XOR<DocumentVersionsCreateWithoutVersionReferenceDocumentsInput, DocumentVersionsUncheckedCreateWithoutVersionReferenceDocumentsInput>
  }

  export type DocumentsUpsertWithoutVersionReferenceDocumentsInput = {
    update: XOR<DocumentsUpdateWithoutVersionReferenceDocumentsInput, DocumentsUncheckedUpdateWithoutVersionReferenceDocumentsInput>
    create: XOR<DocumentsCreateWithoutVersionReferenceDocumentsInput, DocumentsUncheckedCreateWithoutVersionReferenceDocumentsInput>
    where?: DocumentsWhereInput
  }

  export type DocumentsUpdateToOneWithWhereWithoutVersionReferenceDocumentsInput = {
    where?: DocumentsWhereInput
    data: XOR<DocumentsUpdateWithoutVersionReferenceDocumentsInput, DocumentsUncheckedUpdateWithoutVersionReferenceDocumentsInput>
  }

  export type DocumentsUpdateWithoutVersionReferenceDocumentsInput = {
    documentName?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumbering?: NullableStringFieldUpdateOperationsInput | string | null
    reasonOfCreation?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextRevisionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentVersion?: NullableStringFieldUpdateOperationsInput | string | null
    documentLink?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: DocumentsUpdatetagsInput | string[]
    documentState?: NullableStringFieldUpdateOperationsInput | string | null
    system?: DocumentsUpdatesystemInput | string[]
    section?: NullableStringFieldUpdateOperationsInput | string | null
    revertComment?: NullableStringFieldUpdateOperationsInput | string | null
    docType?: NullableStringFieldUpdateOperationsInput | string | null
    documentClassification?: NullableStringFieldUpdateOperationsInput | string | null
    issueNumber?: NullableStringFieldUpdateOperationsInput | string | null
    retireComment?: NullableStringFieldUpdateOperationsInput | string | null
    revisionReminderFlag?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isVersion?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    countNumber?: NullableIntFieldUpdateOperationsInput | number | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    distributionList?: NullableStringFieldUpdateOperationsInput | string | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    reviewers?: DocumentsUpdatereviewersInput | string[]
    approvers?: DocumentsUpdateapproversInput | string[]
    creators?: DocumentsUpdatecreatorsInput | string[]
    distributionUsers?: DocumentsUpdatedistributionUsersInput | InputJsonValue[]
    readAccess?: NullableStringFieldUpdateOperationsInput | string | null
    readAccessUsers?: DocumentsUpdatereadAccessUsersInput | InputJsonValue[]
    versionInfo?: DocumentsUpdateversionInfoInput | InputJsonValue[]
    doctype?: DoctypeUpdateOneWithoutDocumentsNestedInput
    organization?: OrganizationUpdateOneWithoutDocumentsNestedInput
    creatorLocation?: LocationUpdateOneWithoutDocumentsNestedInput
    creatorEntity?: EntityUpdateOneWithoutDocumentsNestedInput
    ReferenceDocuments?: ReferenceDocumentsUpdateManyWithoutDocumentNestedInput
    DocumentVersions?: DocumentVersionsUpdateManyWithoutDocumentNestedInput
    DocumentComments?: DocumentCommentsUpdateManyWithoutDocumentNestedInput
    DocumentWorkFlowHistory?: DocumentWorkFlowHistoryUpdateManyWithoutDocumentNestedInput
    AdditionalDocumentAdmins?: AdditionalDocumentAdminsUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentsUncheckedUpdateWithoutVersionReferenceDocumentsInput = {
    doctypeId?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    documentName?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumbering?: NullableStringFieldUpdateOperationsInput | string | null
    reasonOfCreation?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextRevisionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentVersion?: NullableStringFieldUpdateOperationsInput | string | null
    documentLink?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: DocumentsUpdatetagsInput | string[]
    documentState?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    system?: DocumentsUpdatesystemInput | string[]
    section?: NullableStringFieldUpdateOperationsInput | string | null
    revertComment?: NullableStringFieldUpdateOperationsInput | string | null
    docType?: NullableStringFieldUpdateOperationsInput | string | null
    documentClassification?: NullableStringFieldUpdateOperationsInput | string | null
    issueNumber?: NullableStringFieldUpdateOperationsInput | string | null
    retireComment?: NullableStringFieldUpdateOperationsInput | string | null
    revisionReminderFlag?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isVersion?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    countNumber?: NullableIntFieldUpdateOperationsInput | number | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    distributionList?: NullableStringFieldUpdateOperationsInput | string | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    reviewers?: DocumentsUpdatereviewersInput | string[]
    approvers?: DocumentsUpdateapproversInput | string[]
    creators?: DocumentsUpdatecreatorsInput | string[]
    distributionUsers?: DocumentsUpdatedistributionUsersInput | InputJsonValue[]
    readAccess?: NullableStringFieldUpdateOperationsInput | string | null
    readAccessUsers?: DocumentsUpdatereadAccessUsersInput | InputJsonValue[]
    versionInfo?: DocumentsUpdateversionInfoInput | InputJsonValue[]
    ReferenceDocuments?: ReferenceDocumentsUncheckedUpdateManyWithoutDocumentNestedInput
    DocumentVersions?: DocumentVersionsUncheckedUpdateManyWithoutDocumentNestedInput
    DocumentComments?: DocumentCommentsUncheckedUpdateManyWithoutDocumentNestedInput
    DocumentWorkFlowHistory?: DocumentWorkFlowHistoryUncheckedUpdateManyWithoutDocumentNestedInput
    AdditionalDocumentAdmins?: AdditionalDocumentAdminsUncheckedUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentVersionsUpsertWithoutVersionReferenceDocumentsInput = {
    update: XOR<DocumentVersionsUpdateWithoutVersionReferenceDocumentsInput, DocumentVersionsUncheckedUpdateWithoutVersionReferenceDocumentsInput>
    create: XOR<DocumentVersionsCreateWithoutVersionReferenceDocumentsInput, DocumentVersionsUncheckedCreateWithoutVersionReferenceDocumentsInput>
    where?: DocumentVersionsWhereInput
  }

  export type DocumentVersionsUpdateToOneWithWhereWithoutVersionReferenceDocumentsInput = {
    where?: DocumentVersionsWhereInput
    data: XOR<DocumentVersionsUpdateWithoutVersionReferenceDocumentsInput, DocumentVersionsUncheckedUpdateWithoutVersionReferenceDocumentsInput>
  }

  export type DocumentVersionsUpdateWithoutVersionReferenceDocumentsInput = {
    versionName?: StringFieldUpdateOperationsInput | string
    by?: NullableStringFieldUpdateOperationsInput | string | null
    approvedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    versionLink?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documentName?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumbering?: NullableStringFieldUpdateOperationsInput | string | null
    reasonOfCreation?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    issueNumber?: NullableStringFieldUpdateOperationsInput | string | null
    document?: DocumentsUpdateOneWithoutDocumentVersionsNestedInput
    user?: UserUpdateOneWithoutDocumentVersionsNestedInput
    ReferenceDocuments?: ReferenceDocumentsUpdateManyWithoutVersionsLinkedWithNestedInput
  }

  export type DocumentVersionsUncheckedUpdateWithoutVersionReferenceDocumentsInput = {
    versionName?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    by?: NullableStringFieldUpdateOperationsInput | string | null
    approvedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    versionLink?: StringFieldUpdateOperationsInput | string
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documentName?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumbering?: NullableStringFieldUpdateOperationsInput | string | null
    reasonOfCreation?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    issueNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ReferenceDocuments?: ReferenceDocumentsUncheckedUpdateManyWithoutVersionsLinkedWithNestedInput
  }

  export type DocumentsCreateWithoutDocumentVersionsInput = {
    id?: string
    documentName?: string | null
    documentNumbering?: string | null
    reasonOfCreation?: string | null
    effectiveDate?: Date | string | null
    nextRevisionDate?: Date | string | null
    currentVersion?: string | null
    documentLink?: string | null
    description?: string | null
    tags?: DocumentsCreatetagsInput | string[]
    documentState?: string | null
    system?: DocumentsCreatesystemInput | string[]
    section?: string | null
    revertComment?: string | null
    docType?: string | null
    documentClassification?: string | null
    issueNumber?: string | null
    retireComment?: string | null
    revisionReminderFlag?: boolean | null
    isVersion?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedDate?: Date | string | null
    countNumber?: number | null
    createdBy?: string | null
    distributionList?: string | null
    documentId?: string | null
    reviewers?: DocumentsCreatereviewersInput | string[]
    approvers?: DocumentsCreateapproversInput | string[]
    creators?: DocumentsCreatecreatorsInput | string[]
    distributionUsers?: DocumentsCreatedistributionUsersInput | InputJsonValue[]
    readAccess?: string | null
    readAccessUsers?: DocumentsCreatereadAccessUsersInput | InputJsonValue[]
    versionInfo?: DocumentsCreateversionInfoInput | InputJsonValue[]
    doctype?: DoctypeCreateNestedOneWithoutDocumentsInput
    organization?: OrganizationCreateNestedOneWithoutDocumentsInput
    creatorLocation?: LocationCreateNestedOneWithoutDocumentsInput
    creatorEntity?: EntityCreateNestedOneWithoutDocumentsInput
    ReferenceDocuments?: ReferenceDocumentsCreateNestedManyWithoutDocumentInput
    DocumentComments?: DocumentCommentsCreateNestedManyWithoutDocumentInput
    DocumentWorkFlowHistory?: DocumentWorkFlowHistoryCreateNestedManyWithoutDocumentInput
    AdditionalDocumentAdmins?: AdditionalDocumentAdminsCreateNestedManyWithoutDocumentInput
    VersionReferenceDocuments?: VersionReferenceDocumentsCreateNestedManyWithoutDocumentsInput
  }

  export type DocumentsUncheckedCreateWithoutDocumentVersionsInput = {
    id?: string
    doctypeId?: string | null
    organizationId?: string | null
    documentName?: string | null
    documentNumbering?: string | null
    reasonOfCreation?: string | null
    effectiveDate?: Date | string | null
    nextRevisionDate?: Date | string | null
    currentVersion?: string | null
    documentLink?: string | null
    description?: string | null
    tags?: DocumentsCreatetagsInput | string[]
    documentState?: string | null
    locationId: string
    entityId?: string | null
    system?: DocumentsCreatesystemInput | string[]
    section?: string | null
    revertComment?: string | null
    docType?: string | null
    documentClassification?: string | null
    issueNumber?: string | null
    retireComment?: string | null
    revisionReminderFlag?: boolean | null
    isVersion?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedDate?: Date | string | null
    countNumber?: number | null
    createdBy?: string | null
    distributionList?: string | null
    documentId?: string | null
    reviewers?: DocumentsCreatereviewersInput | string[]
    approvers?: DocumentsCreateapproversInput | string[]
    creators?: DocumentsCreatecreatorsInput | string[]
    distributionUsers?: DocumentsCreatedistributionUsersInput | InputJsonValue[]
    readAccess?: string | null
    readAccessUsers?: DocumentsCreatereadAccessUsersInput | InputJsonValue[]
    versionInfo?: DocumentsCreateversionInfoInput | InputJsonValue[]
    ReferenceDocuments?: ReferenceDocumentsUncheckedCreateNestedManyWithoutDocumentInput
    DocumentComments?: DocumentCommentsUncheckedCreateNestedManyWithoutDocumentInput
    DocumentWorkFlowHistory?: DocumentWorkFlowHistoryUncheckedCreateNestedManyWithoutDocumentInput
    AdditionalDocumentAdmins?: AdditionalDocumentAdminsUncheckedCreateNestedManyWithoutDocumentInput
    VersionReferenceDocuments?: VersionReferenceDocumentsUncheckedCreateNestedManyWithoutDocumentsInput
  }

  export type DocumentsCreateOrConnectWithoutDocumentVersionsInput = {
    where: DocumentsWhereUniqueInput
    create: XOR<DocumentsCreateWithoutDocumentVersionsInput, DocumentsUncheckedCreateWithoutDocumentVersionsInput>
  }

  export type UserCreateWithoutDocumentVersionsInput = {
    id?: string
    kcId?: string | null
    email?: string | null
    username?: string | null
    firstname?: string | null
    lastname?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    enabled?: boolean | null
    userType?: string | null
    status?: boolean | null
    avatar?: string | null
    deleted?: boolean | null
    roleId?: UserCreateroleIdInput | string[]
    functionId?: InputJsonValue | null
    additionalUnits?: UserCreateadditionalUnitsInput | string[]
    entity?: EntityCreateNestedOneWithoutUserInput
    location?: LocationCreateNestedOneWithoutUserInput
    organization?: OrganizationCreateNestedOneWithoutUserInput
    AdditionalDocumentAdmins?: AdditionalDocumentAdminsCreateNestedManyWithoutUserInput
    DocumentComments?: DocumentCommentsCreateNestedManyWithoutUserInput
    DocumentWorkFlowHistory?: DocumentWorkFlowHistoryCreateNestedManyWithoutUserInput
    Logs?: LogsCreateNestedManyWithoutUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
    documentAdmins?: documentAdminsCreateNestedManyWithoutUserInput
    userPersonalisation?: userPersonalisationCreateNestedManyWithoutUserInput
    auditTrial?: auditTrialCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDocumentVersionsInput = {
    id?: string
    kcId?: string | null
    email?: string | null
    username?: string | null
    firstname?: string | null
    lastname?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    enabled?: boolean | null
    organizationId?: string | null
    locationId?: string | null
    entityId?: string | null
    userType?: string | null
    status?: boolean | null
    avatar?: string | null
    deleted?: boolean | null
    roleId?: UserCreateroleIdInput | string[]
    functionId?: InputJsonValue | null
    additionalUnits?: UserCreateadditionalUnitsInput | string[]
    AdditionalDocumentAdmins?: AdditionalDocumentAdminsUncheckedCreateNestedManyWithoutUserInput
    DocumentComments?: DocumentCommentsUncheckedCreateNestedManyWithoutUserInput
    DocumentWorkFlowHistory?: DocumentWorkFlowHistoryUncheckedCreateNestedManyWithoutUserInput
    Logs?: LogsUncheckedCreateNestedManyWithoutUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    documentAdmins?: documentAdminsUncheckedCreateNestedManyWithoutUserInput
    userPersonalisation?: userPersonalisationUncheckedCreateNestedManyWithoutUserInput
    auditTrial?: auditTrialUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDocumentVersionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDocumentVersionsInput, UserUncheckedCreateWithoutDocumentVersionsInput>
  }

  export type ReferenceDocumentsCreateWithoutVersionsLinkedWithInput = {
    id?: string
    documentLink?: string | null
    type?: string | null
    documentName?: string | null
    version?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    referenceDocId?: string | null
    document?: DocumentsCreateNestedOneWithoutReferenceDocumentsInput
  }

  export type ReferenceDocumentsUncheckedCreateWithoutVersionsLinkedWithInput = {
    id?: string
    documentLink?: string | null
    type?: string | null
    documentName?: string | null
    version?: string | null
    documentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    referenceDocId?: string | null
  }

  export type ReferenceDocumentsCreateOrConnectWithoutVersionsLinkedWithInput = {
    where: ReferenceDocumentsWhereUniqueInput
    create: XOR<ReferenceDocumentsCreateWithoutVersionsLinkedWithInput, ReferenceDocumentsUncheckedCreateWithoutVersionsLinkedWithInput>
  }

  export type ReferenceDocumentsCreateManyVersionsLinkedWithInputEnvelope = {
    data: ReferenceDocumentsCreateManyVersionsLinkedWithInput | ReferenceDocumentsCreateManyVersionsLinkedWithInput[]
  }

  export type VersionReferenceDocumentsCreateWithoutVersionsLinkedWithInput = {
    id?: string
    documentLink?: string | null
    type?: string | null
    documentName?: string | null
    version?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    referenceDocId?: string | null
    Documents?: DocumentsCreateNestedOneWithoutVersionReferenceDocumentsInput
  }

  export type VersionReferenceDocumentsUncheckedCreateWithoutVersionsLinkedWithInput = {
    id?: string
    documentLink?: string | null
    type?: string | null
    documentName?: string | null
    version?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    referenceDocId?: string | null
    documentsId?: string | null
  }

  export type VersionReferenceDocumentsCreateOrConnectWithoutVersionsLinkedWithInput = {
    where: VersionReferenceDocumentsWhereUniqueInput
    create: XOR<VersionReferenceDocumentsCreateWithoutVersionsLinkedWithInput, VersionReferenceDocumentsUncheckedCreateWithoutVersionsLinkedWithInput>
  }

  export type VersionReferenceDocumentsCreateManyVersionsLinkedWithInputEnvelope = {
    data: VersionReferenceDocumentsCreateManyVersionsLinkedWithInput | VersionReferenceDocumentsCreateManyVersionsLinkedWithInput[]
  }

  export type DocumentsUpsertWithoutDocumentVersionsInput = {
    update: XOR<DocumentsUpdateWithoutDocumentVersionsInput, DocumentsUncheckedUpdateWithoutDocumentVersionsInput>
    create: XOR<DocumentsCreateWithoutDocumentVersionsInput, DocumentsUncheckedCreateWithoutDocumentVersionsInput>
    where?: DocumentsWhereInput
  }

  export type DocumentsUpdateToOneWithWhereWithoutDocumentVersionsInput = {
    where?: DocumentsWhereInput
    data: XOR<DocumentsUpdateWithoutDocumentVersionsInput, DocumentsUncheckedUpdateWithoutDocumentVersionsInput>
  }

  export type DocumentsUpdateWithoutDocumentVersionsInput = {
    documentName?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumbering?: NullableStringFieldUpdateOperationsInput | string | null
    reasonOfCreation?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextRevisionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentVersion?: NullableStringFieldUpdateOperationsInput | string | null
    documentLink?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: DocumentsUpdatetagsInput | string[]
    documentState?: NullableStringFieldUpdateOperationsInput | string | null
    system?: DocumentsUpdatesystemInput | string[]
    section?: NullableStringFieldUpdateOperationsInput | string | null
    revertComment?: NullableStringFieldUpdateOperationsInput | string | null
    docType?: NullableStringFieldUpdateOperationsInput | string | null
    documentClassification?: NullableStringFieldUpdateOperationsInput | string | null
    issueNumber?: NullableStringFieldUpdateOperationsInput | string | null
    retireComment?: NullableStringFieldUpdateOperationsInput | string | null
    revisionReminderFlag?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isVersion?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    countNumber?: NullableIntFieldUpdateOperationsInput | number | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    distributionList?: NullableStringFieldUpdateOperationsInput | string | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    reviewers?: DocumentsUpdatereviewersInput | string[]
    approvers?: DocumentsUpdateapproversInput | string[]
    creators?: DocumentsUpdatecreatorsInput | string[]
    distributionUsers?: DocumentsUpdatedistributionUsersInput | InputJsonValue[]
    readAccess?: NullableStringFieldUpdateOperationsInput | string | null
    readAccessUsers?: DocumentsUpdatereadAccessUsersInput | InputJsonValue[]
    versionInfo?: DocumentsUpdateversionInfoInput | InputJsonValue[]
    doctype?: DoctypeUpdateOneWithoutDocumentsNestedInput
    organization?: OrganizationUpdateOneWithoutDocumentsNestedInput
    creatorLocation?: LocationUpdateOneWithoutDocumentsNestedInput
    creatorEntity?: EntityUpdateOneWithoutDocumentsNestedInput
    ReferenceDocuments?: ReferenceDocumentsUpdateManyWithoutDocumentNestedInput
    DocumentComments?: DocumentCommentsUpdateManyWithoutDocumentNestedInput
    DocumentWorkFlowHistory?: DocumentWorkFlowHistoryUpdateManyWithoutDocumentNestedInput
    AdditionalDocumentAdmins?: AdditionalDocumentAdminsUpdateManyWithoutDocumentNestedInput
    VersionReferenceDocuments?: VersionReferenceDocumentsUpdateManyWithoutDocumentsNestedInput
  }

  export type DocumentsUncheckedUpdateWithoutDocumentVersionsInput = {
    doctypeId?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    documentName?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumbering?: NullableStringFieldUpdateOperationsInput | string | null
    reasonOfCreation?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextRevisionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentVersion?: NullableStringFieldUpdateOperationsInput | string | null
    documentLink?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: DocumentsUpdatetagsInput | string[]
    documentState?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    system?: DocumentsUpdatesystemInput | string[]
    section?: NullableStringFieldUpdateOperationsInput | string | null
    revertComment?: NullableStringFieldUpdateOperationsInput | string | null
    docType?: NullableStringFieldUpdateOperationsInput | string | null
    documentClassification?: NullableStringFieldUpdateOperationsInput | string | null
    issueNumber?: NullableStringFieldUpdateOperationsInput | string | null
    retireComment?: NullableStringFieldUpdateOperationsInput | string | null
    revisionReminderFlag?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isVersion?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    countNumber?: NullableIntFieldUpdateOperationsInput | number | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    distributionList?: NullableStringFieldUpdateOperationsInput | string | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    reviewers?: DocumentsUpdatereviewersInput | string[]
    approvers?: DocumentsUpdateapproversInput | string[]
    creators?: DocumentsUpdatecreatorsInput | string[]
    distributionUsers?: DocumentsUpdatedistributionUsersInput | InputJsonValue[]
    readAccess?: NullableStringFieldUpdateOperationsInput | string | null
    readAccessUsers?: DocumentsUpdatereadAccessUsersInput | InputJsonValue[]
    versionInfo?: DocumentsUpdateversionInfoInput | InputJsonValue[]
    ReferenceDocuments?: ReferenceDocumentsUncheckedUpdateManyWithoutDocumentNestedInput
    DocumentComments?: DocumentCommentsUncheckedUpdateManyWithoutDocumentNestedInput
    DocumentWorkFlowHistory?: DocumentWorkFlowHistoryUncheckedUpdateManyWithoutDocumentNestedInput
    AdditionalDocumentAdmins?: AdditionalDocumentAdminsUncheckedUpdateManyWithoutDocumentNestedInput
    VersionReferenceDocuments?: VersionReferenceDocumentsUncheckedUpdateManyWithoutDocumentsNestedInput
  }

  export type UserUpsertWithoutDocumentVersionsInput = {
    update: XOR<UserUpdateWithoutDocumentVersionsInput, UserUncheckedUpdateWithoutDocumentVersionsInput>
    create: XOR<UserCreateWithoutDocumentVersionsInput, UserUncheckedCreateWithoutDocumentVersionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDocumentVersionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDocumentVersionsInput, UserUncheckedUpdateWithoutDocumentVersionsInput>
  }

  export type UserUpdateWithoutDocumentVersionsInput = {
    kcId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    userType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    roleId?: UserUpdateroleIdInput | string[]
    functionId?: InputJsonValue | InputJsonValue | null
    additionalUnits?: UserUpdateadditionalUnitsInput | string[]
    entity?: EntityUpdateOneWithoutUserNestedInput
    location?: LocationUpdateOneWithoutUserNestedInput
    organization?: OrganizationUpdateOneWithoutUserNestedInput
    AdditionalDocumentAdmins?: AdditionalDocumentAdminsUpdateManyWithoutUserNestedInput
    DocumentComments?: DocumentCommentsUpdateManyWithoutUserNestedInput
    DocumentWorkFlowHistory?: DocumentWorkFlowHistoryUpdateManyWithoutUserNestedInput
    Logs?: LogsUpdateManyWithoutUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
    documentAdmins?: documentAdminsUpdateManyWithoutUserNestedInput
    userPersonalisation?: userPersonalisationUpdateManyWithoutUserNestedInput
    auditTrial?: auditTrialUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDocumentVersionsInput = {
    kcId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    roleId?: UserUpdateroleIdInput | string[]
    functionId?: InputJsonValue | InputJsonValue | null
    additionalUnits?: UserUpdateadditionalUnitsInput | string[]
    AdditionalDocumentAdmins?: AdditionalDocumentAdminsUncheckedUpdateManyWithoutUserNestedInput
    DocumentComments?: DocumentCommentsUncheckedUpdateManyWithoutUserNestedInput
    DocumentWorkFlowHistory?: DocumentWorkFlowHistoryUncheckedUpdateManyWithoutUserNestedInput
    Logs?: LogsUncheckedUpdateManyWithoutUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    documentAdmins?: documentAdminsUncheckedUpdateManyWithoutUserNestedInput
    userPersonalisation?: userPersonalisationUncheckedUpdateManyWithoutUserNestedInput
    auditTrial?: auditTrialUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ReferenceDocumentsUpsertWithWhereUniqueWithoutVersionsLinkedWithInput = {
    where: ReferenceDocumentsWhereUniqueInput
    update: XOR<ReferenceDocumentsUpdateWithoutVersionsLinkedWithInput, ReferenceDocumentsUncheckedUpdateWithoutVersionsLinkedWithInput>
    create: XOR<ReferenceDocumentsCreateWithoutVersionsLinkedWithInput, ReferenceDocumentsUncheckedCreateWithoutVersionsLinkedWithInput>
  }

  export type ReferenceDocumentsUpdateWithWhereUniqueWithoutVersionsLinkedWithInput = {
    where: ReferenceDocumentsWhereUniqueInput
    data: XOR<ReferenceDocumentsUpdateWithoutVersionsLinkedWithInput, ReferenceDocumentsUncheckedUpdateWithoutVersionsLinkedWithInput>
  }

  export type ReferenceDocumentsUpdateManyWithWhereWithoutVersionsLinkedWithInput = {
    where: ReferenceDocumentsScalarWhereInput
    data: XOR<ReferenceDocumentsUpdateManyMutationInput, ReferenceDocumentsUncheckedUpdateManyWithoutVersionsLinkedWithInput>
  }

  export type VersionReferenceDocumentsUpsertWithWhereUniqueWithoutVersionsLinkedWithInput = {
    where: VersionReferenceDocumentsWhereUniqueInput
    update: XOR<VersionReferenceDocumentsUpdateWithoutVersionsLinkedWithInput, VersionReferenceDocumentsUncheckedUpdateWithoutVersionsLinkedWithInput>
    create: XOR<VersionReferenceDocumentsCreateWithoutVersionsLinkedWithInput, VersionReferenceDocumentsUncheckedCreateWithoutVersionsLinkedWithInput>
  }

  export type VersionReferenceDocumentsUpdateWithWhereUniqueWithoutVersionsLinkedWithInput = {
    where: VersionReferenceDocumentsWhereUniqueInput
    data: XOR<VersionReferenceDocumentsUpdateWithoutVersionsLinkedWithInput, VersionReferenceDocumentsUncheckedUpdateWithoutVersionsLinkedWithInput>
  }

  export type VersionReferenceDocumentsUpdateManyWithWhereWithoutVersionsLinkedWithInput = {
    where: VersionReferenceDocumentsScalarWhereInput
    data: XOR<VersionReferenceDocumentsUpdateManyMutationInput, VersionReferenceDocumentsUncheckedUpdateManyWithoutVersionsLinkedWithInput>
  }

  export type DocumentsCreateWithoutDocumentCommentsInput = {
    id?: string
    documentName?: string | null
    documentNumbering?: string | null
    reasonOfCreation?: string | null
    effectiveDate?: Date | string | null
    nextRevisionDate?: Date | string | null
    currentVersion?: string | null
    documentLink?: string | null
    description?: string | null
    tags?: DocumentsCreatetagsInput | string[]
    documentState?: string | null
    system?: DocumentsCreatesystemInput | string[]
    section?: string | null
    revertComment?: string | null
    docType?: string | null
    documentClassification?: string | null
    issueNumber?: string | null
    retireComment?: string | null
    revisionReminderFlag?: boolean | null
    isVersion?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedDate?: Date | string | null
    countNumber?: number | null
    createdBy?: string | null
    distributionList?: string | null
    documentId?: string | null
    reviewers?: DocumentsCreatereviewersInput | string[]
    approvers?: DocumentsCreateapproversInput | string[]
    creators?: DocumentsCreatecreatorsInput | string[]
    distributionUsers?: DocumentsCreatedistributionUsersInput | InputJsonValue[]
    readAccess?: string | null
    readAccessUsers?: DocumentsCreatereadAccessUsersInput | InputJsonValue[]
    versionInfo?: DocumentsCreateversionInfoInput | InputJsonValue[]
    doctype?: DoctypeCreateNestedOneWithoutDocumentsInput
    organization?: OrganizationCreateNestedOneWithoutDocumentsInput
    creatorLocation?: LocationCreateNestedOneWithoutDocumentsInput
    creatorEntity?: EntityCreateNestedOneWithoutDocumentsInput
    ReferenceDocuments?: ReferenceDocumentsCreateNestedManyWithoutDocumentInput
    DocumentVersions?: DocumentVersionsCreateNestedManyWithoutDocumentInput
    DocumentWorkFlowHistory?: DocumentWorkFlowHistoryCreateNestedManyWithoutDocumentInput
    AdditionalDocumentAdmins?: AdditionalDocumentAdminsCreateNestedManyWithoutDocumentInput
    VersionReferenceDocuments?: VersionReferenceDocumentsCreateNestedManyWithoutDocumentsInput
  }

  export type DocumentsUncheckedCreateWithoutDocumentCommentsInput = {
    id?: string
    doctypeId?: string | null
    organizationId?: string | null
    documentName?: string | null
    documentNumbering?: string | null
    reasonOfCreation?: string | null
    effectiveDate?: Date | string | null
    nextRevisionDate?: Date | string | null
    currentVersion?: string | null
    documentLink?: string | null
    description?: string | null
    tags?: DocumentsCreatetagsInput | string[]
    documentState?: string | null
    locationId: string
    entityId?: string | null
    system?: DocumentsCreatesystemInput | string[]
    section?: string | null
    revertComment?: string | null
    docType?: string | null
    documentClassification?: string | null
    issueNumber?: string | null
    retireComment?: string | null
    revisionReminderFlag?: boolean | null
    isVersion?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedDate?: Date | string | null
    countNumber?: number | null
    createdBy?: string | null
    distributionList?: string | null
    documentId?: string | null
    reviewers?: DocumentsCreatereviewersInput | string[]
    approvers?: DocumentsCreateapproversInput | string[]
    creators?: DocumentsCreatecreatorsInput | string[]
    distributionUsers?: DocumentsCreatedistributionUsersInput | InputJsonValue[]
    readAccess?: string | null
    readAccessUsers?: DocumentsCreatereadAccessUsersInput | InputJsonValue[]
    versionInfo?: DocumentsCreateversionInfoInput | InputJsonValue[]
    ReferenceDocuments?: ReferenceDocumentsUncheckedCreateNestedManyWithoutDocumentInput
    DocumentVersions?: DocumentVersionsUncheckedCreateNestedManyWithoutDocumentInput
    DocumentWorkFlowHistory?: DocumentWorkFlowHistoryUncheckedCreateNestedManyWithoutDocumentInput
    AdditionalDocumentAdmins?: AdditionalDocumentAdminsUncheckedCreateNestedManyWithoutDocumentInput
    VersionReferenceDocuments?: VersionReferenceDocumentsUncheckedCreateNestedManyWithoutDocumentsInput
  }

  export type DocumentsCreateOrConnectWithoutDocumentCommentsInput = {
    where: DocumentsWhereUniqueInput
    create: XOR<DocumentsCreateWithoutDocumentCommentsInput, DocumentsUncheckedCreateWithoutDocumentCommentsInput>
  }

  export type UserCreateWithoutDocumentCommentsInput = {
    id?: string
    kcId?: string | null
    email?: string | null
    username?: string | null
    firstname?: string | null
    lastname?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    enabled?: boolean | null
    userType?: string | null
    status?: boolean | null
    avatar?: string | null
    deleted?: boolean | null
    roleId?: UserCreateroleIdInput | string[]
    functionId?: InputJsonValue | null
    additionalUnits?: UserCreateadditionalUnitsInput | string[]
    entity?: EntityCreateNestedOneWithoutUserInput
    location?: LocationCreateNestedOneWithoutUserInput
    organization?: OrganizationCreateNestedOneWithoutUserInput
    AdditionalDocumentAdmins?: AdditionalDocumentAdminsCreateNestedManyWithoutUserInput
    DocumentVersions?: DocumentVersionsCreateNestedManyWithoutUserInput
    DocumentWorkFlowHistory?: DocumentWorkFlowHistoryCreateNestedManyWithoutUserInput
    Logs?: LogsCreateNestedManyWithoutUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
    documentAdmins?: documentAdminsCreateNestedManyWithoutUserInput
    userPersonalisation?: userPersonalisationCreateNestedManyWithoutUserInput
    auditTrial?: auditTrialCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDocumentCommentsInput = {
    id?: string
    kcId?: string | null
    email?: string | null
    username?: string | null
    firstname?: string | null
    lastname?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    enabled?: boolean | null
    organizationId?: string | null
    locationId?: string | null
    entityId?: string | null
    userType?: string | null
    status?: boolean | null
    avatar?: string | null
    deleted?: boolean | null
    roleId?: UserCreateroleIdInput | string[]
    functionId?: InputJsonValue | null
    additionalUnits?: UserCreateadditionalUnitsInput | string[]
    AdditionalDocumentAdmins?: AdditionalDocumentAdminsUncheckedCreateNestedManyWithoutUserInput
    DocumentVersions?: DocumentVersionsUncheckedCreateNestedManyWithoutUserInput
    DocumentWorkFlowHistory?: DocumentWorkFlowHistoryUncheckedCreateNestedManyWithoutUserInput
    Logs?: LogsUncheckedCreateNestedManyWithoutUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    documentAdmins?: documentAdminsUncheckedCreateNestedManyWithoutUserInput
    userPersonalisation?: userPersonalisationUncheckedCreateNestedManyWithoutUserInput
    auditTrial?: auditTrialUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDocumentCommentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDocumentCommentsInput, UserUncheckedCreateWithoutDocumentCommentsInput>
  }

  export type DocumentsUpsertWithoutDocumentCommentsInput = {
    update: XOR<DocumentsUpdateWithoutDocumentCommentsInput, DocumentsUncheckedUpdateWithoutDocumentCommentsInput>
    create: XOR<DocumentsCreateWithoutDocumentCommentsInput, DocumentsUncheckedCreateWithoutDocumentCommentsInput>
    where?: DocumentsWhereInput
  }

  export type DocumentsUpdateToOneWithWhereWithoutDocumentCommentsInput = {
    where?: DocumentsWhereInput
    data: XOR<DocumentsUpdateWithoutDocumentCommentsInput, DocumentsUncheckedUpdateWithoutDocumentCommentsInput>
  }

  export type DocumentsUpdateWithoutDocumentCommentsInput = {
    documentName?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumbering?: NullableStringFieldUpdateOperationsInput | string | null
    reasonOfCreation?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextRevisionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentVersion?: NullableStringFieldUpdateOperationsInput | string | null
    documentLink?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: DocumentsUpdatetagsInput | string[]
    documentState?: NullableStringFieldUpdateOperationsInput | string | null
    system?: DocumentsUpdatesystemInput | string[]
    section?: NullableStringFieldUpdateOperationsInput | string | null
    revertComment?: NullableStringFieldUpdateOperationsInput | string | null
    docType?: NullableStringFieldUpdateOperationsInput | string | null
    documentClassification?: NullableStringFieldUpdateOperationsInput | string | null
    issueNumber?: NullableStringFieldUpdateOperationsInput | string | null
    retireComment?: NullableStringFieldUpdateOperationsInput | string | null
    revisionReminderFlag?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isVersion?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    countNumber?: NullableIntFieldUpdateOperationsInput | number | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    distributionList?: NullableStringFieldUpdateOperationsInput | string | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    reviewers?: DocumentsUpdatereviewersInput | string[]
    approvers?: DocumentsUpdateapproversInput | string[]
    creators?: DocumentsUpdatecreatorsInput | string[]
    distributionUsers?: DocumentsUpdatedistributionUsersInput | InputJsonValue[]
    readAccess?: NullableStringFieldUpdateOperationsInput | string | null
    readAccessUsers?: DocumentsUpdatereadAccessUsersInput | InputJsonValue[]
    versionInfo?: DocumentsUpdateversionInfoInput | InputJsonValue[]
    doctype?: DoctypeUpdateOneWithoutDocumentsNestedInput
    organization?: OrganizationUpdateOneWithoutDocumentsNestedInput
    creatorLocation?: LocationUpdateOneWithoutDocumentsNestedInput
    creatorEntity?: EntityUpdateOneWithoutDocumentsNestedInput
    ReferenceDocuments?: ReferenceDocumentsUpdateManyWithoutDocumentNestedInput
    DocumentVersions?: DocumentVersionsUpdateManyWithoutDocumentNestedInput
    DocumentWorkFlowHistory?: DocumentWorkFlowHistoryUpdateManyWithoutDocumentNestedInput
    AdditionalDocumentAdmins?: AdditionalDocumentAdminsUpdateManyWithoutDocumentNestedInput
    VersionReferenceDocuments?: VersionReferenceDocumentsUpdateManyWithoutDocumentsNestedInput
  }

  export type DocumentsUncheckedUpdateWithoutDocumentCommentsInput = {
    doctypeId?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    documentName?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumbering?: NullableStringFieldUpdateOperationsInput | string | null
    reasonOfCreation?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextRevisionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentVersion?: NullableStringFieldUpdateOperationsInput | string | null
    documentLink?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: DocumentsUpdatetagsInput | string[]
    documentState?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    system?: DocumentsUpdatesystemInput | string[]
    section?: NullableStringFieldUpdateOperationsInput | string | null
    revertComment?: NullableStringFieldUpdateOperationsInput | string | null
    docType?: NullableStringFieldUpdateOperationsInput | string | null
    documentClassification?: NullableStringFieldUpdateOperationsInput | string | null
    issueNumber?: NullableStringFieldUpdateOperationsInput | string | null
    retireComment?: NullableStringFieldUpdateOperationsInput | string | null
    revisionReminderFlag?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isVersion?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    countNumber?: NullableIntFieldUpdateOperationsInput | number | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    distributionList?: NullableStringFieldUpdateOperationsInput | string | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    reviewers?: DocumentsUpdatereviewersInput | string[]
    approvers?: DocumentsUpdateapproversInput | string[]
    creators?: DocumentsUpdatecreatorsInput | string[]
    distributionUsers?: DocumentsUpdatedistributionUsersInput | InputJsonValue[]
    readAccess?: NullableStringFieldUpdateOperationsInput | string | null
    readAccessUsers?: DocumentsUpdatereadAccessUsersInput | InputJsonValue[]
    versionInfo?: DocumentsUpdateversionInfoInput | InputJsonValue[]
    ReferenceDocuments?: ReferenceDocumentsUncheckedUpdateManyWithoutDocumentNestedInput
    DocumentVersions?: DocumentVersionsUncheckedUpdateManyWithoutDocumentNestedInput
    DocumentWorkFlowHistory?: DocumentWorkFlowHistoryUncheckedUpdateManyWithoutDocumentNestedInput
    AdditionalDocumentAdmins?: AdditionalDocumentAdminsUncheckedUpdateManyWithoutDocumentNestedInput
    VersionReferenceDocuments?: VersionReferenceDocumentsUncheckedUpdateManyWithoutDocumentsNestedInput
  }

  export type UserUpsertWithoutDocumentCommentsInput = {
    update: XOR<UserUpdateWithoutDocumentCommentsInput, UserUncheckedUpdateWithoutDocumentCommentsInput>
    create: XOR<UserCreateWithoutDocumentCommentsInput, UserUncheckedCreateWithoutDocumentCommentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDocumentCommentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDocumentCommentsInput, UserUncheckedUpdateWithoutDocumentCommentsInput>
  }

  export type UserUpdateWithoutDocumentCommentsInput = {
    kcId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    userType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    roleId?: UserUpdateroleIdInput | string[]
    functionId?: InputJsonValue | InputJsonValue | null
    additionalUnits?: UserUpdateadditionalUnitsInput | string[]
    entity?: EntityUpdateOneWithoutUserNestedInput
    location?: LocationUpdateOneWithoutUserNestedInput
    organization?: OrganizationUpdateOneWithoutUserNestedInput
    AdditionalDocumentAdmins?: AdditionalDocumentAdminsUpdateManyWithoutUserNestedInput
    DocumentVersions?: DocumentVersionsUpdateManyWithoutUserNestedInput
    DocumentWorkFlowHistory?: DocumentWorkFlowHistoryUpdateManyWithoutUserNestedInput
    Logs?: LogsUpdateManyWithoutUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
    documentAdmins?: documentAdminsUpdateManyWithoutUserNestedInput
    userPersonalisation?: userPersonalisationUpdateManyWithoutUserNestedInput
    auditTrial?: auditTrialUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDocumentCommentsInput = {
    kcId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    roleId?: UserUpdateroleIdInput | string[]
    functionId?: InputJsonValue | InputJsonValue | null
    additionalUnits?: UserUpdateadditionalUnitsInput | string[]
    AdditionalDocumentAdmins?: AdditionalDocumentAdminsUncheckedUpdateManyWithoutUserNestedInput
    DocumentVersions?: DocumentVersionsUncheckedUpdateManyWithoutUserNestedInput
    DocumentWorkFlowHistory?: DocumentWorkFlowHistoryUncheckedUpdateManyWithoutUserNestedInput
    Logs?: LogsUncheckedUpdateManyWithoutUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    documentAdmins?: documentAdminsUncheckedUpdateManyWithoutUserNestedInput
    userPersonalisation?: userPersonalisationUncheckedUpdateManyWithoutUserNestedInput
    auditTrial?: auditTrialUncheckedUpdateManyWithoutUserNestedInput
  }

  export type DocumentsCreateWithoutDocumentWorkFlowHistoryInput = {
    id?: string
    documentName?: string | null
    documentNumbering?: string | null
    reasonOfCreation?: string | null
    effectiveDate?: Date | string | null
    nextRevisionDate?: Date | string | null
    currentVersion?: string | null
    documentLink?: string | null
    description?: string | null
    tags?: DocumentsCreatetagsInput | string[]
    documentState?: string | null
    system?: DocumentsCreatesystemInput | string[]
    section?: string | null
    revertComment?: string | null
    docType?: string | null
    documentClassification?: string | null
    issueNumber?: string | null
    retireComment?: string | null
    revisionReminderFlag?: boolean | null
    isVersion?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedDate?: Date | string | null
    countNumber?: number | null
    createdBy?: string | null
    distributionList?: string | null
    documentId?: string | null
    reviewers?: DocumentsCreatereviewersInput | string[]
    approvers?: DocumentsCreateapproversInput | string[]
    creators?: DocumentsCreatecreatorsInput | string[]
    distributionUsers?: DocumentsCreatedistributionUsersInput | InputJsonValue[]
    readAccess?: string | null
    readAccessUsers?: DocumentsCreatereadAccessUsersInput | InputJsonValue[]
    versionInfo?: DocumentsCreateversionInfoInput | InputJsonValue[]
    doctype?: DoctypeCreateNestedOneWithoutDocumentsInput
    organization?: OrganizationCreateNestedOneWithoutDocumentsInput
    creatorLocation?: LocationCreateNestedOneWithoutDocumentsInput
    creatorEntity?: EntityCreateNestedOneWithoutDocumentsInput
    ReferenceDocuments?: ReferenceDocumentsCreateNestedManyWithoutDocumentInput
    DocumentVersions?: DocumentVersionsCreateNestedManyWithoutDocumentInput
    DocumentComments?: DocumentCommentsCreateNestedManyWithoutDocumentInput
    AdditionalDocumentAdmins?: AdditionalDocumentAdminsCreateNestedManyWithoutDocumentInput
    VersionReferenceDocuments?: VersionReferenceDocumentsCreateNestedManyWithoutDocumentsInput
  }

  export type DocumentsUncheckedCreateWithoutDocumentWorkFlowHistoryInput = {
    id?: string
    doctypeId?: string | null
    organizationId?: string | null
    documentName?: string | null
    documentNumbering?: string | null
    reasonOfCreation?: string | null
    effectiveDate?: Date | string | null
    nextRevisionDate?: Date | string | null
    currentVersion?: string | null
    documentLink?: string | null
    description?: string | null
    tags?: DocumentsCreatetagsInput | string[]
    documentState?: string | null
    locationId: string
    entityId?: string | null
    system?: DocumentsCreatesystemInput | string[]
    section?: string | null
    revertComment?: string | null
    docType?: string | null
    documentClassification?: string | null
    issueNumber?: string | null
    retireComment?: string | null
    revisionReminderFlag?: boolean | null
    isVersion?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedDate?: Date | string | null
    countNumber?: number | null
    createdBy?: string | null
    distributionList?: string | null
    documentId?: string | null
    reviewers?: DocumentsCreatereviewersInput | string[]
    approvers?: DocumentsCreateapproversInput | string[]
    creators?: DocumentsCreatecreatorsInput | string[]
    distributionUsers?: DocumentsCreatedistributionUsersInput | InputJsonValue[]
    readAccess?: string | null
    readAccessUsers?: DocumentsCreatereadAccessUsersInput | InputJsonValue[]
    versionInfo?: DocumentsCreateversionInfoInput | InputJsonValue[]
    ReferenceDocuments?: ReferenceDocumentsUncheckedCreateNestedManyWithoutDocumentInput
    DocumentVersions?: DocumentVersionsUncheckedCreateNestedManyWithoutDocumentInput
    DocumentComments?: DocumentCommentsUncheckedCreateNestedManyWithoutDocumentInput
    AdditionalDocumentAdmins?: AdditionalDocumentAdminsUncheckedCreateNestedManyWithoutDocumentInput
    VersionReferenceDocuments?: VersionReferenceDocumentsUncheckedCreateNestedManyWithoutDocumentsInput
  }

  export type DocumentsCreateOrConnectWithoutDocumentWorkFlowHistoryInput = {
    where: DocumentsWhereUniqueInput
    create: XOR<DocumentsCreateWithoutDocumentWorkFlowHistoryInput, DocumentsUncheckedCreateWithoutDocumentWorkFlowHistoryInput>
  }

  export type UserCreateWithoutDocumentWorkFlowHistoryInput = {
    id?: string
    kcId?: string | null
    email?: string | null
    username?: string | null
    firstname?: string | null
    lastname?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    enabled?: boolean | null
    userType?: string | null
    status?: boolean | null
    avatar?: string | null
    deleted?: boolean | null
    roleId?: UserCreateroleIdInput | string[]
    functionId?: InputJsonValue | null
    additionalUnits?: UserCreateadditionalUnitsInput | string[]
    entity?: EntityCreateNestedOneWithoutUserInput
    location?: LocationCreateNestedOneWithoutUserInput
    organization?: OrganizationCreateNestedOneWithoutUserInput
    AdditionalDocumentAdmins?: AdditionalDocumentAdminsCreateNestedManyWithoutUserInput
    DocumentComments?: DocumentCommentsCreateNestedManyWithoutUserInput
    DocumentVersions?: DocumentVersionsCreateNestedManyWithoutUserInput
    Logs?: LogsCreateNestedManyWithoutUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
    documentAdmins?: documentAdminsCreateNestedManyWithoutUserInput
    userPersonalisation?: userPersonalisationCreateNestedManyWithoutUserInput
    auditTrial?: auditTrialCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDocumentWorkFlowHistoryInput = {
    id?: string
    kcId?: string | null
    email?: string | null
    username?: string | null
    firstname?: string | null
    lastname?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    enabled?: boolean | null
    organizationId?: string | null
    locationId?: string | null
    entityId?: string | null
    userType?: string | null
    status?: boolean | null
    avatar?: string | null
    deleted?: boolean | null
    roleId?: UserCreateroleIdInput | string[]
    functionId?: InputJsonValue | null
    additionalUnits?: UserCreateadditionalUnitsInput | string[]
    AdditionalDocumentAdmins?: AdditionalDocumentAdminsUncheckedCreateNestedManyWithoutUserInput
    DocumentComments?: DocumentCommentsUncheckedCreateNestedManyWithoutUserInput
    DocumentVersions?: DocumentVersionsUncheckedCreateNestedManyWithoutUserInput
    Logs?: LogsUncheckedCreateNestedManyWithoutUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    documentAdmins?: documentAdminsUncheckedCreateNestedManyWithoutUserInput
    userPersonalisation?: userPersonalisationUncheckedCreateNestedManyWithoutUserInput
    auditTrial?: auditTrialUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDocumentWorkFlowHistoryInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDocumentWorkFlowHistoryInput, UserUncheckedCreateWithoutDocumentWorkFlowHistoryInput>
  }

  export type DocumentsUpsertWithoutDocumentWorkFlowHistoryInput = {
    update: XOR<DocumentsUpdateWithoutDocumentWorkFlowHistoryInput, DocumentsUncheckedUpdateWithoutDocumentWorkFlowHistoryInput>
    create: XOR<DocumentsCreateWithoutDocumentWorkFlowHistoryInput, DocumentsUncheckedCreateWithoutDocumentWorkFlowHistoryInput>
    where?: DocumentsWhereInput
  }

  export type DocumentsUpdateToOneWithWhereWithoutDocumentWorkFlowHistoryInput = {
    where?: DocumentsWhereInput
    data: XOR<DocumentsUpdateWithoutDocumentWorkFlowHistoryInput, DocumentsUncheckedUpdateWithoutDocumentWorkFlowHistoryInput>
  }

  export type DocumentsUpdateWithoutDocumentWorkFlowHistoryInput = {
    documentName?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumbering?: NullableStringFieldUpdateOperationsInput | string | null
    reasonOfCreation?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextRevisionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentVersion?: NullableStringFieldUpdateOperationsInput | string | null
    documentLink?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: DocumentsUpdatetagsInput | string[]
    documentState?: NullableStringFieldUpdateOperationsInput | string | null
    system?: DocumentsUpdatesystemInput | string[]
    section?: NullableStringFieldUpdateOperationsInput | string | null
    revertComment?: NullableStringFieldUpdateOperationsInput | string | null
    docType?: NullableStringFieldUpdateOperationsInput | string | null
    documentClassification?: NullableStringFieldUpdateOperationsInput | string | null
    issueNumber?: NullableStringFieldUpdateOperationsInput | string | null
    retireComment?: NullableStringFieldUpdateOperationsInput | string | null
    revisionReminderFlag?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isVersion?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    countNumber?: NullableIntFieldUpdateOperationsInput | number | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    distributionList?: NullableStringFieldUpdateOperationsInput | string | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    reviewers?: DocumentsUpdatereviewersInput | string[]
    approvers?: DocumentsUpdateapproversInput | string[]
    creators?: DocumentsUpdatecreatorsInput | string[]
    distributionUsers?: DocumentsUpdatedistributionUsersInput | InputJsonValue[]
    readAccess?: NullableStringFieldUpdateOperationsInput | string | null
    readAccessUsers?: DocumentsUpdatereadAccessUsersInput | InputJsonValue[]
    versionInfo?: DocumentsUpdateversionInfoInput | InputJsonValue[]
    doctype?: DoctypeUpdateOneWithoutDocumentsNestedInput
    organization?: OrganizationUpdateOneWithoutDocumentsNestedInput
    creatorLocation?: LocationUpdateOneWithoutDocumentsNestedInput
    creatorEntity?: EntityUpdateOneWithoutDocumentsNestedInput
    ReferenceDocuments?: ReferenceDocumentsUpdateManyWithoutDocumentNestedInput
    DocumentVersions?: DocumentVersionsUpdateManyWithoutDocumentNestedInput
    DocumentComments?: DocumentCommentsUpdateManyWithoutDocumentNestedInput
    AdditionalDocumentAdmins?: AdditionalDocumentAdminsUpdateManyWithoutDocumentNestedInput
    VersionReferenceDocuments?: VersionReferenceDocumentsUpdateManyWithoutDocumentsNestedInput
  }

  export type DocumentsUncheckedUpdateWithoutDocumentWorkFlowHistoryInput = {
    doctypeId?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    documentName?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumbering?: NullableStringFieldUpdateOperationsInput | string | null
    reasonOfCreation?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextRevisionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentVersion?: NullableStringFieldUpdateOperationsInput | string | null
    documentLink?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: DocumentsUpdatetagsInput | string[]
    documentState?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    system?: DocumentsUpdatesystemInput | string[]
    section?: NullableStringFieldUpdateOperationsInput | string | null
    revertComment?: NullableStringFieldUpdateOperationsInput | string | null
    docType?: NullableStringFieldUpdateOperationsInput | string | null
    documentClassification?: NullableStringFieldUpdateOperationsInput | string | null
    issueNumber?: NullableStringFieldUpdateOperationsInput | string | null
    retireComment?: NullableStringFieldUpdateOperationsInput | string | null
    revisionReminderFlag?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isVersion?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    countNumber?: NullableIntFieldUpdateOperationsInput | number | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    distributionList?: NullableStringFieldUpdateOperationsInput | string | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    reviewers?: DocumentsUpdatereviewersInput | string[]
    approvers?: DocumentsUpdateapproversInput | string[]
    creators?: DocumentsUpdatecreatorsInput | string[]
    distributionUsers?: DocumentsUpdatedistributionUsersInput | InputJsonValue[]
    readAccess?: NullableStringFieldUpdateOperationsInput | string | null
    readAccessUsers?: DocumentsUpdatereadAccessUsersInput | InputJsonValue[]
    versionInfo?: DocumentsUpdateversionInfoInput | InputJsonValue[]
    ReferenceDocuments?: ReferenceDocumentsUncheckedUpdateManyWithoutDocumentNestedInput
    DocumentVersions?: DocumentVersionsUncheckedUpdateManyWithoutDocumentNestedInput
    DocumentComments?: DocumentCommentsUncheckedUpdateManyWithoutDocumentNestedInput
    AdditionalDocumentAdmins?: AdditionalDocumentAdminsUncheckedUpdateManyWithoutDocumentNestedInput
    VersionReferenceDocuments?: VersionReferenceDocumentsUncheckedUpdateManyWithoutDocumentsNestedInput
  }

  export type UserUpsertWithoutDocumentWorkFlowHistoryInput = {
    update: XOR<UserUpdateWithoutDocumentWorkFlowHistoryInput, UserUncheckedUpdateWithoutDocumentWorkFlowHistoryInput>
    create: XOR<UserCreateWithoutDocumentWorkFlowHistoryInput, UserUncheckedCreateWithoutDocumentWorkFlowHistoryInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDocumentWorkFlowHistoryInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDocumentWorkFlowHistoryInput, UserUncheckedUpdateWithoutDocumentWorkFlowHistoryInput>
  }

  export type UserUpdateWithoutDocumentWorkFlowHistoryInput = {
    kcId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    userType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    roleId?: UserUpdateroleIdInput | string[]
    functionId?: InputJsonValue | InputJsonValue | null
    additionalUnits?: UserUpdateadditionalUnitsInput | string[]
    entity?: EntityUpdateOneWithoutUserNestedInput
    location?: LocationUpdateOneWithoutUserNestedInput
    organization?: OrganizationUpdateOneWithoutUserNestedInput
    AdditionalDocumentAdmins?: AdditionalDocumentAdminsUpdateManyWithoutUserNestedInput
    DocumentComments?: DocumentCommentsUpdateManyWithoutUserNestedInput
    DocumentVersions?: DocumentVersionsUpdateManyWithoutUserNestedInput
    Logs?: LogsUpdateManyWithoutUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
    documentAdmins?: documentAdminsUpdateManyWithoutUserNestedInput
    userPersonalisation?: userPersonalisationUpdateManyWithoutUserNestedInput
    auditTrial?: auditTrialUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDocumentWorkFlowHistoryInput = {
    kcId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    roleId?: UserUpdateroleIdInput | string[]
    functionId?: InputJsonValue | InputJsonValue | null
    additionalUnits?: UserUpdateadditionalUnitsInput | string[]
    AdditionalDocumentAdmins?: AdditionalDocumentAdminsUncheckedUpdateManyWithoutUserNestedInput
    DocumentComments?: DocumentCommentsUncheckedUpdateManyWithoutUserNestedInput
    DocumentVersions?: DocumentVersionsUncheckedUpdateManyWithoutUserNestedInput
    Logs?: LogsUncheckedUpdateManyWithoutUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    documentAdmins?: documentAdminsUncheckedUpdateManyWithoutUserNestedInput
    userPersonalisation?: userPersonalisationUncheckedUpdateManyWithoutUserNestedInput
    auditTrial?: auditTrialUncheckedUpdateManyWithoutUserNestedInput
  }

  export type DoctypeCreateWithoutDocumentAdminsInput = {
    id?: string
    locationId?: DoctypeCreatelocationIdInput | string[]
    documentTypeName?: string | null
    documentNumbering?: string | null
    reviewFrequency?: number | null
    revisionRemind?: number | null
    prefix?: string | null
    suffix?: string | null
    readAccess?: string | null
    readAccessUsers?: DoctypeCreatereadAccessUsersInput | InputJsonValue[]
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedBy?: string | null
    createdBy?: string | null
    applicable_systems?: DoctypeCreateapplicable_systemsInput | InputJsonValue[]
    users?: DoctypeCreateusersInput | InputJsonValue[]
    document_classification?: string | null
    distributionUsers?: DoctypeCreatedistributionUsersInput | InputJsonValue[]
    currentVersion: string
    distributionList?: string | null
    organization?: OrganizationCreateNestedOneWithoutDoctypeInput
    Entity?: EntityCreateNestedOneWithoutDoctypeInput
    Documents?: DocumentsCreateNestedManyWithoutDoctypeInput
  }

  export type DoctypeUncheckedCreateWithoutDocumentAdminsInput = {
    id?: string
    locationId?: DoctypeCreatelocationIdInput | string[]
    documentTypeName?: string | null
    documentNumbering?: string | null
    reviewFrequency?: number | null
    revisionRemind?: number | null
    prefix?: string | null
    suffix?: string | null
    organizationId?: string | null
    readAccess?: string | null
    readAccessUsers?: DoctypeCreatereadAccessUsersInput | InputJsonValue[]
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedBy?: string | null
    createdBy?: string | null
    applicable_systems?: DoctypeCreateapplicable_systemsInput | InputJsonValue[]
    users?: DoctypeCreateusersInput | InputJsonValue[]
    document_classification?: string | null
    entityId?: string | null
    distributionUsers?: DoctypeCreatedistributionUsersInput | InputJsonValue[]
    currentVersion: string
    distributionList?: string | null
    Documents?: DocumentsUncheckedCreateNestedManyWithoutDoctypeInput
  }

  export type DoctypeCreateOrConnectWithoutDocumentAdminsInput = {
    where: DoctypeWhereUniqueInput
    create: XOR<DoctypeCreateWithoutDocumentAdminsInput, DoctypeUncheckedCreateWithoutDocumentAdminsInput>
  }

  export type UserCreateWithoutDocumentAdminsInput = {
    id?: string
    kcId?: string | null
    email?: string | null
    username?: string | null
    firstname?: string | null
    lastname?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    enabled?: boolean | null
    userType?: string | null
    status?: boolean | null
    avatar?: string | null
    deleted?: boolean | null
    roleId?: UserCreateroleIdInput | string[]
    functionId?: InputJsonValue | null
    additionalUnits?: UserCreateadditionalUnitsInput | string[]
    entity?: EntityCreateNestedOneWithoutUserInput
    location?: LocationCreateNestedOneWithoutUserInput
    organization?: OrganizationCreateNestedOneWithoutUserInput
    AdditionalDocumentAdmins?: AdditionalDocumentAdminsCreateNestedManyWithoutUserInput
    DocumentComments?: DocumentCommentsCreateNestedManyWithoutUserInput
    DocumentVersions?: DocumentVersionsCreateNestedManyWithoutUserInput
    DocumentWorkFlowHistory?: DocumentWorkFlowHistoryCreateNestedManyWithoutUserInput
    Logs?: LogsCreateNestedManyWithoutUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
    userPersonalisation?: userPersonalisationCreateNestedManyWithoutUserInput
    auditTrial?: auditTrialCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDocumentAdminsInput = {
    id?: string
    kcId?: string | null
    email?: string | null
    username?: string | null
    firstname?: string | null
    lastname?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    enabled?: boolean | null
    organizationId?: string | null
    locationId?: string | null
    entityId?: string | null
    userType?: string | null
    status?: boolean | null
    avatar?: string | null
    deleted?: boolean | null
    roleId?: UserCreateroleIdInput | string[]
    functionId?: InputJsonValue | null
    additionalUnits?: UserCreateadditionalUnitsInput | string[]
    AdditionalDocumentAdmins?: AdditionalDocumentAdminsUncheckedCreateNestedManyWithoutUserInput
    DocumentComments?: DocumentCommentsUncheckedCreateNestedManyWithoutUserInput
    DocumentVersions?: DocumentVersionsUncheckedCreateNestedManyWithoutUserInput
    DocumentWorkFlowHistory?: DocumentWorkFlowHistoryUncheckedCreateNestedManyWithoutUserInput
    Logs?: LogsUncheckedCreateNestedManyWithoutUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    userPersonalisation?: userPersonalisationUncheckedCreateNestedManyWithoutUserInput
    auditTrial?: auditTrialUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDocumentAdminsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDocumentAdminsInput, UserUncheckedCreateWithoutDocumentAdminsInput>
  }

  export type DoctypeUpsertWithoutDocumentAdminsInput = {
    update: XOR<DoctypeUpdateWithoutDocumentAdminsInput, DoctypeUncheckedUpdateWithoutDocumentAdminsInput>
    create: XOR<DoctypeCreateWithoutDocumentAdminsInput, DoctypeUncheckedCreateWithoutDocumentAdminsInput>
    where?: DoctypeWhereInput
  }

  export type DoctypeUpdateToOneWithWhereWithoutDocumentAdminsInput = {
    where?: DoctypeWhereInput
    data: XOR<DoctypeUpdateWithoutDocumentAdminsInput, DoctypeUncheckedUpdateWithoutDocumentAdminsInput>
  }

  export type DoctypeUpdateWithoutDocumentAdminsInput = {
    locationId?: DoctypeUpdatelocationIdInput | string[]
    documentTypeName?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumbering?: NullableStringFieldUpdateOperationsInput | string | null
    reviewFrequency?: NullableIntFieldUpdateOperationsInput | number | null
    revisionRemind?: NullableIntFieldUpdateOperationsInput | number | null
    prefix?: NullableStringFieldUpdateOperationsInput | string | null
    suffix?: NullableStringFieldUpdateOperationsInput | string | null
    readAccess?: NullableStringFieldUpdateOperationsInput | string | null
    readAccessUsers?: DoctypeUpdatereadAccessUsersInput | InputJsonValue[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    applicable_systems?: DoctypeUpdateapplicable_systemsInput | InputJsonValue[]
    users?: DoctypeUpdateusersInput | InputJsonValue[]
    document_classification?: NullableStringFieldUpdateOperationsInput | string | null
    distributionUsers?: DoctypeUpdatedistributionUsersInput | InputJsonValue[]
    currentVersion?: StringFieldUpdateOperationsInput | string
    distributionList?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: OrganizationUpdateOneWithoutDoctypeNestedInput
    Entity?: EntityUpdateOneWithoutDoctypeNestedInput
    Documents?: DocumentsUpdateManyWithoutDoctypeNestedInput
  }

  export type DoctypeUncheckedUpdateWithoutDocumentAdminsInput = {
    locationId?: DoctypeUpdatelocationIdInput | string[]
    documentTypeName?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumbering?: NullableStringFieldUpdateOperationsInput | string | null
    reviewFrequency?: NullableIntFieldUpdateOperationsInput | number | null
    revisionRemind?: NullableIntFieldUpdateOperationsInput | number | null
    prefix?: NullableStringFieldUpdateOperationsInput | string | null
    suffix?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    readAccess?: NullableStringFieldUpdateOperationsInput | string | null
    readAccessUsers?: DoctypeUpdatereadAccessUsersInput | InputJsonValue[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    applicable_systems?: DoctypeUpdateapplicable_systemsInput | InputJsonValue[]
    users?: DoctypeUpdateusersInput | InputJsonValue[]
    document_classification?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    distributionUsers?: DoctypeUpdatedistributionUsersInput | InputJsonValue[]
    currentVersion?: StringFieldUpdateOperationsInput | string
    distributionList?: NullableStringFieldUpdateOperationsInput | string | null
    Documents?: DocumentsUncheckedUpdateManyWithoutDoctypeNestedInput
  }

  export type UserUpsertWithoutDocumentAdminsInput = {
    update: XOR<UserUpdateWithoutDocumentAdminsInput, UserUncheckedUpdateWithoutDocumentAdminsInput>
    create: XOR<UserCreateWithoutDocumentAdminsInput, UserUncheckedCreateWithoutDocumentAdminsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDocumentAdminsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDocumentAdminsInput, UserUncheckedUpdateWithoutDocumentAdminsInput>
  }

  export type UserUpdateWithoutDocumentAdminsInput = {
    kcId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    userType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    roleId?: UserUpdateroleIdInput | string[]
    functionId?: InputJsonValue | InputJsonValue | null
    additionalUnits?: UserUpdateadditionalUnitsInput | string[]
    entity?: EntityUpdateOneWithoutUserNestedInput
    location?: LocationUpdateOneWithoutUserNestedInput
    organization?: OrganizationUpdateOneWithoutUserNestedInput
    AdditionalDocumentAdmins?: AdditionalDocumentAdminsUpdateManyWithoutUserNestedInput
    DocumentComments?: DocumentCommentsUpdateManyWithoutUserNestedInput
    DocumentVersions?: DocumentVersionsUpdateManyWithoutUserNestedInput
    DocumentWorkFlowHistory?: DocumentWorkFlowHistoryUpdateManyWithoutUserNestedInput
    Logs?: LogsUpdateManyWithoutUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
    userPersonalisation?: userPersonalisationUpdateManyWithoutUserNestedInput
    auditTrial?: auditTrialUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDocumentAdminsInput = {
    kcId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    roleId?: UserUpdateroleIdInput | string[]
    functionId?: InputJsonValue | InputJsonValue | null
    additionalUnits?: UserUpdateadditionalUnitsInput | string[]
    AdditionalDocumentAdmins?: AdditionalDocumentAdminsUncheckedUpdateManyWithoutUserNestedInput
    DocumentComments?: DocumentCommentsUncheckedUpdateManyWithoutUserNestedInput
    DocumentVersions?: DocumentVersionsUncheckedUpdateManyWithoutUserNestedInput
    DocumentWorkFlowHistory?: DocumentWorkFlowHistoryUncheckedUpdateManyWithoutUserNestedInput
    Logs?: LogsUncheckedUpdateManyWithoutUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    userPersonalisation?: userPersonalisationUncheckedUpdateManyWithoutUserNestedInput
    auditTrial?: auditTrialUncheckedUpdateManyWithoutUserNestedInput
  }

  export type DocumentsCreateWithoutAdditionalDocumentAdminsInput = {
    id?: string
    documentName?: string | null
    documentNumbering?: string | null
    reasonOfCreation?: string | null
    effectiveDate?: Date | string | null
    nextRevisionDate?: Date | string | null
    currentVersion?: string | null
    documentLink?: string | null
    description?: string | null
    tags?: DocumentsCreatetagsInput | string[]
    documentState?: string | null
    system?: DocumentsCreatesystemInput | string[]
    section?: string | null
    revertComment?: string | null
    docType?: string | null
    documentClassification?: string | null
    issueNumber?: string | null
    retireComment?: string | null
    revisionReminderFlag?: boolean | null
    isVersion?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedDate?: Date | string | null
    countNumber?: number | null
    createdBy?: string | null
    distributionList?: string | null
    documentId?: string | null
    reviewers?: DocumentsCreatereviewersInput | string[]
    approvers?: DocumentsCreateapproversInput | string[]
    creators?: DocumentsCreatecreatorsInput | string[]
    distributionUsers?: DocumentsCreatedistributionUsersInput | InputJsonValue[]
    readAccess?: string | null
    readAccessUsers?: DocumentsCreatereadAccessUsersInput | InputJsonValue[]
    versionInfo?: DocumentsCreateversionInfoInput | InputJsonValue[]
    doctype?: DoctypeCreateNestedOneWithoutDocumentsInput
    organization?: OrganizationCreateNestedOneWithoutDocumentsInput
    creatorLocation?: LocationCreateNestedOneWithoutDocumentsInput
    creatorEntity?: EntityCreateNestedOneWithoutDocumentsInput
    ReferenceDocuments?: ReferenceDocumentsCreateNestedManyWithoutDocumentInput
    DocumentVersions?: DocumentVersionsCreateNestedManyWithoutDocumentInput
    DocumentComments?: DocumentCommentsCreateNestedManyWithoutDocumentInput
    DocumentWorkFlowHistory?: DocumentWorkFlowHistoryCreateNestedManyWithoutDocumentInput
    VersionReferenceDocuments?: VersionReferenceDocumentsCreateNestedManyWithoutDocumentsInput
  }

  export type DocumentsUncheckedCreateWithoutAdditionalDocumentAdminsInput = {
    id?: string
    doctypeId?: string | null
    organizationId?: string | null
    documentName?: string | null
    documentNumbering?: string | null
    reasonOfCreation?: string | null
    effectiveDate?: Date | string | null
    nextRevisionDate?: Date | string | null
    currentVersion?: string | null
    documentLink?: string | null
    description?: string | null
    tags?: DocumentsCreatetagsInput | string[]
    documentState?: string | null
    locationId: string
    entityId?: string | null
    system?: DocumentsCreatesystemInput | string[]
    section?: string | null
    revertComment?: string | null
    docType?: string | null
    documentClassification?: string | null
    issueNumber?: string | null
    retireComment?: string | null
    revisionReminderFlag?: boolean | null
    isVersion?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedDate?: Date | string | null
    countNumber?: number | null
    createdBy?: string | null
    distributionList?: string | null
    documentId?: string | null
    reviewers?: DocumentsCreatereviewersInput | string[]
    approvers?: DocumentsCreateapproversInput | string[]
    creators?: DocumentsCreatecreatorsInput | string[]
    distributionUsers?: DocumentsCreatedistributionUsersInput | InputJsonValue[]
    readAccess?: string | null
    readAccessUsers?: DocumentsCreatereadAccessUsersInput | InputJsonValue[]
    versionInfo?: DocumentsCreateversionInfoInput | InputJsonValue[]
    ReferenceDocuments?: ReferenceDocumentsUncheckedCreateNestedManyWithoutDocumentInput
    DocumentVersions?: DocumentVersionsUncheckedCreateNestedManyWithoutDocumentInput
    DocumentComments?: DocumentCommentsUncheckedCreateNestedManyWithoutDocumentInput
    DocumentWorkFlowHistory?: DocumentWorkFlowHistoryUncheckedCreateNestedManyWithoutDocumentInput
    VersionReferenceDocuments?: VersionReferenceDocumentsUncheckedCreateNestedManyWithoutDocumentsInput
  }

  export type DocumentsCreateOrConnectWithoutAdditionalDocumentAdminsInput = {
    where: DocumentsWhereUniqueInput
    create: XOR<DocumentsCreateWithoutAdditionalDocumentAdminsInput, DocumentsUncheckedCreateWithoutAdditionalDocumentAdminsInput>
  }

  export type UserCreateWithoutAdditionalDocumentAdminsInput = {
    id?: string
    kcId?: string | null
    email?: string | null
    username?: string | null
    firstname?: string | null
    lastname?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    enabled?: boolean | null
    userType?: string | null
    status?: boolean | null
    avatar?: string | null
    deleted?: boolean | null
    roleId?: UserCreateroleIdInput | string[]
    functionId?: InputJsonValue | null
    additionalUnits?: UserCreateadditionalUnitsInput | string[]
    entity?: EntityCreateNestedOneWithoutUserInput
    location?: LocationCreateNestedOneWithoutUserInput
    organization?: OrganizationCreateNestedOneWithoutUserInput
    DocumentComments?: DocumentCommentsCreateNestedManyWithoutUserInput
    DocumentVersions?: DocumentVersionsCreateNestedManyWithoutUserInput
    DocumentWorkFlowHistory?: DocumentWorkFlowHistoryCreateNestedManyWithoutUserInput
    Logs?: LogsCreateNestedManyWithoutUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
    documentAdmins?: documentAdminsCreateNestedManyWithoutUserInput
    userPersonalisation?: userPersonalisationCreateNestedManyWithoutUserInput
    auditTrial?: auditTrialCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAdditionalDocumentAdminsInput = {
    id?: string
    kcId?: string | null
    email?: string | null
    username?: string | null
    firstname?: string | null
    lastname?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    enabled?: boolean | null
    organizationId?: string | null
    locationId?: string | null
    entityId?: string | null
    userType?: string | null
    status?: boolean | null
    avatar?: string | null
    deleted?: boolean | null
    roleId?: UserCreateroleIdInput | string[]
    functionId?: InputJsonValue | null
    additionalUnits?: UserCreateadditionalUnitsInput | string[]
    DocumentComments?: DocumentCommentsUncheckedCreateNestedManyWithoutUserInput
    DocumentVersions?: DocumentVersionsUncheckedCreateNestedManyWithoutUserInput
    DocumentWorkFlowHistory?: DocumentWorkFlowHistoryUncheckedCreateNestedManyWithoutUserInput
    Logs?: LogsUncheckedCreateNestedManyWithoutUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    documentAdmins?: documentAdminsUncheckedCreateNestedManyWithoutUserInput
    userPersonalisation?: userPersonalisationUncheckedCreateNestedManyWithoutUserInput
    auditTrial?: auditTrialUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAdditionalDocumentAdminsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAdditionalDocumentAdminsInput, UserUncheckedCreateWithoutAdditionalDocumentAdminsInput>
  }

  export type DocumentsUpsertWithoutAdditionalDocumentAdminsInput = {
    update: XOR<DocumentsUpdateWithoutAdditionalDocumentAdminsInput, DocumentsUncheckedUpdateWithoutAdditionalDocumentAdminsInput>
    create: XOR<DocumentsCreateWithoutAdditionalDocumentAdminsInput, DocumentsUncheckedCreateWithoutAdditionalDocumentAdminsInput>
    where?: DocumentsWhereInput
  }

  export type DocumentsUpdateToOneWithWhereWithoutAdditionalDocumentAdminsInput = {
    where?: DocumentsWhereInput
    data: XOR<DocumentsUpdateWithoutAdditionalDocumentAdminsInput, DocumentsUncheckedUpdateWithoutAdditionalDocumentAdminsInput>
  }

  export type DocumentsUpdateWithoutAdditionalDocumentAdminsInput = {
    documentName?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumbering?: NullableStringFieldUpdateOperationsInput | string | null
    reasonOfCreation?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextRevisionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentVersion?: NullableStringFieldUpdateOperationsInput | string | null
    documentLink?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: DocumentsUpdatetagsInput | string[]
    documentState?: NullableStringFieldUpdateOperationsInput | string | null
    system?: DocumentsUpdatesystemInput | string[]
    section?: NullableStringFieldUpdateOperationsInput | string | null
    revertComment?: NullableStringFieldUpdateOperationsInput | string | null
    docType?: NullableStringFieldUpdateOperationsInput | string | null
    documentClassification?: NullableStringFieldUpdateOperationsInput | string | null
    issueNumber?: NullableStringFieldUpdateOperationsInput | string | null
    retireComment?: NullableStringFieldUpdateOperationsInput | string | null
    revisionReminderFlag?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isVersion?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    countNumber?: NullableIntFieldUpdateOperationsInput | number | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    distributionList?: NullableStringFieldUpdateOperationsInput | string | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    reviewers?: DocumentsUpdatereviewersInput | string[]
    approvers?: DocumentsUpdateapproversInput | string[]
    creators?: DocumentsUpdatecreatorsInput | string[]
    distributionUsers?: DocumentsUpdatedistributionUsersInput | InputJsonValue[]
    readAccess?: NullableStringFieldUpdateOperationsInput | string | null
    readAccessUsers?: DocumentsUpdatereadAccessUsersInput | InputJsonValue[]
    versionInfo?: DocumentsUpdateversionInfoInput | InputJsonValue[]
    doctype?: DoctypeUpdateOneWithoutDocumentsNestedInput
    organization?: OrganizationUpdateOneWithoutDocumentsNestedInput
    creatorLocation?: LocationUpdateOneWithoutDocumentsNestedInput
    creatorEntity?: EntityUpdateOneWithoutDocumentsNestedInput
    ReferenceDocuments?: ReferenceDocumentsUpdateManyWithoutDocumentNestedInput
    DocumentVersions?: DocumentVersionsUpdateManyWithoutDocumentNestedInput
    DocumentComments?: DocumentCommentsUpdateManyWithoutDocumentNestedInput
    DocumentWorkFlowHistory?: DocumentWorkFlowHistoryUpdateManyWithoutDocumentNestedInput
    VersionReferenceDocuments?: VersionReferenceDocumentsUpdateManyWithoutDocumentsNestedInput
  }

  export type DocumentsUncheckedUpdateWithoutAdditionalDocumentAdminsInput = {
    doctypeId?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    documentName?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumbering?: NullableStringFieldUpdateOperationsInput | string | null
    reasonOfCreation?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextRevisionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentVersion?: NullableStringFieldUpdateOperationsInput | string | null
    documentLink?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: DocumentsUpdatetagsInput | string[]
    documentState?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    system?: DocumentsUpdatesystemInput | string[]
    section?: NullableStringFieldUpdateOperationsInput | string | null
    revertComment?: NullableStringFieldUpdateOperationsInput | string | null
    docType?: NullableStringFieldUpdateOperationsInput | string | null
    documentClassification?: NullableStringFieldUpdateOperationsInput | string | null
    issueNumber?: NullableStringFieldUpdateOperationsInput | string | null
    retireComment?: NullableStringFieldUpdateOperationsInput | string | null
    revisionReminderFlag?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isVersion?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    countNumber?: NullableIntFieldUpdateOperationsInput | number | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    distributionList?: NullableStringFieldUpdateOperationsInput | string | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    reviewers?: DocumentsUpdatereviewersInput | string[]
    approvers?: DocumentsUpdateapproversInput | string[]
    creators?: DocumentsUpdatecreatorsInput | string[]
    distributionUsers?: DocumentsUpdatedistributionUsersInput | InputJsonValue[]
    readAccess?: NullableStringFieldUpdateOperationsInput | string | null
    readAccessUsers?: DocumentsUpdatereadAccessUsersInput | InputJsonValue[]
    versionInfo?: DocumentsUpdateversionInfoInput | InputJsonValue[]
    ReferenceDocuments?: ReferenceDocumentsUncheckedUpdateManyWithoutDocumentNestedInput
    DocumentVersions?: DocumentVersionsUncheckedUpdateManyWithoutDocumentNestedInput
    DocumentComments?: DocumentCommentsUncheckedUpdateManyWithoutDocumentNestedInput
    DocumentWorkFlowHistory?: DocumentWorkFlowHistoryUncheckedUpdateManyWithoutDocumentNestedInput
    VersionReferenceDocuments?: VersionReferenceDocumentsUncheckedUpdateManyWithoutDocumentsNestedInput
  }

  export type UserUpsertWithoutAdditionalDocumentAdminsInput = {
    update: XOR<UserUpdateWithoutAdditionalDocumentAdminsInput, UserUncheckedUpdateWithoutAdditionalDocumentAdminsInput>
    create: XOR<UserCreateWithoutAdditionalDocumentAdminsInput, UserUncheckedCreateWithoutAdditionalDocumentAdminsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAdditionalDocumentAdminsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAdditionalDocumentAdminsInput, UserUncheckedUpdateWithoutAdditionalDocumentAdminsInput>
  }

  export type UserUpdateWithoutAdditionalDocumentAdminsInput = {
    kcId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    userType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    roleId?: UserUpdateroleIdInput | string[]
    functionId?: InputJsonValue | InputJsonValue | null
    additionalUnits?: UserUpdateadditionalUnitsInput | string[]
    entity?: EntityUpdateOneWithoutUserNestedInput
    location?: LocationUpdateOneWithoutUserNestedInput
    organization?: OrganizationUpdateOneWithoutUserNestedInput
    DocumentComments?: DocumentCommentsUpdateManyWithoutUserNestedInput
    DocumentVersions?: DocumentVersionsUpdateManyWithoutUserNestedInput
    DocumentWorkFlowHistory?: DocumentWorkFlowHistoryUpdateManyWithoutUserNestedInput
    Logs?: LogsUpdateManyWithoutUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
    documentAdmins?: documentAdminsUpdateManyWithoutUserNestedInput
    userPersonalisation?: userPersonalisationUpdateManyWithoutUserNestedInput
    auditTrial?: auditTrialUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAdditionalDocumentAdminsInput = {
    kcId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    roleId?: UserUpdateroleIdInput | string[]
    functionId?: InputJsonValue | InputJsonValue | null
    additionalUnits?: UserUpdateadditionalUnitsInput | string[]
    DocumentComments?: DocumentCommentsUncheckedUpdateManyWithoutUserNestedInput
    DocumentVersions?: DocumentVersionsUncheckedUpdateManyWithoutUserNestedInput
    DocumentWorkFlowHistory?: DocumentWorkFlowHistoryUncheckedUpdateManyWithoutUserNestedInput
    Logs?: LogsUncheckedUpdateManyWithoutUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    documentAdmins?: documentAdminsUncheckedUpdateManyWithoutUserNestedInput
    userPersonalisation?: userPersonalisationUncheckedUpdateManyWithoutUserNestedInput
    auditTrial?: auditTrialUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutLogsInput = {
    id?: string
    kcId?: string | null
    email?: string | null
    username?: string | null
    firstname?: string | null
    lastname?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    enabled?: boolean | null
    userType?: string | null
    status?: boolean | null
    avatar?: string | null
    deleted?: boolean | null
    roleId?: UserCreateroleIdInput | string[]
    functionId?: InputJsonValue | null
    additionalUnits?: UserCreateadditionalUnitsInput | string[]
    entity?: EntityCreateNestedOneWithoutUserInput
    location?: LocationCreateNestedOneWithoutUserInput
    organization?: OrganizationCreateNestedOneWithoutUserInput
    AdditionalDocumentAdmins?: AdditionalDocumentAdminsCreateNestedManyWithoutUserInput
    DocumentComments?: DocumentCommentsCreateNestedManyWithoutUserInput
    DocumentVersions?: DocumentVersionsCreateNestedManyWithoutUserInput
    DocumentWorkFlowHistory?: DocumentWorkFlowHistoryCreateNestedManyWithoutUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
    documentAdmins?: documentAdminsCreateNestedManyWithoutUserInput
    userPersonalisation?: userPersonalisationCreateNestedManyWithoutUserInput
    auditTrial?: auditTrialCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutLogsInput = {
    id?: string
    kcId?: string | null
    email?: string | null
    username?: string | null
    firstname?: string | null
    lastname?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    enabled?: boolean | null
    organizationId?: string | null
    locationId?: string | null
    entityId?: string | null
    userType?: string | null
    status?: boolean | null
    avatar?: string | null
    deleted?: boolean | null
    roleId?: UserCreateroleIdInput | string[]
    functionId?: InputJsonValue | null
    additionalUnits?: UserCreateadditionalUnitsInput | string[]
    AdditionalDocumentAdmins?: AdditionalDocumentAdminsUncheckedCreateNestedManyWithoutUserInput
    DocumentComments?: DocumentCommentsUncheckedCreateNestedManyWithoutUserInput
    DocumentVersions?: DocumentVersionsUncheckedCreateNestedManyWithoutUserInput
    DocumentWorkFlowHistory?: DocumentWorkFlowHistoryUncheckedCreateNestedManyWithoutUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    documentAdmins?: documentAdminsUncheckedCreateNestedManyWithoutUserInput
    userPersonalisation?: userPersonalisationUncheckedCreateNestedManyWithoutUserInput
    auditTrial?: auditTrialUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLogsInput, UserUncheckedCreateWithoutLogsInput>
  }

  export type UserUpsertWithoutLogsInput = {
    update: XOR<UserUpdateWithoutLogsInput, UserUncheckedUpdateWithoutLogsInput>
    create: XOR<UserCreateWithoutLogsInput, UserUncheckedCreateWithoutLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLogsInput, UserUncheckedUpdateWithoutLogsInput>
  }

  export type UserUpdateWithoutLogsInput = {
    kcId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    userType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    roleId?: UserUpdateroleIdInput | string[]
    functionId?: InputJsonValue | InputJsonValue | null
    additionalUnits?: UserUpdateadditionalUnitsInput | string[]
    entity?: EntityUpdateOneWithoutUserNestedInput
    location?: LocationUpdateOneWithoutUserNestedInput
    organization?: OrganizationUpdateOneWithoutUserNestedInput
    AdditionalDocumentAdmins?: AdditionalDocumentAdminsUpdateManyWithoutUserNestedInput
    DocumentComments?: DocumentCommentsUpdateManyWithoutUserNestedInput
    DocumentVersions?: DocumentVersionsUpdateManyWithoutUserNestedInput
    DocumentWorkFlowHistory?: DocumentWorkFlowHistoryUpdateManyWithoutUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
    documentAdmins?: documentAdminsUpdateManyWithoutUserNestedInput
    userPersonalisation?: userPersonalisationUpdateManyWithoutUserNestedInput
    auditTrial?: auditTrialUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutLogsInput = {
    kcId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    roleId?: UserUpdateroleIdInput | string[]
    functionId?: InputJsonValue | InputJsonValue | null
    additionalUnits?: UserUpdateadditionalUnitsInput | string[]
    AdditionalDocumentAdmins?: AdditionalDocumentAdminsUncheckedUpdateManyWithoutUserNestedInput
    DocumentComments?: DocumentCommentsUncheckedUpdateManyWithoutUserNestedInput
    DocumentVersions?: DocumentVersionsUncheckedUpdateManyWithoutUserNestedInput
    DocumentWorkFlowHistory?: DocumentWorkFlowHistoryUncheckedUpdateManyWithoutUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    documentAdmins?: documentAdminsUncheckedUpdateManyWithoutUserNestedInput
    userPersonalisation?: userPersonalisationUncheckedUpdateManyWithoutUserNestedInput
    auditTrial?: auditTrialUncheckedUpdateManyWithoutUserNestedInput
  }

  export type OrganizationCreateWithoutUserPersonalisationInput = {
    id?: string
    kcId?: string | null
    organizationName?: string | null
    realmName?: string | null
    instanceUrl?: string | null
    principalGeography?: string | null
    loginUrl?: string | null
    logoutUrl?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    activeModules?: OrganizationCreateactiveModulesInput | string[]
    clientID?: string | null
    clientSecret?: string | null
    fiscalYearQuarters?: string | null
    fiscalYearFormat?: string | null
    auditYear?: string | null
    logoUrl?: string | null
    deleted?: boolean | null
    business?: BusinessCreateNestedManyWithoutOrganizationInput
    Doctype?: DoctypeCreateNestedManyWithoutOrganizationInput
    Documents?: DocumentsCreateNestedManyWithoutOrganizationInput
    entity?: EntityCreateNestedManyWithoutOrganizationInput
    entityType?: EntityTypeCreateNestedManyWithoutOrganizationInput
    location?: LocationCreateNestedManyWithoutOrganizationInput
    role?: RoleCreateNestedManyWithoutOrganizationInput
    section?: SectionCreateNestedManyWithoutOrganizationInput
    systemType?: SystemTypeCreateNestedManyWithoutOrganizationInput
    user?: UserCreateNestedManyWithoutOrganizationInput
    ConnectedApps?: ConnectedAppsCreateNestedManyWithoutOrganizationInput
    unitOfMeasurement?: unitTypeCreateNestedManyWithoutOrganizationInput
    kpi?: kpiCreateNestedManyWithoutOrganizationInput
    businessType?: businessTypeCreateNestedManyWithoutOrganizationInput
    prefixSuffix?: prefixSuffixCreateNestedManyWithoutOrganizationInput
    serialNumber?: serialNumberCreateNestedManyWithoutOrganizationInput
    function?: FunctionsCreateNestedManyWithoutOrganizationInput
    rolesTable?: rolesTableCreateNestedManyWithoutOrganizationInput
    problem?: ProblemCreateNestedManyWithoutOrganizationInput
    parts?: PartsCreateNestedManyWithoutOrganizationInput
    Models?: ModelsCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutUserPersonalisationInput = {
    id?: string
    kcId?: string | null
    organizationName?: string | null
    realmName?: string | null
    instanceUrl?: string | null
    principalGeography?: string | null
    loginUrl?: string | null
    logoutUrl?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    activeModules?: OrganizationCreateactiveModulesInput | string[]
    clientID?: string | null
    clientSecret?: string | null
    fiscalYearQuarters?: string | null
    fiscalYearFormat?: string | null
    auditYear?: string | null
    logoUrl?: string | null
    deleted?: boolean | null
    business?: BusinessUncheckedCreateNestedManyWithoutOrganizationInput
    Doctype?: DoctypeUncheckedCreateNestedManyWithoutOrganizationInput
    Documents?: DocumentsUncheckedCreateNestedManyWithoutOrganizationInput
    entity?: EntityUncheckedCreateNestedManyWithoutOrganizationInput
    entityType?: EntityTypeUncheckedCreateNestedManyWithoutOrganizationInput
    location?: LocationUncheckedCreateNestedManyWithoutOrganizationInput
    role?: RoleUncheckedCreateNestedManyWithoutOrganizationInput
    section?: SectionUncheckedCreateNestedManyWithoutOrganizationInput
    systemType?: SystemTypeUncheckedCreateNestedManyWithoutOrganizationInput
    user?: UserUncheckedCreateNestedManyWithoutOrganizationInput
    ConnectedApps?: ConnectedAppsUncheckedCreateNestedManyWithoutOrganizationInput
    unitOfMeasurement?: unitTypeUncheckedCreateNestedManyWithoutOrganizationInput
    kpi?: kpiUncheckedCreateNestedManyWithoutOrganizationInput
    businessType?: businessTypeUncheckedCreateNestedManyWithoutOrganizationInput
    prefixSuffix?: prefixSuffixUncheckedCreateNestedManyWithoutOrganizationInput
    serialNumber?: serialNumberUncheckedCreateNestedManyWithoutOrganizationInput
    function?: FunctionsUncheckedCreateNestedManyWithoutOrganizationInput
    rolesTable?: rolesTableUncheckedCreateNestedManyWithoutOrganizationInput
    problem?: ProblemUncheckedCreateNestedManyWithoutOrganizationInput
    parts?: PartsUncheckedCreateNestedManyWithoutOrganizationInput
    Models?: ModelsUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutUserPersonalisationInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutUserPersonalisationInput, OrganizationUncheckedCreateWithoutUserPersonalisationInput>
  }

  export type UserCreateWithoutUserPersonalisationInput = {
    id?: string
    kcId?: string | null
    email?: string | null
    username?: string | null
    firstname?: string | null
    lastname?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    enabled?: boolean | null
    userType?: string | null
    status?: boolean | null
    avatar?: string | null
    deleted?: boolean | null
    roleId?: UserCreateroleIdInput | string[]
    functionId?: InputJsonValue | null
    additionalUnits?: UserCreateadditionalUnitsInput | string[]
    entity?: EntityCreateNestedOneWithoutUserInput
    location?: LocationCreateNestedOneWithoutUserInput
    organization?: OrganizationCreateNestedOneWithoutUserInput
    AdditionalDocumentAdmins?: AdditionalDocumentAdminsCreateNestedManyWithoutUserInput
    DocumentComments?: DocumentCommentsCreateNestedManyWithoutUserInput
    DocumentVersions?: DocumentVersionsCreateNestedManyWithoutUserInput
    DocumentWorkFlowHistory?: DocumentWorkFlowHistoryCreateNestedManyWithoutUserInput
    Logs?: LogsCreateNestedManyWithoutUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
    documentAdmins?: documentAdminsCreateNestedManyWithoutUserInput
    auditTrial?: auditTrialCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserPersonalisationInput = {
    id?: string
    kcId?: string | null
    email?: string | null
    username?: string | null
    firstname?: string | null
    lastname?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    enabled?: boolean | null
    organizationId?: string | null
    locationId?: string | null
    entityId?: string | null
    userType?: string | null
    status?: boolean | null
    avatar?: string | null
    deleted?: boolean | null
    roleId?: UserCreateroleIdInput | string[]
    functionId?: InputJsonValue | null
    additionalUnits?: UserCreateadditionalUnitsInput | string[]
    AdditionalDocumentAdmins?: AdditionalDocumentAdminsUncheckedCreateNestedManyWithoutUserInput
    DocumentComments?: DocumentCommentsUncheckedCreateNestedManyWithoutUserInput
    DocumentVersions?: DocumentVersionsUncheckedCreateNestedManyWithoutUserInput
    DocumentWorkFlowHistory?: DocumentWorkFlowHistoryUncheckedCreateNestedManyWithoutUserInput
    Logs?: LogsUncheckedCreateNestedManyWithoutUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    documentAdmins?: documentAdminsUncheckedCreateNestedManyWithoutUserInput
    auditTrial?: auditTrialUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserPersonalisationInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserPersonalisationInput, UserUncheckedCreateWithoutUserPersonalisationInput>
  }

  export type OrganizationUpsertWithoutUserPersonalisationInput = {
    update: XOR<OrganizationUpdateWithoutUserPersonalisationInput, OrganizationUncheckedUpdateWithoutUserPersonalisationInput>
    create: XOR<OrganizationCreateWithoutUserPersonalisationInput, OrganizationUncheckedCreateWithoutUserPersonalisationInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutUserPersonalisationInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutUserPersonalisationInput, OrganizationUncheckedUpdateWithoutUserPersonalisationInput>
  }

  export type OrganizationUpdateWithoutUserPersonalisationInput = {
    kcId?: NullableStringFieldUpdateOperationsInput | string | null
    organizationName?: NullableStringFieldUpdateOperationsInput | string | null
    realmName?: NullableStringFieldUpdateOperationsInput | string | null
    instanceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    principalGeography?: NullableStringFieldUpdateOperationsInput | string | null
    loginUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoutUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    activeModules?: OrganizationUpdateactiveModulesInput | string[]
    clientID?: NullableStringFieldUpdateOperationsInput | string | null
    clientSecret?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearQuarters?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearFormat?: NullableStringFieldUpdateOperationsInput | string | null
    auditYear?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    business?: BusinessUpdateManyWithoutOrganizationNestedInput
    Doctype?: DoctypeUpdateManyWithoutOrganizationNestedInput
    Documents?: DocumentsUpdateManyWithoutOrganizationNestedInput
    entity?: EntityUpdateManyWithoutOrganizationNestedInput
    entityType?: EntityTypeUpdateManyWithoutOrganizationNestedInput
    location?: LocationUpdateManyWithoutOrganizationNestedInput
    role?: RoleUpdateManyWithoutOrganizationNestedInput
    section?: SectionUpdateManyWithoutOrganizationNestedInput
    systemType?: SystemTypeUpdateManyWithoutOrganizationNestedInput
    user?: UserUpdateManyWithoutOrganizationNestedInput
    ConnectedApps?: ConnectedAppsUpdateManyWithoutOrganizationNestedInput
    unitOfMeasurement?: unitTypeUpdateManyWithoutOrganizationNestedInput
    kpi?: kpiUpdateManyWithoutOrganizationNestedInput
    businessType?: businessTypeUpdateManyWithoutOrganizationNestedInput
    prefixSuffix?: prefixSuffixUpdateManyWithoutOrganizationNestedInput
    serialNumber?: serialNumberUpdateManyWithoutOrganizationNestedInput
    function?: FunctionsUpdateManyWithoutOrganizationNestedInput
    rolesTable?: rolesTableUpdateManyWithoutOrganizationNestedInput
    problem?: ProblemUpdateManyWithoutOrganizationNestedInput
    parts?: PartsUpdateManyWithoutOrganizationNestedInput
    Models?: ModelsUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutUserPersonalisationInput = {
    kcId?: NullableStringFieldUpdateOperationsInput | string | null
    organizationName?: NullableStringFieldUpdateOperationsInput | string | null
    realmName?: NullableStringFieldUpdateOperationsInput | string | null
    instanceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    principalGeography?: NullableStringFieldUpdateOperationsInput | string | null
    loginUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoutUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    activeModules?: OrganizationUpdateactiveModulesInput | string[]
    clientID?: NullableStringFieldUpdateOperationsInput | string | null
    clientSecret?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearQuarters?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearFormat?: NullableStringFieldUpdateOperationsInput | string | null
    auditYear?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    business?: BusinessUncheckedUpdateManyWithoutOrganizationNestedInput
    Doctype?: DoctypeUncheckedUpdateManyWithoutOrganizationNestedInput
    Documents?: DocumentsUncheckedUpdateManyWithoutOrganizationNestedInput
    entity?: EntityUncheckedUpdateManyWithoutOrganizationNestedInput
    entityType?: EntityTypeUncheckedUpdateManyWithoutOrganizationNestedInput
    location?: LocationUncheckedUpdateManyWithoutOrganizationNestedInput
    role?: RoleUncheckedUpdateManyWithoutOrganizationNestedInput
    section?: SectionUncheckedUpdateManyWithoutOrganizationNestedInput
    systemType?: SystemTypeUncheckedUpdateManyWithoutOrganizationNestedInput
    user?: UserUncheckedUpdateManyWithoutOrganizationNestedInput
    ConnectedApps?: ConnectedAppsUncheckedUpdateManyWithoutOrganizationNestedInput
    unitOfMeasurement?: unitTypeUncheckedUpdateManyWithoutOrganizationNestedInput
    kpi?: kpiUncheckedUpdateManyWithoutOrganizationNestedInput
    businessType?: businessTypeUncheckedUpdateManyWithoutOrganizationNestedInput
    prefixSuffix?: prefixSuffixUncheckedUpdateManyWithoutOrganizationNestedInput
    serialNumber?: serialNumberUncheckedUpdateManyWithoutOrganizationNestedInput
    function?: FunctionsUncheckedUpdateManyWithoutOrganizationNestedInput
    rolesTable?: rolesTableUncheckedUpdateManyWithoutOrganizationNestedInput
    problem?: ProblemUncheckedUpdateManyWithoutOrganizationNestedInput
    parts?: PartsUncheckedUpdateManyWithoutOrganizationNestedInput
    Models?: ModelsUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type UserUpsertWithoutUserPersonalisationInput = {
    update: XOR<UserUpdateWithoutUserPersonalisationInput, UserUncheckedUpdateWithoutUserPersonalisationInput>
    create: XOR<UserCreateWithoutUserPersonalisationInput, UserUncheckedCreateWithoutUserPersonalisationInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserPersonalisationInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserPersonalisationInput, UserUncheckedUpdateWithoutUserPersonalisationInput>
  }

  export type UserUpdateWithoutUserPersonalisationInput = {
    kcId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    userType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    roleId?: UserUpdateroleIdInput | string[]
    functionId?: InputJsonValue | InputJsonValue | null
    additionalUnits?: UserUpdateadditionalUnitsInput | string[]
    entity?: EntityUpdateOneWithoutUserNestedInput
    location?: LocationUpdateOneWithoutUserNestedInput
    organization?: OrganizationUpdateOneWithoutUserNestedInput
    AdditionalDocumentAdmins?: AdditionalDocumentAdminsUpdateManyWithoutUserNestedInput
    DocumentComments?: DocumentCommentsUpdateManyWithoutUserNestedInput
    DocumentVersions?: DocumentVersionsUpdateManyWithoutUserNestedInput
    DocumentWorkFlowHistory?: DocumentWorkFlowHistoryUpdateManyWithoutUserNestedInput
    Logs?: LogsUpdateManyWithoutUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
    documentAdmins?: documentAdminsUpdateManyWithoutUserNestedInput
    auditTrial?: auditTrialUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserPersonalisationInput = {
    kcId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    roleId?: UserUpdateroleIdInput | string[]
    functionId?: InputJsonValue | InputJsonValue | null
    additionalUnits?: UserUpdateadditionalUnitsInput | string[]
    AdditionalDocumentAdmins?: AdditionalDocumentAdminsUncheckedUpdateManyWithoutUserNestedInput
    DocumentComments?: DocumentCommentsUncheckedUpdateManyWithoutUserNestedInput
    DocumentVersions?: DocumentVersionsUncheckedUpdateManyWithoutUserNestedInput
    DocumentWorkFlowHistory?: DocumentWorkFlowHistoryUncheckedUpdateManyWithoutUserNestedInput
    Logs?: LogsUncheckedUpdateManyWithoutUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    documentAdmins?: documentAdminsUncheckedUpdateManyWithoutUserNestedInput
    auditTrial?: auditTrialUncheckedUpdateManyWithoutUserNestedInput
  }

  export type OrganizationCreateWithoutConnectedAppsInput = {
    id?: string
    kcId?: string | null
    organizationName?: string | null
    realmName?: string | null
    instanceUrl?: string | null
    principalGeography?: string | null
    loginUrl?: string | null
    logoutUrl?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    activeModules?: OrganizationCreateactiveModulesInput | string[]
    clientID?: string | null
    clientSecret?: string | null
    fiscalYearQuarters?: string | null
    fiscalYearFormat?: string | null
    auditYear?: string | null
    logoUrl?: string | null
    deleted?: boolean | null
    business?: BusinessCreateNestedManyWithoutOrganizationInput
    Doctype?: DoctypeCreateNestedManyWithoutOrganizationInput
    Documents?: DocumentsCreateNestedManyWithoutOrganizationInput
    entity?: EntityCreateNestedManyWithoutOrganizationInput
    entityType?: EntityTypeCreateNestedManyWithoutOrganizationInput
    location?: LocationCreateNestedManyWithoutOrganizationInput
    role?: RoleCreateNestedManyWithoutOrganizationInput
    section?: SectionCreateNestedManyWithoutOrganizationInput
    systemType?: SystemTypeCreateNestedManyWithoutOrganizationInput
    user?: UserCreateNestedManyWithoutOrganizationInput
    userPersonalisation?: userPersonalisationCreateNestedManyWithoutOrganizationInput
    unitOfMeasurement?: unitTypeCreateNestedManyWithoutOrganizationInput
    kpi?: kpiCreateNestedManyWithoutOrganizationInput
    businessType?: businessTypeCreateNestedManyWithoutOrganizationInput
    prefixSuffix?: prefixSuffixCreateNestedManyWithoutOrganizationInput
    serialNumber?: serialNumberCreateNestedManyWithoutOrganizationInput
    function?: FunctionsCreateNestedManyWithoutOrganizationInput
    rolesTable?: rolesTableCreateNestedManyWithoutOrganizationInput
    problem?: ProblemCreateNestedManyWithoutOrganizationInput
    parts?: PartsCreateNestedManyWithoutOrganizationInput
    Models?: ModelsCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutConnectedAppsInput = {
    id?: string
    kcId?: string | null
    organizationName?: string | null
    realmName?: string | null
    instanceUrl?: string | null
    principalGeography?: string | null
    loginUrl?: string | null
    logoutUrl?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    activeModules?: OrganizationCreateactiveModulesInput | string[]
    clientID?: string | null
    clientSecret?: string | null
    fiscalYearQuarters?: string | null
    fiscalYearFormat?: string | null
    auditYear?: string | null
    logoUrl?: string | null
    deleted?: boolean | null
    business?: BusinessUncheckedCreateNestedManyWithoutOrganizationInput
    Doctype?: DoctypeUncheckedCreateNestedManyWithoutOrganizationInput
    Documents?: DocumentsUncheckedCreateNestedManyWithoutOrganizationInput
    entity?: EntityUncheckedCreateNestedManyWithoutOrganizationInput
    entityType?: EntityTypeUncheckedCreateNestedManyWithoutOrganizationInput
    location?: LocationUncheckedCreateNestedManyWithoutOrganizationInput
    role?: RoleUncheckedCreateNestedManyWithoutOrganizationInput
    section?: SectionUncheckedCreateNestedManyWithoutOrganizationInput
    systemType?: SystemTypeUncheckedCreateNestedManyWithoutOrganizationInput
    user?: UserUncheckedCreateNestedManyWithoutOrganizationInput
    userPersonalisation?: userPersonalisationUncheckedCreateNestedManyWithoutOrganizationInput
    unitOfMeasurement?: unitTypeUncheckedCreateNestedManyWithoutOrganizationInput
    kpi?: kpiUncheckedCreateNestedManyWithoutOrganizationInput
    businessType?: businessTypeUncheckedCreateNestedManyWithoutOrganizationInput
    prefixSuffix?: prefixSuffixUncheckedCreateNestedManyWithoutOrganizationInput
    serialNumber?: serialNumberUncheckedCreateNestedManyWithoutOrganizationInput
    function?: FunctionsUncheckedCreateNestedManyWithoutOrganizationInput
    rolesTable?: rolesTableUncheckedCreateNestedManyWithoutOrganizationInput
    problem?: ProblemUncheckedCreateNestedManyWithoutOrganizationInput
    parts?: PartsUncheckedCreateNestedManyWithoutOrganizationInput
    Models?: ModelsUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutConnectedAppsInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutConnectedAppsInput, OrganizationUncheckedCreateWithoutConnectedAppsInput>
  }

  export type unitTypeCreateWithoutConnectedAppsInput = {
    id?: string
    unitType: string
    unitOfMeasurement?: unitTypeCreateunitOfMeasurementInput | string[]
    deleted?: boolean | null
    createdModifiedBy: string
    createdModifiedAt?: Date | string
    kpi?: kpiCreateNestedManyWithoutUnitTypeInput
    organization?: OrganizationCreateNestedOneWithoutUnitOfMeasurementInput
    location?: LocationCreateNestedOneWithoutUomInput
  }

  export type unitTypeUncheckedCreateWithoutConnectedAppsInput = {
    id?: string
    unitType: string
    unitOfMeasurement?: unitTypeCreateunitOfMeasurementInput | string[]
    organizationId?: string | null
    locationId?: string | null
    deleted?: boolean | null
    createdModifiedBy: string
    createdModifiedAt?: Date | string
    kpi?: kpiUncheckedCreateNestedManyWithoutUnitTypeInput
  }

  export type unitTypeCreateOrConnectWithoutConnectedAppsInput = {
    where: unitTypeWhereUniqueInput
    create: XOR<unitTypeCreateWithoutConnectedAppsInput, unitTypeUncheckedCreateWithoutConnectedAppsInput>
  }

  export type unitTypeCreateManyConnectedAppsInputEnvelope = {
    data: unitTypeCreateManyConnectedAppsInput | unitTypeCreateManyConnectedAppsInput[]
  }

  export type kpiCreateWithoutConnectedAppsInput = {
    id?: string
    kpiName: string
    kpiType?: string | null
    keyFields?: kpiCreatekeyFieldsInput | string[]
    uom: string
    status: boolean
    apiEndPoint?: string | null
    kpiDescription?: string | null
    kpiTargetType?: boolean | null
    locationId?: kpiCreatelocationIdInput | string[]
    createdModifiedBy: string
    createdModifiedAt?: Date | string
    unitType?: unitTypeCreateNestedOneWithoutKpiInput
    organization?: OrganizationCreateNestedOneWithoutKpiInput
  }

  export type kpiUncheckedCreateWithoutConnectedAppsInput = {
    id?: string
    kpiName: string
    kpiType?: string | null
    keyFields?: kpiCreatekeyFieldsInput | string[]
    unitTypeId?: string | null
    uom: string
    status: boolean
    apiEndPoint?: string | null
    kpiDescription?: string | null
    kpiTargetType?: boolean | null
    organizationId?: string | null
    locationId?: kpiCreatelocationIdInput | string[]
    createdModifiedBy: string
    createdModifiedAt?: Date | string
  }

  export type kpiCreateOrConnectWithoutConnectedAppsInput = {
    where: kpiWhereUniqueInput
    create: XOR<kpiCreateWithoutConnectedAppsInput, kpiUncheckedCreateWithoutConnectedAppsInput>
  }

  export type kpiCreateManyConnectedAppsInputEnvelope = {
    data: kpiCreateManyConnectedAppsInput | kpiCreateManyConnectedAppsInput[]
  }

  export type OrganizationUpsertWithoutConnectedAppsInput = {
    update: XOR<OrganizationUpdateWithoutConnectedAppsInput, OrganizationUncheckedUpdateWithoutConnectedAppsInput>
    create: XOR<OrganizationCreateWithoutConnectedAppsInput, OrganizationUncheckedCreateWithoutConnectedAppsInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutConnectedAppsInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutConnectedAppsInput, OrganizationUncheckedUpdateWithoutConnectedAppsInput>
  }

  export type OrganizationUpdateWithoutConnectedAppsInput = {
    kcId?: NullableStringFieldUpdateOperationsInput | string | null
    organizationName?: NullableStringFieldUpdateOperationsInput | string | null
    realmName?: NullableStringFieldUpdateOperationsInput | string | null
    instanceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    principalGeography?: NullableStringFieldUpdateOperationsInput | string | null
    loginUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoutUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    activeModules?: OrganizationUpdateactiveModulesInput | string[]
    clientID?: NullableStringFieldUpdateOperationsInput | string | null
    clientSecret?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearQuarters?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearFormat?: NullableStringFieldUpdateOperationsInput | string | null
    auditYear?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    business?: BusinessUpdateManyWithoutOrganizationNestedInput
    Doctype?: DoctypeUpdateManyWithoutOrganizationNestedInput
    Documents?: DocumentsUpdateManyWithoutOrganizationNestedInput
    entity?: EntityUpdateManyWithoutOrganizationNestedInput
    entityType?: EntityTypeUpdateManyWithoutOrganizationNestedInput
    location?: LocationUpdateManyWithoutOrganizationNestedInput
    role?: RoleUpdateManyWithoutOrganizationNestedInput
    section?: SectionUpdateManyWithoutOrganizationNestedInput
    systemType?: SystemTypeUpdateManyWithoutOrganizationNestedInput
    user?: UserUpdateManyWithoutOrganizationNestedInput
    userPersonalisation?: userPersonalisationUpdateManyWithoutOrganizationNestedInput
    unitOfMeasurement?: unitTypeUpdateManyWithoutOrganizationNestedInput
    kpi?: kpiUpdateManyWithoutOrganizationNestedInput
    businessType?: businessTypeUpdateManyWithoutOrganizationNestedInput
    prefixSuffix?: prefixSuffixUpdateManyWithoutOrganizationNestedInput
    serialNumber?: serialNumberUpdateManyWithoutOrganizationNestedInput
    function?: FunctionsUpdateManyWithoutOrganizationNestedInput
    rolesTable?: rolesTableUpdateManyWithoutOrganizationNestedInput
    problem?: ProblemUpdateManyWithoutOrganizationNestedInput
    parts?: PartsUpdateManyWithoutOrganizationNestedInput
    Models?: ModelsUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutConnectedAppsInput = {
    kcId?: NullableStringFieldUpdateOperationsInput | string | null
    organizationName?: NullableStringFieldUpdateOperationsInput | string | null
    realmName?: NullableStringFieldUpdateOperationsInput | string | null
    instanceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    principalGeography?: NullableStringFieldUpdateOperationsInput | string | null
    loginUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoutUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    activeModules?: OrganizationUpdateactiveModulesInput | string[]
    clientID?: NullableStringFieldUpdateOperationsInput | string | null
    clientSecret?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearQuarters?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearFormat?: NullableStringFieldUpdateOperationsInput | string | null
    auditYear?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    business?: BusinessUncheckedUpdateManyWithoutOrganizationNestedInput
    Doctype?: DoctypeUncheckedUpdateManyWithoutOrganizationNestedInput
    Documents?: DocumentsUncheckedUpdateManyWithoutOrganizationNestedInput
    entity?: EntityUncheckedUpdateManyWithoutOrganizationNestedInput
    entityType?: EntityTypeUncheckedUpdateManyWithoutOrganizationNestedInput
    location?: LocationUncheckedUpdateManyWithoutOrganizationNestedInput
    role?: RoleUncheckedUpdateManyWithoutOrganizationNestedInput
    section?: SectionUncheckedUpdateManyWithoutOrganizationNestedInput
    systemType?: SystemTypeUncheckedUpdateManyWithoutOrganizationNestedInput
    user?: UserUncheckedUpdateManyWithoutOrganizationNestedInput
    userPersonalisation?: userPersonalisationUncheckedUpdateManyWithoutOrganizationNestedInput
    unitOfMeasurement?: unitTypeUncheckedUpdateManyWithoutOrganizationNestedInput
    kpi?: kpiUncheckedUpdateManyWithoutOrganizationNestedInput
    businessType?: businessTypeUncheckedUpdateManyWithoutOrganizationNestedInput
    prefixSuffix?: prefixSuffixUncheckedUpdateManyWithoutOrganizationNestedInput
    serialNumber?: serialNumberUncheckedUpdateManyWithoutOrganizationNestedInput
    function?: FunctionsUncheckedUpdateManyWithoutOrganizationNestedInput
    rolesTable?: rolesTableUncheckedUpdateManyWithoutOrganizationNestedInput
    problem?: ProblemUncheckedUpdateManyWithoutOrganizationNestedInput
    parts?: PartsUncheckedUpdateManyWithoutOrganizationNestedInput
    Models?: ModelsUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type unitTypeUpsertWithWhereUniqueWithoutConnectedAppsInput = {
    where: unitTypeWhereUniqueInput
    update: XOR<unitTypeUpdateWithoutConnectedAppsInput, unitTypeUncheckedUpdateWithoutConnectedAppsInput>
    create: XOR<unitTypeCreateWithoutConnectedAppsInput, unitTypeUncheckedCreateWithoutConnectedAppsInput>
  }

  export type unitTypeUpdateWithWhereUniqueWithoutConnectedAppsInput = {
    where: unitTypeWhereUniqueInput
    data: XOR<unitTypeUpdateWithoutConnectedAppsInput, unitTypeUncheckedUpdateWithoutConnectedAppsInput>
  }

  export type unitTypeUpdateManyWithWhereWithoutConnectedAppsInput = {
    where: unitTypeScalarWhereInput
    data: XOR<unitTypeUpdateManyMutationInput, unitTypeUncheckedUpdateManyWithoutConnectedAppsInput>
  }

  export type kpiUpsertWithWhereUniqueWithoutConnectedAppsInput = {
    where: kpiWhereUniqueInput
    update: XOR<kpiUpdateWithoutConnectedAppsInput, kpiUncheckedUpdateWithoutConnectedAppsInput>
    create: XOR<kpiCreateWithoutConnectedAppsInput, kpiUncheckedCreateWithoutConnectedAppsInput>
  }

  export type kpiUpdateWithWhereUniqueWithoutConnectedAppsInput = {
    where: kpiWhereUniqueInput
    data: XOR<kpiUpdateWithoutConnectedAppsInput, kpiUncheckedUpdateWithoutConnectedAppsInput>
  }

  export type kpiUpdateManyWithWhereWithoutConnectedAppsInput = {
    where: kpiScalarWhereInput
    data: XOR<kpiUpdateManyMutationInput, kpiUncheckedUpdateManyWithoutConnectedAppsInput>
  }

  export type kpiCreateWithoutUnitTypeInput = {
    id?: string
    kpiName: string
    kpiType?: string | null
    keyFields?: kpiCreatekeyFieldsInput | string[]
    uom: string
    status: boolean
    apiEndPoint?: string | null
    kpiDescription?: string | null
    kpiTargetType?: boolean | null
    locationId?: kpiCreatelocationIdInput | string[]
    createdModifiedBy: string
    createdModifiedAt?: Date | string
    ConnectedApps?: ConnectedAppsCreateNestedOneWithoutKpiInput
    organization?: OrganizationCreateNestedOneWithoutKpiInput
  }

  export type kpiUncheckedCreateWithoutUnitTypeInput = {
    id?: string
    kpiName: string
    kpiType?: string | null
    keyFields?: kpiCreatekeyFieldsInput | string[]
    uom: string
    sourceId?: string | null
    status: boolean
    apiEndPoint?: string | null
    kpiDescription?: string | null
    kpiTargetType?: boolean | null
    organizationId?: string | null
    locationId?: kpiCreatelocationIdInput | string[]
    createdModifiedBy: string
    createdModifiedAt?: Date | string
  }

  export type kpiCreateOrConnectWithoutUnitTypeInput = {
    where: kpiWhereUniqueInput
    create: XOR<kpiCreateWithoutUnitTypeInput, kpiUncheckedCreateWithoutUnitTypeInput>
  }

  export type kpiCreateManyUnitTypeInputEnvelope = {
    data: kpiCreateManyUnitTypeInput | kpiCreateManyUnitTypeInput[]
  }

  export type OrganizationCreateWithoutUnitOfMeasurementInput = {
    id?: string
    kcId?: string | null
    organizationName?: string | null
    realmName?: string | null
    instanceUrl?: string | null
    principalGeography?: string | null
    loginUrl?: string | null
    logoutUrl?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    activeModules?: OrganizationCreateactiveModulesInput | string[]
    clientID?: string | null
    clientSecret?: string | null
    fiscalYearQuarters?: string | null
    fiscalYearFormat?: string | null
    auditYear?: string | null
    logoUrl?: string | null
    deleted?: boolean | null
    business?: BusinessCreateNestedManyWithoutOrganizationInput
    Doctype?: DoctypeCreateNestedManyWithoutOrganizationInput
    Documents?: DocumentsCreateNestedManyWithoutOrganizationInput
    entity?: EntityCreateNestedManyWithoutOrganizationInput
    entityType?: EntityTypeCreateNestedManyWithoutOrganizationInput
    location?: LocationCreateNestedManyWithoutOrganizationInput
    role?: RoleCreateNestedManyWithoutOrganizationInput
    section?: SectionCreateNestedManyWithoutOrganizationInput
    systemType?: SystemTypeCreateNestedManyWithoutOrganizationInput
    user?: UserCreateNestedManyWithoutOrganizationInput
    userPersonalisation?: userPersonalisationCreateNestedManyWithoutOrganizationInput
    ConnectedApps?: ConnectedAppsCreateNestedManyWithoutOrganizationInput
    kpi?: kpiCreateNestedManyWithoutOrganizationInput
    businessType?: businessTypeCreateNestedManyWithoutOrganizationInput
    prefixSuffix?: prefixSuffixCreateNestedManyWithoutOrganizationInput
    serialNumber?: serialNumberCreateNestedManyWithoutOrganizationInput
    function?: FunctionsCreateNestedManyWithoutOrganizationInput
    rolesTable?: rolesTableCreateNestedManyWithoutOrganizationInput
    problem?: ProblemCreateNestedManyWithoutOrganizationInput
    parts?: PartsCreateNestedManyWithoutOrganizationInput
    Models?: ModelsCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutUnitOfMeasurementInput = {
    id?: string
    kcId?: string | null
    organizationName?: string | null
    realmName?: string | null
    instanceUrl?: string | null
    principalGeography?: string | null
    loginUrl?: string | null
    logoutUrl?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    activeModules?: OrganizationCreateactiveModulesInput | string[]
    clientID?: string | null
    clientSecret?: string | null
    fiscalYearQuarters?: string | null
    fiscalYearFormat?: string | null
    auditYear?: string | null
    logoUrl?: string | null
    deleted?: boolean | null
    business?: BusinessUncheckedCreateNestedManyWithoutOrganizationInput
    Doctype?: DoctypeUncheckedCreateNestedManyWithoutOrganizationInput
    Documents?: DocumentsUncheckedCreateNestedManyWithoutOrganizationInput
    entity?: EntityUncheckedCreateNestedManyWithoutOrganizationInput
    entityType?: EntityTypeUncheckedCreateNestedManyWithoutOrganizationInput
    location?: LocationUncheckedCreateNestedManyWithoutOrganizationInput
    role?: RoleUncheckedCreateNestedManyWithoutOrganizationInput
    section?: SectionUncheckedCreateNestedManyWithoutOrganizationInput
    systemType?: SystemTypeUncheckedCreateNestedManyWithoutOrganizationInput
    user?: UserUncheckedCreateNestedManyWithoutOrganizationInput
    userPersonalisation?: userPersonalisationUncheckedCreateNestedManyWithoutOrganizationInput
    ConnectedApps?: ConnectedAppsUncheckedCreateNestedManyWithoutOrganizationInput
    kpi?: kpiUncheckedCreateNestedManyWithoutOrganizationInput
    businessType?: businessTypeUncheckedCreateNestedManyWithoutOrganizationInput
    prefixSuffix?: prefixSuffixUncheckedCreateNestedManyWithoutOrganizationInput
    serialNumber?: serialNumberUncheckedCreateNestedManyWithoutOrganizationInput
    function?: FunctionsUncheckedCreateNestedManyWithoutOrganizationInput
    rolesTable?: rolesTableUncheckedCreateNestedManyWithoutOrganizationInput
    problem?: ProblemUncheckedCreateNestedManyWithoutOrganizationInput
    parts?: PartsUncheckedCreateNestedManyWithoutOrganizationInput
    Models?: ModelsUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutUnitOfMeasurementInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutUnitOfMeasurementInput, OrganizationUncheckedCreateWithoutUnitOfMeasurementInput>
  }

  export type LocationCreateWithoutUomInput = {
    id?: string
    locationName?: string | null
    locationType?: string | null
    locationId?: string | null
    description?: string | null
    status?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedBy?: string | null
    functionId?: LocationCreatefunctionIdInput | string[]
    deleted?: boolean | null
    users?: LocationCreateusersInput | InputJsonValue[]
    businessTypeId?: string | null
    type?: string | null
    organization?: OrganizationCreateNestedOneWithoutLocationInput
    Documents?: DocumentsCreateNestedManyWithoutCreatorLocationInput
    entity?: EntityCreateNestedManyWithoutLocationInput
    business?: LocationBusinessCreateNestedManyWithoutLocationInput
    user?: UserCreateNestedManyWithoutLocationInput
    rolesTable?: rolesTableCreateNestedManyWithoutLocationInput
    Role?: RoleCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateWithoutUomInput = {
    id?: string
    locationName?: string | null
    locationType?: string | null
    locationId?: string | null
    description?: string | null
    status?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedBy?: string | null
    functionId?: LocationCreatefunctionIdInput | string[]
    deleted?: boolean | null
    organizationId?: string | null
    users?: LocationCreateusersInput | InputJsonValue[]
    businessTypeId?: string | null
    type?: string | null
    Documents?: DocumentsUncheckedCreateNestedManyWithoutCreatorLocationInput
    entity?: EntityUncheckedCreateNestedManyWithoutLocationInput
    business?: LocationBusinessUncheckedCreateNestedManyWithoutLocationInput
    user?: UserUncheckedCreateNestedManyWithoutLocationInput
    rolesTable?: rolesTableUncheckedCreateNestedManyWithoutLocationInput
    Role?: RoleUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationCreateOrConnectWithoutUomInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutUomInput, LocationUncheckedCreateWithoutUomInput>
  }

  export type ConnectedAppsCreateWithoutUomInput = {
    id?: string
    sourceName: string
    clientId: string
    clientSecret: string
    baseURL: string
    user?: string | null
    password?: string | null
    redirectURL?: string | null
    grantType?: string | null
    description: string
    deleted?: boolean | null
    createdModifiedBy: string
    createdModifiedAt?: Date | string
    locationId?: ConnectedAppsCreatelocationIdInput | string[]
    Status: boolean
    organization?: OrganizationCreateNestedOneWithoutConnectedAppsInput
    kpi?: kpiCreateNestedManyWithoutConnectedAppsInput
  }

  export type ConnectedAppsUncheckedCreateWithoutUomInput = {
    id?: string
    sourceName: string
    clientId: string
    clientSecret: string
    baseURL: string
    user?: string | null
    password?: string | null
    redirectURL?: string | null
    grantType?: string | null
    description: string
    deleted?: boolean | null
    organizationId?: string | null
    createdModifiedBy: string
    createdModifiedAt?: Date | string
    locationId?: ConnectedAppsCreatelocationIdInput | string[]
    Status: boolean
    kpi?: kpiUncheckedCreateNestedManyWithoutConnectedAppsInput
  }

  export type ConnectedAppsCreateOrConnectWithoutUomInput = {
    where: ConnectedAppsWhereUniqueInput
    create: XOR<ConnectedAppsCreateWithoutUomInput, ConnectedAppsUncheckedCreateWithoutUomInput>
  }

  export type kpiUpsertWithWhereUniqueWithoutUnitTypeInput = {
    where: kpiWhereUniqueInput
    update: XOR<kpiUpdateWithoutUnitTypeInput, kpiUncheckedUpdateWithoutUnitTypeInput>
    create: XOR<kpiCreateWithoutUnitTypeInput, kpiUncheckedCreateWithoutUnitTypeInput>
  }

  export type kpiUpdateWithWhereUniqueWithoutUnitTypeInput = {
    where: kpiWhereUniqueInput
    data: XOR<kpiUpdateWithoutUnitTypeInput, kpiUncheckedUpdateWithoutUnitTypeInput>
  }

  export type kpiUpdateManyWithWhereWithoutUnitTypeInput = {
    where: kpiScalarWhereInput
    data: XOR<kpiUpdateManyMutationInput, kpiUncheckedUpdateManyWithoutUnitTypeInput>
  }

  export type OrganizationUpsertWithoutUnitOfMeasurementInput = {
    update: XOR<OrganizationUpdateWithoutUnitOfMeasurementInput, OrganizationUncheckedUpdateWithoutUnitOfMeasurementInput>
    create: XOR<OrganizationCreateWithoutUnitOfMeasurementInput, OrganizationUncheckedCreateWithoutUnitOfMeasurementInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutUnitOfMeasurementInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutUnitOfMeasurementInput, OrganizationUncheckedUpdateWithoutUnitOfMeasurementInput>
  }

  export type OrganizationUpdateWithoutUnitOfMeasurementInput = {
    kcId?: NullableStringFieldUpdateOperationsInput | string | null
    organizationName?: NullableStringFieldUpdateOperationsInput | string | null
    realmName?: NullableStringFieldUpdateOperationsInput | string | null
    instanceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    principalGeography?: NullableStringFieldUpdateOperationsInput | string | null
    loginUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoutUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    activeModules?: OrganizationUpdateactiveModulesInput | string[]
    clientID?: NullableStringFieldUpdateOperationsInput | string | null
    clientSecret?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearQuarters?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearFormat?: NullableStringFieldUpdateOperationsInput | string | null
    auditYear?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    business?: BusinessUpdateManyWithoutOrganizationNestedInput
    Doctype?: DoctypeUpdateManyWithoutOrganizationNestedInput
    Documents?: DocumentsUpdateManyWithoutOrganizationNestedInput
    entity?: EntityUpdateManyWithoutOrganizationNestedInput
    entityType?: EntityTypeUpdateManyWithoutOrganizationNestedInput
    location?: LocationUpdateManyWithoutOrganizationNestedInput
    role?: RoleUpdateManyWithoutOrganizationNestedInput
    section?: SectionUpdateManyWithoutOrganizationNestedInput
    systemType?: SystemTypeUpdateManyWithoutOrganizationNestedInput
    user?: UserUpdateManyWithoutOrganizationNestedInput
    userPersonalisation?: userPersonalisationUpdateManyWithoutOrganizationNestedInput
    ConnectedApps?: ConnectedAppsUpdateManyWithoutOrganizationNestedInput
    kpi?: kpiUpdateManyWithoutOrganizationNestedInput
    businessType?: businessTypeUpdateManyWithoutOrganizationNestedInput
    prefixSuffix?: prefixSuffixUpdateManyWithoutOrganizationNestedInput
    serialNumber?: serialNumberUpdateManyWithoutOrganizationNestedInput
    function?: FunctionsUpdateManyWithoutOrganizationNestedInput
    rolesTable?: rolesTableUpdateManyWithoutOrganizationNestedInput
    problem?: ProblemUpdateManyWithoutOrganizationNestedInput
    parts?: PartsUpdateManyWithoutOrganizationNestedInput
    Models?: ModelsUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutUnitOfMeasurementInput = {
    kcId?: NullableStringFieldUpdateOperationsInput | string | null
    organizationName?: NullableStringFieldUpdateOperationsInput | string | null
    realmName?: NullableStringFieldUpdateOperationsInput | string | null
    instanceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    principalGeography?: NullableStringFieldUpdateOperationsInput | string | null
    loginUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoutUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    activeModules?: OrganizationUpdateactiveModulesInput | string[]
    clientID?: NullableStringFieldUpdateOperationsInput | string | null
    clientSecret?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearQuarters?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearFormat?: NullableStringFieldUpdateOperationsInput | string | null
    auditYear?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    business?: BusinessUncheckedUpdateManyWithoutOrganizationNestedInput
    Doctype?: DoctypeUncheckedUpdateManyWithoutOrganizationNestedInput
    Documents?: DocumentsUncheckedUpdateManyWithoutOrganizationNestedInput
    entity?: EntityUncheckedUpdateManyWithoutOrganizationNestedInput
    entityType?: EntityTypeUncheckedUpdateManyWithoutOrganizationNestedInput
    location?: LocationUncheckedUpdateManyWithoutOrganizationNestedInput
    role?: RoleUncheckedUpdateManyWithoutOrganizationNestedInput
    section?: SectionUncheckedUpdateManyWithoutOrganizationNestedInput
    systemType?: SystemTypeUncheckedUpdateManyWithoutOrganizationNestedInput
    user?: UserUncheckedUpdateManyWithoutOrganizationNestedInput
    userPersonalisation?: userPersonalisationUncheckedUpdateManyWithoutOrganizationNestedInput
    ConnectedApps?: ConnectedAppsUncheckedUpdateManyWithoutOrganizationNestedInput
    kpi?: kpiUncheckedUpdateManyWithoutOrganizationNestedInput
    businessType?: businessTypeUncheckedUpdateManyWithoutOrganizationNestedInput
    prefixSuffix?: prefixSuffixUncheckedUpdateManyWithoutOrganizationNestedInput
    serialNumber?: serialNumberUncheckedUpdateManyWithoutOrganizationNestedInput
    function?: FunctionsUncheckedUpdateManyWithoutOrganizationNestedInput
    rolesTable?: rolesTableUncheckedUpdateManyWithoutOrganizationNestedInput
    problem?: ProblemUncheckedUpdateManyWithoutOrganizationNestedInput
    parts?: PartsUncheckedUpdateManyWithoutOrganizationNestedInput
    Models?: ModelsUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type LocationUpsertWithoutUomInput = {
    update: XOR<LocationUpdateWithoutUomInput, LocationUncheckedUpdateWithoutUomInput>
    create: XOR<LocationCreateWithoutUomInput, LocationUncheckedCreateWithoutUomInput>
    where?: LocationWhereInput
  }

  export type LocationUpdateToOneWithWhereWithoutUomInput = {
    where?: LocationWhereInput
    data: XOR<LocationUpdateWithoutUomInput, LocationUncheckedUpdateWithoutUomInput>
  }

  export type LocationUpdateWithoutUomInput = {
    locationName?: NullableStringFieldUpdateOperationsInput | string | null
    locationType?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    functionId?: LocationUpdatefunctionIdInput | string[]
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    users?: LocationUpdateusersInput | InputJsonValue[]
    businessTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: OrganizationUpdateOneWithoutLocationNestedInput
    Documents?: DocumentsUpdateManyWithoutCreatorLocationNestedInput
    entity?: EntityUpdateManyWithoutLocationNestedInput
    business?: LocationBusinessUpdateManyWithoutLocationNestedInput
    user?: UserUpdateManyWithoutLocationNestedInput
    rolesTable?: rolesTableUpdateManyWithoutLocationNestedInput
    Role?: RoleUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateWithoutUomInput = {
    locationName?: NullableStringFieldUpdateOperationsInput | string | null
    locationType?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    functionId?: LocationUpdatefunctionIdInput | string[]
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    users?: LocationUpdateusersInput | InputJsonValue[]
    businessTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    Documents?: DocumentsUncheckedUpdateManyWithoutCreatorLocationNestedInput
    entity?: EntityUncheckedUpdateManyWithoutLocationNestedInput
    business?: LocationBusinessUncheckedUpdateManyWithoutLocationNestedInput
    user?: UserUncheckedUpdateManyWithoutLocationNestedInput
    rolesTable?: rolesTableUncheckedUpdateManyWithoutLocationNestedInput
    Role?: RoleUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type ConnectedAppsUpsertWithoutUomInput = {
    update: XOR<ConnectedAppsUpdateWithoutUomInput, ConnectedAppsUncheckedUpdateWithoutUomInput>
    create: XOR<ConnectedAppsCreateWithoutUomInput, ConnectedAppsUncheckedCreateWithoutUomInput>
    where?: ConnectedAppsWhereInput
  }

  export type ConnectedAppsUpdateToOneWithWhereWithoutUomInput = {
    where?: ConnectedAppsWhereInput
    data: XOR<ConnectedAppsUpdateWithoutUomInput, ConnectedAppsUncheckedUpdateWithoutUomInput>
  }

  export type ConnectedAppsUpdateWithoutUomInput = {
    sourceName?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    clientSecret?: StringFieldUpdateOperationsInput | string
    baseURL?: StringFieldUpdateOperationsInput | string
    user?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    redirectURL?: NullableStringFieldUpdateOperationsInput | string | null
    grantType?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdModifiedBy?: StringFieldUpdateOperationsInput | string
    createdModifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locationId?: ConnectedAppsUpdatelocationIdInput | string[]
    Status?: BoolFieldUpdateOperationsInput | boolean
    organization?: OrganizationUpdateOneWithoutConnectedAppsNestedInput
    kpi?: kpiUpdateManyWithoutConnectedAppsNestedInput
  }

  export type ConnectedAppsUncheckedUpdateWithoutUomInput = {
    sourceName?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    clientSecret?: StringFieldUpdateOperationsInput | string
    baseURL?: StringFieldUpdateOperationsInput | string
    user?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    redirectURL?: NullableStringFieldUpdateOperationsInput | string | null
    grantType?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdModifiedBy?: StringFieldUpdateOperationsInput | string
    createdModifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locationId?: ConnectedAppsUpdatelocationIdInput | string[]
    Status?: BoolFieldUpdateOperationsInput | boolean
    kpi?: kpiUncheckedUpdateManyWithoutConnectedAppsNestedInput
  }

  export type unitTypeCreateWithoutKpiInput = {
    id?: string
    unitType: string
    unitOfMeasurement?: unitTypeCreateunitOfMeasurementInput | string[]
    deleted?: boolean | null
    createdModifiedBy: string
    createdModifiedAt?: Date | string
    organization?: OrganizationCreateNestedOneWithoutUnitOfMeasurementInput
    location?: LocationCreateNestedOneWithoutUomInput
    ConnectedApps?: ConnectedAppsCreateNestedOneWithoutUomInput
  }

  export type unitTypeUncheckedCreateWithoutKpiInput = {
    id?: string
    unitType: string
    unitOfMeasurement?: unitTypeCreateunitOfMeasurementInput | string[]
    organizationId?: string | null
    locationId?: string | null
    deleted?: boolean | null
    createdModifiedBy: string
    createdModifiedAt?: Date | string
    connectedAppsId?: string | null
  }

  export type unitTypeCreateOrConnectWithoutKpiInput = {
    where: unitTypeWhereUniqueInput
    create: XOR<unitTypeCreateWithoutKpiInput, unitTypeUncheckedCreateWithoutKpiInput>
  }

  export type ConnectedAppsCreateWithoutKpiInput = {
    id?: string
    sourceName: string
    clientId: string
    clientSecret: string
    baseURL: string
    user?: string | null
    password?: string | null
    redirectURL?: string | null
    grantType?: string | null
    description: string
    deleted?: boolean | null
    createdModifiedBy: string
    createdModifiedAt?: Date | string
    locationId?: ConnectedAppsCreatelocationIdInput | string[]
    Status: boolean
    organization?: OrganizationCreateNestedOneWithoutConnectedAppsInput
    uom?: unitTypeCreateNestedManyWithoutConnectedAppsInput
  }

  export type ConnectedAppsUncheckedCreateWithoutKpiInput = {
    id?: string
    sourceName: string
    clientId: string
    clientSecret: string
    baseURL: string
    user?: string | null
    password?: string | null
    redirectURL?: string | null
    grantType?: string | null
    description: string
    deleted?: boolean | null
    organizationId?: string | null
    createdModifiedBy: string
    createdModifiedAt?: Date | string
    locationId?: ConnectedAppsCreatelocationIdInput | string[]
    Status: boolean
    uom?: unitTypeUncheckedCreateNestedManyWithoutConnectedAppsInput
  }

  export type ConnectedAppsCreateOrConnectWithoutKpiInput = {
    where: ConnectedAppsWhereUniqueInput
    create: XOR<ConnectedAppsCreateWithoutKpiInput, ConnectedAppsUncheckedCreateWithoutKpiInput>
  }

  export type OrganizationCreateWithoutKpiInput = {
    id?: string
    kcId?: string | null
    organizationName?: string | null
    realmName?: string | null
    instanceUrl?: string | null
    principalGeography?: string | null
    loginUrl?: string | null
    logoutUrl?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    activeModules?: OrganizationCreateactiveModulesInput | string[]
    clientID?: string | null
    clientSecret?: string | null
    fiscalYearQuarters?: string | null
    fiscalYearFormat?: string | null
    auditYear?: string | null
    logoUrl?: string | null
    deleted?: boolean | null
    business?: BusinessCreateNestedManyWithoutOrganizationInput
    Doctype?: DoctypeCreateNestedManyWithoutOrganizationInput
    Documents?: DocumentsCreateNestedManyWithoutOrganizationInput
    entity?: EntityCreateNestedManyWithoutOrganizationInput
    entityType?: EntityTypeCreateNestedManyWithoutOrganizationInput
    location?: LocationCreateNestedManyWithoutOrganizationInput
    role?: RoleCreateNestedManyWithoutOrganizationInput
    section?: SectionCreateNestedManyWithoutOrganizationInput
    systemType?: SystemTypeCreateNestedManyWithoutOrganizationInput
    user?: UserCreateNestedManyWithoutOrganizationInput
    userPersonalisation?: userPersonalisationCreateNestedManyWithoutOrganizationInput
    ConnectedApps?: ConnectedAppsCreateNestedManyWithoutOrganizationInput
    unitOfMeasurement?: unitTypeCreateNestedManyWithoutOrganizationInput
    businessType?: businessTypeCreateNestedManyWithoutOrganizationInput
    prefixSuffix?: prefixSuffixCreateNestedManyWithoutOrganizationInput
    serialNumber?: serialNumberCreateNestedManyWithoutOrganizationInput
    function?: FunctionsCreateNestedManyWithoutOrganizationInput
    rolesTable?: rolesTableCreateNestedManyWithoutOrganizationInput
    problem?: ProblemCreateNestedManyWithoutOrganizationInput
    parts?: PartsCreateNestedManyWithoutOrganizationInput
    Models?: ModelsCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutKpiInput = {
    id?: string
    kcId?: string | null
    organizationName?: string | null
    realmName?: string | null
    instanceUrl?: string | null
    principalGeography?: string | null
    loginUrl?: string | null
    logoutUrl?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    activeModules?: OrganizationCreateactiveModulesInput | string[]
    clientID?: string | null
    clientSecret?: string | null
    fiscalYearQuarters?: string | null
    fiscalYearFormat?: string | null
    auditYear?: string | null
    logoUrl?: string | null
    deleted?: boolean | null
    business?: BusinessUncheckedCreateNestedManyWithoutOrganizationInput
    Doctype?: DoctypeUncheckedCreateNestedManyWithoutOrganizationInput
    Documents?: DocumentsUncheckedCreateNestedManyWithoutOrganizationInput
    entity?: EntityUncheckedCreateNestedManyWithoutOrganizationInput
    entityType?: EntityTypeUncheckedCreateNestedManyWithoutOrganizationInput
    location?: LocationUncheckedCreateNestedManyWithoutOrganizationInput
    role?: RoleUncheckedCreateNestedManyWithoutOrganizationInput
    section?: SectionUncheckedCreateNestedManyWithoutOrganizationInput
    systemType?: SystemTypeUncheckedCreateNestedManyWithoutOrganizationInput
    user?: UserUncheckedCreateNestedManyWithoutOrganizationInput
    userPersonalisation?: userPersonalisationUncheckedCreateNestedManyWithoutOrganizationInput
    ConnectedApps?: ConnectedAppsUncheckedCreateNestedManyWithoutOrganizationInput
    unitOfMeasurement?: unitTypeUncheckedCreateNestedManyWithoutOrganizationInput
    businessType?: businessTypeUncheckedCreateNestedManyWithoutOrganizationInput
    prefixSuffix?: prefixSuffixUncheckedCreateNestedManyWithoutOrganizationInput
    serialNumber?: serialNumberUncheckedCreateNestedManyWithoutOrganizationInput
    function?: FunctionsUncheckedCreateNestedManyWithoutOrganizationInput
    rolesTable?: rolesTableUncheckedCreateNestedManyWithoutOrganizationInput
    problem?: ProblemUncheckedCreateNestedManyWithoutOrganizationInput
    parts?: PartsUncheckedCreateNestedManyWithoutOrganizationInput
    Models?: ModelsUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutKpiInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutKpiInput, OrganizationUncheckedCreateWithoutKpiInput>
  }

  export type unitTypeUpsertWithoutKpiInput = {
    update: XOR<unitTypeUpdateWithoutKpiInput, unitTypeUncheckedUpdateWithoutKpiInput>
    create: XOR<unitTypeCreateWithoutKpiInput, unitTypeUncheckedCreateWithoutKpiInput>
    where?: unitTypeWhereInput
  }

  export type unitTypeUpdateToOneWithWhereWithoutKpiInput = {
    where?: unitTypeWhereInput
    data: XOR<unitTypeUpdateWithoutKpiInput, unitTypeUncheckedUpdateWithoutKpiInput>
  }

  export type unitTypeUpdateWithoutKpiInput = {
    unitType?: StringFieldUpdateOperationsInput | string
    unitOfMeasurement?: unitTypeUpdateunitOfMeasurementInput | string[]
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdModifiedBy?: StringFieldUpdateOperationsInput | string
    createdModifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneWithoutUnitOfMeasurementNestedInput
    location?: LocationUpdateOneWithoutUomNestedInput
    ConnectedApps?: ConnectedAppsUpdateOneWithoutUomNestedInput
  }

  export type unitTypeUncheckedUpdateWithoutKpiInput = {
    unitType?: StringFieldUpdateOperationsInput | string
    unitOfMeasurement?: unitTypeUpdateunitOfMeasurementInput | string[]
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdModifiedBy?: StringFieldUpdateOperationsInput | string
    createdModifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    connectedAppsId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ConnectedAppsUpsertWithoutKpiInput = {
    update: XOR<ConnectedAppsUpdateWithoutKpiInput, ConnectedAppsUncheckedUpdateWithoutKpiInput>
    create: XOR<ConnectedAppsCreateWithoutKpiInput, ConnectedAppsUncheckedCreateWithoutKpiInput>
    where?: ConnectedAppsWhereInput
  }

  export type ConnectedAppsUpdateToOneWithWhereWithoutKpiInput = {
    where?: ConnectedAppsWhereInput
    data: XOR<ConnectedAppsUpdateWithoutKpiInput, ConnectedAppsUncheckedUpdateWithoutKpiInput>
  }

  export type ConnectedAppsUpdateWithoutKpiInput = {
    sourceName?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    clientSecret?: StringFieldUpdateOperationsInput | string
    baseURL?: StringFieldUpdateOperationsInput | string
    user?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    redirectURL?: NullableStringFieldUpdateOperationsInput | string | null
    grantType?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdModifiedBy?: StringFieldUpdateOperationsInput | string
    createdModifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locationId?: ConnectedAppsUpdatelocationIdInput | string[]
    Status?: BoolFieldUpdateOperationsInput | boolean
    organization?: OrganizationUpdateOneWithoutConnectedAppsNestedInput
    uom?: unitTypeUpdateManyWithoutConnectedAppsNestedInput
  }

  export type ConnectedAppsUncheckedUpdateWithoutKpiInput = {
    sourceName?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    clientSecret?: StringFieldUpdateOperationsInput | string
    baseURL?: StringFieldUpdateOperationsInput | string
    user?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    redirectURL?: NullableStringFieldUpdateOperationsInput | string | null
    grantType?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdModifiedBy?: StringFieldUpdateOperationsInput | string
    createdModifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locationId?: ConnectedAppsUpdatelocationIdInput | string[]
    Status?: BoolFieldUpdateOperationsInput | boolean
    uom?: unitTypeUncheckedUpdateManyWithoutConnectedAppsNestedInput
  }

  export type OrganizationUpsertWithoutKpiInput = {
    update: XOR<OrganizationUpdateWithoutKpiInput, OrganizationUncheckedUpdateWithoutKpiInput>
    create: XOR<OrganizationCreateWithoutKpiInput, OrganizationUncheckedCreateWithoutKpiInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutKpiInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutKpiInput, OrganizationUncheckedUpdateWithoutKpiInput>
  }

  export type OrganizationUpdateWithoutKpiInput = {
    kcId?: NullableStringFieldUpdateOperationsInput | string | null
    organizationName?: NullableStringFieldUpdateOperationsInput | string | null
    realmName?: NullableStringFieldUpdateOperationsInput | string | null
    instanceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    principalGeography?: NullableStringFieldUpdateOperationsInput | string | null
    loginUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoutUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    activeModules?: OrganizationUpdateactiveModulesInput | string[]
    clientID?: NullableStringFieldUpdateOperationsInput | string | null
    clientSecret?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearQuarters?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearFormat?: NullableStringFieldUpdateOperationsInput | string | null
    auditYear?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    business?: BusinessUpdateManyWithoutOrganizationNestedInput
    Doctype?: DoctypeUpdateManyWithoutOrganizationNestedInput
    Documents?: DocumentsUpdateManyWithoutOrganizationNestedInput
    entity?: EntityUpdateManyWithoutOrganizationNestedInput
    entityType?: EntityTypeUpdateManyWithoutOrganizationNestedInput
    location?: LocationUpdateManyWithoutOrganizationNestedInput
    role?: RoleUpdateManyWithoutOrganizationNestedInput
    section?: SectionUpdateManyWithoutOrganizationNestedInput
    systemType?: SystemTypeUpdateManyWithoutOrganizationNestedInput
    user?: UserUpdateManyWithoutOrganizationNestedInput
    userPersonalisation?: userPersonalisationUpdateManyWithoutOrganizationNestedInput
    ConnectedApps?: ConnectedAppsUpdateManyWithoutOrganizationNestedInput
    unitOfMeasurement?: unitTypeUpdateManyWithoutOrganizationNestedInput
    businessType?: businessTypeUpdateManyWithoutOrganizationNestedInput
    prefixSuffix?: prefixSuffixUpdateManyWithoutOrganizationNestedInput
    serialNumber?: serialNumberUpdateManyWithoutOrganizationNestedInput
    function?: FunctionsUpdateManyWithoutOrganizationNestedInput
    rolesTable?: rolesTableUpdateManyWithoutOrganizationNestedInput
    problem?: ProblemUpdateManyWithoutOrganizationNestedInput
    parts?: PartsUpdateManyWithoutOrganizationNestedInput
    Models?: ModelsUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutKpiInput = {
    kcId?: NullableStringFieldUpdateOperationsInput | string | null
    organizationName?: NullableStringFieldUpdateOperationsInput | string | null
    realmName?: NullableStringFieldUpdateOperationsInput | string | null
    instanceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    principalGeography?: NullableStringFieldUpdateOperationsInput | string | null
    loginUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoutUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    activeModules?: OrganizationUpdateactiveModulesInput | string[]
    clientID?: NullableStringFieldUpdateOperationsInput | string | null
    clientSecret?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearQuarters?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearFormat?: NullableStringFieldUpdateOperationsInput | string | null
    auditYear?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    business?: BusinessUncheckedUpdateManyWithoutOrganizationNestedInput
    Doctype?: DoctypeUncheckedUpdateManyWithoutOrganizationNestedInput
    Documents?: DocumentsUncheckedUpdateManyWithoutOrganizationNestedInput
    entity?: EntityUncheckedUpdateManyWithoutOrganizationNestedInput
    entityType?: EntityTypeUncheckedUpdateManyWithoutOrganizationNestedInput
    location?: LocationUncheckedUpdateManyWithoutOrganizationNestedInput
    role?: RoleUncheckedUpdateManyWithoutOrganizationNestedInput
    section?: SectionUncheckedUpdateManyWithoutOrganizationNestedInput
    systemType?: SystemTypeUncheckedUpdateManyWithoutOrganizationNestedInput
    user?: UserUncheckedUpdateManyWithoutOrganizationNestedInput
    userPersonalisation?: userPersonalisationUncheckedUpdateManyWithoutOrganizationNestedInput
    ConnectedApps?: ConnectedAppsUncheckedUpdateManyWithoutOrganizationNestedInput
    unitOfMeasurement?: unitTypeUncheckedUpdateManyWithoutOrganizationNestedInput
    businessType?: businessTypeUncheckedUpdateManyWithoutOrganizationNestedInput
    prefixSuffix?: prefixSuffixUncheckedUpdateManyWithoutOrganizationNestedInput
    serialNumber?: serialNumberUncheckedUpdateManyWithoutOrganizationNestedInput
    function?: FunctionsUncheckedUpdateManyWithoutOrganizationNestedInput
    rolesTable?: rolesTableUncheckedUpdateManyWithoutOrganizationNestedInput
    problem?: ProblemUncheckedUpdateManyWithoutOrganizationNestedInput
    parts?: PartsUncheckedUpdateManyWithoutOrganizationNestedInput
    Models?: ModelsUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type UserCreateWithoutAuditTrialInput = {
    id?: string
    kcId?: string | null
    email?: string | null
    username?: string | null
    firstname?: string | null
    lastname?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    enabled?: boolean | null
    userType?: string | null
    status?: boolean | null
    avatar?: string | null
    deleted?: boolean | null
    roleId?: UserCreateroleIdInput | string[]
    functionId?: InputJsonValue | null
    additionalUnits?: UserCreateadditionalUnitsInput | string[]
    entity?: EntityCreateNestedOneWithoutUserInput
    location?: LocationCreateNestedOneWithoutUserInput
    organization?: OrganizationCreateNestedOneWithoutUserInput
    AdditionalDocumentAdmins?: AdditionalDocumentAdminsCreateNestedManyWithoutUserInput
    DocumentComments?: DocumentCommentsCreateNestedManyWithoutUserInput
    DocumentVersions?: DocumentVersionsCreateNestedManyWithoutUserInput
    DocumentWorkFlowHistory?: DocumentWorkFlowHistoryCreateNestedManyWithoutUserInput
    Logs?: LogsCreateNestedManyWithoutUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
    documentAdmins?: documentAdminsCreateNestedManyWithoutUserInput
    userPersonalisation?: userPersonalisationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAuditTrialInput = {
    id?: string
    kcId?: string | null
    email?: string | null
    username?: string | null
    firstname?: string | null
    lastname?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    enabled?: boolean | null
    organizationId?: string | null
    locationId?: string | null
    entityId?: string | null
    userType?: string | null
    status?: boolean | null
    avatar?: string | null
    deleted?: boolean | null
    roleId?: UserCreateroleIdInput | string[]
    functionId?: InputJsonValue | null
    additionalUnits?: UserCreateadditionalUnitsInput | string[]
    AdditionalDocumentAdmins?: AdditionalDocumentAdminsUncheckedCreateNestedManyWithoutUserInput
    DocumentComments?: DocumentCommentsUncheckedCreateNestedManyWithoutUserInput
    DocumentVersions?: DocumentVersionsUncheckedCreateNestedManyWithoutUserInput
    DocumentWorkFlowHistory?: DocumentWorkFlowHistoryUncheckedCreateNestedManyWithoutUserInput
    Logs?: LogsUncheckedCreateNestedManyWithoutUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    documentAdmins?: documentAdminsUncheckedCreateNestedManyWithoutUserInput
    userPersonalisation?: userPersonalisationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAuditTrialInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditTrialInput, UserUncheckedCreateWithoutAuditTrialInput>
  }

  export type UserUpsertWithoutAuditTrialInput = {
    update: XOR<UserUpdateWithoutAuditTrialInput, UserUncheckedUpdateWithoutAuditTrialInput>
    create: XOR<UserCreateWithoutAuditTrialInput, UserUncheckedCreateWithoutAuditTrialInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditTrialInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditTrialInput, UserUncheckedUpdateWithoutAuditTrialInput>
  }

  export type UserUpdateWithoutAuditTrialInput = {
    kcId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    userType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    roleId?: UserUpdateroleIdInput | string[]
    functionId?: InputJsonValue | InputJsonValue | null
    additionalUnits?: UserUpdateadditionalUnitsInput | string[]
    entity?: EntityUpdateOneWithoutUserNestedInput
    location?: LocationUpdateOneWithoutUserNestedInput
    organization?: OrganizationUpdateOneWithoutUserNestedInput
    AdditionalDocumentAdmins?: AdditionalDocumentAdminsUpdateManyWithoutUserNestedInput
    DocumentComments?: DocumentCommentsUpdateManyWithoutUserNestedInput
    DocumentVersions?: DocumentVersionsUpdateManyWithoutUserNestedInput
    DocumentWorkFlowHistory?: DocumentWorkFlowHistoryUpdateManyWithoutUserNestedInput
    Logs?: LogsUpdateManyWithoutUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
    documentAdmins?: documentAdminsUpdateManyWithoutUserNestedInput
    userPersonalisation?: userPersonalisationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditTrialInput = {
    kcId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    roleId?: UserUpdateroleIdInput | string[]
    functionId?: InputJsonValue | InputJsonValue | null
    additionalUnits?: UserUpdateadditionalUnitsInput | string[]
    AdditionalDocumentAdmins?: AdditionalDocumentAdminsUncheckedUpdateManyWithoutUserNestedInput
    DocumentComments?: DocumentCommentsUncheckedUpdateManyWithoutUserNestedInput
    DocumentVersions?: DocumentVersionsUncheckedUpdateManyWithoutUserNestedInput
    DocumentWorkFlowHistory?: DocumentWorkFlowHistoryUncheckedUpdateManyWithoutUserNestedInput
    Logs?: LogsUncheckedUpdateManyWithoutUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    documentAdmins?: documentAdminsUncheckedUpdateManyWithoutUserNestedInput
    userPersonalisation?: userPersonalisationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type OrganizationCreateWithoutPrefixSuffixInput = {
    id?: string
    kcId?: string | null
    organizationName?: string | null
    realmName?: string | null
    instanceUrl?: string | null
    principalGeography?: string | null
    loginUrl?: string | null
    logoutUrl?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    activeModules?: OrganizationCreateactiveModulesInput | string[]
    clientID?: string | null
    clientSecret?: string | null
    fiscalYearQuarters?: string | null
    fiscalYearFormat?: string | null
    auditYear?: string | null
    logoUrl?: string | null
    deleted?: boolean | null
    business?: BusinessCreateNestedManyWithoutOrganizationInput
    Doctype?: DoctypeCreateNestedManyWithoutOrganizationInput
    Documents?: DocumentsCreateNestedManyWithoutOrganizationInput
    entity?: EntityCreateNestedManyWithoutOrganizationInput
    entityType?: EntityTypeCreateNestedManyWithoutOrganizationInput
    location?: LocationCreateNestedManyWithoutOrganizationInput
    role?: RoleCreateNestedManyWithoutOrganizationInput
    section?: SectionCreateNestedManyWithoutOrganizationInput
    systemType?: SystemTypeCreateNestedManyWithoutOrganizationInput
    user?: UserCreateNestedManyWithoutOrganizationInput
    userPersonalisation?: userPersonalisationCreateNestedManyWithoutOrganizationInput
    ConnectedApps?: ConnectedAppsCreateNestedManyWithoutOrganizationInput
    unitOfMeasurement?: unitTypeCreateNestedManyWithoutOrganizationInput
    kpi?: kpiCreateNestedManyWithoutOrganizationInput
    businessType?: businessTypeCreateNestedManyWithoutOrganizationInput
    serialNumber?: serialNumberCreateNestedManyWithoutOrganizationInput
    function?: FunctionsCreateNestedManyWithoutOrganizationInput
    rolesTable?: rolesTableCreateNestedManyWithoutOrganizationInput
    problem?: ProblemCreateNestedManyWithoutOrganizationInput
    parts?: PartsCreateNestedManyWithoutOrganizationInput
    Models?: ModelsCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutPrefixSuffixInput = {
    id?: string
    kcId?: string | null
    organizationName?: string | null
    realmName?: string | null
    instanceUrl?: string | null
    principalGeography?: string | null
    loginUrl?: string | null
    logoutUrl?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    activeModules?: OrganizationCreateactiveModulesInput | string[]
    clientID?: string | null
    clientSecret?: string | null
    fiscalYearQuarters?: string | null
    fiscalYearFormat?: string | null
    auditYear?: string | null
    logoUrl?: string | null
    deleted?: boolean | null
    business?: BusinessUncheckedCreateNestedManyWithoutOrganizationInput
    Doctype?: DoctypeUncheckedCreateNestedManyWithoutOrganizationInput
    Documents?: DocumentsUncheckedCreateNestedManyWithoutOrganizationInput
    entity?: EntityUncheckedCreateNestedManyWithoutOrganizationInput
    entityType?: EntityTypeUncheckedCreateNestedManyWithoutOrganizationInput
    location?: LocationUncheckedCreateNestedManyWithoutOrganizationInput
    role?: RoleUncheckedCreateNestedManyWithoutOrganizationInput
    section?: SectionUncheckedCreateNestedManyWithoutOrganizationInput
    systemType?: SystemTypeUncheckedCreateNestedManyWithoutOrganizationInput
    user?: UserUncheckedCreateNestedManyWithoutOrganizationInput
    userPersonalisation?: userPersonalisationUncheckedCreateNestedManyWithoutOrganizationInput
    ConnectedApps?: ConnectedAppsUncheckedCreateNestedManyWithoutOrganizationInput
    unitOfMeasurement?: unitTypeUncheckedCreateNestedManyWithoutOrganizationInput
    kpi?: kpiUncheckedCreateNestedManyWithoutOrganizationInput
    businessType?: businessTypeUncheckedCreateNestedManyWithoutOrganizationInput
    serialNumber?: serialNumberUncheckedCreateNestedManyWithoutOrganizationInput
    function?: FunctionsUncheckedCreateNestedManyWithoutOrganizationInput
    rolesTable?: rolesTableUncheckedCreateNestedManyWithoutOrganizationInput
    problem?: ProblemUncheckedCreateNestedManyWithoutOrganizationInput
    parts?: PartsUncheckedCreateNestedManyWithoutOrganizationInput
    Models?: ModelsUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutPrefixSuffixInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutPrefixSuffixInput, OrganizationUncheckedCreateWithoutPrefixSuffixInput>
  }

  export type OrganizationUpsertWithoutPrefixSuffixInput = {
    update: XOR<OrganizationUpdateWithoutPrefixSuffixInput, OrganizationUncheckedUpdateWithoutPrefixSuffixInput>
    create: XOR<OrganizationCreateWithoutPrefixSuffixInput, OrganizationUncheckedCreateWithoutPrefixSuffixInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutPrefixSuffixInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutPrefixSuffixInput, OrganizationUncheckedUpdateWithoutPrefixSuffixInput>
  }

  export type OrganizationUpdateWithoutPrefixSuffixInput = {
    kcId?: NullableStringFieldUpdateOperationsInput | string | null
    organizationName?: NullableStringFieldUpdateOperationsInput | string | null
    realmName?: NullableStringFieldUpdateOperationsInput | string | null
    instanceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    principalGeography?: NullableStringFieldUpdateOperationsInput | string | null
    loginUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoutUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    activeModules?: OrganizationUpdateactiveModulesInput | string[]
    clientID?: NullableStringFieldUpdateOperationsInput | string | null
    clientSecret?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearQuarters?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearFormat?: NullableStringFieldUpdateOperationsInput | string | null
    auditYear?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    business?: BusinessUpdateManyWithoutOrganizationNestedInput
    Doctype?: DoctypeUpdateManyWithoutOrganizationNestedInput
    Documents?: DocumentsUpdateManyWithoutOrganizationNestedInput
    entity?: EntityUpdateManyWithoutOrganizationNestedInput
    entityType?: EntityTypeUpdateManyWithoutOrganizationNestedInput
    location?: LocationUpdateManyWithoutOrganizationNestedInput
    role?: RoleUpdateManyWithoutOrganizationNestedInput
    section?: SectionUpdateManyWithoutOrganizationNestedInput
    systemType?: SystemTypeUpdateManyWithoutOrganizationNestedInput
    user?: UserUpdateManyWithoutOrganizationNestedInput
    userPersonalisation?: userPersonalisationUpdateManyWithoutOrganizationNestedInput
    ConnectedApps?: ConnectedAppsUpdateManyWithoutOrganizationNestedInput
    unitOfMeasurement?: unitTypeUpdateManyWithoutOrganizationNestedInput
    kpi?: kpiUpdateManyWithoutOrganizationNestedInput
    businessType?: businessTypeUpdateManyWithoutOrganizationNestedInput
    serialNumber?: serialNumberUpdateManyWithoutOrganizationNestedInput
    function?: FunctionsUpdateManyWithoutOrganizationNestedInput
    rolesTable?: rolesTableUpdateManyWithoutOrganizationNestedInput
    problem?: ProblemUpdateManyWithoutOrganizationNestedInput
    parts?: PartsUpdateManyWithoutOrganizationNestedInput
    Models?: ModelsUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutPrefixSuffixInput = {
    kcId?: NullableStringFieldUpdateOperationsInput | string | null
    organizationName?: NullableStringFieldUpdateOperationsInput | string | null
    realmName?: NullableStringFieldUpdateOperationsInput | string | null
    instanceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    principalGeography?: NullableStringFieldUpdateOperationsInput | string | null
    loginUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoutUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    activeModules?: OrganizationUpdateactiveModulesInput | string[]
    clientID?: NullableStringFieldUpdateOperationsInput | string | null
    clientSecret?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearQuarters?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearFormat?: NullableStringFieldUpdateOperationsInput | string | null
    auditYear?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    business?: BusinessUncheckedUpdateManyWithoutOrganizationNestedInput
    Doctype?: DoctypeUncheckedUpdateManyWithoutOrganizationNestedInput
    Documents?: DocumentsUncheckedUpdateManyWithoutOrganizationNestedInput
    entity?: EntityUncheckedUpdateManyWithoutOrganizationNestedInput
    entityType?: EntityTypeUncheckedUpdateManyWithoutOrganizationNestedInput
    location?: LocationUncheckedUpdateManyWithoutOrganizationNestedInput
    role?: RoleUncheckedUpdateManyWithoutOrganizationNestedInput
    section?: SectionUncheckedUpdateManyWithoutOrganizationNestedInput
    systemType?: SystemTypeUncheckedUpdateManyWithoutOrganizationNestedInput
    user?: UserUncheckedUpdateManyWithoutOrganizationNestedInput
    userPersonalisation?: userPersonalisationUncheckedUpdateManyWithoutOrganizationNestedInput
    ConnectedApps?: ConnectedAppsUncheckedUpdateManyWithoutOrganizationNestedInput
    unitOfMeasurement?: unitTypeUncheckedUpdateManyWithoutOrganizationNestedInput
    kpi?: kpiUncheckedUpdateManyWithoutOrganizationNestedInput
    businessType?: businessTypeUncheckedUpdateManyWithoutOrganizationNestedInput
    serialNumber?: serialNumberUncheckedUpdateManyWithoutOrganizationNestedInput
    function?: FunctionsUncheckedUpdateManyWithoutOrganizationNestedInput
    rolesTable?: rolesTableUncheckedUpdateManyWithoutOrganizationNestedInput
    problem?: ProblemUncheckedUpdateManyWithoutOrganizationNestedInput
    parts?: PartsUncheckedUpdateManyWithoutOrganizationNestedInput
    Models?: ModelsUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationCreateWithoutSerialNumberInput = {
    id?: string
    kcId?: string | null
    organizationName?: string | null
    realmName?: string | null
    instanceUrl?: string | null
    principalGeography?: string | null
    loginUrl?: string | null
    logoutUrl?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    activeModules?: OrganizationCreateactiveModulesInput | string[]
    clientID?: string | null
    clientSecret?: string | null
    fiscalYearQuarters?: string | null
    fiscalYearFormat?: string | null
    auditYear?: string | null
    logoUrl?: string | null
    deleted?: boolean | null
    business?: BusinessCreateNestedManyWithoutOrganizationInput
    Doctype?: DoctypeCreateNestedManyWithoutOrganizationInput
    Documents?: DocumentsCreateNestedManyWithoutOrganizationInput
    entity?: EntityCreateNestedManyWithoutOrganizationInput
    entityType?: EntityTypeCreateNestedManyWithoutOrganizationInput
    location?: LocationCreateNestedManyWithoutOrganizationInput
    role?: RoleCreateNestedManyWithoutOrganizationInput
    section?: SectionCreateNestedManyWithoutOrganizationInput
    systemType?: SystemTypeCreateNestedManyWithoutOrganizationInput
    user?: UserCreateNestedManyWithoutOrganizationInput
    userPersonalisation?: userPersonalisationCreateNestedManyWithoutOrganizationInput
    ConnectedApps?: ConnectedAppsCreateNestedManyWithoutOrganizationInput
    unitOfMeasurement?: unitTypeCreateNestedManyWithoutOrganizationInput
    kpi?: kpiCreateNestedManyWithoutOrganizationInput
    businessType?: businessTypeCreateNestedManyWithoutOrganizationInput
    prefixSuffix?: prefixSuffixCreateNestedManyWithoutOrganizationInput
    function?: FunctionsCreateNestedManyWithoutOrganizationInput
    rolesTable?: rolesTableCreateNestedManyWithoutOrganizationInput
    problem?: ProblemCreateNestedManyWithoutOrganizationInput
    parts?: PartsCreateNestedManyWithoutOrganizationInput
    Models?: ModelsCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutSerialNumberInput = {
    id?: string
    kcId?: string | null
    organizationName?: string | null
    realmName?: string | null
    instanceUrl?: string | null
    principalGeography?: string | null
    loginUrl?: string | null
    logoutUrl?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    activeModules?: OrganizationCreateactiveModulesInput | string[]
    clientID?: string | null
    clientSecret?: string | null
    fiscalYearQuarters?: string | null
    fiscalYearFormat?: string | null
    auditYear?: string | null
    logoUrl?: string | null
    deleted?: boolean | null
    business?: BusinessUncheckedCreateNestedManyWithoutOrganizationInput
    Doctype?: DoctypeUncheckedCreateNestedManyWithoutOrganizationInput
    Documents?: DocumentsUncheckedCreateNestedManyWithoutOrganizationInput
    entity?: EntityUncheckedCreateNestedManyWithoutOrganizationInput
    entityType?: EntityTypeUncheckedCreateNestedManyWithoutOrganizationInput
    location?: LocationUncheckedCreateNestedManyWithoutOrganizationInput
    role?: RoleUncheckedCreateNestedManyWithoutOrganizationInput
    section?: SectionUncheckedCreateNestedManyWithoutOrganizationInput
    systemType?: SystemTypeUncheckedCreateNestedManyWithoutOrganizationInput
    user?: UserUncheckedCreateNestedManyWithoutOrganizationInput
    userPersonalisation?: userPersonalisationUncheckedCreateNestedManyWithoutOrganizationInput
    ConnectedApps?: ConnectedAppsUncheckedCreateNestedManyWithoutOrganizationInput
    unitOfMeasurement?: unitTypeUncheckedCreateNestedManyWithoutOrganizationInput
    kpi?: kpiUncheckedCreateNestedManyWithoutOrganizationInput
    businessType?: businessTypeUncheckedCreateNestedManyWithoutOrganizationInput
    prefixSuffix?: prefixSuffixUncheckedCreateNestedManyWithoutOrganizationInput
    function?: FunctionsUncheckedCreateNestedManyWithoutOrganizationInput
    rolesTable?: rolesTableUncheckedCreateNestedManyWithoutOrganizationInput
    problem?: ProblemUncheckedCreateNestedManyWithoutOrganizationInput
    parts?: PartsUncheckedCreateNestedManyWithoutOrganizationInput
    Models?: ModelsUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutSerialNumberInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutSerialNumberInput, OrganizationUncheckedCreateWithoutSerialNumberInput>
  }

  export type OrganizationUpsertWithoutSerialNumberInput = {
    update: XOR<OrganizationUpdateWithoutSerialNumberInput, OrganizationUncheckedUpdateWithoutSerialNumberInput>
    create: XOR<OrganizationCreateWithoutSerialNumberInput, OrganizationUncheckedCreateWithoutSerialNumberInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutSerialNumberInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutSerialNumberInput, OrganizationUncheckedUpdateWithoutSerialNumberInput>
  }

  export type OrganizationUpdateWithoutSerialNumberInput = {
    kcId?: NullableStringFieldUpdateOperationsInput | string | null
    organizationName?: NullableStringFieldUpdateOperationsInput | string | null
    realmName?: NullableStringFieldUpdateOperationsInput | string | null
    instanceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    principalGeography?: NullableStringFieldUpdateOperationsInput | string | null
    loginUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoutUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    activeModules?: OrganizationUpdateactiveModulesInput | string[]
    clientID?: NullableStringFieldUpdateOperationsInput | string | null
    clientSecret?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearQuarters?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearFormat?: NullableStringFieldUpdateOperationsInput | string | null
    auditYear?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    business?: BusinessUpdateManyWithoutOrganizationNestedInput
    Doctype?: DoctypeUpdateManyWithoutOrganizationNestedInput
    Documents?: DocumentsUpdateManyWithoutOrganizationNestedInput
    entity?: EntityUpdateManyWithoutOrganizationNestedInput
    entityType?: EntityTypeUpdateManyWithoutOrganizationNestedInput
    location?: LocationUpdateManyWithoutOrganizationNestedInput
    role?: RoleUpdateManyWithoutOrganizationNestedInput
    section?: SectionUpdateManyWithoutOrganizationNestedInput
    systemType?: SystemTypeUpdateManyWithoutOrganizationNestedInput
    user?: UserUpdateManyWithoutOrganizationNestedInput
    userPersonalisation?: userPersonalisationUpdateManyWithoutOrganizationNestedInput
    ConnectedApps?: ConnectedAppsUpdateManyWithoutOrganizationNestedInput
    unitOfMeasurement?: unitTypeUpdateManyWithoutOrganizationNestedInput
    kpi?: kpiUpdateManyWithoutOrganizationNestedInput
    businessType?: businessTypeUpdateManyWithoutOrganizationNestedInput
    prefixSuffix?: prefixSuffixUpdateManyWithoutOrganizationNestedInput
    function?: FunctionsUpdateManyWithoutOrganizationNestedInput
    rolesTable?: rolesTableUpdateManyWithoutOrganizationNestedInput
    problem?: ProblemUpdateManyWithoutOrganizationNestedInput
    parts?: PartsUpdateManyWithoutOrganizationNestedInput
    Models?: ModelsUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutSerialNumberInput = {
    kcId?: NullableStringFieldUpdateOperationsInput | string | null
    organizationName?: NullableStringFieldUpdateOperationsInput | string | null
    realmName?: NullableStringFieldUpdateOperationsInput | string | null
    instanceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    principalGeography?: NullableStringFieldUpdateOperationsInput | string | null
    loginUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoutUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    activeModules?: OrganizationUpdateactiveModulesInput | string[]
    clientID?: NullableStringFieldUpdateOperationsInput | string | null
    clientSecret?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearQuarters?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearFormat?: NullableStringFieldUpdateOperationsInput | string | null
    auditYear?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    business?: BusinessUncheckedUpdateManyWithoutOrganizationNestedInput
    Doctype?: DoctypeUncheckedUpdateManyWithoutOrganizationNestedInput
    Documents?: DocumentsUncheckedUpdateManyWithoutOrganizationNestedInput
    entity?: EntityUncheckedUpdateManyWithoutOrganizationNestedInput
    entityType?: EntityTypeUncheckedUpdateManyWithoutOrganizationNestedInput
    location?: LocationUncheckedUpdateManyWithoutOrganizationNestedInput
    role?: RoleUncheckedUpdateManyWithoutOrganizationNestedInput
    section?: SectionUncheckedUpdateManyWithoutOrganizationNestedInput
    systemType?: SystemTypeUncheckedUpdateManyWithoutOrganizationNestedInput
    user?: UserUncheckedUpdateManyWithoutOrganizationNestedInput
    userPersonalisation?: userPersonalisationUncheckedUpdateManyWithoutOrganizationNestedInput
    ConnectedApps?: ConnectedAppsUncheckedUpdateManyWithoutOrganizationNestedInput
    unitOfMeasurement?: unitTypeUncheckedUpdateManyWithoutOrganizationNestedInput
    kpi?: kpiUncheckedUpdateManyWithoutOrganizationNestedInput
    businessType?: businessTypeUncheckedUpdateManyWithoutOrganizationNestedInput
    prefixSuffix?: prefixSuffixUncheckedUpdateManyWithoutOrganizationNestedInput
    function?: FunctionsUncheckedUpdateManyWithoutOrganizationNestedInput
    rolesTable?: rolesTableUncheckedUpdateManyWithoutOrganizationNestedInput
    problem?: ProblemUncheckedUpdateManyWithoutOrganizationNestedInput
    parts?: PartsUncheckedUpdateManyWithoutOrganizationNestedInput
    Models?: ModelsUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationCreateWithoutRolesTableInput = {
    id?: string
    kcId?: string | null
    organizationName?: string | null
    realmName?: string | null
    instanceUrl?: string | null
    principalGeography?: string | null
    loginUrl?: string | null
    logoutUrl?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    activeModules?: OrganizationCreateactiveModulesInput | string[]
    clientID?: string | null
    clientSecret?: string | null
    fiscalYearQuarters?: string | null
    fiscalYearFormat?: string | null
    auditYear?: string | null
    logoUrl?: string | null
    deleted?: boolean | null
    business?: BusinessCreateNestedManyWithoutOrganizationInput
    Doctype?: DoctypeCreateNestedManyWithoutOrganizationInput
    Documents?: DocumentsCreateNestedManyWithoutOrganizationInput
    entity?: EntityCreateNestedManyWithoutOrganizationInput
    entityType?: EntityTypeCreateNestedManyWithoutOrganizationInput
    location?: LocationCreateNestedManyWithoutOrganizationInput
    role?: RoleCreateNestedManyWithoutOrganizationInput
    section?: SectionCreateNestedManyWithoutOrganizationInput
    systemType?: SystemTypeCreateNestedManyWithoutOrganizationInput
    user?: UserCreateNestedManyWithoutOrganizationInput
    userPersonalisation?: userPersonalisationCreateNestedManyWithoutOrganizationInput
    ConnectedApps?: ConnectedAppsCreateNestedManyWithoutOrganizationInput
    unitOfMeasurement?: unitTypeCreateNestedManyWithoutOrganizationInput
    kpi?: kpiCreateNestedManyWithoutOrganizationInput
    businessType?: businessTypeCreateNestedManyWithoutOrganizationInput
    prefixSuffix?: prefixSuffixCreateNestedManyWithoutOrganizationInput
    serialNumber?: serialNumberCreateNestedManyWithoutOrganizationInput
    function?: FunctionsCreateNestedManyWithoutOrganizationInput
    problem?: ProblemCreateNestedManyWithoutOrganizationInput
    parts?: PartsCreateNestedManyWithoutOrganizationInput
    Models?: ModelsCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutRolesTableInput = {
    id?: string
    kcId?: string | null
    organizationName?: string | null
    realmName?: string | null
    instanceUrl?: string | null
    principalGeography?: string | null
    loginUrl?: string | null
    logoutUrl?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    activeModules?: OrganizationCreateactiveModulesInput | string[]
    clientID?: string | null
    clientSecret?: string | null
    fiscalYearQuarters?: string | null
    fiscalYearFormat?: string | null
    auditYear?: string | null
    logoUrl?: string | null
    deleted?: boolean | null
    business?: BusinessUncheckedCreateNestedManyWithoutOrganizationInput
    Doctype?: DoctypeUncheckedCreateNestedManyWithoutOrganizationInput
    Documents?: DocumentsUncheckedCreateNestedManyWithoutOrganizationInput
    entity?: EntityUncheckedCreateNestedManyWithoutOrganizationInput
    entityType?: EntityTypeUncheckedCreateNestedManyWithoutOrganizationInput
    location?: LocationUncheckedCreateNestedManyWithoutOrganizationInput
    role?: RoleUncheckedCreateNestedManyWithoutOrganizationInput
    section?: SectionUncheckedCreateNestedManyWithoutOrganizationInput
    systemType?: SystemTypeUncheckedCreateNestedManyWithoutOrganizationInput
    user?: UserUncheckedCreateNestedManyWithoutOrganizationInput
    userPersonalisation?: userPersonalisationUncheckedCreateNestedManyWithoutOrganizationInput
    ConnectedApps?: ConnectedAppsUncheckedCreateNestedManyWithoutOrganizationInput
    unitOfMeasurement?: unitTypeUncheckedCreateNestedManyWithoutOrganizationInput
    kpi?: kpiUncheckedCreateNestedManyWithoutOrganizationInput
    businessType?: businessTypeUncheckedCreateNestedManyWithoutOrganizationInput
    prefixSuffix?: prefixSuffixUncheckedCreateNestedManyWithoutOrganizationInput
    serialNumber?: serialNumberUncheckedCreateNestedManyWithoutOrganizationInput
    function?: FunctionsUncheckedCreateNestedManyWithoutOrganizationInput
    problem?: ProblemUncheckedCreateNestedManyWithoutOrganizationInput
    parts?: PartsUncheckedCreateNestedManyWithoutOrganizationInput
    Models?: ModelsUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutRolesTableInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutRolesTableInput, OrganizationUncheckedCreateWithoutRolesTableInput>
  }

  export type LocationCreateWithoutRolesTableInput = {
    id?: string
    locationName?: string | null
    locationType?: string | null
    locationId?: string | null
    description?: string | null
    status?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedBy?: string | null
    functionId?: LocationCreatefunctionIdInput | string[]
    deleted?: boolean | null
    users?: LocationCreateusersInput | InputJsonValue[]
    businessTypeId?: string | null
    type?: string | null
    organization?: OrganizationCreateNestedOneWithoutLocationInput
    Documents?: DocumentsCreateNestedManyWithoutCreatorLocationInput
    entity?: EntityCreateNestedManyWithoutLocationInput
    business?: LocationBusinessCreateNestedManyWithoutLocationInput
    user?: UserCreateNestedManyWithoutLocationInput
    uom?: unitTypeCreateNestedManyWithoutLocationInput
    Role?: RoleCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateWithoutRolesTableInput = {
    id?: string
    locationName?: string | null
    locationType?: string | null
    locationId?: string | null
    description?: string | null
    status?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedBy?: string | null
    functionId?: LocationCreatefunctionIdInput | string[]
    deleted?: boolean | null
    organizationId?: string | null
    users?: LocationCreateusersInput | InputJsonValue[]
    businessTypeId?: string | null
    type?: string | null
    Documents?: DocumentsUncheckedCreateNestedManyWithoutCreatorLocationInput
    entity?: EntityUncheckedCreateNestedManyWithoutLocationInput
    business?: LocationBusinessUncheckedCreateNestedManyWithoutLocationInput
    user?: UserUncheckedCreateNestedManyWithoutLocationInput
    uom?: unitTypeUncheckedCreateNestedManyWithoutLocationInput
    Role?: RoleUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationCreateOrConnectWithoutRolesTableInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutRolesTableInput, LocationUncheckedCreateWithoutRolesTableInput>
  }

  export type OrganizationUpsertWithoutRolesTableInput = {
    update: XOR<OrganizationUpdateWithoutRolesTableInput, OrganizationUncheckedUpdateWithoutRolesTableInput>
    create: XOR<OrganizationCreateWithoutRolesTableInput, OrganizationUncheckedCreateWithoutRolesTableInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutRolesTableInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutRolesTableInput, OrganizationUncheckedUpdateWithoutRolesTableInput>
  }

  export type OrganizationUpdateWithoutRolesTableInput = {
    kcId?: NullableStringFieldUpdateOperationsInput | string | null
    organizationName?: NullableStringFieldUpdateOperationsInput | string | null
    realmName?: NullableStringFieldUpdateOperationsInput | string | null
    instanceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    principalGeography?: NullableStringFieldUpdateOperationsInput | string | null
    loginUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoutUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    activeModules?: OrganizationUpdateactiveModulesInput | string[]
    clientID?: NullableStringFieldUpdateOperationsInput | string | null
    clientSecret?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearQuarters?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearFormat?: NullableStringFieldUpdateOperationsInput | string | null
    auditYear?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    business?: BusinessUpdateManyWithoutOrganizationNestedInput
    Doctype?: DoctypeUpdateManyWithoutOrganizationNestedInput
    Documents?: DocumentsUpdateManyWithoutOrganizationNestedInput
    entity?: EntityUpdateManyWithoutOrganizationNestedInput
    entityType?: EntityTypeUpdateManyWithoutOrganizationNestedInput
    location?: LocationUpdateManyWithoutOrganizationNestedInput
    role?: RoleUpdateManyWithoutOrganizationNestedInput
    section?: SectionUpdateManyWithoutOrganizationNestedInput
    systemType?: SystemTypeUpdateManyWithoutOrganizationNestedInput
    user?: UserUpdateManyWithoutOrganizationNestedInput
    userPersonalisation?: userPersonalisationUpdateManyWithoutOrganizationNestedInput
    ConnectedApps?: ConnectedAppsUpdateManyWithoutOrganizationNestedInput
    unitOfMeasurement?: unitTypeUpdateManyWithoutOrganizationNestedInput
    kpi?: kpiUpdateManyWithoutOrganizationNestedInput
    businessType?: businessTypeUpdateManyWithoutOrganizationNestedInput
    prefixSuffix?: prefixSuffixUpdateManyWithoutOrganizationNestedInput
    serialNumber?: serialNumberUpdateManyWithoutOrganizationNestedInput
    function?: FunctionsUpdateManyWithoutOrganizationNestedInput
    problem?: ProblemUpdateManyWithoutOrganizationNestedInput
    parts?: PartsUpdateManyWithoutOrganizationNestedInput
    Models?: ModelsUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutRolesTableInput = {
    kcId?: NullableStringFieldUpdateOperationsInput | string | null
    organizationName?: NullableStringFieldUpdateOperationsInput | string | null
    realmName?: NullableStringFieldUpdateOperationsInput | string | null
    instanceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    principalGeography?: NullableStringFieldUpdateOperationsInput | string | null
    loginUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoutUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    activeModules?: OrganizationUpdateactiveModulesInput | string[]
    clientID?: NullableStringFieldUpdateOperationsInput | string | null
    clientSecret?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearQuarters?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearFormat?: NullableStringFieldUpdateOperationsInput | string | null
    auditYear?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    business?: BusinessUncheckedUpdateManyWithoutOrganizationNestedInput
    Doctype?: DoctypeUncheckedUpdateManyWithoutOrganizationNestedInput
    Documents?: DocumentsUncheckedUpdateManyWithoutOrganizationNestedInput
    entity?: EntityUncheckedUpdateManyWithoutOrganizationNestedInput
    entityType?: EntityTypeUncheckedUpdateManyWithoutOrganizationNestedInput
    location?: LocationUncheckedUpdateManyWithoutOrganizationNestedInput
    role?: RoleUncheckedUpdateManyWithoutOrganizationNestedInput
    section?: SectionUncheckedUpdateManyWithoutOrganizationNestedInput
    systemType?: SystemTypeUncheckedUpdateManyWithoutOrganizationNestedInput
    user?: UserUncheckedUpdateManyWithoutOrganizationNestedInput
    userPersonalisation?: userPersonalisationUncheckedUpdateManyWithoutOrganizationNestedInput
    ConnectedApps?: ConnectedAppsUncheckedUpdateManyWithoutOrganizationNestedInput
    unitOfMeasurement?: unitTypeUncheckedUpdateManyWithoutOrganizationNestedInput
    kpi?: kpiUncheckedUpdateManyWithoutOrganizationNestedInput
    businessType?: businessTypeUncheckedUpdateManyWithoutOrganizationNestedInput
    prefixSuffix?: prefixSuffixUncheckedUpdateManyWithoutOrganizationNestedInput
    serialNumber?: serialNumberUncheckedUpdateManyWithoutOrganizationNestedInput
    function?: FunctionsUncheckedUpdateManyWithoutOrganizationNestedInput
    problem?: ProblemUncheckedUpdateManyWithoutOrganizationNestedInput
    parts?: PartsUncheckedUpdateManyWithoutOrganizationNestedInput
    Models?: ModelsUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type LocationUpsertWithoutRolesTableInput = {
    update: XOR<LocationUpdateWithoutRolesTableInput, LocationUncheckedUpdateWithoutRolesTableInput>
    create: XOR<LocationCreateWithoutRolesTableInput, LocationUncheckedCreateWithoutRolesTableInput>
    where?: LocationWhereInput
  }

  export type LocationUpdateToOneWithWhereWithoutRolesTableInput = {
    where?: LocationWhereInput
    data: XOR<LocationUpdateWithoutRolesTableInput, LocationUncheckedUpdateWithoutRolesTableInput>
  }

  export type LocationUpdateWithoutRolesTableInput = {
    locationName?: NullableStringFieldUpdateOperationsInput | string | null
    locationType?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    functionId?: LocationUpdatefunctionIdInput | string[]
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    users?: LocationUpdateusersInput | InputJsonValue[]
    businessTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: OrganizationUpdateOneWithoutLocationNestedInput
    Documents?: DocumentsUpdateManyWithoutCreatorLocationNestedInput
    entity?: EntityUpdateManyWithoutLocationNestedInput
    business?: LocationBusinessUpdateManyWithoutLocationNestedInput
    user?: UserUpdateManyWithoutLocationNestedInput
    uom?: unitTypeUpdateManyWithoutLocationNestedInput
    Role?: RoleUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateWithoutRolesTableInput = {
    locationName?: NullableStringFieldUpdateOperationsInput | string | null
    locationType?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    functionId?: LocationUpdatefunctionIdInput | string[]
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    users?: LocationUpdateusersInput | InputJsonValue[]
    businessTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    Documents?: DocumentsUncheckedUpdateManyWithoutCreatorLocationNestedInput
    entity?: EntityUncheckedUpdateManyWithoutLocationNestedInput
    business?: LocationBusinessUncheckedUpdateManyWithoutLocationNestedInput
    user?: UserUncheckedUpdateManyWithoutLocationNestedInput
    uom?: unitTypeUncheckedUpdateManyWithoutLocationNestedInput
    Role?: RoleUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type AdditionalDocumentAdminsCreateManyUserInput = {
    id?: string
    type: string
    firstname: string
    lastname: string
    email: string
    documentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentCommentsCreateManyUserInput = {
    id?: string
    commentBy?: string | null
    commentText: string
    documentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentVersionsCreateManyUserInput = {
    id?: string
    versionName: string
    by?: string | null
    approvedDate?: Date | string | null
    versionLink: string
    documentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    documentName?: string | null
    documentNumbering?: string | null
    reasonOfCreation?: string | null
    effectiveDate?: Date | string | null
    description?: string | null
    issueNumber?: string | null
  }

  export type DocumentWorkFlowHistoryCreateManyUserInput = {
    id?: string
    actionName: string
    actionBy?: string | null
    documentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LogsCreateManyUserInput = {
    id?: string
    action: string
    resource: string
    type: string
    additionalDetails: InputJsonValue
  }

  export type NotificationCreateManyUserInput = {
    id?: string
    type?: string | null
    text: string
    content: string
    creator?: string | null
    date?: Date | string
    style?: string | null
    read?: boolean
  }

  export type documentAdminsCreateManyUserInput = {
    id?: string
    type: string
    firstname: string
    lastname: string
    email: string
    doctypeId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type userPersonalisationCreateManyUserInput = {
    id?: string
    organizationId?: string | null
    targetObject: string
    targetObjectId?: userPersonalisationCreatetargetObjectIdInput | string[]
  }

  export type auditTrialCreateManyUserInput = {
    id?: string
    moduleType?: string | null
    actionType?: string | null
    transactionId?: string | null
    actionDate?: Date | string | null
  }

  export type AdditionalDocumentAdminsUpdateWithoutUserInput = {
    type?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    document?: DocumentsUpdateOneWithoutAdditionalDocumentAdminsNestedInput
  }

  export type AdditionalDocumentAdminsUncheckedUpdateWithoutUserInput = {
    type?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdditionalDocumentAdminsUncheckedUpdateManyWithoutUserInput = {
    type?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentCommentsUpdateWithoutUserInput = {
    commentBy?: NullableStringFieldUpdateOperationsInput | string | null
    commentText?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    document?: DocumentsUpdateOneWithoutDocumentCommentsNestedInput
  }

  export type DocumentCommentsUncheckedUpdateWithoutUserInput = {
    commentBy?: NullableStringFieldUpdateOperationsInput | string | null
    commentText?: StringFieldUpdateOperationsInput | string
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentCommentsUncheckedUpdateManyWithoutUserInput = {
    commentBy?: NullableStringFieldUpdateOperationsInput | string | null
    commentText?: StringFieldUpdateOperationsInput | string
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentVersionsUpdateWithoutUserInput = {
    versionName?: StringFieldUpdateOperationsInput | string
    by?: NullableStringFieldUpdateOperationsInput | string | null
    approvedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    versionLink?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documentName?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumbering?: NullableStringFieldUpdateOperationsInput | string | null
    reasonOfCreation?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    issueNumber?: NullableStringFieldUpdateOperationsInput | string | null
    document?: DocumentsUpdateOneWithoutDocumentVersionsNestedInput
    ReferenceDocuments?: ReferenceDocumentsUpdateManyWithoutVersionsLinkedWithNestedInput
    VersionReferenceDocuments?: VersionReferenceDocumentsUpdateManyWithoutVersionsLinkedWithNestedInput
  }

  export type DocumentVersionsUncheckedUpdateWithoutUserInput = {
    versionName?: StringFieldUpdateOperationsInput | string
    by?: NullableStringFieldUpdateOperationsInput | string | null
    approvedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    versionLink?: StringFieldUpdateOperationsInput | string
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documentName?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumbering?: NullableStringFieldUpdateOperationsInput | string | null
    reasonOfCreation?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    issueNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ReferenceDocuments?: ReferenceDocumentsUncheckedUpdateManyWithoutVersionsLinkedWithNestedInput
    VersionReferenceDocuments?: VersionReferenceDocumentsUncheckedUpdateManyWithoutVersionsLinkedWithNestedInput
  }

  export type DocumentVersionsUncheckedUpdateManyWithoutUserInput = {
    versionName?: StringFieldUpdateOperationsInput | string
    by?: NullableStringFieldUpdateOperationsInput | string | null
    approvedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    versionLink?: StringFieldUpdateOperationsInput | string
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documentName?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumbering?: NullableStringFieldUpdateOperationsInput | string | null
    reasonOfCreation?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    issueNumber?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DocumentWorkFlowHistoryUpdateWithoutUserInput = {
    actionName?: StringFieldUpdateOperationsInput | string
    actionBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    document?: DocumentsUpdateOneWithoutDocumentWorkFlowHistoryNestedInput
  }

  export type DocumentWorkFlowHistoryUncheckedUpdateWithoutUserInput = {
    actionName?: StringFieldUpdateOperationsInput | string
    actionBy?: NullableStringFieldUpdateOperationsInput | string | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentWorkFlowHistoryUncheckedUpdateManyWithoutUserInput = {
    actionName?: StringFieldUpdateOperationsInput | string
    actionBy?: NullableStringFieldUpdateOperationsInput | string | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogsUpdateWithoutUserInput = {
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    additionalDetails?: InputJsonValue | InputJsonValue
  }

  export type LogsUncheckedUpdateWithoutUserInput = {
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    additionalDetails?: InputJsonValue | InputJsonValue
  }

  export type LogsUncheckedUpdateManyWithoutUserInput = {
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    additionalDetails?: InputJsonValue | InputJsonValue
  }

  export type NotificationUpdateWithoutUserInput = {
    type?: NullableStringFieldUpdateOperationsInput | string | null
    text?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    creator?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    style?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    type?: NullableStringFieldUpdateOperationsInput | string | null
    text?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    creator?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    style?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    type?: NullableStringFieldUpdateOperationsInput | string | null
    text?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    creator?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    style?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
  }

  export type documentAdminsUpdateWithoutUserInput = {
    type?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doctype?: DoctypeUpdateOneWithoutDocumentAdminsNestedInput
  }

  export type documentAdminsUncheckedUpdateWithoutUserInput = {
    type?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    doctypeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type documentAdminsUncheckedUpdateManyWithoutUserInput = {
    type?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    doctypeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type userPersonalisationUpdateWithoutUserInput = {
    targetObject?: StringFieldUpdateOperationsInput | string
    targetObjectId?: userPersonalisationUpdatetargetObjectIdInput | string[]
    Organization?: OrganizationUpdateOneWithoutUserPersonalisationNestedInput
  }

  export type userPersonalisationUncheckedUpdateWithoutUserInput = {
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    targetObject?: StringFieldUpdateOperationsInput | string
    targetObjectId?: userPersonalisationUpdatetargetObjectIdInput | string[]
  }

  export type userPersonalisationUncheckedUpdateManyWithoutUserInput = {
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    targetObject?: StringFieldUpdateOperationsInput | string
    targetObjectId?: userPersonalisationUpdatetargetObjectIdInput | string[]
  }

  export type auditTrialUpdateWithoutUserInput = {
    moduleType?: NullableStringFieldUpdateOperationsInput | string | null
    actionType?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    actionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type auditTrialUncheckedUpdateWithoutUserInput = {
    moduleType?: NullableStringFieldUpdateOperationsInput | string | null
    actionType?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    actionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type auditTrialUncheckedUpdateManyWithoutUserInput = {
    moduleType?: NullableStringFieldUpdateOperationsInput | string | null
    actionType?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    actionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ClaimCreateManyModelsInput = {
    id?: string
    partId?: string | null
    partRecieptDate: string
    vehicleType: string
    FrameNo: string
    prNo: string
    lineOffDate: string
    saleDate: string
    repairDate: string
    shipmentId?: string | null
    investigationId?: string | null
    settleMonth?: string | null
    kms: number
    problemId?: string | null
    mis: number
    claimNo: number
  }

  export type ClaimUpdateWithoutModelsInput = {
    partRecieptDate?: StringFieldUpdateOperationsInput | string
    vehicleType?: StringFieldUpdateOperationsInput | string
    FrameNo?: StringFieldUpdateOperationsInput | string
    prNo?: StringFieldUpdateOperationsInput | string
    lineOffDate?: StringFieldUpdateOperationsInput | string
    saleDate?: StringFieldUpdateOperationsInput | string
    repairDate?: StringFieldUpdateOperationsInput | string
    settleMonth?: NullableStringFieldUpdateOperationsInput | string | null
    kms?: IntFieldUpdateOperationsInput | number
    mis?: IntFieldUpdateOperationsInput | number
    claimNo?: IntFieldUpdateOperationsInput | number
    problem?: ProblemUpdateOneWithoutClaimNestedInput
    investigations?: InvestigationUpdateOneWithoutClaimsNestedInput
    parts?: PartsUpdateOneWithoutClaimsNestedInput
    shipments?: ShipmentUpdateOneWithoutClaimsNestedInput
    claimToEntity?: ClaimToEntityUpdateManyWithoutClaimNestedInput
  }

  export type ClaimUncheckedUpdateWithoutModelsInput = {
    partId?: NullableStringFieldUpdateOperationsInput | string | null
    partRecieptDate?: StringFieldUpdateOperationsInput | string
    vehicleType?: StringFieldUpdateOperationsInput | string
    FrameNo?: StringFieldUpdateOperationsInput | string
    prNo?: StringFieldUpdateOperationsInput | string
    lineOffDate?: StringFieldUpdateOperationsInput | string
    saleDate?: StringFieldUpdateOperationsInput | string
    repairDate?: StringFieldUpdateOperationsInput | string
    shipmentId?: NullableStringFieldUpdateOperationsInput | string | null
    investigationId?: NullableStringFieldUpdateOperationsInput | string | null
    settleMonth?: NullableStringFieldUpdateOperationsInput | string | null
    kms?: IntFieldUpdateOperationsInput | number
    problemId?: NullableStringFieldUpdateOperationsInput | string | null
    mis?: IntFieldUpdateOperationsInput | number
    claimNo?: IntFieldUpdateOperationsInput | number
    claimToEntity?: ClaimToEntityUncheckedUpdateManyWithoutClaimNestedInput
  }

  export type ClaimUncheckedUpdateManyWithoutModelsInput = {
    partId?: NullableStringFieldUpdateOperationsInput | string | null
    partRecieptDate?: StringFieldUpdateOperationsInput | string
    vehicleType?: StringFieldUpdateOperationsInput | string
    FrameNo?: StringFieldUpdateOperationsInput | string
    prNo?: StringFieldUpdateOperationsInput | string
    lineOffDate?: StringFieldUpdateOperationsInput | string
    saleDate?: StringFieldUpdateOperationsInput | string
    repairDate?: StringFieldUpdateOperationsInput | string
    shipmentId?: NullableStringFieldUpdateOperationsInput | string | null
    investigationId?: NullableStringFieldUpdateOperationsInput | string | null
    settleMonth?: NullableStringFieldUpdateOperationsInput | string | null
    kms?: IntFieldUpdateOperationsInput | number
    problemId?: NullableStringFieldUpdateOperationsInput | string | null
    mis?: IntFieldUpdateOperationsInput | number
    claimNo?: IntFieldUpdateOperationsInput | number
  }

  export type PartsUpdateWithoutModelsInput = {
    partNo?: StringFieldUpdateOperationsInput | string
    partName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    claimId?: PartsUpdateclaimIdInput | string[]
    claims?: ClaimUpdateManyWithoutPartsNestedInput
    entity?: EntityUpdateOneWithoutPartsNestedInput
    organization?: OrganizationUpdateOneWithoutPartsNestedInput
  }

  export type PartsUncheckedUpdateWithoutModelsInput = {
    partNo?: StringFieldUpdateOperationsInput | string
    partName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    claimId?: PartsUpdateclaimIdInput | string[]
    modelsId?: PartsUpdatemodelsIdInput | string[]
    claims?: ClaimUncheckedUpdateManyWithoutPartsNestedInput
  }

  export type PartsUncheckedUpdateManyWithoutModelsInput = {
    partNo?: StringFieldUpdateOperationsInput | string
    partName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    claimId?: PartsUpdateclaimIdInput | string[]
    modelsId?: PartsUpdatemodelsIdInput | string[]
  }

  export type ClaimCreateManyPartsInput = {
    id?: string
    modelId?: string | null
    partRecieptDate: string
    vehicleType: string
    FrameNo: string
    prNo: string
    lineOffDate: string
    saleDate: string
    repairDate: string
    shipmentId?: string | null
    investigationId?: string | null
    settleMonth?: string | null
    kms: number
    problemId?: string | null
    mis: number
    claimNo: number
  }

  export type ClaimUpdateWithoutPartsInput = {
    partRecieptDate?: StringFieldUpdateOperationsInput | string
    vehicleType?: StringFieldUpdateOperationsInput | string
    FrameNo?: StringFieldUpdateOperationsInput | string
    prNo?: StringFieldUpdateOperationsInput | string
    lineOffDate?: StringFieldUpdateOperationsInput | string
    saleDate?: StringFieldUpdateOperationsInput | string
    repairDate?: StringFieldUpdateOperationsInput | string
    settleMonth?: NullableStringFieldUpdateOperationsInput | string | null
    kms?: IntFieldUpdateOperationsInput | number
    mis?: IntFieldUpdateOperationsInput | number
    claimNo?: IntFieldUpdateOperationsInput | number
    problem?: ProblemUpdateOneWithoutClaimNestedInput
    investigations?: InvestigationUpdateOneWithoutClaimsNestedInput
    models?: ModelsUpdateOneWithoutClaimsNestedInput
    shipments?: ShipmentUpdateOneWithoutClaimsNestedInput
    claimToEntity?: ClaimToEntityUpdateManyWithoutClaimNestedInput
  }

  export type ClaimUncheckedUpdateWithoutPartsInput = {
    modelId?: NullableStringFieldUpdateOperationsInput | string | null
    partRecieptDate?: StringFieldUpdateOperationsInput | string
    vehicleType?: StringFieldUpdateOperationsInput | string
    FrameNo?: StringFieldUpdateOperationsInput | string
    prNo?: StringFieldUpdateOperationsInput | string
    lineOffDate?: StringFieldUpdateOperationsInput | string
    saleDate?: StringFieldUpdateOperationsInput | string
    repairDate?: StringFieldUpdateOperationsInput | string
    shipmentId?: NullableStringFieldUpdateOperationsInput | string | null
    investigationId?: NullableStringFieldUpdateOperationsInput | string | null
    settleMonth?: NullableStringFieldUpdateOperationsInput | string | null
    kms?: IntFieldUpdateOperationsInput | number
    problemId?: NullableStringFieldUpdateOperationsInput | string | null
    mis?: IntFieldUpdateOperationsInput | number
    claimNo?: IntFieldUpdateOperationsInput | number
    claimToEntity?: ClaimToEntityUncheckedUpdateManyWithoutClaimNestedInput
  }

  export type ClaimUncheckedUpdateManyWithoutPartsInput = {
    modelId?: NullableStringFieldUpdateOperationsInput | string | null
    partRecieptDate?: StringFieldUpdateOperationsInput | string
    vehicleType?: StringFieldUpdateOperationsInput | string
    FrameNo?: StringFieldUpdateOperationsInput | string
    prNo?: StringFieldUpdateOperationsInput | string
    lineOffDate?: StringFieldUpdateOperationsInput | string
    saleDate?: StringFieldUpdateOperationsInput | string
    repairDate?: StringFieldUpdateOperationsInput | string
    shipmentId?: NullableStringFieldUpdateOperationsInput | string | null
    investigationId?: NullableStringFieldUpdateOperationsInput | string | null
    settleMonth?: NullableStringFieldUpdateOperationsInput | string | null
    kms?: IntFieldUpdateOperationsInput | number
    problemId?: NullableStringFieldUpdateOperationsInput | string | null
    mis?: IntFieldUpdateOperationsInput | number
    claimNo?: IntFieldUpdateOperationsInput | number
  }

  export type ModelsUpdateWithoutPartsInput = {
    modelNo?: StringFieldUpdateOperationsInput | string
    modelName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    claimId?: ModelsUpdateclaimIdInput | string[]
    claims?: ClaimUpdateManyWithoutModelsNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutModelsNestedInput
  }

  export type ModelsUncheckedUpdateWithoutPartsInput = {
    modelNo?: StringFieldUpdateOperationsInput | string
    modelName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: StringFieldUpdateOperationsInput | string
    partsId?: ModelsUpdatepartsIdInput | string[]
    claimId?: ModelsUpdateclaimIdInput | string[]
    claims?: ClaimUncheckedUpdateManyWithoutModelsNestedInput
  }

  export type ModelsUncheckedUpdateManyWithoutPartsInput = {
    modelNo?: StringFieldUpdateOperationsInput | string
    modelName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: StringFieldUpdateOperationsInput | string
    partsId?: ModelsUpdatepartsIdInput | string[]
    claimId?: ModelsUpdateclaimIdInput | string[]
  }

  export type ClaimToEntityCreateManyClaimInput = {
    id?: string
    entityId: string
  }

  export type ClaimToEntityUpdateWithoutClaimInput = {
    entity?: EntityUpdateOneRequiredWithoutClaimToEntityNestedInput
  }

  export type ClaimToEntityUncheckedUpdateWithoutClaimInput = {
    entityId?: StringFieldUpdateOperationsInput | string
  }

  export type ClaimToEntityUncheckedUpdateManyWithoutClaimInput = {
    entityId?: StringFieldUpdateOperationsInput | string
  }

  export type InvestigationCreateManyProblemInput = {
    id?: string
    rootCause: string
    counterMeasure: string
    leadTime: string
    claimType: string
    implementDate: string
    attachment?: InvestigationCreateattachmentInput | InputJsonValue[]
    claimNo: number
  }

  export type ClaimCreateManyProblemInput = {
    id?: string
    partId?: string | null
    modelId?: string | null
    partRecieptDate: string
    vehicleType: string
    FrameNo: string
    prNo: string
    lineOffDate: string
    saleDate: string
    repairDate: string
    shipmentId?: string | null
    investigationId?: string | null
    settleMonth?: string | null
    kms: number
    mis: number
    claimNo: number
  }

  export type InvestigationUpdateWithoutProblemInput = {
    rootCause?: StringFieldUpdateOperationsInput | string
    counterMeasure?: StringFieldUpdateOperationsInput | string
    leadTime?: StringFieldUpdateOperationsInput | string
    claimType?: StringFieldUpdateOperationsInput | string
    implementDate?: StringFieldUpdateOperationsInput | string
    attachment?: InvestigationUpdateattachmentInput | InputJsonValue[]
    claimNo?: IntFieldUpdateOperationsInput | number
    claims?: ClaimUpdateManyWithoutInvestigationsNestedInput
  }

  export type InvestigationUncheckedUpdateWithoutProblemInput = {
    rootCause?: StringFieldUpdateOperationsInput | string
    counterMeasure?: StringFieldUpdateOperationsInput | string
    leadTime?: StringFieldUpdateOperationsInput | string
    claimType?: StringFieldUpdateOperationsInput | string
    implementDate?: StringFieldUpdateOperationsInput | string
    attachment?: InvestigationUpdateattachmentInput | InputJsonValue[]
    claimNo?: IntFieldUpdateOperationsInput | number
    claims?: ClaimUncheckedUpdateManyWithoutInvestigationsNestedInput
  }

  export type InvestigationUncheckedUpdateManyWithoutProblemInput = {
    rootCause?: StringFieldUpdateOperationsInput | string
    counterMeasure?: StringFieldUpdateOperationsInput | string
    leadTime?: StringFieldUpdateOperationsInput | string
    claimType?: StringFieldUpdateOperationsInput | string
    implementDate?: StringFieldUpdateOperationsInput | string
    attachment?: InvestigationUpdateattachmentInput | InputJsonValue[]
    claimNo?: IntFieldUpdateOperationsInput | number
  }

  export type ClaimUpdateWithoutProblemInput = {
    partRecieptDate?: StringFieldUpdateOperationsInput | string
    vehicleType?: StringFieldUpdateOperationsInput | string
    FrameNo?: StringFieldUpdateOperationsInput | string
    prNo?: StringFieldUpdateOperationsInput | string
    lineOffDate?: StringFieldUpdateOperationsInput | string
    saleDate?: StringFieldUpdateOperationsInput | string
    repairDate?: StringFieldUpdateOperationsInput | string
    settleMonth?: NullableStringFieldUpdateOperationsInput | string | null
    kms?: IntFieldUpdateOperationsInput | number
    mis?: IntFieldUpdateOperationsInput | number
    claimNo?: IntFieldUpdateOperationsInput | number
    investigations?: InvestigationUpdateOneWithoutClaimsNestedInput
    models?: ModelsUpdateOneWithoutClaimsNestedInput
    parts?: PartsUpdateOneWithoutClaimsNestedInput
    shipments?: ShipmentUpdateOneWithoutClaimsNestedInput
    claimToEntity?: ClaimToEntityUpdateManyWithoutClaimNestedInput
  }

  export type ClaimUncheckedUpdateWithoutProblemInput = {
    partId?: NullableStringFieldUpdateOperationsInput | string | null
    modelId?: NullableStringFieldUpdateOperationsInput | string | null
    partRecieptDate?: StringFieldUpdateOperationsInput | string
    vehicleType?: StringFieldUpdateOperationsInput | string
    FrameNo?: StringFieldUpdateOperationsInput | string
    prNo?: StringFieldUpdateOperationsInput | string
    lineOffDate?: StringFieldUpdateOperationsInput | string
    saleDate?: StringFieldUpdateOperationsInput | string
    repairDate?: StringFieldUpdateOperationsInput | string
    shipmentId?: NullableStringFieldUpdateOperationsInput | string | null
    investigationId?: NullableStringFieldUpdateOperationsInput | string | null
    settleMonth?: NullableStringFieldUpdateOperationsInput | string | null
    kms?: IntFieldUpdateOperationsInput | number
    mis?: IntFieldUpdateOperationsInput | number
    claimNo?: IntFieldUpdateOperationsInput | number
    claimToEntity?: ClaimToEntityUncheckedUpdateManyWithoutClaimNestedInput
  }

  export type ClaimUncheckedUpdateManyWithoutProblemInput = {
    partId?: NullableStringFieldUpdateOperationsInput | string | null
    modelId?: NullableStringFieldUpdateOperationsInput | string | null
    partRecieptDate?: StringFieldUpdateOperationsInput | string
    vehicleType?: StringFieldUpdateOperationsInput | string
    FrameNo?: StringFieldUpdateOperationsInput | string
    prNo?: StringFieldUpdateOperationsInput | string
    lineOffDate?: StringFieldUpdateOperationsInput | string
    saleDate?: StringFieldUpdateOperationsInput | string
    repairDate?: StringFieldUpdateOperationsInput | string
    shipmentId?: NullableStringFieldUpdateOperationsInput | string | null
    investigationId?: NullableStringFieldUpdateOperationsInput | string | null
    settleMonth?: NullableStringFieldUpdateOperationsInput | string | null
    kms?: IntFieldUpdateOperationsInput | number
    mis?: IntFieldUpdateOperationsInput | number
    claimNo?: IntFieldUpdateOperationsInput | number
  }

  export type ClaimCreateManyInvestigationsInput = {
    id?: string
    partId?: string | null
    modelId?: string | null
    partRecieptDate: string
    vehicleType: string
    FrameNo: string
    prNo: string
    lineOffDate: string
    saleDate: string
    repairDate: string
    shipmentId?: string | null
    settleMonth?: string | null
    kms: number
    problemId?: string | null
    mis: number
    claimNo: number
  }

  export type ClaimUpdateWithoutInvestigationsInput = {
    partRecieptDate?: StringFieldUpdateOperationsInput | string
    vehicleType?: StringFieldUpdateOperationsInput | string
    FrameNo?: StringFieldUpdateOperationsInput | string
    prNo?: StringFieldUpdateOperationsInput | string
    lineOffDate?: StringFieldUpdateOperationsInput | string
    saleDate?: StringFieldUpdateOperationsInput | string
    repairDate?: StringFieldUpdateOperationsInput | string
    settleMonth?: NullableStringFieldUpdateOperationsInput | string | null
    kms?: IntFieldUpdateOperationsInput | number
    mis?: IntFieldUpdateOperationsInput | number
    claimNo?: IntFieldUpdateOperationsInput | number
    problem?: ProblemUpdateOneWithoutClaimNestedInput
    models?: ModelsUpdateOneWithoutClaimsNestedInput
    parts?: PartsUpdateOneWithoutClaimsNestedInput
    shipments?: ShipmentUpdateOneWithoutClaimsNestedInput
    claimToEntity?: ClaimToEntityUpdateManyWithoutClaimNestedInput
  }

  export type ClaimUncheckedUpdateWithoutInvestigationsInput = {
    partId?: NullableStringFieldUpdateOperationsInput | string | null
    modelId?: NullableStringFieldUpdateOperationsInput | string | null
    partRecieptDate?: StringFieldUpdateOperationsInput | string
    vehicleType?: StringFieldUpdateOperationsInput | string
    FrameNo?: StringFieldUpdateOperationsInput | string
    prNo?: StringFieldUpdateOperationsInput | string
    lineOffDate?: StringFieldUpdateOperationsInput | string
    saleDate?: StringFieldUpdateOperationsInput | string
    repairDate?: StringFieldUpdateOperationsInput | string
    shipmentId?: NullableStringFieldUpdateOperationsInput | string | null
    settleMonth?: NullableStringFieldUpdateOperationsInput | string | null
    kms?: IntFieldUpdateOperationsInput | number
    problemId?: NullableStringFieldUpdateOperationsInput | string | null
    mis?: IntFieldUpdateOperationsInput | number
    claimNo?: IntFieldUpdateOperationsInput | number
    claimToEntity?: ClaimToEntityUncheckedUpdateManyWithoutClaimNestedInput
  }

  export type ClaimUncheckedUpdateManyWithoutInvestigationsInput = {
    partId?: NullableStringFieldUpdateOperationsInput | string | null
    modelId?: NullableStringFieldUpdateOperationsInput | string | null
    partRecieptDate?: StringFieldUpdateOperationsInput | string
    vehicleType?: StringFieldUpdateOperationsInput | string
    FrameNo?: StringFieldUpdateOperationsInput | string
    prNo?: StringFieldUpdateOperationsInput | string
    lineOffDate?: StringFieldUpdateOperationsInput | string
    saleDate?: StringFieldUpdateOperationsInput | string
    repairDate?: StringFieldUpdateOperationsInput | string
    shipmentId?: NullableStringFieldUpdateOperationsInput | string | null
    settleMonth?: NullableStringFieldUpdateOperationsInput | string | null
    kms?: IntFieldUpdateOperationsInput | number
    problemId?: NullableStringFieldUpdateOperationsInput | string | null
    mis?: IntFieldUpdateOperationsInput | number
    claimNo?: IntFieldUpdateOperationsInput | number
  }

  export type ClaimCreateManyShipmentsInput = {
    id?: string
    partId?: string | null
    modelId?: string | null
    partRecieptDate: string
    vehicleType: string
    FrameNo: string
    prNo: string
    lineOffDate: string
    saleDate: string
    repairDate: string
    investigationId?: string | null
    settleMonth?: string | null
    kms: number
    problemId?: string | null
    mis: number
    claimNo: number
  }

  export type ClaimUpdateWithoutShipmentsInput = {
    partRecieptDate?: StringFieldUpdateOperationsInput | string
    vehicleType?: StringFieldUpdateOperationsInput | string
    FrameNo?: StringFieldUpdateOperationsInput | string
    prNo?: StringFieldUpdateOperationsInput | string
    lineOffDate?: StringFieldUpdateOperationsInput | string
    saleDate?: StringFieldUpdateOperationsInput | string
    repairDate?: StringFieldUpdateOperationsInput | string
    settleMonth?: NullableStringFieldUpdateOperationsInput | string | null
    kms?: IntFieldUpdateOperationsInput | number
    mis?: IntFieldUpdateOperationsInput | number
    claimNo?: IntFieldUpdateOperationsInput | number
    problem?: ProblemUpdateOneWithoutClaimNestedInput
    investigations?: InvestigationUpdateOneWithoutClaimsNestedInput
    models?: ModelsUpdateOneWithoutClaimsNestedInput
    parts?: PartsUpdateOneWithoutClaimsNestedInput
    claimToEntity?: ClaimToEntityUpdateManyWithoutClaimNestedInput
  }

  export type ClaimUncheckedUpdateWithoutShipmentsInput = {
    partId?: NullableStringFieldUpdateOperationsInput | string | null
    modelId?: NullableStringFieldUpdateOperationsInput | string | null
    partRecieptDate?: StringFieldUpdateOperationsInput | string
    vehicleType?: StringFieldUpdateOperationsInput | string
    FrameNo?: StringFieldUpdateOperationsInput | string
    prNo?: StringFieldUpdateOperationsInput | string
    lineOffDate?: StringFieldUpdateOperationsInput | string
    saleDate?: StringFieldUpdateOperationsInput | string
    repairDate?: StringFieldUpdateOperationsInput | string
    investigationId?: NullableStringFieldUpdateOperationsInput | string | null
    settleMonth?: NullableStringFieldUpdateOperationsInput | string | null
    kms?: IntFieldUpdateOperationsInput | number
    problemId?: NullableStringFieldUpdateOperationsInput | string | null
    mis?: IntFieldUpdateOperationsInput | number
    claimNo?: IntFieldUpdateOperationsInput | number
    claimToEntity?: ClaimToEntityUncheckedUpdateManyWithoutClaimNestedInput
  }

  export type ClaimUncheckedUpdateManyWithoutShipmentsInput = {
    partId?: NullableStringFieldUpdateOperationsInput | string | null
    modelId?: NullableStringFieldUpdateOperationsInput | string | null
    partRecieptDate?: StringFieldUpdateOperationsInput | string
    vehicleType?: StringFieldUpdateOperationsInput | string
    FrameNo?: StringFieldUpdateOperationsInput | string
    prNo?: StringFieldUpdateOperationsInput | string
    lineOffDate?: StringFieldUpdateOperationsInput | string
    saleDate?: StringFieldUpdateOperationsInput | string
    repairDate?: StringFieldUpdateOperationsInput | string
    investigationId?: NullableStringFieldUpdateOperationsInput | string | null
    settleMonth?: NullableStringFieldUpdateOperationsInput | string | null
    kms?: IntFieldUpdateOperationsInput | number
    problemId?: NullableStringFieldUpdateOperationsInput | string | null
    mis?: IntFieldUpdateOperationsInput | number
    claimNo?: IntFieldUpdateOperationsInput | number
  }

  export type BusinessCreateManyOrganizationInput = {
    id?: string
    name?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    deleted?: boolean | null
  }

  export type DoctypeCreateManyOrganizationInput = {
    id?: string
    locationId?: DoctypeCreatelocationIdInput | string[]
    documentTypeName?: string | null
    documentNumbering?: string | null
    reviewFrequency?: number | null
    revisionRemind?: number | null
    prefix?: string | null
    suffix?: string | null
    readAccess?: string | null
    readAccessUsers?: DoctypeCreatereadAccessUsersInput | InputJsonValue[]
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedBy?: string | null
    createdBy?: string | null
    applicable_systems?: DoctypeCreateapplicable_systemsInput | InputJsonValue[]
    users?: DoctypeCreateusersInput | InputJsonValue[]
    document_classification?: string | null
    entityId?: string | null
    distributionUsers?: DoctypeCreatedistributionUsersInput | InputJsonValue[]
    currentVersion: string
    distributionList?: string | null
  }

  export type DocumentsCreateManyOrganizationInput = {
    id?: string
    doctypeId?: string | null
    documentName?: string | null
    documentNumbering?: string | null
    reasonOfCreation?: string | null
    effectiveDate?: Date | string | null
    nextRevisionDate?: Date | string | null
    currentVersion?: string | null
    documentLink?: string | null
    description?: string | null
    tags?: DocumentsCreatetagsInput | string[]
    documentState?: string | null
    locationId: string
    entityId?: string | null
    system?: DocumentsCreatesystemInput | string[]
    section?: string | null
    revertComment?: string | null
    docType?: string | null
    documentClassification?: string | null
    issueNumber?: string | null
    retireComment?: string | null
    revisionReminderFlag?: boolean | null
    isVersion?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedDate?: Date | string | null
    countNumber?: number | null
    createdBy?: string | null
    distributionList?: string | null
    documentId?: string | null
    reviewers?: DocumentsCreatereviewersInput | string[]
    approvers?: DocumentsCreateapproversInput | string[]
    creators?: DocumentsCreatecreatorsInput | string[]
    distributionUsers?: DocumentsCreatedistributionUsersInput | InputJsonValue[]
    readAccess?: string | null
    readAccessUsers?: DocumentsCreatereadAccessUsersInput | InputJsonValue[]
    versionInfo?: DocumentsCreateversionInfoInput | InputJsonValue[]
  }

  export type EntityCreateManyOrganizationInput = {
    id?: string
    entityName?: string | null
    description?: string | null
    entityTypeId?: string | null
    locationId?: string | null
    createdBy?: string | null
    entityId?: string | null
    deleted?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedBy?: string | null
    users?: EntityCreateusersInput | string[]
    sections?: EntityCreatesectionsInput | string[]
    functionId?: string | null
  }

  export type EntityTypeCreateManyOrganizationInput = {
    id?: string
    name?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    deleted?: boolean | null
  }

  export type LocationCreateManyOrganizationInput = {
    id?: string
    locationName?: string | null
    locationType?: string | null
    locationId?: string | null
    description?: string | null
    status?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedBy?: string | null
    functionId?: LocationCreatefunctionIdInput | string[]
    deleted?: boolean | null
    users?: LocationCreateusersInput | InputJsonValue[]
    businessTypeId?: string | null
    type?: string | null
  }

  export type RoleCreateManyOrganizationInput = {
    id?: string
    kcId?: string | null
    roleName?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    deleted?: boolean | null
    locationId?: string | null
  }

  export type SectionCreateManyOrganizationInput = {
    id?: string
    name?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    deleted?: boolean | null
  }

  export type SystemTypeCreateManyOrganizationInput = {
    id?: string
    name?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    color?: string | null
    updatedBy?: string | null
    deleted?: boolean | null
  }

  export type UserCreateManyOrganizationInput = {
    id?: string
    kcId?: string | null
    email?: string | null
    username?: string | null
    firstname?: string | null
    lastname?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    enabled?: boolean | null
    locationId?: string | null
    entityId?: string | null
    userType?: string | null
    status?: boolean | null
    avatar?: string | null
    deleted?: boolean | null
    roleId?: UserCreateroleIdInput | string[]
    functionId?: InputJsonValue | null
    additionalUnits?: UserCreateadditionalUnitsInput | string[]
  }

  export type userPersonalisationCreateManyOrganizationInput = {
    id?: string
    userId: string
    targetObject: string
    targetObjectId?: userPersonalisationCreatetargetObjectIdInput | string[]
  }

  export type ConnectedAppsCreateManyOrganizationInput = {
    id?: string
    sourceName: string
    clientId: string
    clientSecret: string
    baseURL: string
    user?: string | null
    password?: string | null
    redirectURL?: string | null
    grantType?: string | null
    description: string
    deleted?: boolean | null
    createdModifiedBy: string
    createdModifiedAt?: Date | string
    locationId?: ConnectedAppsCreatelocationIdInput | string[]
    Status: boolean
  }

  export type unitTypeCreateManyOrganizationInput = {
    id?: string
    unitType: string
    unitOfMeasurement?: unitTypeCreateunitOfMeasurementInput | string[]
    locationId?: string | null
    deleted?: boolean | null
    createdModifiedBy: string
    createdModifiedAt?: Date | string
    connectedAppsId?: string | null
  }

  export type kpiCreateManyOrganizationInput = {
    id?: string
    kpiName: string
    kpiType?: string | null
    keyFields?: kpiCreatekeyFieldsInput | string[]
    unitTypeId?: string | null
    uom: string
    sourceId?: string | null
    status: boolean
    apiEndPoint?: string | null
    kpiDescription?: string | null
    kpiTargetType?: boolean | null
    locationId?: kpiCreatelocationIdInput | string[]
    createdModifiedBy: string
    createdModifiedAt?: Date | string
  }

  export type businessTypeCreateManyOrganizationInput = {
    id?: string
    name?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    deleted?: boolean | null
  }

  export type prefixSuffixCreateManyOrganizationInput = {
    id?: string
    prefix?: string | null
    suffix?: string | null
    moduleType?: string | null
    location?: string | null
    createdBy?: string | null
    createdAt?: Date | string
  }

  export type serialNumberCreateManyOrganizationInput = {
    id?: string
    moduleType?: string | null
    location?: string | null
    entity?: string | null
    year?: string | null
    tid?: string | null
    serialNumber?: number
    createdBy?: string | null
    createdAt?: Date | string
  }

  export type FunctionsCreateManyOrganizationInput = {
    id?: string
    name?: string | null
    functionId?: string | null
    description?: string | null
    functionHead?: FunctionsCreatefunctionHeadInput | string[]
    functionSpoc?: FunctionsCreatefunctionSpocInput | string[]
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    deleted?: boolean | null
    type?: boolean
    locationId?: FunctionsCreatelocationIdInput | string[]
    businessId?: FunctionsCreatebusinessIdInput | string[]
    unitId?: string | null
  }

  export type rolesTableCreateManyOrganizationInput = {
    id?: string
    unitId: string
    users?: rolesTableCreateusersInput | string[]
    roleId?: rolesTableCreateroleIdInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProblemCreateManyOrganizationInput = {
    id?: string
    problem: string
    createdAt: string
  }

  export type PartsCreateManyOrganizationInput = {
    id?: string
    partNo: string
    partName: string
    description?: string | null
    entityId?: string | null
    claimId?: PartsCreateclaimIdInput | string[]
    modelsId?: PartsCreatemodelsIdInput | string[]
  }

  export type ModelsCreateManyOrganizationInput = {
    id?: string
    modelNo: string
    modelName: string
    description?: string | null
    partsId?: ModelsCreatepartsIdInput | string[]
    claimId?: ModelsCreateclaimIdInput | string[]
  }

  export type BusinessUpdateWithoutOrganizationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    location?: LocationBusinessUpdateManyWithoutBusinessNestedInput
  }

  export type BusinessUncheckedUpdateWithoutOrganizationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    location?: LocationBusinessUncheckedUpdateManyWithoutBusinessNestedInput
  }

  export type BusinessUncheckedUpdateManyWithoutOrganizationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type DoctypeUpdateWithoutOrganizationInput = {
    locationId?: DoctypeUpdatelocationIdInput | string[]
    documentTypeName?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumbering?: NullableStringFieldUpdateOperationsInput | string | null
    reviewFrequency?: NullableIntFieldUpdateOperationsInput | number | null
    revisionRemind?: NullableIntFieldUpdateOperationsInput | number | null
    prefix?: NullableStringFieldUpdateOperationsInput | string | null
    suffix?: NullableStringFieldUpdateOperationsInput | string | null
    readAccess?: NullableStringFieldUpdateOperationsInput | string | null
    readAccessUsers?: DoctypeUpdatereadAccessUsersInput | InputJsonValue[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    applicable_systems?: DoctypeUpdateapplicable_systemsInput | InputJsonValue[]
    users?: DoctypeUpdateusersInput | InputJsonValue[]
    document_classification?: NullableStringFieldUpdateOperationsInput | string | null
    distributionUsers?: DoctypeUpdatedistributionUsersInput | InputJsonValue[]
    currentVersion?: StringFieldUpdateOperationsInput | string
    distributionList?: NullableStringFieldUpdateOperationsInput | string | null
    Entity?: EntityUpdateOneWithoutDoctypeNestedInput
    Documents?: DocumentsUpdateManyWithoutDoctypeNestedInput
    documentAdmins?: documentAdminsUpdateManyWithoutDoctypeNestedInput
  }

  export type DoctypeUncheckedUpdateWithoutOrganizationInput = {
    locationId?: DoctypeUpdatelocationIdInput | string[]
    documentTypeName?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumbering?: NullableStringFieldUpdateOperationsInput | string | null
    reviewFrequency?: NullableIntFieldUpdateOperationsInput | number | null
    revisionRemind?: NullableIntFieldUpdateOperationsInput | number | null
    prefix?: NullableStringFieldUpdateOperationsInput | string | null
    suffix?: NullableStringFieldUpdateOperationsInput | string | null
    readAccess?: NullableStringFieldUpdateOperationsInput | string | null
    readAccessUsers?: DoctypeUpdatereadAccessUsersInput | InputJsonValue[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    applicable_systems?: DoctypeUpdateapplicable_systemsInput | InputJsonValue[]
    users?: DoctypeUpdateusersInput | InputJsonValue[]
    document_classification?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    distributionUsers?: DoctypeUpdatedistributionUsersInput | InputJsonValue[]
    currentVersion?: StringFieldUpdateOperationsInput | string
    distributionList?: NullableStringFieldUpdateOperationsInput | string | null
    Documents?: DocumentsUncheckedUpdateManyWithoutDoctypeNestedInput
    documentAdmins?: documentAdminsUncheckedUpdateManyWithoutDoctypeNestedInput
  }

  export type DoctypeUncheckedUpdateManyWithoutOrganizationInput = {
    locationId?: DoctypeUpdatelocationIdInput | string[]
    documentTypeName?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumbering?: NullableStringFieldUpdateOperationsInput | string | null
    reviewFrequency?: NullableIntFieldUpdateOperationsInput | number | null
    revisionRemind?: NullableIntFieldUpdateOperationsInput | number | null
    prefix?: NullableStringFieldUpdateOperationsInput | string | null
    suffix?: NullableStringFieldUpdateOperationsInput | string | null
    readAccess?: NullableStringFieldUpdateOperationsInput | string | null
    readAccessUsers?: DoctypeUpdatereadAccessUsersInput | InputJsonValue[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    applicable_systems?: DoctypeUpdateapplicable_systemsInput | InputJsonValue[]
    users?: DoctypeUpdateusersInput | InputJsonValue[]
    document_classification?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    distributionUsers?: DoctypeUpdatedistributionUsersInput | InputJsonValue[]
    currentVersion?: StringFieldUpdateOperationsInput | string
    distributionList?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DocumentsUpdateWithoutOrganizationInput = {
    documentName?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumbering?: NullableStringFieldUpdateOperationsInput | string | null
    reasonOfCreation?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextRevisionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentVersion?: NullableStringFieldUpdateOperationsInput | string | null
    documentLink?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: DocumentsUpdatetagsInput | string[]
    documentState?: NullableStringFieldUpdateOperationsInput | string | null
    system?: DocumentsUpdatesystemInput | string[]
    section?: NullableStringFieldUpdateOperationsInput | string | null
    revertComment?: NullableStringFieldUpdateOperationsInput | string | null
    docType?: NullableStringFieldUpdateOperationsInput | string | null
    documentClassification?: NullableStringFieldUpdateOperationsInput | string | null
    issueNumber?: NullableStringFieldUpdateOperationsInput | string | null
    retireComment?: NullableStringFieldUpdateOperationsInput | string | null
    revisionReminderFlag?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isVersion?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    countNumber?: NullableIntFieldUpdateOperationsInput | number | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    distributionList?: NullableStringFieldUpdateOperationsInput | string | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    reviewers?: DocumentsUpdatereviewersInput | string[]
    approvers?: DocumentsUpdateapproversInput | string[]
    creators?: DocumentsUpdatecreatorsInput | string[]
    distributionUsers?: DocumentsUpdatedistributionUsersInput | InputJsonValue[]
    readAccess?: NullableStringFieldUpdateOperationsInput | string | null
    readAccessUsers?: DocumentsUpdatereadAccessUsersInput | InputJsonValue[]
    versionInfo?: DocumentsUpdateversionInfoInput | InputJsonValue[]
    doctype?: DoctypeUpdateOneWithoutDocumentsNestedInput
    creatorLocation?: LocationUpdateOneWithoutDocumentsNestedInput
    creatorEntity?: EntityUpdateOneWithoutDocumentsNestedInput
    ReferenceDocuments?: ReferenceDocumentsUpdateManyWithoutDocumentNestedInput
    DocumentVersions?: DocumentVersionsUpdateManyWithoutDocumentNestedInput
    DocumentComments?: DocumentCommentsUpdateManyWithoutDocumentNestedInput
    DocumentWorkFlowHistory?: DocumentWorkFlowHistoryUpdateManyWithoutDocumentNestedInput
    AdditionalDocumentAdmins?: AdditionalDocumentAdminsUpdateManyWithoutDocumentNestedInput
    VersionReferenceDocuments?: VersionReferenceDocumentsUpdateManyWithoutDocumentsNestedInput
  }

  export type DocumentsUncheckedUpdateWithoutOrganizationInput = {
    doctypeId?: NullableStringFieldUpdateOperationsInput | string | null
    documentName?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumbering?: NullableStringFieldUpdateOperationsInput | string | null
    reasonOfCreation?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextRevisionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentVersion?: NullableStringFieldUpdateOperationsInput | string | null
    documentLink?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: DocumentsUpdatetagsInput | string[]
    documentState?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    system?: DocumentsUpdatesystemInput | string[]
    section?: NullableStringFieldUpdateOperationsInput | string | null
    revertComment?: NullableStringFieldUpdateOperationsInput | string | null
    docType?: NullableStringFieldUpdateOperationsInput | string | null
    documentClassification?: NullableStringFieldUpdateOperationsInput | string | null
    issueNumber?: NullableStringFieldUpdateOperationsInput | string | null
    retireComment?: NullableStringFieldUpdateOperationsInput | string | null
    revisionReminderFlag?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isVersion?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    countNumber?: NullableIntFieldUpdateOperationsInput | number | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    distributionList?: NullableStringFieldUpdateOperationsInput | string | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    reviewers?: DocumentsUpdatereviewersInput | string[]
    approvers?: DocumentsUpdateapproversInput | string[]
    creators?: DocumentsUpdatecreatorsInput | string[]
    distributionUsers?: DocumentsUpdatedistributionUsersInput | InputJsonValue[]
    readAccess?: NullableStringFieldUpdateOperationsInput | string | null
    readAccessUsers?: DocumentsUpdatereadAccessUsersInput | InputJsonValue[]
    versionInfo?: DocumentsUpdateversionInfoInput | InputJsonValue[]
    ReferenceDocuments?: ReferenceDocumentsUncheckedUpdateManyWithoutDocumentNestedInput
    DocumentVersions?: DocumentVersionsUncheckedUpdateManyWithoutDocumentNestedInput
    DocumentComments?: DocumentCommentsUncheckedUpdateManyWithoutDocumentNestedInput
    DocumentWorkFlowHistory?: DocumentWorkFlowHistoryUncheckedUpdateManyWithoutDocumentNestedInput
    AdditionalDocumentAdmins?: AdditionalDocumentAdminsUncheckedUpdateManyWithoutDocumentNestedInput
    VersionReferenceDocuments?: VersionReferenceDocumentsUncheckedUpdateManyWithoutDocumentsNestedInput
  }

  export type DocumentsUncheckedUpdateManyWithoutOrganizationInput = {
    doctypeId?: NullableStringFieldUpdateOperationsInput | string | null
    documentName?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumbering?: NullableStringFieldUpdateOperationsInput | string | null
    reasonOfCreation?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextRevisionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentVersion?: NullableStringFieldUpdateOperationsInput | string | null
    documentLink?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: DocumentsUpdatetagsInput | string[]
    documentState?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    system?: DocumentsUpdatesystemInput | string[]
    section?: NullableStringFieldUpdateOperationsInput | string | null
    revertComment?: NullableStringFieldUpdateOperationsInput | string | null
    docType?: NullableStringFieldUpdateOperationsInput | string | null
    documentClassification?: NullableStringFieldUpdateOperationsInput | string | null
    issueNumber?: NullableStringFieldUpdateOperationsInput | string | null
    retireComment?: NullableStringFieldUpdateOperationsInput | string | null
    revisionReminderFlag?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isVersion?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    countNumber?: NullableIntFieldUpdateOperationsInput | number | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    distributionList?: NullableStringFieldUpdateOperationsInput | string | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    reviewers?: DocumentsUpdatereviewersInput | string[]
    approvers?: DocumentsUpdateapproversInput | string[]
    creators?: DocumentsUpdatecreatorsInput | string[]
    distributionUsers?: DocumentsUpdatedistributionUsersInput | InputJsonValue[]
    readAccess?: NullableStringFieldUpdateOperationsInput | string | null
    readAccessUsers?: DocumentsUpdatereadAccessUsersInput | InputJsonValue[]
    versionInfo?: DocumentsUpdateversionInfoInput | InputJsonValue[]
  }

  export type EntityUpdateWithoutOrganizationInput = {
    entityName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    users?: EntityUpdateusersInput | string[]
    sections?: EntityUpdatesectionsInput | string[]
    entityType?: EntityTypeUpdateOneWithoutEntityNestedInput
    location?: LocationUpdateOneWithoutEntityNestedInput
    Doctype?: DoctypeUpdateManyWithoutEntityNestedInput
    Documents?: DocumentsUpdateManyWithoutCreatorEntityNestedInput
    user?: UserUpdateManyWithoutEntityNestedInput
    parts?: PartsUpdateManyWithoutEntityNestedInput
    claimToEntity?: ClaimToEntityUpdateManyWithoutEntityNestedInput
    function?: FunctionsUpdateOneWithoutEntityNestedInput
  }

  export type EntityUncheckedUpdateWithoutOrganizationInput = {
    entityName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    entityTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    users?: EntityUpdateusersInput | string[]
    sections?: EntityUpdatesectionsInput | string[]
    functionId?: NullableStringFieldUpdateOperationsInput | string | null
    Doctype?: DoctypeUncheckedUpdateManyWithoutEntityNestedInput
    Documents?: DocumentsUncheckedUpdateManyWithoutCreatorEntityNestedInput
    user?: UserUncheckedUpdateManyWithoutEntityNestedInput
    parts?: PartsUncheckedUpdateManyWithoutEntityNestedInput
    claimToEntity?: ClaimToEntityUncheckedUpdateManyWithoutEntityNestedInput
  }

  export type EntityUncheckedUpdateManyWithoutOrganizationInput = {
    entityName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    entityTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    users?: EntityUpdateusersInput | string[]
    sections?: EntityUpdatesectionsInput | string[]
    functionId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EntityTypeUpdateWithoutOrganizationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    entity?: EntityUpdateManyWithoutEntityTypeNestedInput
  }

  export type EntityTypeUncheckedUpdateWithoutOrganizationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    entity?: EntityUncheckedUpdateManyWithoutEntityTypeNestedInput
  }

  export type EntityTypeUncheckedUpdateManyWithoutOrganizationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type LocationUpdateWithoutOrganizationInput = {
    locationName?: NullableStringFieldUpdateOperationsInput | string | null
    locationType?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    functionId?: LocationUpdatefunctionIdInput | string[]
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    users?: LocationUpdateusersInput | InputJsonValue[]
    businessTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    Documents?: DocumentsUpdateManyWithoutCreatorLocationNestedInput
    entity?: EntityUpdateManyWithoutLocationNestedInput
    business?: LocationBusinessUpdateManyWithoutLocationNestedInput
    user?: UserUpdateManyWithoutLocationNestedInput
    uom?: unitTypeUpdateManyWithoutLocationNestedInput
    rolesTable?: rolesTableUpdateManyWithoutLocationNestedInput
    Role?: RoleUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateWithoutOrganizationInput = {
    locationName?: NullableStringFieldUpdateOperationsInput | string | null
    locationType?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    functionId?: LocationUpdatefunctionIdInput | string[]
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    users?: LocationUpdateusersInput | InputJsonValue[]
    businessTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    Documents?: DocumentsUncheckedUpdateManyWithoutCreatorLocationNestedInput
    entity?: EntityUncheckedUpdateManyWithoutLocationNestedInput
    business?: LocationBusinessUncheckedUpdateManyWithoutLocationNestedInput
    user?: UserUncheckedUpdateManyWithoutLocationNestedInput
    uom?: unitTypeUncheckedUpdateManyWithoutLocationNestedInput
    rolesTable?: rolesTableUncheckedUpdateManyWithoutLocationNestedInput
    Role?: RoleUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateManyWithoutOrganizationInput = {
    locationName?: NullableStringFieldUpdateOperationsInput | string | null
    locationType?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    functionId?: LocationUpdatefunctionIdInput | string[]
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    users?: LocationUpdateusersInput | InputJsonValue[]
    businessTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RoleUpdateWithoutOrganizationInput = {
    kcId?: NullableStringFieldUpdateOperationsInput | string | null
    roleName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Location?: LocationUpdateOneWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateWithoutOrganizationInput = {
    kcId?: NullableStringFieldUpdateOperationsInput | string | null
    roleName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RoleUncheckedUpdateManyWithoutOrganizationInput = {
    kcId?: NullableStringFieldUpdateOperationsInput | string | null
    roleName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SectionUpdateWithoutOrganizationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type SectionUncheckedUpdateWithoutOrganizationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type SectionUncheckedUpdateManyWithoutOrganizationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type SystemTypeUpdateWithoutOrganizationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type SystemTypeUncheckedUpdateWithoutOrganizationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type SystemTypeUncheckedUpdateManyWithoutOrganizationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type UserUpdateWithoutOrganizationInput = {
    kcId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    userType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    roleId?: UserUpdateroleIdInput | string[]
    functionId?: InputJsonValue | InputJsonValue | null
    additionalUnits?: UserUpdateadditionalUnitsInput | string[]
    entity?: EntityUpdateOneWithoutUserNestedInput
    location?: LocationUpdateOneWithoutUserNestedInput
    AdditionalDocumentAdmins?: AdditionalDocumentAdminsUpdateManyWithoutUserNestedInput
    DocumentComments?: DocumentCommentsUpdateManyWithoutUserNestedInput
    DocumentVersions?: DocumentVersionsUpdateManyWithoutUserNestedInput
    DocumentWorkFlowHistory?: DocumentWorkFlowHistoryUpdateManyWithoutUserNestedInput
    Logs?: LogsUpdateManyWithoutUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
    documentAdmins?: documentAdminsUpdateManyWithoutUserNestedInput
    userPersonalisation?: userPersonalisationUpdateManyWithoutUserNestedInput
    auditTrial?: auditTrialUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOrganizationInput = {
    kcId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    roleId?: UserUpdateroleIdInput | string[]
    functionId?: InputJsonValue | InputJsonValue | null
    additionalUnits?: UserUpdateadditionalUnitsInput | string[]
    AdditionalDocumentAdmins?: AdditionalDocumentAdminsUncheckedUpdateManyWithoutUserNestedInput
    DocumentComments?: DocumentCommentsUncheckedUpdateManyWithoutUserNestedInput
    DocumentVersions?: DocumentVersionsUncheckedUpdateManyWithoutUserNestedInput
    DocumentWorkFlowHistory?: DocumentWorkFlowHistoryUncheckedUpdateManyWithoutUserNestedInput
    Logs?: LogsUncheckedUpdateManyWithoutUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    documentAdmins?: documentAdminsUncheckedUpdateManyWithoutUserNestedInput
    userPersonalisation?: userPersonalisationUncheckedUpdateManyWithoutUserNestedInput
    auditTrial?: auditTrialUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutOrganizationInput = {
    kcId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    roleId?: UserUpdateroleIdInput | string[]
    functionId?: InputJsonValue | InputJsonValue | null
    additionalUnits?: UserUpdateadditionalUnitsInput | string[]
  }

  export type userPersonalisationUpdateWithoutOrganizationInput = {
    targetObject?: StringFieldUpdateOperationsInput | string
    targetObjectId?: userPersonalisationUpdatetargetObjectIdInput | string[]
    user?: UserUpdateOneRequiredWithoutUserPersonalisationNestedInput
  }

  export type userPersonalisationUncheckedUpdateWithoutOrganizationInput = {
    userId?: StringFieldUpdateOperationsInput | string
    targetObject?: StringFieldUpdateOperationsInput | string
    targetObjectId?: userPersonalisationUpdatetargetObjectIdInput | string[]
  }

  export type userPersonalisationUncheckedUpdateManyWithoutOrganizationInput = {
    userId?: StringFieldUpdateOperationsInput | string
    targetObject?: StringFieldUpdateOperationsInput | string
    targetObjectId?: userPersonalisationUpdatetargetObjectIdInput | string[]
  }

  export type ConnectedAppsUpdateWithoutOrganizationInput = {
    sourceName?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    clientSecret?: StringFieldUpdateOperationsInput | string
    baseURL?: StringFieldUpdateOperationsInput | string
    user?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    redirectURL?: NullableStringFieldUpdateOperationsInput | string | null
    grantType?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdModifiedBy?: StringFieldUpdateOperationsInput | string
    createdModifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locationId?: ConnectedAppsUpdatelocationIdInput | string[]
    Status?: BoolFieldUpdateOperationsInput | boolean
    uom?: unitTypeUpdateManyWithoutConnectedAppsNestedInput
    kpi?: kpiUpdateManyWithoutConnectedAppsNestedInput
  }

  export type ConnectedAppsUncheckedUpdateWithoutOrganizationInput = {
    sourceName?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    clientSecret?: StringFieldUpdateOperationsInput | string
    baseURL?: StringFieldUpdateOperationsInput | string
    user?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    redirectURL?: NullableStringFieldUpdateOperationsInput | string | null
    grantType?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdModifiedBy?: StringFieldUpdateOperationsInput | string
    createdModifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locationId?: ConnectedAppsUpdatelocationIdInput | string[]
    Status?: BoolFieldUpdateOperationsInput | boolean
    uom?: unitTypeUncheckedUpdateManyWithoutConnectedAppsNestedInput
    kpi?: kpiUncheckedUpdateManyWithoutConnectedAppsNestedInput
  }

  export type ConnectedAppsUncheckedUpdateManyWithoutOrganizationInput = {
    sourceName?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    clientSecret?: StringFieldUpdateOperationsInput | string
    baseURL?: StringFieldUpdateOperationsInput | string
    user?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    redirectURL?: NullableStringFieldUpdateOperationsInput | string | null
    grantType?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdModifiedBy?: StringFieldUpdateOperationsInput | string
    createdModifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locationId?: ConnectedAppsUpdatelocationIdInput | string[]
    Status?: BoolFieldUpdateOperationsInput | boolean
  }

  export type unitTypeUpdateWithoutOrganizationInput = {
    unitType?: StringFieldUpdateOperationsInput | string
    unitOfMeasurement?: unitTypeUpdateunitOfMeasurementInput | string[]
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdModifiedBy?: StringFieldUpdateOperationsInput | string
    createdModifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kpi?: kpiUpdateManyWithoutUnitTypeNestedInput
    location?: LocationUpdateOneWithoutUomNestedInput
    ConnectedApps?: ConnectedAppsUpdateOneWithoutUomNestedInput
  }

  export type unitTypeUncheckedUpdateWithoutOrganizationInput = {
    unitType?: StringFieldUpdateOperationsInput | string
    unitOfMeasurement?: unitTypeUpdateunitOfMeasurementInput | string[]
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdModifiedBy?: StringFieldUpdateOperationsInput | string
    createdModifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    connectedAppsId?: NullableStringFieldUpdateOperationsInput | string | null
    kpi?: kpiUncheckedUpdateManyWithoutUnitTypeNestedInput
  }

  export type unitTypeUncheckedUpdateManyWithoutOrganizationInput = {
    unitType?: StringFieldUpdateOperationsInput | string
    unitOfMeasurement?: unitTypeUpdateunitOfMeasurementInput | string[]
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdModifiedBy?: StringFieldUpdateOperationsInput | string
    createdModifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    connectedAppsId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type kpiUpdateWithoutOrganizationInput = {
    kpiName?: StringFieldUpdateOperationsInput | string
    kpiType?: NullableStringFieldUpdateOperationsInput | string | null
    keyFields?: kpiUpdatekeyFieldsInput | string[]
    uom?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    apiEndPoint?: NullableStringFieldUpdateOperationsInput | string | null
    kpiDescription?: NullableStringFieldUpdateOperationsInput | string | null
    kpiTargetType?: NullableBoolFieldUpdateOperationsInput | boolean | null
    locationId?: kpiUpdatelocationIdInput | string[]
    createdModifiedBy?: StringFieldUpdateOperationsInput | string
    createdModifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    unitType?: unitTypeUpdateOneWithoutKpiNestedInput
    ConnectedApps?: ConnectedAppsUpdateOneWithoutKpiNestedInput
  }

  export type kpiUncheckedUpdateWithoutOrganizationInput = {
    kpiName?: StringFieldUpdateOperationsInput | string
    kpiType?: NullableStringFieldUpdateOperationsInput | string | null
    keyFields?: kpiUpdatekeyFieldsInput | string[]
    unitTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    uom?: StringFieldUpdateOperationsInput | string
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    apiEndPoint?: NullableStringFieldUpdateOperationsInput | string | null
    kpiDescription?: NullableStringFieldUpdateOperationsInput | string | null
    kpiTargetType?: NullableBoolFieldUpdateOperationsInput | boolean | null
    locationId?: kpiUpdatelocationIdInput | string[]
    createdModifiedBy?: StringFieldUpdateOperationsInput | string
    createdModifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type kpiUncheckedUpdateManyWithoutOrganizationInput = {
    kpiName?: StringFieldUpdateOperationsInput | string
    kpiType?: NullableStringFieldUpdateOperationsInput | string | null
    keyFields?: kpiUpdatekeyFieldsInput | string[]
    unitTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    uom?: StringFieldUpdateOperationsInput | string
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    apiEndPoint?: NullableStringFieldUpdateOperationsInput | string | null
    kpiDescription?: NullableStringFieldUpdateOperationsInput | string | null
    kpiTargetType?: NullableBoolFieldUpdateOperationsInput | boolean | null
    locationId?: kpiUpdatelocationIdInput | string[]
    createdModifiedBy?: StringFieldUpdateOperationsInput | string
    createdModifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type businessTypeUpdateWithoutOrganizationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type businessTypeUncheckedUpdateWithoutOrganizationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type businessTypeUncheckedUpdateManyWithoutOrganizationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type prefixSuffixUpdateWithoutOrganizationInput = {
    prefix?: NullableStringFieldUpdateOperationsInput | string | null
    suffix?: NullableStringFieldUpdateOperationsInput | string | null
    moduleType?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type prefixSuffixUncheckedUpdateWithoutOrganizationInput = {
    prefix?: NullableStringFieldUpdateOperationsInput | string | null
    suffix?: NullableStringFieldUpdateOperationsInput | string | null
    moduleType?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type prefixSuffixUncheckedUpdateManyWithoutOrganizationInput = {
    prefix?: NullableStringFieldUpdateOperationsInput | string | null
    suffix?: NullableStringFieldUpdateOperationsInput | string | null
    moduleType?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type serialNumberUpdateWithoutOrganizationInput = {
    moduleType?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    entity?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    tid?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: IntFieldUpdateOperationsInput | number
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type serialNumberUncheckedUpdateWithoutOrganizationInput = {
    moduleType?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    entity?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    tid?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: IntFieldUpdateOperationsInput | number
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type serialNumberUncheckedUpdateManyWithoutOrganizationInput = {
    moduleType?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    entity?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    tid?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: IntFieldUpdateOperationsInput | number
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FunctionsUpdateWithoutOrganizationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    functionId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    functionHead?: FunctionsUpdatefunctionHeadInput | string[]
    functionSpoc?: FunctionsUpdatefunctionSpocInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    type?: BoolFieldUpdateOperationsInput | boolean
    locationId?: FunctionsUpdatelocationIdInput | string[]
    businessId?: FunctionsUpdatebusinessIdInput | string[]
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
    entity?: EntityUpdateManyWithoutFunctionNestedInput
  }

  export type FunctionsUncheckedUpdateWithoutOrganizationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    functionId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    functionHead?: FunctionsUpdatefunctionHeadInput | string[]
    functionSpoc?: FunctionsUpdatefunctionSpocInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    type?: BoolFieldUpdateOperationsInput | boolean
    locationId?: FunctionsUpdatelocationIdInput | string[]
    businessId?: FunctionsUpdatebusinessIdInput | string[]
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
    entity?: EntityUncheckedUpdateManyWithoutFunctionNestedInput
  }

  export type FunctionsUncheckedUpdateManyWithoutOrganizationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    functionId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    functionHead?: FunctionsUpdatefunctionHeadInput | string[]
    functionSpoc?: FunctionsUpdatefunctionSpocInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    type?: BoolFieldUpdateOperationsInput | boolean
    locationId?: FunctionsUpdatelocationIdInput | string[]
    businessId?: FunctionsUpdatebusinessIdInput | string[]
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type rolesTableUpdateWithoutOrganizationInput = {
    users?: rolesTableUpdateusersInput | string[]
    roleId?: rolesTableUpdateroleIdInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: LocationUpdateOneRequiredWithoutRolesTableNestedInput
  }

  export type rolesTableUncheckedUpdateWithoutOrganizationInput = {
    unitId?: StringFieldUpdateOperationsInput | string
    users?: rolesTableUpdateusersInput | string[]
    roleId?: rolesTableUpdateroleIdInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type rolesTableUncheckedUpdateManyWithoutOrganizationInput = {
    unitId?: StringFieldUpdateOperationsInput | string
    users?: rolesTableUpdateusersInput | string[]
    roleId?: rolesTableUpdateroleIdInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProblemUpdateWithoutOrganizationInput = {
    problem?: StringFieldUpdateOperationsInput | string
    createdAt?: StringFieldUpdateOperationsInput | string
    investigations?: InvestigationUpdateManyWithoutProblemNestedInput
    claim?: ClaimUpdateManyWithoutProblemNestedInput
  }

  export type ProblemUncheckedUpdateWithoutOrganizationInput = {
    problem?: StringFieldUpdateOperationsInput | string
    createdAt?: StringFieldUpdateOperationsInput | string
    investigations?: InvestigationUncheckedUpdateManyWithoutProblemNestedInput
    claim?: ClaimUncheckedUpdateManyWithoutProblemNestedInput
  }

  export type ProblemUncheckedUpdateManyWithoutOrganizationInput = {
    problem?: StringFieldUpdateOperationsInput | string
    createdAt?: StringFieldUpdateOperationsInput | string
  }

  export type PartsUpdateWithoutOrganizationInput = {
    partNo?: StringFieldUpdateOperationsInput | string
    partName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    claimId?: PartsUpdateclaimIdInput | string[]
    claims?: ClaimUpdateManyWithoutPartsNestedInput
    entity?: EntityUpdateOneWithoutPartsNestedInput
    models?: ModelsUpdateManyWithoutPartsNestedInput
  }

  export type PartsUncheckedUpdateWithoutOrganizationInput = {
    partNo?: StringFieldUpdateOperationsInput | string
    partName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    claimId?: PartsUpdateclaimIdInput | string[]
    modelsId?: PartsUpdatemodelsIdInput | string[]
    claims?: ClaimUncheckedUpdateManyWithoutPartsNestedInput
    models?: ModelsUncheckedUpdateManyWithoutPartsNestedInput
  }

  export type PartsUncheckedUpdateManyWithoutOrganizationInput = {
    partNo?: StringFieldUpdateOperationsInput | string
    partName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    claimId?: PartsUpdateclaimIdInput | string[]
    modelsId?: PartsUpdatemodelsIdInput | string[]
  }

  export type ModelsUpdateWithoutOrganizationInput = {
    modelNo?: StringFieldUpdateOperationsInput | string
    modelName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    claimId?: ModelsUpdateclaimIdInput | string[]
    claims?: ClaimUpdateManyWithoutModelsNestedInput
    Parts?: PartsUpdateManyWithoutModelsNestedInput
  }

  export type ModelsUncheckedUpdateWithoutOrganizationInput = {
    modelNo?: StringFieldUpdateOperationsInput | string
    modelName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    partsId?: ModelsUpdatepartsIdInput | string[]
    claimId?: ModelsUpdateclaimIdInput | string[]
    claims?: ClaimUncheckedUpdateManyWithoutModelsNestedInput
    Parts?: PartsUncheckedUpdateManyWithoutModelsNestedInput
  }

  export type ModelsUncheckedUpdateManyWithoutOrganizationInput = {
    modelNo?: StringFieldUpdateOperationsInput | string
    modelName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    partsId?: ModelsUpdatepartsIdInput | string[]
    claimId?: ModelsUpdateclaimIdInput | string[]
  }

  export type EntityCreateManyEntityTypeInput = {
    id?: string
    entityName?: string | null
    description?: string | null
    organizationId?: string | null
    locationId?: string | null
    createdBy?: string | null
    entityId?: string | null
    deleted?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedBy?: string | null
    users?: EntityCreateusersInput | string[]
    sections?: EntityCreatesectionsInput | string[]
    functionId?: string | null
  }

  export type EntityUpdateWithoutEntityTypeInput = {
    entityName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    users?: EntityUpdateusersInput | string[]
    sections?: EntityUpdatesectionsInput | string[]
    location?: LocationUpdateOneWithoutEntityNestedInput
    organization?: OrganizationUpdateOneWithoutEntityNestedInput
    Doctype?: DoctypeUpdateManyWithoutEntityNestedInput
    Documents?: DocumentsUpdateManyWithoutCreatorEntityNestedInput
    user?: UserUpdateManyWithoutEntityNestedInput
    parts?: PartsUpdateManyWithoutEntityNestedInput
    claimToEntity?: ClaimToEntityUpdateManyWithoutEntityNestedInput
    function?: FunctionsUpdateOneWithoutEntityNestedInput
  }

  export type EntityUncheckedUpdateWithoutEntityTypeInput = {
    entityName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    users?: EntityUpdateusersInput | string[]
    sections?: EntityUpdatesectionsInput | string[]
    functionId?: NullableStringFieldUpdateOperationsInput | string | null
    Doctype?: DoctypeUncheckedUpdateManyWithoutEntityNestedInput
    Documents?: DocumentsUncheckedUpdateManyWithoutCreatorEntityNestedInput
    user?: UserUncheckedUpdateManyWithoutEntityNestedInput
    parts?: PartsUncheckedUpdateManyWithoutEntityNestedInput
    claimToEntity?: ClaimToEntityUncheckedUpdateManyWithoutEntityNestedInput
  }

  export type EntityUncheckedUpdateManyWithoutEntityTypeInput = {
    entityName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    users?: EntityUpdateusersInput | string[]
    sections?: EntityUpdatesectionsInput | string[]
    functionId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LocationBusinessCreateManyBusinessInput = {
    id?: string
    locationId?: string | null
  }

  export type LocationBusinessUpdateWithoutBusinessInput = {
    location?: LocationUpdateOneWithoutBusinessNestedInput
  }

  export type LocationBusinessUncheckedUpdateWithoutBusinessInput = {
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LocationBusinessUncheckedUpdateManyWithoutBusinessInput = {
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EntityCreateManyFunctionInput = {
    id?: string
    entityName?: string | null
    description?: string | null
    entityTypeId?: string | null
    organizationId?: string | null
    locationId?: string | null
    createdBy?: string | null
    entityId?: string | null
    deleted?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedBy?: string | null
    users?: EntityCreateusersInput | string[]
    sections?: EntityCreatesectionsInput | string[]
  }

  export type EntityUpdateWithoutFunctionInput = {
    entityName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    users?: EntityUpdateusersInput | string[]
    sections?: EntityUpdatesectionsInput | string[]
    entityType?: EntityTypeUpdateOneWithoutEntityNestedInput
    location?: LocationUpdateOneWithoutEntityNestedInput
    organization?: OrganizationUpdateOneWithoutEntityNestedInput
    Doctype?: DoctypeUpdateManyWithoutEntityNestedInput
    Documents?: DocumentsUpdateManyWithoutCreatorEntityNestedInput
    user?: UserUpdateManyWithoutEntityNestedInput
    parts?: PartsUpdateManyWithoutEntityNestedInput
    claimToEntity?: ClaimToEntityUpdateManyWithoutEntityNestedInput
  }

  export type EntityUncheckedUpdateWithoutFunctionInput = {
    entityName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    entityTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    users?: EntityUpdateusersInput | string[]
    sections?: EntityUpdatesectionsInput | string[]
    Doctype?: DoctypeUncheckedUpdateManyWithoutEntityNestedInput
    Documents?: DocumentsUncheckedUpdateManyWithoutCreatorEntityNestedInput
    user?: UserUncheckedUpdateManyWithoutEntityNestedInput
    parts?: PartsUncheckedUpdateManyWithoutEntityNestedInput
    claimToEntity?: ClaimToEntityUncheckedUpdateManyWithoutEntityNestedInput
  }

  export type EntityUncheckedUpdateManyWithoutFunctionInput = {
    entityName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    entityTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    users?: EntityUpdateusersInput | string[]
    sections?: EntityUpdatesectionsInput | string[]
  }

  export type DocumentsCreateManyCreatorLocationInput = {
    id?: string
    doctypeId?: string | null
    organizationId?: string | null
    documentName?: string | null
    documentNumbering?: string | null
    reasonOfCreation?: string | null
    effectiveDate?: Date | string | null
    nextRevisionDate?: Date | string | null
    currentVersion?: string | null
    documentLink?: string | null
    description?: string | null
    tags?: DocumentsCreatetagsInput | string[]
    documentState?: string | null
    entityId?: string | null
    system?: DocumentsCreatesystemInput | string[]
    section?: string | null
    revertComment?: string | null
    docType?: string | null
    documentClassification?: string | null
    issueNumber?: string | null
    retireComment?: string | null
    revisionReminderFlag?: boolean | null
    isVersion?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedDate?: Date | string | null
    countNumber?: number | null
    createdBy?: string | null
    distributionList?: string | null
    documentId?: string | null
    reviewers?: DocumentsCreatereviewersInput | string[]
    approvers?: DocumentsCreateapproversInput | string[]
    creators?: DocumentsCreatecreatorsInput | string[]
    distributionUsers?: DocumentsCreatedistributionUsersInput | InputJsonValue[]
    readAccess?: string | null
    readAccessUsers?: DocumentsCreatereadAccessUsersInput | InputJsonValue[]
    versionInfo?: DocumentsCreateversionInfoInput | InputJsonValue[]
  }

  export type EntityCreateManyLocationInput = {
    id?: string
    entityName?: string | null
    description?: string | null
    entityTypeId?: string | null
    organizationId?: string | null
    createdBy?: string | null
    entityId?: string | null
    deleted?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedBy?: string | null
    users?: EntityCreateusersInput | string[]
    sections?: EntityCreatesectionsInput | string[]
    functionId?: string | null
  }

  export type LocationBusinessCreateManyLocationInput = {
    id?: string
    businessId?: string | null
  }

  export type UserCreateManyLocationInput = {
    id?: string
    kcId?: string | null
    email?: string | null
    username?: string | null
    firstname?: string | null
    lastname?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    enabled?: boolean | null
    organizationId?: string | null
    entityId?: string | null
    userType?: string | null
    status?: boolean | null
    avatar?: string | null
    deleted?: boolean | null
    roleId?: UserCreateroleIdInput | string[]
    functionId?: InputJsonValue | null
    additionalUnits?: UserCreateadditionalUnitsInput | string[]
  }

  export type unitTypeCreateManyLocationInput = {
    id?: string
    unitType: string
    unitOfMeasurement?: unitTypeCreateunitOfMeasurementInput | string[]
    organizationId?: string | null
    deleted?: boolean | null
    createdModifiedBy: string
    createdModifiedAt?: Date | string
    connectedAppsId?: string | null
  }

  export type rolesTableCreateManyLocationInput = {
    id?: string
    orgId: string
    users?: rolesTableCreateusersInput | string[]
    roleId?: rolesTableCreateroleIdInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoleCreateManyLocationInput = {
    id?: string
    kcId?: string | null
    roleName?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    deleted?: boolean | null
    organizationId?: string | null
  }

  export type DocumentsUpdateWithoutCreatorLocationInput = {
    documentName?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumbering?: NullableStringFieldUpdateOperationsInput | string | null
    reasonOfCreation?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextRevisionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentVersion?: NullableStringFieldUpdateOperationsInput | string | null
    documentLink?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: DocumentsUpdatetagsInput | string[]
    documentState?: NullableStringFieldUpdateOperationsInput | string | null
    system?: DocumentsUpdatesystemInput | string[]
    section?: NullableStringFieldUpdateOperationsInput | string | null
    revertComment?: NullableStringFieldUpdateOperationsInput | string | null
    docType?: NullableStringFieldUpdateOperationsInput | string | null
    documentClassification?: NullableStringFieldUpdateOperationsInput | string | null
    issueNumber?: NullableStringFieldUpdateOperationsInput | string | null
    retireComment?: NullableStringFieldUpdateOperationsInput | string | null
    revisionReminderFlag?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isVersion?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    countNumber?: NullableIntFieldUpdateOperationsInput | number | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    distributionList?: NullableStringFieldUpdateOperationsInput | string | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    reviewers?: DocumentsUpdatereviewersInput | string[]
    approvers?: DocumentsUpdateapproversInput | string[]
    creators?: DocumentsUpdatecreatorsInput | string[]
    distributionUsers?: DocumentsUpdatedistributionUsersInput | InputJsonValue[]
    readAccess?: NullableStringFieldUpdateOperationsInput | string | null
    readAccessUsers?: DocumentsUpdatereadAccessUsersInput | InputJsonValue[]
    versionInfo?: DocumentsUpdateversionInfoInput | InputJsonValue[]
    doctype?: DoctypeUpdateOneWithoutDocumentsNestedInput
    organization?: OrganizationUpdateOneWithoutDocumentsNestedInput
    creatorEntity?: EntityUpdateOneWithoutDocumentsNestedInput
    ReferenceDocuments?: ReferenceDocumentsUpdateManyWithoutDocumentNestedInput
    DocumentVersions?: DocumentVersionsUpdateManyWithoutDocumentNestedInput
    DocumentComments?: DocumentCommentsUpdateManyWithoutDocumentNestedInput
    DocumentWorkFlowHistory?: DocumentWorkFlowHistoryUpdateManyWithoutDocumentNestedInput
    AdditionalDocumentAdmins?: AdditionalDocumentAdminsUpdateManyWithoutDocumentNestedInput
    VersionReferenceDocuments?: VersionReferenceDocumentsUpdateManyWithoutDocumentsNestedInput
  }

  export type DocumentsUncheckedUpdateWithoutCreatorLocationInput = {
    doctypeId?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    documentName?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumbering?: NullableStringFieldUpdateOperationsInput | string | null
    reasonOfCreation?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextRevisionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentVersion?: NullableStringFieldUpdateOperationsInput | string | null
    documentLink?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: DocumentsUpdatetagsInput | string[]
    documentState?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    system?: DocumentsUpdatesystemInput | string[]
    section?: NullableStringFieldUpdateOperationsInput | string | null
    revertComment?: NullableStringFieldUpdateOperationsInput | string | null
    docType?: NullableStringFieldUpdateOperationsInput | string | null
    documentClassification?: NullableStringFieldUpdateOperationsInput | string | null
    issueNumber?: NullableStringFieldUpdateOperationsInput | string | null
    retireComment?: NullableStringFieldUpdateOperationsInput | string | null
    revisionReminderFlag?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isVersion?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    countNumber?: NullableIntFieldUpdateOperationsInput | number | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    distributionList?: NullableStringFieldUpdateOperationsInput | string | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    reviewers?: DocumentsUpdatereviewersInput | string[]
    approvers?: DocumentsUpdateapproversInput | string[]
    creators?: DocumentsUpdatecreatorsInput | string[]
    distributionUsers?: DocumentsUpdatedistributionUsersInput | InputJsonValue[]
    readAccess?: NullableStringFieldUpdateOperationsInput | string | null
    readAccessUsers?: DocumentsUpdatereadAccessUsersInput | InputJsonValue[]
    versionInfo?: DocumentsUpdateversionInfoInput | InputJsonValue[]
    ReferenceDocuments?: ReferenceDocumentsUncheckedUpdateManyWithoutDocumentNestedInput
    DocumentVersions?: DocumentVersionsUncheckedUpdateManyWithoutDocumentNestedInput
    DocumentComments?: DocumentCommentsUncheckedUpdateManyWithoutDocumentNestedInput
    DocumentWorkFlowHistory?: DocumentWorkFlowHistoryUncheckedUpdateManyWithoutDocumentNestedInput
    AdditionalDocumentAdmins?: AdditionalDocumentAdminsUncheckedUpdateManyWithoutDocumentNestedInput
    VersionReferenceDocuments?: VersionReferenceDocumentsUncheckedUpdateManyWithoutDocumentsNestedInput
  }

  export type DocumentsUncheckedUpdateManyWithoutCreatorLocationInput = {
    doctypeId?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    documentName?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumbering?: NullableStringFieldUpdateOperationsInput | string | null
    reasonOfCreation?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextRevisionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentVersion?: NullableStringFieldUpdateOperationsInput | string | null
    documentLink?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: DocumentsUpdatetagsInput | string[]
    documentState?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    system?: DocumentsUpdatesystemInput | string[]
    section?: NullableStringFieldUpdateOperationsInput | string | null
    revertComment?: NullableStringFieldUpdateOperationsInput | string | null
    docType?: NullableStringFieldUpdateOperationsInput | string | null
    documentClassification?: NullableStringFieldUpdateOperationsInput | string | null
    issueNumber?: NullableStringFieldUpdateOperationsInput | string | null
    retireComment?: NullableStringFieldUpdateOperationsInput | string | null
    revisionReminderFlag?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isVersion?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    countNumber?: NullableIntFieldUpdateOperationsInput | number | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    distributionList?: NullableStringFieldUpdateOperationsInput | string | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    reviewers?: DocumentsUpdatereviewersInput | string[]
    approvers?: DocumentsUpdateapproversInput | string[]
    creators?: DocumentsUpdatecreatorsInput | string[]
    distributionUsers?: DocumentsUpdatedistributionUsersInput | InputJsonValue[]
    readAccess?: NullableStringFieldUpdateOperationsInput | string | null
    readAccessUsers?: DocumentsUpdatereadAccessUsersInput | InputJsonValue[]
    versionInfo?: DocumentsUpdateversionInfoInput | InputJsonValue[]
  }

  export type EntityUpdateWithoutLocationInput = {
    entityName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    users?: EntityUpdateusersInput | string[]
    sections?: EntityUpdatesectionsInput | string[]
    entityType?: EntityTypeUpdateOneWithoutEntityNestedInput
    organization?: OrganizationUpdateOneWithoutEntityNestedInput
    Doctype?: DoctypeUpdateManyWithoutEntityNestedInput
    Documents?: DocumentsUpdateManyWithoutCreatorEntityNestedInput
    user?: UserUpdateManyWithoutEntityNestedInput
    parts?: PartsUpdateManyWithoutEntityNestedInput
    claimToEntity?: ClaimToEntityUpdateManyWithoutEntityNestedInput
    function?: FunctionsUpdateOneWithoutEntityNestedInput
  }

  export type EntityUncheckedUpdateWithoutLocationInput = {
    entityName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    entityTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    users?: EntityUpdateusersInput | string[]
    sections?: EntityUpdatesectionsInput | string[]
    functionId?: NullableStringFieldUpdateOperationsInput | string | null
    Doctype?: DoctypeUncheckedUpdateManyWithoutEntityNestedInput
    Documents?: DocumentsUncheckedUpdateManyWithoutCreatorEntityNestedInput
    user?: UserUncheckedUpdateManyWithoutEntityNestedInput
    parts?: PartsUncheckedUpdateManyWithoutEntityNestedInput
    claimToEntity?: ClaimToEntityUncheckedUpdateManyWithoutEntityNestedInput
  }

  export type EntityUncheckedUpdateManyWithoutLocationInput = {
    entityName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    entityTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    users?: EntityUpdateusersInput | string[]
    sections?: EntityUpdatesectionsInput | string[]
    functionId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LocationBusinessUpdateWithoutLocationInput = {
    business?: BusinessUpdateOneWithoutLocationNestedInput
  }

  export type LocationBusinessUncheckedUpdateWithoutLocationInput = {
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LocationBusinessUncheckedUpdateManyWithoutLocationInput = {
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUpdateWithoutLocationInput = {
    kcId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    userType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    roleId?: UserUpdateroleIdInput | string[]
    functionId?: InputJsonValue | InputJsonValue | null
    additionalUnits?: UserUpdateadditionalUnitsInput | string[]
    entity?: EntityUpdateOneWithoutUserNestedInput
    organization?: OrganizationUpdateOneWithoutUserNestedInput
    AdditionalDocumentAdmins?: AdditionalDocumentAdminsUpdateManyWithoutUserNestedInput
    DocumentComments?: DocumentCommentsUpdateManyWithoutUserNestedInput
    DocumentVersions?: DocumentVersionsUpdateManyWithoutUserNestedInput
    DocumentWorkFlowHistory?: DocumentWorkFlowHistoryUpdateManyWithoutUserNestedInput
    Logs?: LogsUpdateManyWithoutUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
    documentAdmins?: documentAdminsUpdateManyWithoutUserNestedInput
    userPersonalisation?: userPersonalisationUpdateManyWithoutUserNestedInput
    auditTrial?: auditTrialUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutLocationInput = {
    kcId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    roleId?: UserUpdateroleIdInput | string[]
    functionId?: InputJsonValue | InputJsonValue | null
    additionalUnits?: UserUpdateadditionalUnitsInput | string[]
    AdditionalDocumentAdmins?: AdditionalDocumentAdminsUncheckedUpdateManyWithoutUserNestedInput
    DocumentComments?: DocumentCommentsUncheckedUpdateManyWithoutUserNestedInput
    DocumentVersions?: DocumentVersionsUncheckedUpdateManyWithoutUserNestedInput
    DocumentWorkFlowHistory?: DocumentWorkFlowHistoryUncheckedUpdateManyWithoutUserNestedInput
    Logs?: LogsUncheckedUpdateManyWithoutUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    documentAdmins?: documentAdminsUncheckedUpdateManyWithoutUserNestedInput
    userPersonalisation?: userPersonalisationUncheckedUpdateManyWithoutUserNestedInput
    auditTrial?: auditTrialUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutLocationInput = {
    kcId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    roleId?: UserUpdateroleIdInput | string[]
    functionId?: InputJsonValue | InputJsonValue | null
    additionalUnits?: UserUpdateadditionalUnitsInput | string[]
  }

  export type unitTypeUpdateWithoutLocationInput = {
    unitType?: StringFieldUpdateOperationsInput | string
    unitOfMeasurement?: unitTypeUpdateunitOfMeasurementInput | string[]
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdModifiedBy?: StringFieldUpdateOperationsInput | string
    createdModifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kpi?: kpiUpdateManyWithoutUnitTypeNestedInput
    organization?: OrganizationUpdateOneWithoutUnitOfMeasurementNestedInput
    ConnectedApps?: ConnectedAppsUpdateOneWithoutUomNestedInput
  }

  export type unitTypeUncheckedUpdateWithoutLocationInput = {
    unitType?: StringFieldUpdateOperationsInput | string
    unitOfMeasurement?: unitTypeUpdateunitOfMeasurementInput | string[]
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdModifiedBy?: StringFieldUpdateOperationsInput | string
    createdModifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    connectedAppsId?: NullableStringFieldUpdateOperationsInput | string | null
    kpi?: kpiUncheckedUpdateManyWithoutUnitTypeNestedInput
  }

  export type unitTypeUncheckedUpdateManyWithoutLocationInput = {
    unitType?: StringFieldUpdateOperationsInput | string
    unitOfMeasurement?: unitTypeUpdateunitOfMeasurementInput | string[]
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdModifiedBy?: StringFieldUpdateOperationsInput | string
    createdModifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    connectedAppsId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type rolesTableUpdateWithoutLocationInput = {
    users?: rolesTableUpdateusersInput | string[]
    roleId?: rolesTableUpdateroleIdInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutRolesTableNestedInput
  }

  export type rolesTableUncheckedUpdateWithoutLocationInput = {
    orgId?: StringFieldUpdateOperationsInput | string
    users?: rolesTableUpdateusersInput | string[]
    roleId?: rolesTableUpdateroleIdInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type rolesTableUncheckedUpdateManyWithoutLocationInput = {
    orgId?: StringFieldUpdateOperationsInput | string
    users?: rolesTableUpdateusersInput | string[]
    roleId?: rolesTableUpdateroleIdInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleUpdateWithoutLocationInput = {
    kcId?: NullableStringFieldUpdateOperationsInput | string | null
    roleName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    organization?: OrganizationUpdateOneWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateWithoutLocationInput = {
    kcId?: NullableStringFieldUpdateOperationsInput | string | null
    roleName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RoleUncheckedUpdateManyWithoutLocationInput = {
    kcId?: NullableStringFieldUpdateOperationsInput | string | null
    roleName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DoctypeCreateManyEntityInput = {
    id?: string
    locationId?: DoctypeCreatelocationIdInput | string[]
    documentTypeName?: string | null
    documentNumbering?: string | null
    reviewFrequency?: number | null
    revisionRemind?: number | null
    prefix?: string | null
    suffix?: string | null
    organizationId?: string | null
    readAccess?: string | null
    readAccessUsers?: DoctypeCreatereadAccessUsersInput | InputJsonValue[]
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedBy?: string | null
    createdBy?: string | null
    applicable_systems?: DoctypeCreateapplicable_systemsInput | InputJsonValue[]
    users?: DoctypeCreateusersInput | InputJsonValue[]
    document_classification?: string | null
    distributionUsers?: DoctypeCreatedistributionUsersInput | InputJsonValue[]
    currentVersion: string
    distributionList?: string | null
  }

  export type DocumentsCreateManyCreatorEntityInput = {
    id?: string
    doctypeId?: string | null
    organizationId?: string | null
    documentName?: string | null
    documentNumbering?: string | null
    reasonOfCreation?: string | null
    effectiveDate?: Date | string | null
    nextRevisionDate?: Date | string | null
    currentVersion?: string | null
    documentLink?: string | null
    description?: string | null
    tags?: DocumentsCreatetagsInput | string[]
    documentState?: string | null
    locationId: string
    system?: DocumentsCreatesystemInput | string[]
    section?: string | null
    revertComment?: string | null
    docType?: string | null
    documentClassification?: string | null
    issueNumber?: string | null
    retireComment?: string | null
    revisionReminderFlag?: boolean | null
    isVersion?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedDate?: Date | string | null
    countNumber?: number | null
    createdBy?: string | null
    distributionList?: string | null
    documentId?: string | null
    reviewers?: DocumentsCreatereviewersInput | string[]
    approvers?: DocumentsCreateapproversInput | string[]
    creators?: DocumentsCreatecreatorsInput | string[]
    distributionUsers?: DocumentsCreatedistributionUsersInput | InputJsonValue[]
    readAccess?: string | null
    readAccessUsers?: DocumentsCreatereadAccessUsersInput | InputJsonValue[]
    versionInfo?: DocumentsCreateversionInfoInput | InputJsonValue[]
  }

  export type UserCreateManyEntityInput = {
    id?: string
    kcId?: string | null
    email?: string | null
    username?: string | null
    firstname?: string | null
    lastname?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    enabled?: boolean | null
    organizationId?: string | null
    locationId?: string | null
    userType?: string | null
    status?: boolean | null
    avatar?: string | null
    deleted?: boolean | null
    roleId?: UserCreateroleIdInput | string[]
    functionId?: InputJsonValue | null
    additionalUnits?: UserCreateadditionalUnitsInput | string[]
  }

  export type PartsCreateManyEntityInput = {
    id?: string
    partNo: string
    partName: string
    description?: string | null
    organizationId?: string | null
    claimId?: PartsCreateclaimIdInput | string[]
    modelsId?: PartsCreatemodelsIdInput | string[]
  }

  export type ClaimToEntityCreateManyEntityInput = {
    id?: string
    claimId: string
  }

  export type DoctypeUpdateWithoutEntityInput = {
    locationId?: DoctypeUpdatelocationIdInput | string[]
    documentTypeName?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumbering?: NullableStringFieldUpdateOperationsInput | string | null
    reviewFrequency?: NullableIntFieldUpdateOperationsInput | number | null
    revisionRemind?: NullableIntFieldUpdateOperationsInput | number | null
    prefix?: NullableStringFieldUpdateOperationsInput | string | null
    suffix?: NullableStringFieldUpdateOperationsInput | string | null
    readAccess?: NullableStringFieldUpdateOperationsInput | string | null
    readAccessUsers?: DoctypeUpdatereadAccessUsersInput | InputJsonValue[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    applicable_systems?: DoctypeUpdateapplicable_systemsInput | InputJsonValue[]
    users?: DoctypeUpdateusersInput | InputJsonValue[]
    document_classification?: NullableStringFieldUpdateOperationsInput | string | null
    distributionUsers?: DoctypeUpdatedistributionUsersInput | InputJsonValue[]
    currentVersion?: StringFieldUpdateOperationsInput | string
    distributionList?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: OrganizationUpdateOneWithoutDoctypeNestedInput
    Documents?: DocumentsUpdateManyWithoutDoctypeNestedInput
    documentAdmins?: documentAdminsUpdateManyWithoutDoctypeNestedInput
  }

  export type DoctypeUncheckedUpdateWithoutEntityInput = {
    locationId?: DoctypeUpdatelocationIdInput | string[]
    documentTypeName?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumbering?: NullableStringFieldUpdateOperationsInput | string | null
    reviewFrequency?: NullableIntFieldUpdateOperationsInput | number | null
    revisionRemind?: NullableIntFieldUpdateOperationsInput | number | null
    prefix?: NullableStringFieldUpdateOperationsInput | string | null
    suffix?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    readAccess?: NullableStringFieldUpdateOperationsInput | string | null
    readAccessUsers?: DoctypeUpdatereadAccessUsersInput | InputJsonValue[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    applicable_systems?: DoctypeUpdateapplicable_systemsInput | InputJsonValue[]
    users?: DoctypeUpdateusersInput | InputJsonValue[]
    document_classification?: NullableStringFieldUpdateOperationsInput | string | null
    distributionUsers?: DoctypeUpdatedistributionUsersInput | InputJsonValue[]
    currentVersion?: StringFieldUpdateOperationsInput | string
    distributionList?: NullableStringFieldUpdateOperationsInput | string | null
    Documents?: DocumentsUncheckedUpdateManyWithoutDoctypeNestedInput
    documentAdmins?: documentAdminsUncheckedUpdateManyWithoutDoctypeNestedInput
  }

  export type DoctypeUncheckedUpdateManyWithoutEntityInput = {
    locationId?: DoctypeUpdatelocationIdInput | string[]
    documentTypeName?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumbering?: NullableStringFieldUpdateOperationsInput | string | null
    reviewFrequency?: NullableIntFieldUpdateOperationsInput | number | null
    revisionRemind?: NullableIntFieldUpdateOperationsInput | number | null
    prefix?: NullableStringFieldUpdateOperationsInput | string | null
    suffix?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    readAccess?: NullableStringFieldUpdateOperationsInput | string | null
    readAccessUsers?: DoctypeUpdatereadAccessUsersInput | InputJsonValue[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    applicable_systems?: DoctypeUpdateapplicable_systemsInput | InputJsonValue[]
    users?: DoctypeUpdateusersInput | InputJsonValue[]
    document_classification?: NullableStringFieldUpdateOperationsInput | string | null
    distributionUsers?: DoctypeUpdatedistributionUsersInput | InputJsonValue[]
    currentVersion?: StringFieldUpdateOperationsInput | string
    distributionList?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DocumentsUpdateWithoutCreatorEntityInput = {
    documentName?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumbering?: NullableStringFieldUpdateOperationsInput | string | null
    reasonOfCreation?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextRevisionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentVersion?: NullableStringFieldUpdateOperationsInput | string | null
    documentLink?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: DocumentsUpdatetagsInput | string[]
    documentState?: NullableStringFieldUpdateOperationsInput | string | null
    system?: DocumentsUpdatesystemInput | string[]
    section?: NullableStringFieldUpdateOperationsInput | string | null
    revertComment?: NullableStringFieldUpdateOperationsInput | string | null
    docType?: NullableStringFieldUpdateOperationsInput | string | null
    documentClassification?: NullableStringFieldUpdateOperationsInput | string | null
    issueNumber?: NullableStringFieldUpdateOperationsInput | string | null
    retireComment?: NullableStringFieldUpdateOperationsInput | string | null
    revisionReminderFlag?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isVersion?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    countNumber?: NullableIntFieldUpdateOperationsInput | number | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    distributionList?: NullableStringFieldUpdateOperationsInput | string | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    reviewers?: DocumentsUpdatereviewersInput | string[]
    approvers?: DocumentsUpdateapproversInput | string[]
    creators?: DocumentsUpdatecreatorsInput | string[]
    distributionUsers?: DocumentsUpdatedistributionUsersInput | InputJsonValue[]
    readAccess?: NullableStringFieldUpdateOperationsInput | string | null
    readAccessUsers?: DocumentsUpdatereadAccessUsersInput | InputJsonValue[]
    versionInfo?: DocumentsUpdateversionInfoInput | InputJsonValue[]
    doctype?: DoctypeUpdateOneWithoutDocumentsNestedInput
    organization?: OrganizationUpdateOneWithoutDocumentsNestedInput
    creatorLocation?: LocationUpdateOneWithoutDocumentsNestedInput
    ReferenceDocuments?: ReferenceDocumentsUpdateManyWithoutDocumentNestedInput
    DocumentVersions?: DocumentVersionsUpdateManyWithoutDocumentNestedInput
    DocumentComments?: DocumentCommentsUpdateManyWithoutDocumentNestedInput
    DocumentWorkFlowHistory?: DocumentWorkFlowHistoryUpdateManyWithoutDocumentNestedInput
    AdditionalDocumentAdmins?: AdditionalDocumentAdminsUpdateManyWithoutDocumentNestedInput
    VersionReferenceDocuments?: VersionReferenceDocumentsUpdateManyWithoutDocumentsNestedInput
  }

  export type DocumentsUncheckedUpdateWithoutCreatorEntityInput = {
    doctypeId?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    documentName?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumbering?: NullableStringFieldUpdateOperationsInput | string | null
    reasonOfCreation?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextRevisionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentVersion?: NullableStringFieldUpdateOperationsInput | string | null
    documentLink?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: DocumentsUpdatetagsInput | string[]
    documentState?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: StringFieldUpdateOperationsInput | string
    system?: DocumentsUpdatesystemInput | string[]
    section?: NullableStringFieldUpdateOperationsInput | string | null
    revertComment?: NullableStringFieldUpdateOperationsInput | string | null
    docType?: NullableStringFieldUpdateOperationsInput | string | null
    documentClassification?: NullableStringFieldUpdateOperationsInput | string | null
    issueNumber?: NullableStringFieldUpdateOperationsInput | string | null
    retireComment?: NullableStringFieldUpdateOperationsInput | string | null
    revisionReminderFlag?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isVersion?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    countNumber?: NullableIntFieldUpdateOperationsInput | number | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    distributionList?: NullableStringFieldUpdateOperationsInput | string | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    reviewers?: DocumentsUpdatereviewersInput | string[]
    approvers?: DocumentsUpdateapproversInput | string[]
    creators?: DocumentsUpdatecreatorsInput | string[]
    distributionUsers?: DocumentsUpdatedistributionUsersInput | InputJsonValue[]
    readAccess?: NullableStringFieldUpdateOperationsInput | string | null
    readAccessUsers?: DocumentsUpdatereadAccessUsersInput | InputJsonValue[]
    versionInfo?: DocumentsUpdateversionInfoInput | InputJsonValue[]
    ReferenceDocuments?: ReferenceDocumentsUncheckedUpdateManyWithoutDocumentNestedInput
    DocumentVersions?: DocumentVersionsUncheckedUpdateManyWithoutDocumentNestedInput
    DocumentComments?: DocumentCommentsUncheckedUpdateManyWithoutDocumentNestedInput
    DocumentWorkFlowHistory?: DocumentWorkFlowHistoryUncheckedUpdateManyWithoutDocumentNestedInput
    AdditionalDocumentAdmins?: AdditionalDocumentAdminsUncheckedUpdateManyWithoutDocumentNestedInput
    VersionReferenceDocuments?: VersionReferenceDocumentsUncheckedUpdateManyWithoutDocumentsNestedInput
  }

  export type DocumentsUncheckedUpdateManyWithoutCreatorEntityInput = {
    doctypeId?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    documentName?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumbering?: NullableStringFieldUpdateOperationsInput | string | null
    reasonOfCreation?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextRevisionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentVersion?: NullableStringFieldUpdateOperationsInput | string | null
    documentLink?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: DocumentsUpdatetagsInput | string[]
    documentState?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: StringFieldUpdateOperationsInput | string
    system?: DocumentsUpdatesystemInput | string[]
    section?: NullableStringFieldUpdateOperationsInput | string | null
    revertComment?: NullableStringFieldUpdateOperationsInput | string | null
    docType?: NullableStringFieldUpdateOperationsInput | string | null
    documentClassification?: NullableStringFieldUpdateOperationsInput | string | null
    issueNumber?: NullableStringFieldUpdateOperationsInput | string | null
    retireComment?: NullableStringFieldUpdateOperationsInput | string | null
    revisionReminderFlag?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isVersion?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    countNumber?: NullableIntFieldUpdateOperationsInput | number | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    distributionList?: NullableStringFieldUpdateOperationsInput | string | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    reviewers?: DocumentsUpdatereviewersInput | string[]
    approvers?: DocumentsUpdateapproversInput | string[]
    creators?: DocumentsUpdatecreatorsInput | string[]
    distributionUsers?: DocumentsUpdatedistributionUsersInput | InputJsonValue[]
    readAccess?: NullableStringFieldUpdateOperationsInput | string | null
    readAccessUsers?: DocumentsUpdatereadAccessUsersInput | InputJsonValue[]
    versionInfo?: DocumentsUpdateversionInfoInput | InputJsonValue[]
  }

  export type UserUpdateWithoutEntityInput = {
    kcId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    userType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    roleId?: UserUpdateroleIdInput | string[]
    functionId?: InputJsonValue | InputJsonValue | null
    additionalUnits?: UserUpdateadditionalUnitsInput | string[]
    location?: LocationUpdateOneWithoutUserNestedInput
    organization?: OrganizationUpdateOneWithoutUserNestedInput
    AdditionalDocumentAdmins?: AdditionalDocumentAdminsUpdateManyWithoutUserNestedInput
    DocumentComments?: DocumentCommentsUpdateManyWithoutUserNestedInput
    DocumentVersions?: DocumentVersionsUpdateManyWithoutUserNestedInput
    DocumentWorkFlowHistory?: DocumentWorkFlowHistoryUpdateManyWithoutUserNestedInput
    Logs?: LogsUpdateManyWithoutUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
    documentAdmins?: documentAdminsUpdateManyWithoutUserNestedInput
    userPersonalisation?: userPersonalisationUpdateManyWithoutUserNestedInput
    auditTrial?: auditTrialUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutEntityInput = {
    kcId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    roleId?: UserUpdateroleIdInput | string[]
    functionId?: InputJsonValue | InputJsonValue | null
    additionalUnits?: UserUpdateadditionalUnitsInput | string[]
    AdditionalDocumentAdmins?: AdditionalDocumentAdminsUncheckedUpdateManyWithoutUserNestedInput
    DocumentComments?: DocumentCommentsUncheckedUpdateManyWithoutUserNestedInput
    DocumentVersions?: DocumentVersionsUncheckedUpdateManyWithoutUserNestedInput
    DocumentWorkFlowHistory?: DocumentWorkFlowHistoryUncheckedUpdateManyWithoutUserNestedInput
    Logs?: LogsUncheckedUpdateManyWithoutUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    documentAdmins?: documentAdminsUncheckedUpdateManyWithoutUserNestedInput
    userPersonalisation?: userPersonalisationUncheckedUpdateManyWithoutUserNestedInput
    auditTrial?: auditTrialUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutEntityInput = {
    kcId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    roleId?: UserUpdateroleIdInput | string[]
    functionId?: InputJsonValue | InputJsonValue | null
    additionalUnits?: UserUpdateadditionalUnitsInput | string[]
  }

  export type PartsUpdateWithoutEntityInput = {
    partNo?: StringFieldUpdateOperationsInput | string
    partName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    claimId?: PartsUpdateclaimIdInput | string[]
    claims?: ClaimUpdateManyWithoutPartsNestedInput
    organization?: OrganizationUpdateOneWithoutPartsNestedInput
    models?: ModelsUpdateManyWithoutPartsNestedInput
  }

  export type PartsUncheckedUpdateWithoutEntityInput = {
    partNo?: StringFieldUpdateOperationsInput | string
    partName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    claimId?: PartsUpdateclaimIdInput | string[]
    modelsId?: PartsUpdatemodelsIdInput | string[]
    claims?: ClaimUncheckedUpdateManyWithoutPartsNestedInput
    models?: ModelsUncheckedUpdateManyWithoutPartsNestedInput
  }

  export type PartsUncheckedUpdateManyWithoutEntityInput = {
    partNo?: StringFieldUpdateOperationsInput | string
    partName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    claimId?: PartsUpdateclaimIdInput | string[]
    modelsId?: PartsUpdatemodelsIdInput | string[]
  }

  export type ClaimToEntityUpdateWithoutEntityInput = {
    claim?: ClaimUpdateOneRequiredWithoutClaimToEntityNestedInput
  }

  export type ClaimToEntityUncheckedUpdateWithoutEntityInput = {
    claimId?: StringFieldUpdateOperationsInput | string
  }

  export type ClaimToEntityUncheckedUpdateManyWithoutEntityInput = {
    claimId?: StringFieldUpdateOperationsInput | string
  }

  export type DocumentsCreateManyDoctypeInput = {
    id?: string
    organizationId?: string | null
    documentName?: string | null
    documentNumbering?: string | null
    reasonOfCreation?: string | null
    effectiveDate?: Date | string | null
    nextRevisionDate?: Date | string | null
    currentVersion?: string | null
    documentLink?: string | null
    description?: string | null
    tags?: DocumentsCreatetagsInput | string[]
    documentState?: string | null
    locationId: string
    entityId?: string | null
    system?: DocumentsCreatesystemInput | string[]
    section?: string | null
    revertComment?: string | null
    docType?: string | null
    documentClassification?: string | null
    issueNumber?: string | null
    retireComment?: string | null
    revisionReminderFlag?: boolean | null
    isVersion?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedDate?: Date | string | null
    countNumber?: number | null
    createdBy?: string | null
    distributionList?: string | null
    documentId?: string | null
    reviewers?: DocumentsCreatereviewersInput | string[]
    approvers?: DocumentsCreateapproversInput | string[]
    creators?: DocumentsCreatecreatorsInput | string[]
    distributionUsers?: DocumentsCreatedistributionUsersInput | InputJsonValue[]
    readAccess?: string | null
    readAccessUsers?: DocumentsCreatereadAccessUsersInput | InputJsonValue[]
    versionInfo?: DocumentsCreateversionInfoInput | InputJsonValue[]
  }

  export type documentAdminsCreateManyDoctypeInput = {
    id?: string
    type: string
    firstname: string
    lastname: string
    email: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentsUpdateWithoutDoctypeInput = {
    documentName?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumbering?: NullableStringFieldUpdateOperationsInput | string | null
    reasonOfCreation?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextRevisionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentVersion?: NullableStringFieldUpdateOperationsInput | string | null
    documentLink?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: DocumentsUpdatetagsInput | string[]
    documentState?: NullableStringFieldUpdateOperationsInput | string | null
    system?: DocumentsUpdatesystemInput | string[]
    section?: NullableStringFieldUpdateOperationsInput | string | null
    revertComment?: NullableStringFieldUpdateOperationsInput | string | null
    docType?: NullableStringFieldUpdateOperationsInput | string | null
    documentClassification?: NullableStringFieldUpdateOperationsInput | string | null
    issueNumber?: NullableStringFieldUpdateOperationsInput | string | null
    retireComment?: NullableStringFieldUpdateOperationsInput | string | null
    revisionReminderFlag?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isVersion?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    countNumber?: NullableIntFieldUpdateOperationsInput | number | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    distributionList?: NullableStringFieldUpdateOperationsInput | string | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    reviewers?: DocumentsUpdatereviewersInput | string[]
    approvers?: DocumentsUpdateapproversInput | string[]
    creators?: DocumentsUpdatecreatorsInput | string[]
    distributionUsers?: DocumentsUpdatedistributionUsersInput | InputJsonValue[]
    readAccess?: NullableStringFieldUpdateOperationsInput | string | null
    readAccessUsers?: DocumentsUpdatereadAccessUsersInput | InputJsonValue[]
    versionInfo?: DocumentsUpdateversionInfoInput | InputJsonValue[]
    organization?: OrganizationUpdateOneWithoutDocumentsNestedInput
    creatorLocation?: LocationUpdateOneWithoutDocumentsNestedInput
    creatorEntity?: EntityUpdateOneWithoutDocumentsNestedInput
    ReferenceDocuments?: ReferenceDocumentsUpdateManyWithoutDocumentNestedInput
    DocumentVersions?: DocumentVersionsUpdateManyWithoutDocumentNestedInput
    DocumentComments?: DocumentCommentsUpdateManyWithoutDocumentNestedInput
    DocumentWorkFlowHistory?: DocumentWorkFlowHistoryUpdateManyWithoutDocumentNestedInput
    AdditionalDocumentAdmins?: AdditionalDocumentAdminsUpdateManyWithoutDocumentNestedInput
    VersionReferenceDocuments?: VersionReferenceDocumentsUpdateManyWithoutDocumentsNestedInput
  }

  export type DocumentsUncheckedUpdateWithoutDoctypeInput = {
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    documentName?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumbering?: NullableStringFieldUpdateOperationsInput | string | null
    reasonOfCreation?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextRevisionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentVersion?: NullableStringFieldUpdateOperationsInput | string | null
    documentLink?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: DocumentsUpdatetagsInput | string[]
    documentState?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    system?: DocumentsUpdatesystemInput | string[]
    section?: NullableStringFieldUpdateOperationsInput | string | null
    revertComment?: NullableStringFieldUpdateOperationsInput | string | null
    docType?: NullableStringFieldUpdateOperationsInput | string | null
    documentClassification?: NullableStringFieldUpdateOperationsInput | string | null
    issueNumber?: NullableStringFieldUpdateOperationsInput | string | null
    retireComment?: NullableStringFieldUpdateOperationsInput | string | null
    revisionReminderFlag?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isVersion?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    countNumber?: NullableIntFieldUpdateOperationsInput | number | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    distributionList?: NullableStringFieldUpdateOperationsInput | string | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    reviewers?: DocumentsUpdatereviewersInput | string[]
    approvers?: DocumentsUpdateapproversInput | string[]
    creators?: DocumentsUpdatecreatorsInput | string[]
    distributionUsers?: DocumentsUpdatedistributionUsersInput | InputJsonValue[]
    readAccess?: NullableStringFieldUpdateOperationsInput | string | null
    readAccessUsers?: DocumentsUpdatereadAccessUsersInput | InputJsonValue[]
    versionInfo?: DocumentsUpdateversionInfoInput | InputJsonValue[]
    ReferenceDocuments?: ReferenceDocumentsUncheckedUpdateManyWithoutDocumentNestedInput
    DocumentVersions?: DocumentVersionsUncheckedUpdateManyWithoutDocumentNestedInput
    DocumentComments?: DocumentCommentsUncheckedUpdateManyWithoutDocumentNestedInput
    DocumentWorkFlowHistory?: DocumentWorkFlowHistoryUncheckedUpdateManyWithoutDocumentNestedInput
    AdditionalDocumentAdmins?: AdditionalDocumentAdminsUncheckedUpdateManyWithoutDocumentNestedInput
    VersionReferenceDocuments?: VersionReferenceDocumentsUncheckedUpdateManyWithoutDocumentsNestedInput
  }

  export type DocumentsUncheckedUpdateManyWithoutDoctypeInput = {
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    documentName?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumbering?: NullableStringFieldUpdateOperationsInput | string | null
    reasonOfCreation?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextRevisionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentVersion?: NullableStringFieldUpdateOperationsInput | string | null
    documentLink?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: DocumentsUpdatetagsInput | string[]
    documentState?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    system?: DocumentsUpdatesystemInput | string[]
    section?: NullableStringFieldUpdateOperationsInput | string | null
    revertComment?: NullableStringFieldUpdateOperationsInput | string | null
    docType?: NullableStringFieldUpdateOperationsInput | string | null
    documentClassification?: NullableStringFieldUpdateOperationsInput | string | null
    issueNumber?: NullableStringFieldUpdateOperationsInput | string | null
    retireComment?: NullableStringFieldUpdateOperationsInput | string | null
    revisionReminderFlag?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isVersion?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    countNumber?: NullableIntFieldUpdateOperationsInput | number | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    distributionList?: NullableStringFieldUpdateOperationsInput | string | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    reviewers?: DocumentsUpdatereviewersInput | string[]
    approvers?: DocumentsUpdateapproversInput | string[]
    creators?: DocumentsUpdatecreatorsInput | string[]
    distributionUsers?: DocumentsUpdatedistributionUsersInput | InputJsonValue[]
    readAccess?: NullableStringFieldUpdateOperationsInput | string | null
    readAccessUsers?: DocumentsUpdatereadAccessUsersInput | InputJsonValue[]
    versionInfo?: DocumentsUpdateversionInfoInput | InputJsonValue[]
  }

  export type documentAdminsUpdateWithoutDoctypeInput = {
    type?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDocumentAdminsNestedInput
  }

  export type documentAdminsUncheckedUpdateWithoutDoctypeInput = {
    type?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type documentAdminsUncheckedUpdateManyWithoutDoctypeInput = {
    type?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferenceDocumentsCreateManyDocumentInput = {
    id?: string
    documentLink?: string | null
    type?: string | null
    documentName?: string | null
    version?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    referenceDocId?: string | null
    versionId?: string | null
  }

  export type DocumentVersionsCreateManyDocumentInput = {
    id?: string
    versionName: string
    userId?: string | null
    by?: string | null
    approvedDate?: Date | string | null
    versionLink: string
    createdAt?: Date | string
    updatedAt?: Date | string
    documentName?: string | null
    documentNumbering?: string | null
    reasonOfCreation?: string | null
    effectiveDate?: Date | string | null
    description?: string | null
    issueNumber?: string | null
  }

  export type DocumentCommentsCreateManyDocumentInput = {
    id?: string
    userId?: string | null
    commentBy?: string | null
    commentText: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentWorkFlowHistoryCreateManyDocumentInput = {
    id?: string
    actionName: string
    userId?: string | null
    actionBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdditionalDocumentAdminsCreateManyDocumentInput = {
    id?: string
    type: string
    firstname: string
    lastname: string
    email: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VersionReferenceDocumentsCreateManyDocumentsInput = {
    id?: string
    documentLink?: string | null
    type?: string | null
    documentName?: string | null
    version?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    referenceDocId?: string | null
    versionId?: string | null
  }

  export type ReferenceDocumentsUpdateWithoutDocumentInput = {
    documentLink?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    documentName?: NullableStringFieldUpdateOperationsInput | string | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referenceDocId?: NullableStringFieldUpdateOperationsInput | string | null
    versionsLinkedWith?: DocumentVersionsUpdateOneWithoutReferenceDocumentsNestedInput
  }

  export type ReferenceDocumentsUncheckedUpdateWithoutDocumentInput = {
    documentLink?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    documentName?: NullableStringFieldUpdateOperationsInput | string | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referenceDocId?: NullableStringFieldUpdateOperationsInput | string | null
    versionId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReferenceDocumentsUncheckedUpdateManyWithoutDocumentInput = {
    documentLink?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    documentName?: NullableStringFieldUpdateOperationsInput | string | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referenceDocId?: NullableStringFieldUpdateOperationsInput | string | null
    versionId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DocumentVersionsUpdateWithoutDocumentInput = {
    versionName?: StringFieldUpdateOperationsInput | string
    by?: NullableStringFieldUpdateOperationsInput | string | null
    approvedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    versionLink?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documentName?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumbering?: NullableStringFieldUpdateOperationsInput | string | null
    reasonOfCreation?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    issueNumber?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneWithoutDocumentVersionsNestedInput
    ReferenceDocuments?: ReferenceDocumentsUpdateManyWithoutVersionsLinkedWithNestedInput
    VersionReferenceDocuments?: VersionReferenceDocumentsUpdateManyWithoutVersionsLinkedWithNestedInput
  }

  export type DocumentVersionsUncheckedUpdateWithoutDocumentInput = {
    versionName?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    by?: NullableStringFieldUpdateOperationsInput | string | null
    approvedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    versionLink?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documentName?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumbering?: NullableStringFieldUpdateOperationsInput | string | null
    reasonOfCreation?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    issueNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ReferenceDocuments?: ReferenceDocumentsUncheckedUpdateManyWithoutVersionsLinkedWithNestedInput
    VersionReferenceDocuments?: VersionReferenceDocumentsUncheckedUpdateManyWithoutVersionsLinkedWithNestedInput
  }

  export type DocumentVersionsUncheckedUpdateManyWithoutDocumentInput = {
    versionName?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    by?: NullableStringFieldUpdateOperationsInput | string | null
    approvedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    versionLink?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documentName?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumbering?: NullableStringFieldUpdateOperationsInput | string | null
    reasonOfCreation?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    issueNumber?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DocumentCommentsUpdateWithoutDocumentInput = {
    commentBy?: NullableStringFieldUpdateOperationsInput | string | null
    commentText?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutDocumentCommentsNestedInput
  }

  export type DocumentCommentsUncheckedUpdateWithoutDocumentInput = {
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    commentBy?: NullableStringFieldUpdateOperationsInput | string | null
    commentText?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentCommentsUncheckedUpdateManyWithoutDocumentInput = {
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    commentBy?: NullableStringFieldUpdateOperationsInput | string | null
    commentText?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentWorkFlowHistoryUpdateWithoutDocumentInput = {
    actionName?: StringFieldUpdateOperationsInput | string
    actionBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutDocumentWorkFlowHistoryNestedInput
  }

  export type DocumentWorkFlowHistoryUncheckedUpdateWithoutDocumentInput = {
    actionName?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    actionBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentWorkFlowHistoryUncheckedUpdateManyWithoutDocumentInput = {
    actionName?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    actionBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdditionalDocumentAdminsUpdateWithoutDocumentInput = {
    type?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAdditionalDocumentAdminsNestedInput
  }

  export type AdditionalDocumentAdminsUncheckedUpdateWithoutDocumentInput = {
    type?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdditionalDocumentAdminsUncheckedUpdateManyWithoutDocumentInput = {
    type?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VersionReferenceDocumentsUpdateWithoutDocumentsInput = {
    documentLink?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    documentName?: NullableStringFieldUpdateOperationsInput | string | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referenceDocId?: NullableStringFieldUpdateOperationsInput | string | null
    versionsLinkedWith?: DocumentVersionsUpdateOneWithoutVersionReferenceDocumentsNestedInput
  }

  export type VersionReferenceDocumentsUncheckedUpdateWithoutDocumentsInput = {
    documentLink?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    documentName?: NullableStringFieldUpdateOperationsInput | string | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referenceDocId?: NullableStringFieldUpdateOperationsInput | string | null
    versionId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VersionReferenceDocumentsUncheckedUpdateManyWithoutDocumentsInput = {
    documentLink?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    documentName?: NullableStringFieldUpdateOperationsInput | string | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referenceDocId?: NullableStringFieldUpdateOperationsInput | string | null
    versionId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReferenceDocumentsCreateManyVersionsLinkedWithInput = {
    id?: string
    documentLink?: string | null
    type?: string | null
    documentName?: string | null
    version?: string | null
    documentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    referenceDocId?: string | null
  }

  export type VersionReferenceDocumentsCreateManyVersionsLinkedWithInput = {
    id?: string
    documentLink?: string | null
    type?: string | null
    documentName?: string | null
    version?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    referenceDocId?: string | null
    documentsId?: string | null
  }

  export type ReferenceDocumentsUpdateWithoutVersionsLinkedWithInput = {
    documentLink?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    documentName?: NullableStringFieldUpdateOperationsInput | string | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referenceDocId?: NullableStringFieldUpdateOperationsInput | string | null
    document?: DocumentsUpdateOneWithoutReferenceDocumentsNestedInput
  }

  export type ReferenceDocumentsUncheckedUpdateWithoutVersionsLinkedWithInput = {
    documentLink?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    documentName?: NullableStringFieldUpdateOperationsInput | string | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referenceDocId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReferenceDocumentsUncheckedUpdateManyWithoutVersionsLinkedWithInput = {
    documentLink?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    documentName?: NullableStringFieldUpdateOperationsInput | string | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referenceDocId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VersionReferenceDocumentsUpdateWithoutVersionsLinkedWithInput = {
    documentLink?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    documentName?: NullableStringFieldUpdateOperationsInput | string | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referenceDocId?: NullableStringFieldUpdateOperationsInput | string | null
    Documents?: DocumentsUpdateOneWithoutVersionReferenceDocumentsNestedInput
  }

  export type VersionReferenceDocumentsUncheckedUpdateWithoutVersionsLinkedWithInput = {
    documentLink?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    documentName?: NullableStringFieldUpdateOperationsInput | string | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referenceDocId?: NullableStringFieldUpdateOperationsInput | string | null
    documentsId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VersionReferenceDocumentsUncheckedUpdateManyWithoutVersionsLinkedWithInput = {
    documentLink?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    documentName?: NullableStringFieldUpdateOperationsInput | string | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referenceDocId?: NullableStringFieldUpdateOperationsInput | string | null
    documentsId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type unitTypeCreateManyConnectedAppsInput = {
    id?: string
    unitType: string
    unitOfMeasurement?: unitTypeCreateunitOfMeasurementInput | string[]
    organizationId?: string | null
    locationId?: string | null
    deleted?: boolean | null
    createdModifiedBy: string
    createdModifiedAt?: Date | string
  }

  export type kpiCreateManyConnectedAppsInput = {
    id?: string
    kpiName: string
    kpiType?: string | null
    keyFields?: kpiCreatekeyFieldsInput | string[]
    unitTypeId?: string | null
    uom: string
    status: boolean
    apiEndPoint?: string | null
    kpiDescription?: string | null
    kpiTargetType?: boolean | null
    organizationId?: string | null
    locationId?: kpiCreatelocationIdInput | string[]
    createdModifiedBy: string
    createdModifiedAt?: Date | string
  }

  export type unitTypeUpdateWithoutConnectedAppsInput = {
    unitType?: StringFieldUpdateOperationsInput | string
    unitOfMeasurement?: unitTypeUpdateunitOfMeasurementInput | string[]
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdModifiedBy?: StringFieldUpdateOperationsInput | string
    createdModifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kpi?: kpiUpdateManyWithoutUnitTypeNestedInput
    organization?: OrganizationUpdateOneWithoutUnitOfMeasurementNestedInput
    location?: LocationUpdateOneWithoutUomNestedInput
  }

  export type unitTypeUncheckedUpdateWithoutConnectedAppsInput = {
    unitType?: StringFieldUpdateOperationsInput | string
    unitOfMeasurement?: unitTypeUpdateunitOfMeasurementInput | string[]
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdModifiedBy?: StringFieldUpdateOperationsInput | string
    createdModifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kpi?: kpiUncheckedUpdateManyWithoutUnitTypeNestedInput
  }

  export type unitTypeUncheckedUpdateManyWithoutConnectedAppsInput = {
    unitType?: StringFieldUpdateOperationsInput | string
    unitOfMeasurement?: unitTypeUpdateunitOfMeasurementInput | string[]
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdModifiedBy?: StringFieldUpdateOperationsInput | string
    createdModifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type kpiUpdateWithoutConnectedAppsInput = {
    kpiName?: StringFieldUpdateOperationsInput | string
    kpiType?: NullableStringFieldUpdateOperationsInput | string | null
    keyFields?: kpiUpdatekeyFieldsInput | string[]
    uom?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    apiEndPoint?: NullableStringFieldUpdateOperationsInput | string | null
    kpiDescription?: NullableStringFieldUpdateOperationsInput | string | null
    kpiTargetType?: NullableBoolFieldUpdateOperationsInput | boolean | null
    locationId?: kpiUpdatelocationIdInput | string[]
    createdModifiedBy?: StringFieldUpdateOperationsInput | string
    createdModifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    unitType?: unitTypeUpdateOneWithoutKpiNestedInput
    organization?: OrganizationUpdateOneWithoutKpiNestedInput
  }

  export type kpiUncheckedUpdateWithoutConnectedAppsInput = {
    kpiName?: StringFieldUpdateOperationsInput | string
    kpiType?: NullableStringFieldUpdateOperationsInput | string | null
    keyFields?: kpiUpdatekeyFieldsInput | string[]
    unitTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    uom?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    apiEndPoint?: NullableStringFieldUpdateOperationsInput | string | null
    kpiDescription?: NullableStringFieldUpdateOperationsInput | string | null
    kpiTargetType?: NullableBoolFieldUpdateOperationsInput | boolean | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: kpiUpdatelocationIdInput | string[]
    createdModifiedBy?: StringFieldUpdateOperationsInput | string
    createdModifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type kpiUncheckedUpdateManyWithoutConnectedAppsInput = {
    kpiName?: StringFieldUpdateOperationsInput | string
    kpiType?: NullableStringFieldUpdateOperationsInput | string | null
    keyFields?: kpiUpdatekeyFieldsInput | string[]
    unitTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    uom?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    apiEndPoint?: NullableStringFieldUpdateOperationsInput | string | null
    kpiDescription?: NullableStringFieldUpdateOperationsInput | string | null
    kpiTargetType?: NullableBoolFieldUpdateOperationsInput | boolean | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: kpiUpdatelocationIdInput | string[]
    createdModifiedBy?: StringFieldUpdateOperationsInput | string
    createdModifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type kpiCreateManyUnitTypeInput = {
    id?: string
    kpiName: string
    kpiType?: string | null
    keyFields?: kpiCreatekeyFieldsInput | string[]
    uom: string
    sourceId?: string | null
    status: boolean
    apiEndPoint?: string | null
    kpiDescription?: string | null
    kpiTargetType?: boolean | null
    organizationId?: string | null
    locationId?: kpiCreatelocationIdInput | string[]
    createdModifiedBy: string
    createdModifiedAt?: Date | string
  }

  export type kpiUpdateWithoutUnitTypeInput = {
    kpiName?: StringFieldUpdateOperationsInput | string
    kpiType?: NullableStringFieldUpdateOperationsInput | string | null
    keyFields?: kpiUpdatekeyFieldsInput | string[]
    uom?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    apiEndPoint?: NullableStringFieldUpdateOperationsInput | string | null
    kpiDescription?: NullableStringFieldUpdateOperationsInput | string | null
    kpiTargetType?: NullableBoolFieldUpdateOperationsInput | boolean | null
    locationId?: kpiUpdatelocationIdInput | string[]
    createdModifiedBy?: StringFieldUpdateOperationsInput | string
    createdModifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ConnectedApps?: ConnectedAppsUpdateOneWithoutKpiNestedInput
    organization?: OrganizationUpdateOneWithoutKpiNestedInput
  }

  export type kpiUncheckedUpdateWithoutUnitTypeInput = {
    kpiName?: StringFieldUpdateOperationsInput | string
    kpiType?: NullableStringFieldUpdateOperationsInput | string | null
    keyFields?: kpiUpdatekeyFieldsInput | string[]
    uom?: StringFieldUpdateOperationsInput | string
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    apiEndPoint?: NullableStringFieldUpdateOperationsInput | string | null
    kpiDescription?: NullableStringFieldUpdateOperationsInput | string | null
    kpiTargetType?: NullableBoolFieldUpdateOperationsInput | boolean | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: kpiUpdatelocationIdInput | string[]
    createdModifiedBy?: StringFieldUpdateOperationsInput | string
    createdModifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type kpiUncheckedUpdateManyWithoutUnitTypeInput = {
    kpiName?: StringFieldUpdateOperationsInput | string
    kpiType?: NullableStringFieldUpdateOperationsInput | string | null
    keyFields?: kpiUpdatekeyFieldsInput | string[]
    uom?: StringFieldUpdateOperationsInput | string
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    apiEndPoint?: NullableStringFieldUpdateOperationsInput | string | null
    kpiDescription?: NullableStringFieldUpdateOperationsInput | string | null
    kpiTargetType?: NullableBoolFieldUpdateOperationsInput | boolean | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: kpiUpdatelocationIdInput | string[]
    createdModifiedBy?: StringFieldUpdateOperationsInput | string
    createdModifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ModelsCountOutputTypeDefaultArgs instead
     */
    export type ModelsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ModelsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PartsCountOutputTypeDefaultArgs instead
     */
    export type PartsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PartsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClaimCountOutputTypeDefaultArgs instead
     */
    export type ClaimCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClaimCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProblemCountOutputTypeDefaultArgs instead
     */
    export type ProblemCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProblemCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InvestigationCountOutputTypeDefaultArgs instead
     */
    export type InvestigationCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InvestigationCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ShipmentCountOutputTypeDefaultArgs instead
     */
    export type ShipmentCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ShipmentCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OrganizationCountOutputTypeDefaultArgs instead
     */
    export type OrganizationCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OrganizationCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EntityTypeCountOutputTypeDefaultArgs instead
     */
    export type EntityTypeCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EntityTypeCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BusinessCountOutputTypeDefaultArgs instead
     */
    export type BusinessCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BusinessCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FunctionsCountOutputTypeDefaultArgs instead
     */
    export type FunctionsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FunctionsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LocationCountOutputTypeDefaultArgs instead
     */
    export type LocationCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LocationCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EntityCountOutputTypeDefaultArgs instead
     */
    export type EntityCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EntityCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DoctypeCountOutputTypeDefaultArgs instead
     */
    export type DoctypeCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DoctypeCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DocumentsCountOutputTypeDefaultArgs instead
     */
    export type DocumentsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DocumentsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DocumentVersionsCountOutputTypeDefaultArgs instead
     */
    export type DocumentVersionsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DocumentVersionsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ConnectedAppsCountOutputTypeDefaultArgs instead
     */
    export type ConnectedAppsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ConnectedAppsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UnitTypeCountOutputTypeDefaultArgs instead
     */
    export type UnitTypeCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UnitTypeCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ModelsDefaultArgs instead
     */
    export type ModelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ModelsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PartsDefaultArgs instead
     */
    export type PartsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PartsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClaimDefaultArgs instead
     */
    export type ClaimArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClaimDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProblemDefaultArgs instead
     */
    export type ProblemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProblemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClaimToEntityDefaultArgs instead
     */
    export type ClaimToEntityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClaimToEntityDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InvestigationDefaultArgs instead
     */
    export type InvestigationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InvestigationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ShipmentDefaultArgs instead
     */
    export type ShipmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ShipmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OrganizationDefaultArgs instead
     */
    export type OrganizationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OrganizationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoleDefaultArgs instead
     */
    export type RoleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SystemTypeDefaultArgs instead
     */
    export type SystemTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SystemTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EntityTypeDefaultArgs instead
     */
    export type EntityTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EntityTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use businessTypeDefaultArgs instead
     */
    export type businessTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = businessTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BusinessDefaultArgs instead
     */
    export type BusinessArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BusinessDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FunctionsDefaultArgs instead
     */
    export type FunctionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FunctionsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SectionDefaultArgs instead
     */
    export type SectionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SectionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LocationDefaultArgs instead
     */
    export type LocationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LocationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EntityDefaultArgs instead
     */
    export type EntityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EntityDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LocationBusinessDefaultArgs instead
     */
    export type LocationBusinessArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LocationBusinessDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotificationDefaultArgs instead
     */
    export type NotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotificationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DoctypeDefaultArgs instead
     */
    export type DoctypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DoctypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DocumentsDefaultArgs instead
     */
    export type DocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DocumentsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use documentAttachmentHistoryDefaultArgs instead
     */
    export type documentAttachmentHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = documentAttachmentHistoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReferenceDocumentsDefaultArgs instead
     */
    export type ReferenceDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReferenceDocumentsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VersionReferenceDocumentsDefaultArgs instead
     */
    export type VersionReferenceDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VersionReferenceDocumentsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DocumentVersionsDefaultArgs instead
     */
    export type DocumentVersionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DocumentVersionsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DocumentCommentsDefaultArgs instead
     */
    export type DocumentCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DocumentCommentsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DocumentWorkFlowHistoryDefaultArgs instead
     */
    export type DocumentWorkFlowHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DocumentWorkFlowHistoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use documentAdminsDefaultArgs instead
     */
    export type documentAdminsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = documentAdminsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AdditionalDocumentAdminsDefaultArgs instead
     */
    export type AdditionalDocumentAdminsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AdditionalDocumentAdminsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LogsDefaultArgs instead
     */
    export type LogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LogsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use userPersonalisationDefaultArgs instead
     */
    export type userPersonalisationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = userPersonalisationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ConnectedAppsDefaultArgs instead
     */
    export type ConnectedAppsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ConnectedAppsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use unitTypeDefaultArgs instead
     */
    export type unitTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = unitTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use kpiDefaultArgs instead
     */
    export type kpiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = kpiDefaultArgs<ExtArgs>
    /**
     * @deprecated Use auditTrialDefaultArgs instead
     */
    export type auditTrialArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = auditTrialDefaultArgs<ExtArgs>
    /**
     * @deprecated Use prefixSuffixDefaultArgs instead
     */
    export type prefixSuffixArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = prefixSuffixDefaultArgs<ExtArgs>
    /**
     * @deprecated Use serialNumberDefaultArgs instead
     */
    export type serialNumberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = serialNumberDefaultArgs<ExtArgs>
    /**
     * @deprecated Use rolesTableDefaultArgs instead
     */
    export type rolesTableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = rolesTableDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}